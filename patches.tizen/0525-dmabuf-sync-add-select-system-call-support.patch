From a091524f9feef9d49cefeafabe6951cc96a72be6 Mon Sep 17 00:00:00 2001
From: Inki Dae <inki.dae@samsung.com>
Date: Fri, 9 Aug 2013 15:38:34 +0900
Subject: [PATCH 0525/1302] dmabuf-sync: add select system call support.

This patch implements select system call for DMA BUF module
and adds related codes to dmabuf sync framework.

The purpose of this feature is to wait for the completion of DMA
or CPU access to a dmabuf without that caller locks the dmabuf
again after the completion.

This feature is useful when caller wants to be aware of the completion
of DMA access to a shared dmabuf, and the caller doesn't use interfaces
for the DMA device driver.

Signed-off-by: Inki Dae <inki.dae@samsung.com>
Signed-off-by: MyungJoo Ham <myungjoo.ham@samsung.com>
---
 drivers/base/dma-buf.c      | 48 +++++++++++++++++++++++++++++++++++++++++++++
 drivers/base/dmabuf-sync.c  | 18 +++++++++++++++++
 include/linux/dmabuf-sync.h |  5 +++++
 3 files changed, 71 insertions(+)

diff --git a/drivers/base/dma-buf.c b/drivers/base/dma-buf.c
index e1b8583..53ade7b 100644
--- a/drivers/base/dma-buf.c
+++ b/drivers/base/dma-buf.c
@@ -29,6 +29,7 @@
 #include <linux/export.h>
 #include <linux/debugfs.h>
 #include <linux/seq_file.h>
+#include <linux/poll.h>
 #include <linux/dmabuf-sync.h>
 
 static inline int is_dma_buf_file(struct file *);
@@ -80,6 +81,52 @@ static int dma_buf_mmap_internal(struct file *file, struct vm_area_struct *vma)
 	return dmabuf->ops->mmap(dmabuf, vma);
 }
 
+static unsigned int dma_buf_poll(struct file *filp,
+					struct poll_table_struct *poll)
+{
+	struct dma_buf *dmabuf;
+	struct dmabuf_sync_reservation *robj;
+	int ret = 0;
+
+	if (!is_dma_buf_file(filp))
+		return POLLERR;
+
+	dmabuf = filp->private_data;
+	if (!dmabuf || !dmabuf->sync)
+		return POLLERR;
+
+	robj = dmabuf->sync;
+
+	mutex_lock(&robj->lock);
+
+	robj->polled = true;
+
+	/*
+	 * CPU or DMA access to this buffer has been completed, and
+	 * the blocked task has been waked up. Return poll event
+	 * so that the task can get out of select().
+	 */
+	if (robj->poll_event) {
+		robj->poll_event = false;
+		mutex_unlock(&robj->lock);
+		return POLLIN | POLLOUT;
+	}
+
+	/*
+	 * There is no anyone accessing this buffer so just return POLLERR.
+	 */
+	if (!robj->locked) {
+		mutex_unlock(&robj->lock);
+		return POLLERR;
+	}
+
+	poll_wait(filp, &robj->poll_wait, poll);
+
+	mutex_unlock(&robj->lock);
+
+	return ret;
+}
+
 static int dma_buf_lock(struct file *file, int cmd, struct file_lock *fl)
 {
 	struct dma_buf *dmabuf;
@@ -115,6 +162,7 @@ static int dma_buf_lock(struct file *file, int cmd, struct file_lock *fl)
 static const struct file_operations dma_buf_fops = {
 	.release	= dma_buf_release,
 	.mmap		= dma_buf_mmap_internal,
+	.poll		= dma_buf_poll,
 	.lock		= dma_buf_lock,
 };
 
diff --git a/drivers/base/dmabuf-sync.c b/drivers/base/dmabuf-sync.c
index abfd8e3..dab5b32 100644
--- a/drivers/base/dmabuf-sync.c
+++ b/drivers/base/dmabuf-sync.c
@@ -63,6 +63,12 @@ static void dmabuf_sync_timeout_worker(struct work_struct *work)
 			continue;
 		}
 
+		if (sobj->robj->polled) {
+			sobj->robj->poll_event = true;
+			sobj->robj->polled = false;
+			wake_up_interruptible(&sobj->robj->poll_wait);
+		}
+
 		if (atomic_add_unless(&sobj->robj->shared_cnt, -1, 1)) {
 			mutex_unlock(&sobj->robj->lock);
 			continue;
@@ -277,6 +283,12 @@ static void dmabuf_sync_unlock_objs(struct dmabuf_sync *sync,
 	list_for_each_entry(sobj, &sync->syncs, head) {
 		mutex_lock(&sobj->robj->lock);
 
+		if (sobj->robj->polled) {
+			sobj->robj->poll_event = true;
+			sobj->robj->polled = false;
+			wake_up_interruptible(&sobj->robj->poll_wait);
+		}
+
 		if (atomic_add_unless(&sobj->robj->shared_cnt, -1, 1)) {
 			mutex_unlock(&sobj->robj->lock);
 			continue;
@@ -624,6 +636,12 @@ void dmabuf_sync_single_unlock(struct dma_buf *dmabuf)
 
 	mutex_lock(&robj->lock);
 
+	if (robj->polled) {
+		robj->poll_event = true;
+		robj->polled = false;
+		wake_up_interruptible(&robj->poll_wait);
+	}
+
 	if (atomic_add_unless(&robj->shared_cnt, -1 , 1)) {
 		mutex_unlock(&robj->lock);
 		dma_buf_put(dmabuf);
diff --git a/include/linux/dmabuf-sync.h b/include/linux/dmabuf-sync.h
index d4dcf4f..9a3afc4 100644
--- a/include/linux/dmabuf-sync.h
+++ b/include/linux/dmabuf-sync.h
@@ -22,6 +22,9 @@ enum dmabuf_sync_status {
 struct dmabuf_sync_reservation {
 	struct ww_mutex		sync_lock;
 	struct mutex		lock;
+	wait_queue_head_t	poll_wait;
+	unsigned int		poll_event;
+	unsigned int		polled;
 	atomic_t		shared_cnt;
 	unsigned int		accessed_type;
 	unsigned int		locked;
@@ -91,6 +94,8 @@ static inline void dmabuf_sync_reservation_init(struct dma_buf *dmabuf)
 
 	mutex_init(&obj->lock);
 	atomic_set(&obj->shared_cnt, 1);
+
+	init_waitqueue_head(&obj->poll_wait);
 }
 
 static inline void dmabuf_sync_reservation_fini(struct dma_buf *dmabuf)
-- 
1.8.3.2

