From 0801037a6e7c6b36eb56ff8be8515b2c639c873b Mon Sep 17 00:00:00 2001
From: Tomasz Stanislawski <t.stanislaws@samsung.com>
Date: Mon, 30 Sep 2013 17:46:53 +0200
Subject: [PATCH 1218/1302] phy: Add exynos-phy driver

Add exynos-phy driver to support a single register
PHY interfaces present on Exynos4 SoC.

Signed-off-by: Tomasz Stanislawski <t.stanislaws@samsung.com>
Change-Id: I1a2eeab876507e1e427fcb26782d060a1614852a
Signed-off-by: MyungJoo Ham <myungjoo.ham@samsung.com>
---
 drivers/phy/Kconfig      |   5 ++
 drivers/phy/Makefile     |   1 +
 drivers/phy/exynos-phy.c | 152 +++++++++++++++++++++++++++++++++++++++++++++++
 3 files changed, 158 insertions(+)
 create mode 100644 drivers/phy/exynos-phy.c

diff --git a/drivers/phy/Kconfig b/drivers/phy/Kconfig
index bf63eb8..62bd2cb 100644
--- a/drivers/phy/Kconfig
+++ b/drivers/phy/Kconfig
@@ -42,4 +42,9 @@ config PHY_EXYNOS4212_USB
 	help
   	  Enable USB PHY support for Exynos 4212
   	  
+config EXYNOS_PHY
+	tristate "Exynos PHY driver"
+	help
+	  Support for PHY controllers on SoCs from Exynos family.
+
 endmenu
diff --git a/drivers/phy/Makefile b/drivers/phy/Makefile
index d75f932..e56dd72 100644
--- a/drivers/phy/Makefile
+++ b/drivers/phy/Makefile
@@ -7,3 +7,4 @@ obj-$(CONFIG_PHY_EXYNOS_MIPI_VIDEO)	+= phy-exynos-mipi-video.o
 obj-$(CONFIG_PHY_EXYNOS_USB)		+= phy-exynos-usb.o
 obj-$(CONFIG_PHY_EXYNOS4210_USB)	+= phy-exynos4210-usb.o
 obj-$(CONFIG_PHY_EXYNOS4212_USB)	+= phy-exynos4212-usb.o
+obj-$(CONFIG_EXYNOS_PHY)	+= exynos-phy.o
diff --git a/drivers/phy/exynos-phy.c b/drivers/phy/exynos-phy.c
new file mode 100644
index 0000000..46d5603
--- /dev/null
+++ b/drivers/phy/exynos-phy.c
@@ -0,0 +1,152 @@
+/*
+ * Exynos PHY driver
+ *
+ * Copyright (C) 2013 Samsung Electronics Co., Ltd.
+ * Author: Tomasz Stanislawski <t.stanislaws@samsung.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/io.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/of_address.h>
+#include <linux/of_device.h>
+#include <linux/phy/phy.h>
+
+#define EXYNOS_PHY_ENABLE	(1 << 0)
+
+static int exynos_phy_power_on(struct phy *phy)
+{
+	void __iomem *reg = phy_get_drvdata(phy);
+	u32 val;
+
+	val = readl(reg);
+	val |= EXYNOS_PHY_ENABLE;
+	writel(val, reg);
+
+	return 0;
+}
+
+static int exynos_phy_power_off(struct phy *phy)
+{
+	void __iomem *reg = phy_get_drvdata(phy);
+	u32 val;
+
+	val = readl(reg);
+	val &= ~EXYNOS_PHY_ENABLE;
+	writel(val, reg);
+
+	return 0;
+}
+
+static struct phy_ops exynos_phy_ops = {
+	.power_on	= exynos_phy_power_on,
+	.power_off	= exynos_phy_power_off,
+	.owner		= THIS_MODULE,
+};
+
+static const u32 exynos4210_offsets[] = {
+	0x0700, /* HDMI_PHY */
+	0x070C, /* DAC_PHY */
+	0x0718, /* ADC_PHY */
+	0x071C, /* PCIE_PHY */
+	0x0720, /* SATA_PHY */
+	~0, /* end mark */
+};
+
+static const u32 exynos4412_offsets[] = {
+	0x0700, /* HDMI_PHY */
+	0x0718, /* ADC_PHY */
+	~0, /* end mark */
+};
+
+static const struct of_device_id exynos_phy_of_match[] = {
+	{ .compatible = "exynos4210-phy", .data = exynos4210_offsets},
+	{ .compatible = "exynos4412-phy", .data = exynos4412_offsets},
+	{ },
+};
+MODULE_DEVICE_TABLE(of, exynos_phy_of_match);
+
+static struct phy *exynos_phy_xlate(struct device *dev,
+					struct of_phandle_args *args)
+{
+	struct phy **phys = dev_get_drvdata(dev);
+	int index = args->args[0];
+	int i;
+
+	/* verify if index is valid */
+	for (i = 0; i <= index; ++i)
+		if (!phys[i])
+			return ERR_PTR(-ENODEV);
+
+	return phys[index];
+}
+
+static int exynos_phy_probe(struct platform_device *pdev)
+{
+	const struct of_device_id *of_id = of_match_device(
+		of_match_ptr(exynos_phy_of_match), &pdev->dev);
+	const u32 *offsets = of_id->data;
+	int count;
+	struct device *dev = &pdev->dev;
+	struct phy **phys;
+	struct resource *res;
+	void __iomem *regs;
+	int i;
+	struct phy_provider *phy_provider;
+
+	/* count number of phys to create */
+	for (count = 0; offsets[count] != ~0; ++count)
+		;
+
+	phys = devm_kzalloc(dev, (count + 1) * sizeof(phys[0]), GFP_KERNEL);
+	if (!phys)
+		return -ENOMEM;
+
+	dev_set_drvdata(dev, phys);
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+
+	regs = devm_ioremap(dev, res->start, res->end - res->start);
+	if (!regs) {
+		dev_err(dev, "failed to ioremap registers\n");
+		return -EFAULT;
+	}
+
+	/* NOTE: last entry in phys[] is NULL */
+	for (i = 0; i < count; ++i) {
+		phys[i] = devm_phy_create(dev, &exynos_phy_ops, NULL);
+		if (IS_ERR(phys[i])) {
+			dev_err(dev, "failed to create PHY %d\n", i);
+			return PTR_ERR(phys[i]);
+		}
+		phy_set_drvdata(phys[i], regs + offsets[i]);
+	}
+
+	phy_provider = devm_of_phy_provider_register(dev, exynos_phy_xlate);
+	if (IS_ERR(phy_provider)) {
+		dev_err(dev, "failed to register PHY provider\n");
+		return PTR_ERR(phy_provider);
+	}
+
+	dev_info(dev, "added %d phys\n", count);
+
+	return 0;
+}
+
+static struct platform_driver exynos_phy_driver = {
+	.probe	= exynos_phy_probe,
+	.driver = {
+		.of_match_table	= exynos_phy_of_match,
+		.name  = "exynos-phy",
+		.owner = THIS_MODULE,
+	}
+};
+module_platform_driver(exynos_phy_driver);
+
+MODULE_DESCRIPTION("Exynos PHY driver");
+MODULE_AUTHOR("Tomasz Stanislawski <t.stanislaws@samsung.com>");
+MODULE_LICENSE("GPL v2");
-- 
1.8.3.2

