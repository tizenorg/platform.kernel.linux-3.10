From dbe528492fe2349dc092258a87261b3423ec31b5 Mon Sep 17 00:00:00 2001
From: Jonghwa Lee <jonghwa3.lee@samsung.com>
Date: Fri, 5 Apr 2013 15:48:47 +0900
Subject: [PATCH 0190/1302] regulator: max77693: Support to parse data from
 device tree

This patch supports max77693 regulator driver to get a initial
data from device tree.

Signed-off-by: Jonghwa Lee <jonghwa3.lee@samsung.com>
Signed-off-by: MyungJoo Ham <myungjoo.ham@samsung.com>
---
 drivers/regulator/max77693.c | 58 ++++++++++++++++++++++++++++++++++++++++++++
 1 file changed, 58 insertions(+)

diff --git a/drivers/regulator/max77693.c b/drivers/regulator/max77693.c
index 0720ea8..60842a8 100644
--- a/drivers/regulator/max77693.c
+++ b/drivers/regulator/max77693.c
@@ -33,6 +33,7 @@
 #include <linux/regulator/machine.h>
 #include <linux/mfd/max77693.h>
 #include <linux/mfd/max77693-private.h>
+#include <linux/regulator/of_regulator.h>
 
 struct max77693_data {
 	struct device *dev;
@@ -669,7 +670,57 @@ static struct regulator_desc regulators[] = {
 		.owner = THIS_MODULE,
 	},
 };
+#ifdef CONFIG_OF
+static int max77693_pmic_dt_parse_pdata(struct platform_device *pdev,
+					struct max77693_platform_data *pdata)
+{
+	struct max77693_dev *iodev = dev_get_drvdata(pdev->dev.parent);
+	struct device_node *np;
+	struct max77693_regulator_data *rdata;
+	struct of_regulator_match rmatch;
+	int i, ret, cnt = 0;
+
+	np = of_find_node_by_name(iodev->dev->of_node, "regulators");
+	if (!np)
+		return -EINVAL;
+
+	of_property_read_u32(np, "number-of-regulators", &pdata->num_regulators);
+
+	/* Keep going whether the number of regulators prdefined or not*/
+	if (!pdata->num_regulators) {
+		dev_err(&pdev->dev,
+			"failed to get the number of regulators supported\n");
+		pdata->num_regulators = ARRAY_SIZE(regulators);
+	}
+
+	rdata = devm_kzalloc(&pdev->dev, sizeof(*rdata) *
+			     pdata->num_regulators, GFP_KERNEL);
+	if (!rdata)
+		return -ENOMEM;
+
+	for (i = 0; i < pdata->num_regulators; i++) {
+		rmatch.name = regulators[i].name;
+		ret = of_regulator_match(&pdev->dev, np, &rmatch, 1);
+		if (ret == 1)
+			rdata[cnt++].id = regulators[i].id;
+		else
+			continue;
+		rdata[i].initdata = rmatch.init_data;
+		rdata[i].of_node = rmatch.of_node;
+	}
+
+	pdata->regulators = rdata;
+	pdata->num_regulators = cnt;
 
+	return 0;
+}
+#else
+static int max77693_pmic_dt_parse_pdata(struct platform_device *pdev,
+					struct max77693_platform_data *pdata)
+{
+	return 0;
+}
+#endif
 static int max77693_pmic_probe(struct platform_device *pdev)
 {
 	struct max77693_dev *iodev = dev_get_drvdata(pdev->dev.parent);
@@ -679,12 +730,19 @@ static int max77693_pmic_probe(struct platform_device *pdev)
 	struct regulator_config config = {};
 
 	dev_info(&pdev->dev, "%s\n", __func__);
+
 	if (!pdata) {
 		pr_info("[%s:%d] !pdata\n", __FILE__, __LINE__);
 		dev_err(pdev->dev.parent, "No platform init data supplied.\n");
 		return -ENODEV;
 	}
 
+	if (iodev->dev->of_node) {
+		ret = max77693_pmic_dt_parse_pdata(pdev, pdata);
+		if (ret)
+			return ret;
+	}
+
 	max77693 = devm_kzalloc(&pdev->dev, sizeof(struct max77693_data),
 				GFP_KERNEL);
 	if (!max77693) {
-- 
1.8.3.2

