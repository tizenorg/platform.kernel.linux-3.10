From 69d693b2152e83a3ef3d94e4554e2bad1203d5b0 Mon Sep 17 00:00:00 2001
From: Mark Brown <broonie@linaro.org>
Date: Fri, 9 Aug 2013 11:41:51 +0100
Subject: [PATCH 1265/1302] usb: misc: usb3503: Actively manage Hub Connect
 GPIO

If the connect signal is pulled high then the device will start up meaning
that if we just pull it high on probe then the device will start running
prior to the configuration being written out. Fix this by pulling the GPIO
low when we reset and only pulling it high when configuration is finished.

Signed-off-by: Mark Brown <broonie@linaro.org>
Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
[mszyprow: mainline commit 8e7245b8386cb1dc941e10a4c97307e3f48da5da]
Signed-off-by: Marek Szyprowski <m.szyprowski@samsung.com>
Change-Id: I8e7245b8386cb1dc941e10a4c97307e3f48da5da

Signed-off-by: MyungJoo Ham <myungjoo.ham@samsung.com>
---
 drivers/usb/misc/usb3503.c | 18 ++++++++++++------
 1 file changed, 12 insertions(+), 6 deletions(-)

diff --git a/drivers/usb/misc/usb3503.c b/drivers/usb/misc/usb3503.c
index 2e9e100..4b6572a 100644
--- a/drivers/usb/misc/usb3503.c
+++ b/drivers/usb/misc/usb3503.c
@@ -100,10 +100,13 @@ static int usb3503_clear_bits(struct i2c_client *client, char reg, char req)
 	return 0;
 }
 
-static int usb3503_reset(int gpio_reset, int state)
+static int usb3503_reset(struct usb3503 *hub, int state)
 {
-	if (gpio_is_valid(gpio_reset))
-		gpio_set_value_cansleep(gpio_reset, state);
+	if (!state && gpio_is_valid(hub->gpio_connect))
+		gpio_set_value_cansleep(hub->gpio_connect, 0);
+
+	if (gpio_is_valid(hub->gpio_reset))
+		gpio_set_value_cansleep(hub->gpio_reset, state);
 
 	/* Wait T_HUBINIT == 4ms for hub logic to stabilize */
 	if (state)
@@ -119,7 +122,7 @@ static int usb3503_switch_mode(struct usb3503 *hub, enum usb3503_mode mode)
 
 	switch (mode) {
 	case USB3503_MODE_HUB:
-		usb3503_reset(hub->gpio_reset, 1);
+		usb3503_reset(hub, 1);
 
 		/* SP_ILOCK: set connect_n, config_n for config */
 		err = usb3503_write_register(i2c, USB3503_SP_ILOCK,
@@ -156,12 +159,15 @@ static int usb3503_switch_mode(struct usb3503 *hub, enum usb3503_mode mode)
 			goto err_hubmode;
 		}
 
+		if (gpio_is_valid(hub->gpio_connect))
+			gpio_set_value_cansleep(hub->gpio_connect, 1);
+
 		hub->mode = mode;
 		dev_info(&i2c->dev, "switched to HUB mode\n");
 		break;
 
 	case USB3503_MODE_STANDBY:
-		usb3503_reset(hub->gpio_reset, 0);
+		usb3503_reset(hub, 0);
 
 		hub->mode = mode;
 		dev_info(&i2c->dev, "switched to STANDBY mode\n");
@@ -241,7 +247,7 @@ static int usb3503_probe(struct i2c_client *i2c, const struct i2c_device_id *id)
 
 	if (gpio_is_valid(hub->gpio_connect)) {
 		err = devm_gpio_request_one(&i2c->dev, hub->gpio_connect,
-				GPIOF_OUT_INIT_HIGH, "usb3503 connect");
+				GPIOF_OUT_INIT_LOW, "usb3503 connect");
 		if (err) {
 			dev_err(&i2c->dev,
 					"unable to request GPIO %d as connect pin (%d)\n",
-- 
1.8.3.2

