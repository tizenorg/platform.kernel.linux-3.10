From 54a34eca28757e9d0de09cbbf574cbdc4bb747a1 Mon Sep 17 00:00:00 2001
From: Tomasz Figa <t.figa@samsung.com>
Date: Thu, 28 Feb 2013 19:38:05 +0100
Subject: [PATCH 0144/1302] sound: soc: codecs: Import Yamaha YMU823 (MC1N2)
 codec driver

This patch adds initial version of Yamaha YMU823 (MC1N2) codec driver
ported for Linux 3.8 and Device Tree.

Signed-off-by: Tomasz Figa <t.figa@samsung.com>
Signed-off-by: MyungJoo Ham <myungjoo.ham@samsung.com>
---
 include/linux/mfd/mc1n2_pdata.h        |    29 +
 include/uapi/sound/asound.h            |     1 +
 sound/soc/codecs/Kconfig               |     2 +
 sound/soc/codecs/Makefile              |     2 +
 sound/soc/codecs/mc1n2/Kconfig         |    12 +
 sound/soc/codecs/mc1n2/Makefile        |     4 +
 sound/soc/codecs/mc1n2/mc1n2.c         |  4774 ++++++++
 sound/soc/codecs/mc1n2/mc1n2.h         |   126 +
 sound/soc/codecs/mc1n2/mc1n2_cfg.h     |  1199 ++
 sound/soc/codecs/mc1n2/mc1n2_cfg_gsm.h |  1159 ++
 sound/soc/codecs/mc1n2/mc1n2_cfg_lgt.h |  1199 ++
 sound/soc/codecs/mc1n2/mc1n2_cfg_px.h  |  1199 ++
 sound/soc/codecs/mc1n2/mc1n2_cfg_q1.h  |  1199 ++
 sound/soc/codecs/mc1n2/mc1n2_dbg.c     |   439 +
 sound/soc/codecs/mc1n2/mc1n2_priv.h    |   196 +
 sound/soc/codecs/mc1n2/mcdebuglog.c    |  1771 +++
 sound/soc/codecs/mc1n2/mcdebuglog.h    |    31 +
 sound/soc/codecs/mc1n2/mcdefs.h        |  1160 ++
 sound/soc/codecs/mc1n2/mcdevif.c       |   317 +
 sound/soc/codecs/mc1n2/mcdevif.h       |    81 +
 sound/soc/codecs/mc1n2/mcdevprof.c     |   131 +
 sound/soc/codecs/mc1n2/mcdevprof.h     |    53 +
 sound/soc/codecs/mc1n2/mcdriver.c      |  4047 +++++++
 sound/soc/codecs/mc1n2/mcdriver.h      |   906 ++
 sound/soc/codecs/mc1n2/mcdriver_AA.c   | 18276 +++++++++++++++++++++++++++++++
 sound/soc/codecs/mc1n2/mcdriver_AA.h   |    25 +
 sound/soc/codecs/mc1n2/mcmachdep.c     |   318 +
 sound/soc/codecs/mc1n2/mcmachdep.h     |    34 +
 sound/soc/codecs/mc1n2/mcpacking.c     |  4710 ++++++++
 sound/soc/codecs/mc1n2/mcpacking.h     |    91 +
 sound/soc/codecs/mc1n2/mcresctrl.c     |  9419 ++++++++++++++++
 sound/soc/codecs/mc1n2/mcresctrl.h     |   263 +
 sound/soc/codecs/mc1n2/mcservice.c     |   365 +
 sound/soc/codecs/mc1n2/mcservice.h     |    34 +
 sound/soc/codecs/mc1n2/mctypedef.h     |    38 +
 35 files changed, 53610 insertions(+)
 create mode 100644 include/linux/mfd/mc1n2_pdata.h
 create mode 100644 sound/soc/codecs/mc1n2/Kconfig
 create mode 100644 sound/soc/codecs/mc1n2/Makefile
 create mode 100644 sound/soc/codecs/mc1n2/mc1n2.c
 create mode 100644 sound/soc/codecs/mc1n2/mc1n2.h
 create mode 100644 sound/soc/codecs/mc1n2/mc1n2_cfg.h
 create mode 100755 sound/soc/codecs/mc1n2/mc1n2_cfg_gsm.h
 create mode 100644 sound/soc/codecs/mc1n2/mc1n2_cfg_lgt.h
 create mode 100644 sound/soc/codecs/mc1n2/mc1n2_cfg_px.h
 create mode 100644 sound/soc/codecs/mc1n2/mc1n2_cfg_q1.h
 create mode 100644 sound/soc/codecs/mc1n2/mc1n2_dbg.c
 create mode 100644 sound/soc/codecs/mc1n2/mc1n2_priv.h
 create mode 100644 sound/soc/codecs/mc1n2/mcdebuglog.c
 create mode 100644 sound/soc/codecs/mc1n2/mcdebuglog.h
 create mode 100644 sound/soc/codecs/mc1n2/mcdefs.h
 create mode 100644 sound/soc/codecs/mc1n2/mcdevif.c
 create mode 100644 sound/soc/codecs/mc1n2/mcdevif.h
 create mode 100644 sound/soc/codecs/mc1n2/mcdevprof.c
 create mode 100644 sound/soc/codecs/mc1n2/mcdevprof.h
 create mode 100644 sound/soc/codecs/mc1n2/mcdriver.c
 create mode 100644 sound/soc/codecs/mc1n2/mcdriver.h
 create mode 100644 sound/soc/codecs/mc1n2/mcdriver_AA.c
 create mode 100644 sound/soc/codecs/mc1n2/mcdriver_AA.h
 create mode 100644 sound/soc/codecs/mc1n2/mcmachdep.c
 create mode 100644 sound/soc/codecs/mc1n2/mcmachdep.h
 create mode 100644 sound/soc/codecs/mc1n2/mcpacking.c
 create mode 100644 sound/soc/codecs/mc1n2/mcpacking.h
 create mode 100644 sound/soc/codecs/mc1n2/mcresctrl.c
 create mode 100644 sound/soc/codecs/mc1n2/mcresctrl.h
 create mode 100644 sound/soc/codecs/mc1n2/mcservice.c
 create mode 100644 sound/soc/codecs/mc1n2/mcservice.h
 create mode 100644 sound/soc/codecs/mc1n2/mctypedef.h

diff --git a/include/linux/mfd/mc1n2_pdata.h b/include/linux/mfd/mc1n2_pdata.h
new file mode 100644
index 0000000..474f6e1
--- /dev/null
+++ b/include/linux/mfd/mc1n2_pdata.h
@@ -0,0 +1,29 @@
+ /*
+  * Copyright (C) 2008 Samsung Electronics, Inc.
+  *
+  * This software is licensed under the terms of the GNU General Public
+  * License version 2, as published by the Free Software Foundation, and
+  * may be copied, distributed, and modified under those terms.
+  *
+  * This program is distributed in the hope that it will be useful,
+  * but WITHOUT ANY WARRANTY; without even the implied warranty of
+  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+  * GNU General Public License for more details.
+  *
+  */
+
+#ifndef __S5PC210_MC1N2_H
+#define __S5PC210_MC1N2_H
+
+enum mic_type {
+	MAIN_MIC = 0x1,
+	SUB_MIC  = 0x2,
+};
+
+struct mc1n2_platform_data {
+	void (*set_main_mic_bias)(struct device *dev, bool on);
+	void (*set_sub_mic_bias)(struct device *dev, bool on);
+	int (*set_adc_power_constraints)(struct device *dev, int disabled);
+};
+
+#endif
diff --git a/include/uapi/sound/asound.h b/include/uapi/sound/asound.h
index e3983d5..d2fc951 100644
--- a/include/uapi/sound/asound.h
+++ b/include/uapi/sound/asound.h
@@ -93,6 +93,7 @@ enum {
 	SNDRV_HWDEP_IFACE_SB_RC,	/* SB Extigy/Audigy2NX remote control */
 	SNDRV_HWDEP_IFACE_HDA,		/* HD-audio */
 	SNDRV_HWDEP_IFACE_USB_STREAM,	/* direct access to usb stream */
+	SNDRV_HWDEP_IFACE_MC1N2,	/* FIXME */
 
 	/* Don't forget to change the following: */
 	SNDRV_HWDEP_IFACE_LAST = SNDRV_HWDEP_IFACE_USB_STREAM
diff --git a/sound/soc/codecs/Kconfig b/sound/soc/codecs/Kconfig
index 2f45f00..576065f 100644
--- a/sound/soc/codecs/Kconfig
+++ b/sound/soc/codecs/Kconfig
@@ -525,3 +525,5 @@ config SND_SOC_ML26124
 
 config SND_SOC_TPA6130A2
 	tristate
+
+source "sound/soc/codecs/mc1n2/Kconfig"
diff --git a/sound/soc/codecs/Makefile b/sound/soc/codecs/Makefile
index b9e41c9..bcbd4a5 100644
--- a/sound/soc/codecs/Makefile
+++ b/sound/soc/codecs/Makefile
@@ -246,3 +246,5 @@ obj-$(CONFIG_SND_SOC_WM_HUBS)	+= snd-soc-wm-hubs.o
 # Amp
 obj-$(CONFIG_SND_SOC_MAX9877)	+= snd-soc-max9877.o
 obj-$(CONFIG_SND_SOC_TPA6130A2)	+= snd-soc-tpa6130a2.o
+
+obj-$(CONFIG_SND_SOC)		+= mc1n2/
diff --git a/sound/soc/codecs/mc1n2/Kconfig b/sound/soc/codecs/mc1n2/Kconfig
new file mode 100644
index 0000000..2b521c1
--- /dev/null
+++ b/sound/soc/codecs/mc1n2/Kconfig
@@ -0,0 +1,12 @@
+config SND_SOC_MC1N2
+	tristate
+	depends on SND_SOC && I2C
+	select SND_HWDEP
+
+config SND_SOC_USE_EXTERNAL_MIC_BIAS
+	bool "Use External Mic Bias"
+
+config SND_SOC_MC1N2_DEBUG
+	bool "MC-1N2 verbose debug messages while core driver call"
+	select SND_DEBUG
+	depends on SND_SOC_MC1N2
diff --git a/sound/soc/codecs/mc1n2/Makefile b/sound/soc/codecs/mc1n2/Makefile
new file mode 100644
index 0000000..9c6b1c0
--- /dev/null
+++ b/sound/soc/codecs/mc1n2/Makefile
@@ -0,0 +1,4 @@
+snd-soc-mc1n2-objs := mc1n2.o mc1n2_dbg.o \
+	mcdevif.o mcdevprof.o mcdriver.o mcmachdep.o mcpacking.o mcresctrl.o mcservice.o mcdebuglog.o mcdriver_AA.o
+
+obj-$(CONFIG_SND_SOC_MC1N2) += snd-soc-mc1n2.o
diff --git a/sound/soc/codecs/mc1n2/mc1n2.c b/sound/soc/codecs/mc1n2/mc1n2.c
new file mode 100644
index 0000000..9f56575
--- /dev/null
+++ b/sound/soc/codecs/mc1n2/mc1n2.c
@@ -0,0 +1,4774 @@
+/*
+ * MC-1N2 ASoC codec driver
+ *
+ * Copyright (c) 2010-2011 Yamaha Corporation
+ *
+ * This software is provided 'as-is', without any express or implied
+ * warranty.  In no event will the authors be held liable for any damages
+ * arising from the use of this software.
+ *
+ * Permission is granted to anyone to use this software for any purpose,
+ * including commercial applications, and to alter it and redistribute it
+ * freely, subject to the following restrictions:
+ *
+ * 1. The origin of this software must not be misrepresented; you must not
+ *    claim that you wrote the original software. If you use this software
+ *    in a product, an acknowledgment in the product documentation would be
+ *    appreciated but is not required.
+ * 2. Altered source versions must be plainly marked as such, and must not be
+ *    misrepresented as being the original software.
+ * 3. This notice may not be removed or altered from any source distribution.
+ */
+
+#include <linux/delay.h>
+#include <linux/errno.h>
+#include <linux/slab.h>
+#include <linux/gpio.h>
+#include <linux/regulator/consumer.h>
+#include <linux/i2c.h>
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/mutex.h>
+#include <linux/of.h>
+#include <linux/of_gpio.h>
+#include <linux/types.h>
+#ifdef CONFIG_SND_SOC_PM_RUNTIME
+#include <linux/pm_runtime.h>
+#endif
+#include <sound/hwdep.h>
+#include <sound/initval.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/soc.h>
+#include <sound/soc-dapm.h>
+#include <sound/tlv.h>
+#include "mc1n2.h"
+#include "mc1n2_priv.h"
+
+#include <plat/gpio-cfg.h>
+#include <mach/gpio.h>
+
+#ifdef CONFIG_TARGET_LOCALE_NAATT_TEMP
+/* CONFIG_TARGET_LOCALE_NAATT_TEMP is intentionally introduced temporarily*/
+
+#include "mc1n2_cfg_gsm.h"
+#elif defined(CONFIG_MACH_Q1_BD)
+#include "mc1n2_cfg_q1.h"
+#elif defined(CONFIG_MACH_U1_KOR_LGT)
+#include "mc1n2_cfg_lgt.h"
+#elif defined(CONFIG_MACH_PX)
+#include "mc1n2_cfg_px.h"
+#else
+#include "mc1n2_cfg.h"
+#endif
+
+extern int mc1n2_set_mclk_source(bool on);
+static int audio_ctrl_mic_bias_gpio(struct mc1n2_platform_data *pdata, int mic, bool on);
+
+#define MC1N2_DRIVER_VERSION "1.0.4"
+
+#define MC1N2_NAME "mc1n2"
+
+#define MC1N2_I2S_RATE (SNDRV_PCM_RATE_8000_48000)
+#define MC1N2_I2S_FORMATS \
+	(SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S20_3LE | \
+	 SNDRV_PCM_FMTBIT_S24_3LE)
+
+#define MC1N2_PCM_RATE (SNDRV_PCM_RATE_8000 | SNDRV_PCM_RATE_16000)
+#define MC1N2_PCM_FORMATS \
+	(SNDRV_PCM_FMTBIT_S8 | \
+	 SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S16_BE | \
+	 SNDRV_PCM_FMTBIT_A_LAW | SNDRV_PCM_FMTBIT_MU_LAW)
+
+#define MC1N2_HWDEP_ID "mc1n2"
+
+#define MC1N2_HW_ID_AA 0x78
+#define MC1N2_HW_ID_AB 0x79
+
+#define MC1N2_WAITTIME_MICIN	100
+
+#ifdef ALSA_VER_ANDROID_3_0
+static struct i2c_client *mc1n2_i2c;
+#endif
+
+/*
+ * Driver private data structure
+ */
+static UINT8 mc1n2_hwid;
+
+static size_t mc1n2_path_channel_tbl[] = {
+	offsetof(MCDRV_PATH_INFO, asDit0[0]),
+	offsetof(MCDRV_PATH_INFO, asDit1[0]),
+	offsetof(MCDRV_PATH_INFO, asDit2[0]),
+	offsetof(MCDRV_PATH_INFO, asHpOut[0]),
+	offsetof(MCDRV_PATH_INFO, asHpOut[1]),
+	offsetof(MCDRV_PATH_INFO, asSpOut[0]),
+	offsetof(MCDRV_PATH_INFO, asSpOut[1]),
+	offsetof(MCDRV_PATH_INFO, asRcOut[0]),
+	offsetof(MCDRV_PATH_INFO, asLout1[0]),
+	offsetof(MCDRV_PATH_INFO, asLout1[1]),
+	offsetof(MCDRV_PATH_INFO, asLout2[0]),
+	offsetof(MCDRV_PATH_INFO, asLout2[1]),
+	offsetof(MCDRV_PATH_INFO, asDac[0]),
+	offsetof(MCDRV_PATH_INFO, asDac[1]),
+	offsetof(MCDRV_PATH_INFO, asAe[0]),
+	offsetof(MCDRV_PATH_INFO, asAdc0[0]),
+	offsetof(MCDRV_PATH_INFO, asAdc0[1]),
+	offsetof(MCDRV_PATH_INFO, asMix[0]),
+	offsetof(MCDRV_PATH_INFO, asBias[0]),
+};
+#define MC1N2_N_PATH_CHANNELS (sizeof(mc1n2_path_channel_tbl) / sizeof(size_t))
+
+struct mc1n2_port_params {
+	UINT8 rate;
+	UINT8 bits[SNDRV_PCM_STREAM_LAST+1];
+	UINT8 pcm_mono[SNDRV_PCM_STREAM_LAST+1];
+	UINT8 pcm_order[SNDRV_PCM_STREAM_LAST+1];
+	UINT8 pcm_law[SNDRV_PCM_STREAM_LAST+1];
+	UINT8 master;
+	UINT8 inv;
+	UINT8 format;
+	UINT8 bckfs;
+	UINT8 pcm_clkdown;
+	UINT8 channels;
+	UINT8 stream;                     /* bit0: Playback, bit1: Capture */
+	UINT8 dir[MC1N2_N_PATH_CHANNELS]; /* path settings for DIR */
+	MCDRV_CHANNEL dit;                /* path settings for DIT */
+};
+
+struct mc1n2_data {
+	struct mutex mutex;
+	struct mc1n2_setup setup;
+	struct mc1n2_port_params port[IOPORT_NUM];
+	struct snd_hwdep *hwdep;
+	struct mc1n2_platform_data *pdata;
+	int clk_update;
+	MCDRV_PATH_INFO path_store;
+	MCDRV_VOL_INFO vol_store;
+	MCDRV_DIO_INFO dio_store;
+	MCDRV_DAC_INFO dac_store;
+	MCDRV_ADC_INFO adc_store;
+	MCDRV_SP_INFO sp_store;
+	MCDRV_DNG_INFO dng_store;
+	MCDRV_SYSEQ_INFO syseq_store;
+	MCDRV_AE_INFO ae_store;
+	MCDRV_PDM_INFO pdm_store;
+	UINT32 hdmicount;
+	UINT32 delay_mic1in;
+	UINT32 lineoutenable;
+#ifdef CONFIG_SND_SOC_PM_RUNTIME
+	int suspended;
+#endif
+	struct regulator *regulator;
+	int gpio_main_mic_bias;
+	int gpio_sub_mic_bias;
+};
+
+struct mc1n2_info_store {
+	UINT32 get;
+	UINT32 set;
+	size_t offset;
+	UINT32 flags;
+};
+
+struct mc1n2_info_store mc1n2_info_store_tbl[] = {
+	{MCDRV_GET_DIGITALIO, MCDRV_SET_DIGITALIO,
+	 offsetof(struct mc1n2_data, dio_store), 0x1ff},
+	{MCDRV_GET_DAC, MCDRV_SET_DAC,
+	 offsetof(struct mc1n2_data, dac_store), 0x7},
+	{MCDRV_GET_ADC, MCDRV_SET_ADC,
+	 offsetof(struct mc1n2_data, adc_store), 0x7},
+	{MCDRV_GET_SP, MCDRV_SET_SP,
+	 offsetof(struct mc1n2_data, sp_store), 0},
+	{MCDRV_GET_DNG, MCDRV_SET_DNG,
+	 offsetof(struct mc1n2_data, dng_store), 0x3f3f3f},
+	{MCDRV_GET_SYSEQ, MCDRV_SET_SYSEQ,
+	 offsetof(struct mc1n2_data, syseq_store), 0x3},
+	{0, MCDRV_SET_AUDIOENGINE,
+	 offsetof(struct mc1n2_data, ae_store), 0x1ff},
+	{MCDRV_GET_PDM, MCDRV_SET_PDM,
+	 offsetof(struct mc1n2_data, pdm_store), 0x7f},
+	{MCDRV_GET_PATH, MCDRV_SET_PATH,
+	 offsetof(struct mc1n2_data, path_store), 0},
+	{MCDRV_GET_VOLUME, MCDRV_SET_VOLUME,
+	 offsetof(struct mc1n2_data, vol_store), 0},
+};
+#define MC1N2_N_INFO_STORE (sizeof(mc1n2_info_store_tbl) / sizeof(struct mc1n2_info_store))
+
+#define mc1n2_is_in_playback(p) ((p)->stream & (1 << SNDRV_PCM_STREAM_PLAYBACK))
+#define mc1n2_is_in_capture(p)  ((p)->stream & (1 << SNDRV_PCM_STREAM_CAPTURE))
+#define get_port_id(id) (id-1)
+
+static int mc1n2_current_mode;
+
+#ifdef CONFIG_SND_SOC_PM_RUNTIME
+#define MC1N2_PM_RUNTIME_DELAY_MS 500
+#endif
+#if !defined(ALSA_VER_ANDROID_3_0) || defined(CONFIG_SND_SOC_PM_RUNTIME)
+static struct snd_soc_codec *mc1n2_codec;
+#endif
+
+#if !defined(ALSA_VER_ANDROID_3_0) || defined(CONFIG_SND_SOC_PM_RUNTIME)
+static struct snd_soc_codec *mc1n2_get_codec_data(void)
+{
+	return mc1n2_codec;
+}
+
+static void mc1n2_set_codec_data(struct snd_soc_codec *codec)
+{
+	mc1n2_codec = codec;
+}
+#endif
+
+/* deliver i2c access to machdep */
+struct i2c_client *mc1n2_get_i2c_client(void)
+{
+#ifdef ALSA_VER_ANDROID_3_0
+	return mc1n2_i2c;
+#else
+	return mc1n2_codec->control_data;
+#endif
+}
+
+static int audio_ctrl_mic_bias_gpio(struct mc1n2_platform_data *pdata, int mic, bool on)
+{
+	if (!pdata) {
+		pr_err("failed to control mic bias\n");
+		return -EINVAL;
+	}
+
+	if ((mic & MAIN_MIC) && (pdata->set_main_mic_bias != NULL))
+		pdata->set_main_mic_bias(&mc1n2_i2c->dev, on);
+
+	if ((mic & SUB_MIC) && (pdata->set_sub_mic_bias != NULL))
+		pdata->set_sub_mic_bias(&mc1n2_i2c->dev, on);
+
+	return 0;
+}
+
+/*
+ * DAI (PCM interface)
+ */
+/* SRC_RATE settings @ 73728000Hz (ideal PLL output) */
+static int mc1n2_src_rate[][SNDRV_PCM_STREAM_LAST+1] = {
+	/* DIR, DIT */
+	{32768, 4096},                  /* MCDRV_FS_48000 */
+	{30106, 4458},                  /* MCDRV_FS_44100 */
+	{21845, 6144},                  /* MCDRV_FS_32000 */
+	{0, 0},                         /* N/A */
+	{0, 0},                         /* N/A */
+	{15053, 8916},                  /* MCDRV_FS_22050 */
+	{10923, 12288},                 /* MCDRV_FS_16000 */
+	{0, 0},                         /* N/A */
+	{0, 0},                         /* N/A */
+	{7526, 17833},                  /* MCDRV_FS_11025 */
+	{5461, 24576},                  /* MCDRV_FS_8000 */
+};
+
+#define mc1n2_fs_to_srcrate(rate,dir) mc1n2_src_rate[(rate)][(dir)];
+
+static int mc1n2_setup_dai(struct mc1n2_data *mc1n2, int id, int mode, int dir)
+{
+	MCDRV_DIO_INFO dio;
+	MCDRV_DIO_PORT *port = &dio.asPortInfo[id];
+	struct mc1n2_setup *setup = &mc1n2->setup;
+	struct mc1n2_port_params *par = &mc1n2->port[id];
+	UINT32 update = 0;
+	int i;
+
+	memset(&dio, 0, sizeof(MCDRV_DIO_INFO));
+
+	if (par->stream == 0) {
+		port->sDioCommon.bMasterSlave = par->master;
+		port->sDioCommon.bAutoFs = MCDRV_AUTOFS_OFF;
+		port->sDioCommon.bFs = par->rate;
+		port->sDioCommon.bBckFs = par->bckfs;
+		port->sDioCommon.bInterface = mode;
+		port->sDioCommon.bBckInvert = par->inv;
+		if (mode == MCDRV_DIO_PCM) {
+			port->sDioCommon.bPcmHizTim = setup->pcm_hiz_redge[id];
+			port->sDioCommon.bPcmClkDown = par->pcm_clkdown;
+			port->sDioCommon.bPcmFrame = par->format;
+			port->sDioCommon.bPcmHighPeriod = setup->pcm_hperiod[id];
+		}
+		update |= MCDRV_DIO0_COM_UPDATE_FLAG;
+	}
+
+	if (dir == SNDRV_PCM_STREAM_PLAYBACK) {
+		port->sDir.wSrcRate = mc1n2_fs_to_srcrate(par->rate, dir);
+		if (mode == MCDRV_DIO_DA) {
+			port->sDir.sDaFormat.bBitSel = par->bits[dir];
+			port->sDir.sDaFormat.bMode = par->format;
+		} else {
+			port->sDir.sPcmFormat.bMono = par->pcm_mono[dir];
+			port->sDir.sPcmFormat.bOrder = par->pcm_order[dir];
+			if (setup->pcm_extend[id]) {
+				port->sDir.sPcmFormat.bOrder |=
+					(1 << setup->pcm_extend[id]);
+			}
+			port->sDir.sPcmFormat.bLaw = par->pcm_law[dir];
+			port->sDir.sPcmFormat.bBitSel = par->bits[dir];
+		}
+		for (i = 0; i < DIO_CHANNELS; i++) {
+			if (i && par->channels == 1) {
+				port->sDir.abSlot[i] = port->sDir.abSlot[i-1];
+			} else {
+				port->sDir.abSlot[i] = setup->slot[id][dir][i];
+			}
+
+		}
+		update |= MCDRV_DIO0_DIR_UPDATE_FLAG;
+	}
+
+	if (dir == SNDRV_PCM_STREAM_CAPTURE) {
+		port->sDit.wSrcRate = mc1n2_fs_to_srcrate(par->rate, dir);
+		if (mode == MCDRV_DIO_DA) {
+			port->sDit.sDaFormat.bBitSel = par->bits[dir];
+			port->sDit.sDaFormat.bMode = par->format;
+		} else {
+			port->sDit.sPcmFormat.bMono = par->pcm_mono[dir];
+			port->sDit.sPcmFormat.bOrder = par->pcm_order[dir];
+			if (setup->pcm_extend[id]) {
+				port->sDit.sPcmFormat.bOrder |=
+					(1 << setup->pcm_extend[id]);
+			}
+			port->sDit.sPcmFormat.bLaw = par->pcm_law[dir];
+			port->sDit.sPcmFormat.bBitSel = par->bits[dir];
+		}
+		for (i = 0; i < DIO_CHANNELS; i++) {
+			port->sDit.abSlot[i] = setup->slot[id][dir][i];
+		}
+		update |= MCDRV_DIO0_DIT_UPDATE_FLAG;
+	}
+
+	return _McDrv_Ctrl(MCDRV_SET_DIGITALIO, &dio, update << (id*3));
+}
+
+static int mc1n2_control_dir(struct mc1n2_data *mc1n2, int id, int enable)
+{
+	MCDRV_PATH_INFO info;
+	MCDRV_CHANNEL *ch;
+	int activate;
+	int i;
+
+	memset(&info, 0, sizeof(MCDRV_PATH_INFO));
+
+	for (i = 0; i < MC1N2_N_PATH_CHANNELS; i++) {
+		ch = (MCDRV_CHANNEL *)((void *)&info + mc1n2_path_channel_tbl[i]);
+
+		switch (i) {
+		case 0:
+#ifdef DIO0_DAI_ENABLE
+			activate = enable && mc1n2_is_in_capture(&mc1n2->port[0]);
+#else
+			activate = enable;
+#endif
+			break;
+
+		case 1:
+#ifdef DIO1_DAI_ENABLE
+			activate = enable && mc1n2_is_in_capture(&mc1n2->port[1]);
+#else
+			activate = enable;
+#endif
+			break;
+		case 2:
+#ifdef DIO2_DAI_ENABLE
+			activate = enable && mc1n2_is_in_capture(&mc1n2->port[2]);
+#else
+			activate = enable;
+#endif
+			break;
+		default:
+			activate = enable;
+			break;
+		}
+
+		if (mc1n2->port[id].dir[i]) {
+			ch->abSrcOnOff[3] = 0x1 << (id * 2 + !activate);
+		}
+	}
+
+	return _McDrv_Ctrl(MCDRV_SET_PATH, &info, 0);
+}
+
+static int mc1n2_control_dit(struct mc1n2_data *mc1n2, int id, int enable)
+{
+	MCDRV_PATH_INFO info;
+	MCDRV_CHANNEL *ch = info.asDit0 + id;
+	int stream;
+	int i;
+
+	memset(&info, 0, sizeof(MCDRV_PATH_INFO));
+
+	for (i = 0; i < SOURCE_BLOCK_NUM; i++) {
+		if (i == 3) {
+			stream = 0;
+
+#ifdef DIO0_DAI_ENABLE
+			stream |= mc1n2_is_in_playback(&mc1n2->port[0]);
+#endif
+#ifdef DIO1_DAI_ENABLE
+			stream |= mc1n2_is_in_playback(&mc1n2->port[1]) << 2;
+#endif
+#ifdef DIO2_DAI_ENABLE
+			stream |= mc1n2_is_in_playback(&mc1n2->port[2]) << 4;
+#endif
+
+			ch->abSrcOnOff[3] = (stream & mc1n2->port[id].dit.abSrcOnOff[3]) << !enable;
+		} else {
+			ch->abSrcOnOff[i] = mc1n2->port[id].dit.abSrcOnOff[i] << !enable;
+		}
+	}
+
+	return _McDrv_Ctrl(MCDRV_SET_PATH, &info, 0);
+}
+
+static int mc1n2_update_clock(struct mc1n2_data *mc1n2)
+{
+	MCDRV_CLOCK_INFO info;
+
+	memset(&info, 0, sizeof(MCDRV_CLOCK_INFO));
+	info.bCkSel = mc1n2->setup.init.bCkSel;
+	info.bDivR0 = mc1n2->setup.init.bDivR0;
+	info.bDivF0 = mc1n2->setup.init.bDivF0;
+	info.bDivR1 = mc1n2->setup.init.bDivR1;
+	info.bDivF1 = mc1n2->setup.init.bDivF1;
+
+	return _McDrv_Ctrl(MCDRV_UPDATE_CLOCK, &info, 0);
+}
+
+static int mc1n2_set_clkdiv_common(struct mc1n2_data *mc1n2, int div_id, int div)
+{
+	struct mc1n2_setup *setup = &mc1n2->setup;
+
+	switch (div_id) {
+	case MC1N2_CKSEL:
+		switch (div) {
+		case 0:
+			setup->init.bCkSel = MCDRV_CKSEL_CMOS;
+			break;
+		case 1:
+			setup->init.bCkSel = MCDRV_CKSEL_TCXO;
+			break;
+		case 2:
+			setup->init.bCkSel = MCDRV_CKSEL_CMOS_TCXO;
+			break;
+		case 3:
+			setup->init.bCkSel = MCDRV_CKSEL_TCXO_CMOS;
+			break;
+		default:
+			return -EINVAL;
+		}
+		break;
+	case MC1N2_DIVR0:
+		if ((div < 1) || (div > 127)) {
+			return -EINVAL;
+		}
+		setup->init.bDivR0 = div;
+		break;
+	case MC1N2_DIVF0:
+		if ((div < 1) || (div > 255)) {
+			return -EINVAL;
+		}
+		setup->init.bDivF0 = div;
+		break;
+	case MC1N2_DIVR1:
+		if ((div < 1) || (div > 127)) {
+			return -EINVAL;
+		}
+		setup->init.bDivR1 = div;
+		break;
+	case MC1N2_DIVF1:
+		if ((div < 1) || (div > 255)) {
+			return -EINVAL;
+		}
+		setup->init.bDivF1 = div;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	mc1n2->clk_update = 1;
+
+	return 0;
+}
+
+static int mc1n2_set_fmt_common(struct mc1n2_port_params *port, unsigned int fmt)
+{
+	/* master */
+	switch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {
+	case SND_SOC_DAIFMT_CBM_CFM:
+		port->master = MCDRV_DIO_MASTER;
+		break;
+	case SND_SOC_DAIFMT_CBS_CFS:
+		port->master = MCDRV_DIO_SLAVE;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	/* inv */
+	switch (fmt & SND_SOC_DAIFMT_INV_MASK) {
+	case SND_SOC_DAIFMT_NB_NF:
+		port->inv = MCDRV_BCLK_NORMAL;
+		break;
+	case SND_SOC_DAIFMT_IB_NF:
+		port->inv = MCDRV_BCLK_INVERT;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+#ifdef ALSA_VER_1_0_19
+	/* clock */
+	switch (fmt & SND_SOC_DAIFMT_CLOCK_MASK) {
+	case SND_SOC_DAIFMT_SYNC:
+		/* just validating */
+		break;
+	default:
+		return -EINVAL;
+	}
+#endif
+
+	return 0;
+}
+
+static int mc1n2_i2s_set_clkdiv(struct snd_soc_dai *dai, int div_id, int div)
+{
+	struct snd_soc_codec *codec = dai->codec;
+#if (defined ALSA_VER_ANDROID_2_6_35) || (defined ALSA_VER_ANDROID_3_0)
+	struct mc1n2_data *mc1n2 = snd_soc_codec_get_drvdata(codec);
+#else
+	struct mc1n2_data *mc1n2 = codec->private_data;
+#endif
+	struct mc1n2_port_params *port = &mc1n2->port[get_port_id(dai->id)];
+
+	switch (div_id) {
+	case MC1N2_BCLK_MULT:
+		switch (div) {
+		case MC1N2_LRCK_X32:
+			port->bckfs = MCDRV_BCKFS_32;
+			break;
+		case MC1N2_LRCK_X48:
+			port->bckfs = MCDRV_BCKFS_48;
+			break;
+		case MC1N2_LRCK_X64:
+			port->bckfs = MCDRV_BCKFS_64;
+			break;
+		default:
+			return -EINVAL;
+		}
+		break;
+	default:
+		return mc1n2_set_clkdiv_common(mc1n2, div_id, div);
+	}
+
+	return 0;
+}
+
+static int mc1n2_i2s_set_fmt(struct snd_soc_dai *dai, unsigned int fmt)
+{
+	struct snd_soc_codec *codec = dai->codec;
+#if (defined ALSA_VER_ANDROID_2_6_35) || (defined ALSA_VER_ANDROID_3_0)
+	struct mc1n2_data *mc1n2 = snd_soc_codec_get_drvdata(codec);
+#else
+	struct mc1n2_data *mc1n2 = codec->private_data;
+#endif
+	struct mc1n2_port_params *port = &mc1n2->port[get_port_id(dai->id)];
+
+	/* format */
+	switch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {
+	case SND_SOC_DAIFMT_I2S:
+		port->format = MCDRV_DAMODE_I2S;
+		break;
+	case SND_SOC_DAIFMT_RIGHT_J:
+		port->format = MCDRV_DAMODE_TAILALIGN;
+		break;
+	case SND_SOC_DAIFMT_LEFT_J:
+		port->format = MCDRV_DAMODE_HEADALIGN;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return mc1n2_set_fmt_common(port, fmt);
+}
+
+static int mc1n2_i2s_hw_params(struct snd_pcm_substream *substream,
+			       struct snd_pcm_hw_params *params,
+			       struct snd_soc_dai *dai)
+{
+#ifdef ALSA_VER_ANDROID_3_0
+	struct snd_soc_codec *codec = dai->codec;
+#else
+	struct snd_soc_pcm_runtime *runtime = snd_pcm_substream_chip(substream);
+#ifdef ALSA_VER_1_0_19
+	struct snd_soc_codec *codec = runtime->socdev->codec;
+#else
+	struct snd_soc_codec *codec = runtime->socdev->card->codec;
+#endif
+#endif
+#if (defined ALSA_VER_ANDROID_2_6_35) || (defined ALSA_VER_ANDROID_3_0)
+	struct mc1n2_data *mc1n2 = snd_soc_codec_get_drvdata(codec);
+#else
+	struct mc1n2_data *mc1n2 = codec->private_data;
+#endif
+	struct mc1n2_port_params *port = &mc1n2->port[get_port_id(dai->id)];
+	int dir = substream->stream;
+	int rate;
+	int err = 0;
+
+	dbg_info("hw_params: [%d] name=%s, dir=%d, rate=%d, bits=%d, ch=%d\n",
+		 get_port_id(dai->id), substream->name, dir,
+		 params_rate(params), params_format(params), params_channels(params));
+
+	/* format (bits) */
+	switch (params_format(params)) {
+	case SNDRV_PCM_FORMAT_S16_LE:
+		port->bits[dir] = MCDRV_BITSEL_16;
+		break;
+	case SNDRV_PCM_FORMAT_S20_3LE:
+		port->bits[dir] = MCDRV_BITSEL_20;
+		break;
+	case SNDRV_PCM_FORMAT_S24_3LE:
+		port->bits[dir] = MCDRV_BITSEL_24;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	/* rate */
+	switch (params_rate(params)) {
+	case 8000:
+		rate = MCDRV_FS_8000;
+		break;
+	case 11025:
+		rate = MCDRV_FS_11025;
+		break;
+	case 16000:
+		rate = MCDRV_FS_16000;
+		break;
+	case 22050:
+		rate = MCDRV_FS_22050;
+		break;
+	case 32000:
+		rate = MCDRV_FS_32000;
+		break;
+	case 44100:
+		rate = MCDRV_FS_44100;
+		break;
+	case 48000:
+		rate = MCDRV_FS_48000;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	mutex_lock(&mc1n2->mutex);
+
+	if ((port->stream & ~(1 << dir)) && (rate != port->rate)) {
+		err = -EBUSY;
+		goto error;
+	}
+
+#ifdef CONFIG_SND_SAMSUNG_RP
+	if ((dir == SNDRV_PCM_STREAM_PLAYBACK) && (get_port_id(dai->id) == 0)
+		&& (port->stream & (1 << dir)) && (rate == port->rate)) {
+		/* During ULP Audio, DAI should not be touched
+		   if i2s port already opened. */
+		err = 0;
+		goto error;
+	}
+#endif
+
+/* Because of line out pop up noise issue, i2s port already opend */
+	if ((mc1n2->lineoutenable == 1) && (port->stream & (1 << dir))) {
+		err = 0;
+		goto error;
+	}
+
+	port->rate = rate;
+	port->channels = params_channels(params);
+
+	err = mc1n2_update_clock(mc1n2);
+	if (err != MCDRV_SUCCESS) {
+		dev_err(codec->dev, "%d: Error in mc1n2_update_clock\n", err);
+		err = -EIO;
+		goto error;
+	}
+
+	err = mc1n2_setup_dai(mc1n2, get_port_id(dai->id), MCDRV_DIO_DA, dir);
+	if (err != MCDRV_SUCCESS) {
+		dev_err(codec->dev, "%d: Error in mc1n2_setup_dai\n", err);
+		err = -EIO;
+		goto error;
+	}
+
+	if (dir == SNDRV_PCM_STREAM_PLAYBACK) {
+		err = mc1n2_control_dir(mc1n2, get_port_id(dai->id), 1);
+	} else {
+		err = mc1n2_control_dit(mc1n2, get_port_id(dai->id), 1);
+	}
+	if (err != MCDRV_SUCCESS) {
+		dev_err(codec->dev, "%d: Error in mc1n2_control_dir/dit\n", err);
+		err = -EIO;
+		goto error;
+	}
+
+	port->stream |= (1 << dir);
+
+error:
+	mutex_unlock(&mc1n2->mutex);
+
+	return err;
+}
+
+static int mc1n2_hw_free(struct snd_pcm_substream *substream,
+			 struct snd_soc_dai *dai)
+{
+#ifdef ALSA_VER_ANDROID_3_0
+	struct snd_soc_codec *codec = dai->codec;
+#else
+	struct snd_soc_pcm_runtime *runtime = snd_pcm_substream_chip(substream);
+#ifdef ALSA_VER_1_0_19
+	struct snd_soc_codec *codec = runtime->socdev->codec;
+#else
+	struct snd_soc_codec *codec = runtime->socdev->card->codec;
+#endif
+#endif
+#if (defined ALSA_VER_ANDROID_2_6_35) || (defined ALSA_VER_ANDROID_3_0)
+	struct mc1n2_data *mc1n2 = snd_soc_codec_get_drvdata(codec);
+#else
+	struct mc1n2_data *mc1n2 = codec->private_data;
+#endif
+	struct mc1n2_port_params *port = &mc1n2->port[get_port_id(dai->id)];
+	int dir = substream->stream;
+	int err;
+
+	mutex_lock(&mc1n2->mutex);
+
+	if (!(port->stream & (1 << dir))) {
+		err = 0;
+		goto error;
+	}
+
+#ifdef CONFIG_SND_SAMSUNG_RP
+	if ((dir == SNDRV_PCM_STREAM_PLAYBACK) && (get_port_id(dai->id) == 0)) {
+		/* Leave codec opened during ULP Audio */
+		err = 0;
+		goto error;
+	}
+#endif
+
+/* Because of line out pop up noise, leave codec opened */
+	if (mc1n2->lineoutenable == 1) {
+		err = 0;
+		goto error;
+	}
+
+	if (dir == SNDRV_PCM_STREAM_PLAYBACK) {
+		err = mc1n2_control_dir(mc1n2, get_port_id(dai->id), 0);
+	} else {
+		err = mc1n2_control_dit(mc1n2, get_port_id(dai->id), 0);
+	}
+	if (err != MCDRV_SUCCESS) {
+		dev_err(codec->dev, "%d: Error in mc1n2_control_dir/dit\n", err);
+		err = -EIO;
+		goto error;
+	}
+
+	port->stream &= ~(1 << dir);
+
+error:
+	mutex_unlock(&mc1n2->mutex);
+
+	return err;
+}
+
+static int mc1n2_pcm_set_clkdiv(struct snd_soc_dai *dai, int div_id, int div)
+{
+	struct snd_soc_codec *codec = dai->codec;
+#if (defined ALSA_VER_ANDROID_2_6_35) || (defined ALSA_VER_ANDROID_3_0)
+	struct mc1n2_data *mc1n2 = snd_soc_codec_get_drvdata(codec);
+#else
+	struct mc1n2_data *mc1n2 = codec->private_data;
+#endif
+	struct mc1n2_port_params *port = &mc1n2->port[get_port_id(dai->id)];
+
+	switch (div_id) {
+	case MC1N2_BCLK_MULT:
+		switch (div) {
+		case MC1N2_LRCK_X8:
+			port->bckfs = MCDRV_BCKFS_16;
+			port->pcm_clkdown = MCDRV_PCM_CLKDOWN_HALF;
+			break;
+		case MC1N2_LRCK_X16:
+			port->bckfs = MCDRV_BCKFS_16;
+			port->pcm_clkdown = MCDRV_PCM_CLKDOWN_OFF;
+			break;
+		case MC1N2_LRCK_X24:
+			port->bckfs = MCDRV_BCKFS_48;
+			port->pcm_clkdown = MCDRV_PCM_CLKDOWN_HALF;
+			break;
+		case MC1N2_LRCK_X32:
+			port->bckfs = MCDRV_BCKFS_32;
+			port->pcm_clkdown = MCDRV_PCM_CLKDOWN_OFF;
+			break;
+		case MC1N2_LRCK_X48:
+			port->bckfs = MCDRV_BCKFS_48;
+			port->pcm_clkdown = MCDRV_PCM_CLKDOWN_OFF;
+			break;
+		case MC1N2_LRCK_X64:
+			port->bckfs = MCDRV_BCKFS_64;
+			port->pcm_clkdown = MCDRV_PCM_CLKDOWN_OFF;
+			break;
+		case MC1N2_LRCK_X128:
+			port->bckfs = MCDRV_BCKFS_128;
+			port->pcm_clkdown = MCDRV_PCM_CLKDOWN_OFF;
+			break;
+		case MC1N2_LRCK_X256:
+			port->bckfs = MCDRV_BCKFS_256;
+			port->pcm_clkdown = MCDRV_PCM_CLKDOWN_OFF;
+			break;
+		case MC1N2_LRCK_X512:
+			port->bckfs = MCDRV_BCKFS_512;
+			port->pcm_clkdown = MCDRV_PCM_CLKDOWN_OFF;
+			break;
+		}
+		break;
+	default:
+		return mc1n2_set_clkdiv_common(mc1n2, div_id, div);
+	}
+
+	return 0;
+}
+
+static int mc1n2_pcm_set_fmt(struct snd_soc_dai *dai, unsigned int fmt)
+{
+	struct snd_soc_codec *codec = dai->codec;
+#if (defined ALSA_VER_ANDROID_2_6_35) || (defined ALSA_VER_ANDROID_3_0)
+	struct mc1n2_data *mc1n2 = snd_soc_codec_get_drvdata(codec);
+#else
+	struct mc1n2_data *mc1n2 = codec->private_data;
+#endif
+	struct mc1n2_port_params *port = &mc1n2->port[get_port_id(dai->id)];
+
+	/* format */
+	switch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {
+	case SND_SOC_DAIFMT_DSP_A:
+		port->format = MCDRV_PCM_SHORTFRAME;
+		break;
+	case SND_SOC_DAIFMT_DSP_B:
+		port->format = MCDRV_PCM_LONGFRAME;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return mc1n2_set_fmt_common(port, fmt);
+}
+
+static int mc1n2_pcm_hw_params(struct snd_pcm_substream *substream,
+			       struct snd_pcm_hw_params *params,
+			       struct snd_soc_dai *dai)
+{
+#ifdef ALSA_VER_ANDROID_3_0
+	struct snd_soc_codec *codec = dai->codec;
+#else
+	struct snd_soc_pcm_runtime *runtime = snd_pcm_substream_chip(substream);
+#ifdef ALSA_VER_1_0_19
+	struct snd_soc_codec *codec = runtime->socdev->codec;
+#else
+	struct snd_soc_codec *codec = runtime->socdev->card->codec;
+#endif
+#endif
+#if (defined ALSA_VER_ANDROID_2_6_35) || (defined ALSA_VER_ANDROID_3_0)
+	struct mc1n2_data *mc1n2 = snd_soc_codec_get_drvdata(codec);
+#else
+	struct mc1n2_data *mc1n2 = codec->private_data;
+#endif
+	struct mc1n2_port_params *port = &mc1n2->port[get_port_id(dai->id)];
+	int dir = substream->stream;
+	int rate;
+	int err;
+
+	dbg_info("hw_params: [%d] name=%s, dir=%d, rate=%d, bits=%d, ch=%d\n",
+		 get_port_id(dai->id), substream->name, dir,
+		 params_rate(params), params_format(params), params_channels(params));
+
+	/* channels */
+	switch (params_channels(params)) {
+	case 1:
+		port->pcm_mono[dir] = MCDRV_PCM_MONO;
+		break;
+	case 2:
+		port->pcm_mono[dir] = MCDRV_PCM_STEREO;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	/* format (bits) */
+	switch (params_format(params)) {
+	case SNDRV_PCM_FORMAT_S8:
+		port->bits[dir] = MCDRV_PCM_BITSEL_8;
+		port->pcm_order[dir] = MCDRV_PCM_MSB_FIRST;
+		port->pcm_law[dir] = MCDRV_PCM_LINEAR;
+		break;
+	case SNDRV_PCM_FORMAT_S16_LE:
+		port->bits[dir] = MCDRV_PCM_BITSEL_16;
+		port->pcm_order[dir] = MCDRV_PCM_LSB_FIRST;
+		port->pcm_law[dir] = MCDRV_PCM_LINEAR;
+		break;
+	case SNDRV_PCM_FORMAT_S16_BE:
+		port->bits[dir] = MCDRV_PCM_BITSEL_16;
+		port->pcm_order[dir] = MCDRV_PCM_MSB_FIRST;
+		port->pcm_law[dir] = MCDRV_PCM_LINEAR;
+		break;
+	case SNDRV_PCM_FORMAT_A_LAW:
+		port->bits[dir] = MCDRV_PCM_BITSEL_8;
+		port->pcm_order[dir] = MCDRV_PCM_MSB_FIRST;
+		port->pcm_law[dir] = MCDRV_PCM_ALAW;
+		break;
+	case SNDRV_PCM_FORMAT_MU_LAW:
+		port->bits[dir] = MCDRV_PCM_BITSEL_8;
+		port->pcm_order[dir] = MCDRV_PCM_MSB_FIRST;
+		port->pcm_law[dir] = MCDRV_PCM_MULAW;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	/* rate */
+	switch (params_rate(params)) {
+	case 8000:
+		rate = MCDRV_FS_8000;
+		break;
+	case 16000:
+		rate = MCDRV_FS_16000;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	mutex_lock(&mc1n2->mutex);
+
+	if ((port->stream & ~(1 << dir)) && (rate != port->rate)) {
+		err = -EBUSY;
+		goto error;
+	}
+
+	port->rate = rate;
+	port->channels = params_channels(params);
+
+	err = mc1n2_update_clock(mc1n2);
+	if (err != MCDRV_SUCCESS) {
+		dev_err(codec->dev, "%d: Error in mc1n2_update_clock\n", err);
+		err = -EIO;
+		goto error;
+	}
+
+	err = mc1n2_setup_dai(mc1n2, get_port_id(dai->id), MCDRV_DIO_PCM, dir);
+	if (err != MCDRV_SUCCESS) {
+		dev_err(codec->dev, "%d: Error in mc1n2_setup_dai\n", err);
+		err = -EIO;
+		goto error;
+	}
+
+	if (dir == SNDRV_PCM_STREAM_PLAYBACK) {
+		err = mc1n2_control_dir(mc1n2, get_port_id(dai->id), 1);
+	} else {
+		err = mc1n2_control_dit(mc1n2, get_port_id(dai->id), 1);
+	}
+	if (err != MCDRV_SUCCESS) {
+		dev_err(codec->dev, "%d: Error in mc1n2_control_dir/dit\n", err);
+		err = -EIO;
+		goto error;
+	}
+
+	port->stream |= (1 << dir);
+
+error:
+	mutex_unlock(&mc1n2->mutex);
+
+	return err;
+}
+
+#ifndef ALSA_VER_1_0_19
+static struct snd_soc_dai_ops mc1n2_dai_ops[] = {
+	{
+		.set_clkdiv = mc1n2_i2s_set_clkdiv,
+		.set_fmt = mc1n2_i2s_set_fmt,
+		.hw_params = mc1n2_i2s_hw_params,
+		.hw_free = mc1n2_hw_free,
+	},
+	{
+		.set_clkdiv = mc1n2_pcm_set_clkdiv,
+		.set_fmt = mc1n2_pcm_set_fmt,
+		.hw_params = mc1n2_pcm_hw_params,
+		.hw_free = mc1n2_hw_free,
+	},
+	{
+		.set_clkdiv = mc1n2_i2s_set_clkdiv,
+		.set_fmt = mc1n2_i2s_set_fmt,
+		.hw_params = mc1n2_i2s_hw_params,
+		.hw_free = mc1n2_hw_free,
+	},
+	{
+		.set_clkdiv = mc1n2_pcm_set_clkdiv,
+		.set_fmt = mc1n2_pcm_set_fmt,
+		.hw_params = mc1n2_pcm_hw_params,
+		.hw_free = mc1n2_hw_free,
+	},
+	{
+		.set_clkdiv = mc1n2_i2s_set_clkdiv,
+		.set_fmt = mc1n2_i2s_set_fmt,
+		.hw_params = mc1n2_i2s_hw_params,
+		.hw_free = mc1n2_hw_free,
+	},
+	{
+		.set_clkdiv = mc1n2_pcm_set_clkdiv,
+		.set_fmt = mc1n2_pcm_set_fmt,
+		.hw_params = mc1n2_pcm_hw_params,
+		.hw_free = mc1n2_hw_free,
+	}
+};
+#endif
+
+
+#ifdef ALSA_VER_ANDROID_3_0
+struct snd_soc_dai_driver mc1n2_dai[] = {
+#else
+struct snd_soc_dai mc1n2_dai[] = {
+#endif
+	{
+		.name = MC1N2_NAME "-da0i",
+		.id = 1,
+		.playback = {
+			.stream_name = "Playback",
+			.channels_min = 1,
+			.channels_max = 2,
+			.rates = MC1N2_I2S_RATE,
+			.formats = MC1N2_I2S_FORMATS,
+		},
+		.capture = {
+			.stream_name = "Capture",
+			.channels_min = 1,
+			.channels_max = 2,
+			.rates = MC1N2_I2S_RATE,
+			.formats = MC1N2_I2S_FORMATS,
+		},
+#ifdef ALSA_VER_1_0_19
+		.ops = {
+			.set_clkdiv = mc1n2_i2s_set_clkdiv,
+			.set_fmt = mc1n2_i2s_set_fmt,
+			.hw_params = mc1n2_i2s_hw_params,
+			.hw_free = mc1n2_hw_free,
+		}
+#else
+		.ops = &mc1n2_dai_ops[0]
+#endif
+	},
+	{
+		.name = MC1N2_NAME "-da0p",
+		.id = 1,
+		.playback = {
+			.stream_name = "Playback",
+			.channels_min = 1,
+			.channels_max = 2,
+			.rates = MC1N2_PCM_RATE,
+			.formats = MC1N2_PCM_FORMATS,
+		},
+		.capture = {
+			.stream_name = "Capture",
+			.channels_min = 1,
+			.channels_max = 2,
+			.rates = MC1N2_PCM_RATE,
+			.formats = MC1N2_PCM_FORMATS,
+		},
+#ifdef ALSA_VER_1_0_19
+		.ops = {
+			.set_clkdiv = mc1n2_pcm_set_clkdiv,
+			.set_fmt = mc1n2_pcm_set_fmt,
+			.hw_params = mc1n2_pcm_hw_params,
+			.hw_free = mc1n2_hw_free,
+		}
+#else
+		.ops = &mc1n2_dai_ops[1]
+#endif
+	},
+	{
+		.name = MC1N2_NAME "-da1i",
+		.id = 2,
+		.playback = {
+			.stream_name = "Playback",
+			.channels_min = 1,
+			.channels_max = 2,
+			.rates = MC1N2_I2S_RATE,
+			.formats = MC1N2_I2S_FORMATS,
+		},
+		.capture = {
+			.stream_name = "Capture",
+			.channels_min = 1,
+			.channels_max = 2,
+			.rates = MC1N2_I2S_RATE,
+			.formats = MC1N2_I2S_FORMATS,
+		},
+#ifdef ALSA_VER_1_0_19
+		.ops = {
+			.set_clkdiv = mc1n2_i2s_set_clkdiv,
+			.set_fmt = mc1n2_i2s_set_fmt,
+			.hw_params = mc1n2_i2s_hw_params,
+			.hw_free = mc1n2_hw_free,
+		}
+#else
+		.ops = &mc1n2_dai_ops[2]
+#endif
+	},
+	{
+		.name = MC1N2_NAME "-da1p",
+		.id = 2,
+		.playback = {
+			.stream_name = "Playback",
+			.channels_min = 1,
+			.channels_max = 2,
+			.rates = MC1N2_PCM_RATE,
+			.formats = MC1N2_PCM_FORMATS,
+		},
+		.capture = {
+			.stream_name = "Capture",
+			.channels_min = 1,
+			.channels_max = 2,
+			.rates = MC1N2_PCM_RATE,
+			.formats = MC1N2_PCM_FORMATS,
+		},
+#ifdef ALSA_VER_1_0_19
+		.ops = {
+			.set_clkdiv = mc1n2_pcm_set_clkdiv,
+			.set_fmt = mc1n2_pcm_set_fmt,
+			.hw_params = mc1n2_pcm_hw_params,
+			.hw_free = mc1n2_hw_free,
+		}
+#else
+		.ops = &mc1n2_dai_ops[3]
+#endif
+	},
+	{
+		.name = MC1N2_NAME "-da2i",
+		.id = 3,
+		.playback = {
+			.stream_name = "Playback",
+			.channels_min = 1,
+			.channels_max = 2,
+			.rates = MC1N2_I2S_RATE,
+			.formats = MC1N2_I2S_FORMATS,
+		},
+		.capture = {
+			.stream_name = "Capture",
+			.channels_min = 1,
+			.channels_max = 2,
+			.rates = MC1N2_I2S_RATE,
+			.formats = MC1N2_I2S_FORMATS,
+		},
+#ifdef ALSA_VER_1_0_19
+		.ops = {
+			.set_clkdiv = mc1n2_i2s_set_clkdiv,
+			.set_fmt = mc1n2_i2s_set_fmt,
+			.hw_params = mc1n2_i2s_hw_params,
+			.hw_free = mc1n2_hw_free,
+		}
+#else
+		.ops = &mc1n2_dai_ops[4]
+#endif
+	},
+	{
+		.name = MC1N2_NAME "-da2p",
+		.id = 3,
+		.playback = {
+			.stream_name = "Playback",
+			.channels_min = 1,
+			.channels_max = 2,
+			.rates = MC1N2_PCM_RATE,
+			.formats = MC1N2_PCM_FORMATS,
+		},
+		.capture = {
+			.stream_name = "Capture",
+			.channels_min = 1,
+			.channels_max = 2,
+			.rates = MC1N2_PCM_RATE,
+			.formats = MC1N2_PCM_FORMATS,
+		},
+#ifdef ALSA_VER_1_0_19
+		.ops = {
+			.set_clkdiv = mc1n2_pcm_set_clkdiv,
+			.set_fmt = mc1n2_pcm_set_fmt,
+			.hw_params = mc1n2_pcm_hw_params,
+			.hw_free = mc1n2_hw_free,
+		}
+#else
+		.ops = &mc1n2_dai_ops[5]
+#endif
+	},
+};
+#ifndef ALSA_VER_ANDROID_3_0
+EXPORT_SYMBOL_GPL(mc1n2_dai);
+#endif
+
+/*
+ * Control interface
+ */
+/*
+ * Virtual register
+ *
+ * 16bit software registers are implemented for volumes and mute
+ * switches (as an exception, no mute switches for MIC and HP gain).
+ * Register contents are stored in codec's register cache.
+ *
+ *   15  14                       8   7   6                       0
+ *  +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
+ *  |swR|          volume-R         |swL|          volume-L         |
+ *  +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
+ */
+struct mc1n2_vreg_info {
+	size_t offset;
+	SINT16 *volmap;
+};
+
+/* volmap for Digital Volumes */
+static SINT16 mc1n2_vol_digital[] = {
+	0xa000, 0xb600, 0xb700, 0xb800, 0xb900, 0xba00, 0xbb00, 0xbc00,
+	0xbd00, 0xbe00, 0xbf00, 0xc000, 0xc100, 0xc200, 0xc300, 0xc400,
+	0xc500, 0xc600, 0xc700, 0xc800, 0xc900, 0xca00, 0xcb00, 0xcc00,
+	0xcd00, 0xce00, 0xcf00, 0xd000, 0xd100, 0xd200, 0xd300, 0xd400,
+	0xd500, 0xd600, 0xd700, 0xd800, 0xd900, 0xda00, 0xdb00, 0xdc00,
+	0xdd00, 0xde00, 0xdf00, 0xe000, 0xe100, 0xe200, 0xe300, 0xe400,
+	0xe500, 0xe600, 0xe700, 0xe800, 0xe900, 0xea00, 0xeb00, 0xec00,
+	0xed00, 0xee00, 0xef00, 0xf000, 0xf100, 0xf200, 0xf300, 0xf400,
+	0xf500, 0xf600, 0xf700, 0xf800, 0xf900, 0xfa00, 0xfb00, 0xfc00,
+	0xfd00, 0xfe00, 0xff00, 0x0000, 0x0100, 0x0200, 0x0300, 0x0400,
+	0x0500, 0x0600, 0x0700, 0x0800, 0x0900, 0x0a00, 0x0b00, 0x0c00,
+	0x0d00, 0x0e00, 0x0f00, 0x1000, 0x1100, 0x1200,
+};
+
+/* volmap for ADC Analog Volume */
+static SINT16 mc1n2_vol_adc[] = {
+	0xa000, 0xe500, 0xe680, 0xe800, 0xe980, 0xeb00, 0xec80, 0xee00,
+	0xef80, 0xf100, 0xf280, 0xf400, 0xf580, 0xf700, 0xf880, 0xfa00,
+	0xfb80, 0xfd00, 0xfe80, 0x0000, 0x0180, 0x0300, 0x0480, 0x0600,
+	0x0780, 0x0900, 0x0a80, 0x0c00, 0x0d80, 0x0f00, 0x1080, 0x1200,
+};
+
+/* volmap for LINE/MIC Input Volumes */
+static SINT16 mc1n2_vol_ain[] = {
+	0xa000, 0xe200, 0xe380, 0xe500, 0xe680, 0xe800, 0xe980, 0xeb00,
+	0xec80, 0xee00, 0xef80, 0xf100, 0xf280, 0xf400, 0xf580, 0xf700,
+	0xf880, 0xfa00, 0xfb80, 0xfd00, 0xfe80, 0x0000, 0x0180, 0x0300,
+	0x0480, 0x0600, 0x0780, 0x0900, 0x0a80, 0x0c00, 0x0d80, 0x0f00,
+};
+
+/* volmap for HP/SP Output Volumes */
+static SINT16 mc1n2_vol_hpsp[] = {
+	0xa000, 0xdc00, 0xe400, 0xe800, 0xea00, 0xec00, 0xee00, 0xf000,
+	0xf100, 0xf200, 0xf300, 0xf400, 0xf500, 0xf600, 0xf700, 0xf800,
+	0xf880, 0xf900, 0xf980, 0xfa00, 0xfa80, 0xfb00, 0xfb80, 0xfc00,
+	0xfc80, 0xfd00, 0xfd80, 0xfe00, 0xfe80, 0xff00, 0xff80, 0x0000,
+};
+
+/* volmap for RC/LINE Output Volumes */
+static SINT16 mc1n2_vol_aout[] = {
+	0xa000, 0xe200, 0xe300, 0xe400, 0xe500, 0xe600, 0xe700, 0xe800,
+	0xe900, 0xea00, 0xeb00, 0xec00, 0xed00, 0xee00, 0xef00, 0xf000,
+	0xf100, 0xf200, 0xf300, 0xf400, 0xf500, 0xf600, 0xf700, 0xf800,
+	0xf900, 0xfa00, 0xfb00, 0xfc00, 0xfd00, 0xfe00, 0xff00, 0x0000,
+};
+
+/* volmap for MIC Gain Volumes */
+static SINT16 mc1n2_vol_micgain[] = {
+	0x0f00, 0x1400, 0x1900, 0x1e00,
+};
+
+/* volmap for HP Gain Volume */
+static SINT16 mc1n2_vol_hpgain[] = {
+	0x0000, 0x0180, 0x0300, 0x0600,
+};
+
+struct mc1n2_vreg_info mc1n2_vreg_map[MC1N2_N_VOL_REG] = {
+	{offsetof(MCDRV_VOL_INFO, aswD_Ad0),       mc1n2_vol_digital},
+	{offsetof(MCDRV_VOL_INFO, aswD_Aeng6),     mc1n2_vol_digital},
+	{offsetof(MCDRV_VOL_INFO, aswD_Pdm),       mc1n2_vol_digital},
+	{offsetof(MCDRV_VOL_INFO, aswD_Dir0),      mc1n2_vol_digital},
+	{offsetof(MCDRV_VOL_INFO, aswD_Dir1),      mc1n2_vol_digital},
+	{offsetof(MCDRV_VOL_INFO, aswD_Dir2),      mc1n2_vol_digital},
+	{offsetof(MCDRV_VOL_INFO, aswD_Ad0Att),    mc1n2_vol_digital},
+	{offsetof(MCDRV_VOL_INFO, aswD_Dir0Att),   mc1n2_vol_digital},
+	{offsetof(MCDRV_VOL_INFO, aswD_Dir1Att),   mc1n2_vol_digital},
+	{offsetof(MCDRV_VOL_INFO, aswD_Dir2Att),   mc1n2_vol_digital},
+	{offsetof(MCDRV_VOL_INFO, aswD_SideTone),  mc1n2_vol_digital},
+	{offsetof(MCDRV_VOL_INFO, aswD_DacMaster), mc1n2_vol_digital},
+	{offsetof(MCDRV_VOL_INFO, aswD_DacVoice),  mc1n2_vol_digital},
+	{offsetof(MCDRV_VOL_INFO, aswD_DacAtt),    mc1n2_vol_digital},
+	{offsetof(MCDRV_VOL_INFO, aswD_Dit0),      mc1n2_vol_digital},
+	{offsetof(MCDRV_VOL_INFO, aswD_Dit1),      mc1n2_vol_digital},
+	{offsetof(MCDRV_VOL_INFO, aswD_Dit2),      mc1n2_vol_digital},
+	{offsetof(MCDRV_VOL_INFO, aswA_Ad0),       mc1n2_vol_adc},
+	{offsetof(MCDRV_VOL_INFO, aswA_Lin1),      mc1n2_vol_ain},
+	{offsetof(MCDRV_VOL_INFO, aswA_Mic1),      mc1n2_vol_ain},
+	{offsetof(MCDRV_VOL_INFO, aswA_Mic2),      mc1n2_vol_ain},
+	{offsetof(MCDRV_VOL_INFO, aswA_Mic3),      mc1n2_vol_ain},
+	{offsetof(MCDRV_VOL_INFO, aswA_Hp),        mc1n2_vol_hpsp},
+	{offsetof(MCDRV_VOL_INFO, aswA_Sp),        mc1n2_vol_hpsp},
+	{offsetof(MCDRV_VOL_INFO, aswA_Rc),        mc1n2_vol_hpsp},
+	{offsetof(MCDRV_VOL_INFO, aswA_Lout1),     mc1n2_vol_aout},
+	{offsetof(MCDRV_VOL_INFO, aswA_Lout2),     mc1n2_vol_aout},
+	{offsetof(MCDRV_VOL_INFO, aswA_Mic1Gain),  mc1n2_vol_micgain},
+	{offsetof(MCDRV_VOL_INFO, aswA_Mic2Gain),  mc1n2_vol_micgain},
+	{offsetof(MCDRV_VOL_INFO, aswA_Mic3Gain),  mc1n2_vol_micgain},
+	{offsetof(MCDRV_VOL_INFO, aswA_HpGain),    mc1n2_vol_hpgain},
+};
+
+#ifdef ALSA_VER_ANDROID_3_0
+static int cache_read(struct snd_soc_codec *codec, unsigned int reg)
+{
+	int ret;
+	unsigned int val;
+
+	ret = snd_soc_cache_read(codec, reg, &val);
+	if (ret != 0) {
+		dev_err(codec->dev, "Cache read to %x failed: %d\n", reg, ret);
+		return -EIO;
+	}
+	return val;
+}
+static int cache_write(struct snd_soc_codec *codec,
+					   unsigned int reg, unsigned int value)
+{
+	return ((int)snd_soc_cache_write(codec, reg, value));
+}
+#else
+static int cache_read(struct snd_soc_codec *codec, unsigned int reg)
+{
+	return ((u16 *)codec->reg_cache)[reg];
+}
+static int cache_write(struct snd_soc_codec *codec,
+					   unsigned int reg, unsigned int value)
+{
+	u16 *cp = (u16 *)codec->reg_cache + reg;
+	*cp = value;
+	return 0;
+}
+#endif
+
+static unsigned int mc1n2_read_reg(struct snd_soc_codec *codec, unsigned int reg)
+{
+	int ret;
+
+	ret = cache_read(codec, reg);
+	if (ret < 0) {
+		return -EIO;
+	}
+	return (unsigned int)ret;
+}
+
+#ifdef ALSA_VER_ANDROID_3_0
+#define REG_CACHE_READ(reg)	(mc1n2_read_reg(codec, reg))
+#else
+#define REG_CACHE_READ(reg)	((u16 *)codec->reg_cache)[reg]
+#endif
+
+static int write_reg_vol(struct snd_soc_codec *codec,
+			   unsigned int reg, unsigned int value)
+{
+	MCDRV_VOL_INFO update;
+	SINT16 *vp;
+	int ret;
+	int err, i;
+
+	memset(&update, 0, sizeof(MCDRV_VOL_INFO));
+	vp = (SINT16 *)((void *)&update + mc1n2_vreg_map[reg].offset);
+
+	for (i = 0; i < 2; i++, vp++) {
+		unsigned int v = (value >> (i*8)) & 0xff;
+		unsigned int c = (mc1n2_read_reg(codec, reg) >> (i*8)) & 0xff;
+		if (v != c) {
+			int sw, vol;
+			SINT16 db;
+			sw = (reg < MC1N2_AVOL_MIC1_GAIN) ? (v & 0x80) : 1;
+			vol = sw ? (v & 0x7f) : 0;
+			db = mc1n2_vreg_map[reg].volmap[vol];
+			*vp = db | MCDRV_VOL_UPDATE;
+		}
+	}
+
+	err = _McDrv_Ctrl(MCDRV_SET_VOLUME, &update, 0);
+	if (err != MCDRV_SUCCESS) {
+		dev_err(codec->dev, "%d: Error in MCDRV_SET_VOLUME\n", err);
+		return -EIO;
+	}
+	ret = cache_write(codec, reg, value);
+	if (ret != 0) {
+		dev_err(codec->dev, "Cache write to %x failed: %d\n", reg, ret);
+	}
+
+	return 0;
+}
+
+static int mc1n2_hwdep_ioctl_set_path(struct snd_soc_codec *codec,
+				      void *info, unsigned int update);
+
+static int write_reg_path(struct snd_soc_codec *codec,
+			   unsigned int reg, unsigned int value)
+{
+	MCDRV_PATH_INFO update;
+	MCDRV_CHANNEL *pch;
+	MCDRV_AE_INFO *pae;
+	int ret = 0;
+	int err;
+
+	memset(&update, 0, sizeof(MCDRV_PATH_INFO));
+
+	ret = cache_write(codec, reg, value);
+	if (ret != 0) {
+		dev_err(codec->dev, "Cache write to %x failed: %d\n",reg, ret);
+	}
+
+	switch (reg) {
+	case MC1N2_ADCL_MIC1_SW:
+		if (value) {
+			update.asAdc0[0].abSrcOnOff[0] = MCDRV_SRC0_MIC1_ON;
+		}
+		else {
+			update.asAdc0[0].abSrcOnOff[0] = MCDRV_SRC0_MIC1_OFF;
+		}
+		break;
+	case MC1N2_ADCL_MIC2_SW:
+		if (value) {
+			update.asAdc0[0].abSrcOnOff[0] = MCDRV_SRC0_MIC2_ON;
+		}
+		else {
+			update.asAdc0[0].abSrcOnOff[0] = MCDRV_SRC0_MIC2_OFF;
+		}
+		break;
+	case MC1N2_ADCL_MIC3_SW:
+		if (value) {
+			update.asAdc0[0].abSrcOnOff[0] = MCDRV_SRC0_MIC3_ON;
+		}
+		else {
+			update.asAdc0[0].abSrcOnOff[0] = MCDRV_SRC0_MIC3_OFF;
+		}
+		break;
+	case MC1N2_ADCL_LINE_SW:
+	case MC1N2_ADCL_LINE_SRC:
+		if (REG_CACHE_READ(MC1N2_ADCL_LINE_SRC) == 0) {
+			if (REG_CACHE_READ(MC1N2_ADCL_LINE_SW)) {
+				update.asAdc0[0].abSrcOnOff[1] = MCDRV_SRC1_LINE1_L_ON;
+			}
+			else {
+				update.asAdc0[0].abSrcOnOff[1] = MCDRV_SRC1_LINE1_L_OFF;
+			}
+		}
+		else {
+			if (REG_CACHE_READ(MC1N2_ADCL_LINE_SW)) {
+				update.asAdc0[0].abSrcOnOff[1] = MCDRV_SRC1_LINE1_M_ON;
+			}
+			else {
+				update.asAdc0[0].abSrcOnOff[1] = MCDRV_SRC1_LINE1_M_OFF;
+			}
+		}
+		break;
+	case MC1N2_ADCR_MIC1_SW:
+		if (value) {
+			update.asAdc0[1].abSrcOnOff[0] = MCDRV_SRC0_MIC1_ON;
+		}
+		else {
+			update.asAdc0[1].abSrcOnOff[0] = MCDRV_SRC0_MIC1_OFF;
+		}
+		break;
+	case MC1N2_ADCR_MIC2_SW:
+		if (value) {
+			update.asAdc0[1].abSrcOnOff[0] = MCDRV_SRC0_MIC2_ON;
+		}
+		else {
+			update.asAdc0[1].abSrcOnOff[0] = MCDRV_SRC0_MIC2_OFF;
+		}
+		break;
+	case MC1N2_ADCR_MIC3_SW:
+		if (value) {
+			update.asAdc0[1].abSrcOnOff[0] = MCDRV_SRC0_MIC3_ON;
+		}
+		else {
+			update.asAdc0[1].abSrcOnOff[0] = MCDRV_SRC0_MIC3_OFF;
+		}
+		break;
+	case MC1N2_ADCR_LINE_SW:
+	case MC1N2_ADCR_LINE_SRC:
+		if (REG_CACHE_READ(MC1N2_ADCR_LINE_SRC) == 0) {
+			if (REG_CACHE_READ(MC1N2_ADCR_LINE_SW)) {
+				update.asAdc0[1].abSrcOnOff[1] = MCDRV_SRC1_LINE1_R_ON;
+			}
+			else {
+				update.asAdc0[1].abSrcOnOff[1] = MCDRV_SRC1_LINE1_R_OFF;
+			}
+		}
+		else {
+			if (REG_CACHE_READ(MC1N2_ADCR_LINE_SW)) {
+				update.asAdc0[1].abSrcOnOff[1] = MCDRV_SRC1_LINE1_M_ON;
+			}
+			else {
+				update.asAdc0[1].abSrcOnOff[1] = MCDRV_SRC1_LINE1_M_OFF;
+			}
+		}
+		break;
+	case MC1N2_HPL_MIC1_SW:
+		if (value) {
+			update.asHpOut[0].abSrcOnOff[0] = MCDRV_SRC0_MIC1_ON;
+		}
+		else {
+			update.asHpOut[0].abSrcOnOff[0] = MCDRV_SRC0_MIC1_OFF;
+		}
+		break;
+	case MC1N2_HPL_MIC2_SW:
+		if (value) {
+			update.asHpOut[0].abSrcOnOff[0] = MCDRV_SRC0_MIC2_ON;
+		}
+		else {
+			update.asHpOut[0].abSrcOnOff[0] = MCDRV_SRC0_MIC2_OFF;
+		}
+		break;
+	case MC1N2_HPL_MIC3_SW:
+		if (value) {
+			update.asHpOut[0].abSrcOnOff[0] = MCDRV_SRC0_MIC3_ON;
+		}
+		else {
+			update.asHpOut[0].abSrcOnOff[0] = MCDRV_SRC0_MIC3_OFF;
+		}
+		break;
+	case MC1N2_HPL_LINE_SW:
+	case MC1N2_HPL_LINE_SRC:
+		if (REG_CACHE_READ(MC1N2_HPL_LINE_SRC) == 0) {
+			if (REG_CACHE_READ(MC1N2_HPL_LINE_SW)) {
+				update.asHpOut[0].abSrcOnOff[1] = MCDRV_SRC1_LINE1_L_ON;
+			}
+			else {
+				update.asHpOut[0].abSrcOnOff[1] = MCDRV_SRC1_LINE1_L_OFF;
+			}
+		}
+		else {
+			if (REG_CACHE_READ(MC1N2_HPL_LINE_SW)) {
+				update.asHpOut[0].abSrcOnOff[1] = MCDRV_SRC1_LINE1_M_ON;
+			}
+			else {
+				update.asHpOut[0].abSrcOnOff[1] = MCDRV_SRC1_LINE1_M_OFF;
+			}
+		}
+		break;
+	case MC1N2_HPL_DAC_SW:
+	case MC1N2_HPL_DAC_SRC:
+		if (REG_CACHE_READ(MC1N2_HPL_DAC_SRC) == 0) {
+			if (REG_CACHE_READ(MC1N2_HPL_DAC_SW)) {
+				update.asHpOut[0].abSrcOnOff[5] = MCDRV_SRC5_DAC_L_ON;
+			}
+			else {
+				update.asHpOut[0].abSrcOnOff[5] = MCDRV_SRC5_DAC_L_OFF;
+			}
+		}
+		else {
+			if (REG_CACHE_READ(MC1N2_HPL_DAC_SW)) {
+				update.asHpOut[0].abSrcOnOff[5] = MCDRV_SRC5_DAC_M_ON;
+			}
+			else {
+				update.asHpOut[0].abSrcOnOff[5] = MCDRV_SRC5_DAC_M_OFF;
+			}
+		}
+		break;
+	case MC1N2_HPR_MIC1_SW:
+		if (value) {
+			update.asHpOut[1].abSrcOnOff[0] = MCDRV_SRC0_MIC1_ON;
+		}
+		else {
+			update.asHpOut[1].abSrcOnOff[0] = MCDRV_SRC0_MIC1_OFF;
+		}
+		break;
+	case MC1N2_HPR_MIC2_SW:
+		if (value) {
+			update.asHpOut[1].abSrcOnOff[0] = MCDRV_SRC0_MIC2_ON;
+		}
+		else {
+			update.asHpOut[1].abSrcOnOff[0] = MCDRV_SRC0_MIC2_OFF;
+		}
+		break;
+	case MC1N2_HPR_MIC3_SW:
+		if (value) {
+			update.asHpOut[1].abSrcOnOff[0] = MCDRV_SRC0_MIC3_ON;
+		}
+		else {
+			update.asHpOut[1].abSrcOnOff[0] = MCDRV_SRC0_MIC3_OFF;
+		}
+		break;
+	case MC1N2_HPR_LINER_SW:
+		if (value) {
+			update.asHpOut[1].abSrcOnOff[1] = MCDRV_SRC1_LINE1_R_ON;
+		}
+		else {
+			update.asHpOut[1].abSrcOnOff[1] = MCDRV_SRC1_LINE1_R_OFF;
+		}
+		break;
+	case MC1N2_HPR_DACR_SW:
+		if (value) {
+			update.asHpOut[1].abSrcOnOff[5] = MCDRV_SRC5_DAC_R_ON;
+		}
+		else {
+			update.asHpOut[1].abSrcOnOff[5] = MCDRV_SRC5_DAC_R_OFF;
+		}
+		break;
+	case MC1N2_SPL_LINE_SW:
+	case MC1N2_SPL_LINE_SRC:
+		if (REG_CACHE_READ(MC1N2_SPL_LINE_SRC) == 0) {
+			if (REG_CACHE_READ(MC1N2_SPL_LINE_SW)) {
+				update.asSpOut[0].abSrcOnOff[1] = MCDRV_SRC1_LINE1_L_ON;
+			}
+			else {
+				update.asSpOut[0].abSrcOnOff[1] = MCDRV_SRC1_LINE1_L_OFF;
+			}
+		}
+		else {
+			if (REG_CACHE_READ(MC1N2_SPL_LINE_SW)) {
+				update.asSpOut[0].abSrcOnOff[1] = MCDRV_SRC1_LINE1_M_ON;
+			}
+			else {
+				update.asSpOut[0].abSrcOnOff[1] = MCDRV_SRC1_LINE1_M_OFF;
+			}
+		}
+		break;
+	case MC1N2_SPL_DAC_SW:
+	case MC1N2_SPL_DAC_SRC:
+		if (REG_CACHE_READ(MC1N2_SPL_DAC_SRC) == 0) {
+			if (REG_CACHE_READ(MC1N2_SPL_DAC_SW)) {
+				update.asSpOut[0].abSrcOnOff[5] = MCDRV_SRC5_DAC_L_ON;
+			}
+			else {
+				update.asSpOut[0].abSrcOnOff[5] = MCDRV_SRC5_DAC_L_OFF;
+			}
+		}
+		else {
+			if (REG_CACHE_READ(MC1N2_SPL_DAC_SW)) {
+				update.asSpOut[0].abSrcOnOff[5] = MCDRV_SRC5_DAC_M_ON;
+			}
+			else {
+				update.asSpOut[0].abSrcOnOff[5] = MCDRV_SRC5_DAC_M_OFF;
+			}
+		}
+		break;
+	case MC1N2_SPR_LINE_SW:
+	case MC1N2_SPR_LINE_SRC:
+		if (REG_CACHE_READ(MC1N2_SPR_LINE_SRC) == 0) {
+			if (REG_CACHE_READ(MC1N2_SPR_LINE_SW)) {
+				update.asSpOut[1].abSrcOnOff[1] = MCDRV_SRC1_LINE1_R_ON;
+			}
+			else {
+				update.asSpOut[1].abSrcOnOff[1] = MCDRV_SRC1_LINE1_R_OFF;
+			}
+		}
+		else {
+			if (REG_CACHE_READ(MC1N2_SPR_LINE_SW)) {
+				update.asSpOut[1].abSrcOnOff[1] = MCDRV_SRC1_LINE1_M_ON;
+			}
+			else {
+				update.asSpOut[1].abSrcOnOff[1] = MCDRV_SRC1_LINE1_M_OFF;
+			}
+		}
+		break;
+	case MC1N2_SPR_DAC_SW:
+	case MC1N2_SPR_DAC_SRC:
+		if (REG_CACHE_READ(MC1N2_SPR_DAC_SRC) == 0) {
+			if (REG_CACHE_READ(MC1N2_SPR_DAC_SW)) {
+				update.asSpOut[1].abSrcOnOff[5] = MCDRV_SRC5_DAC_R_ON;
+			}
+			else {
+				update.asSpOut[1].abSrcOnOff[5] = MCDRV_SRC5_DAC_R_OFF;
+			}
+		}
+		else {
+			if (REG_CACHE_READ(MC1N2_SPR_DAC_SW)) {
+				update.asSpOut[1].abSrcOnOff[5] = MCDRV_SRC5_DAC_M_ON;
+			}
+			else {
+				update.asSpOut[1].abSrcOnOff[5] = MCDRV_SRC5_DAC_M_OFF;
+			}
+		}
+		break;
+	case MC1N2_RC_MIC1_SW:
+		if (value) {
+			update.asRcOut[0].abSrcOnOff[0] = MCDRV_SRC0_MIC1_ON;
+		}
+		else {
+			update.asRcOut[0].abSrcOnOff[0] = MCDRV_SRC0_MIC1_OFF;
+		}
+		break;
+	case MC1N2_RC_MIC2_SW:
+		if (value) {
+			update.asRcOut[0].abSrcOnOff[0] = MCDRV_SRC0_MIC2_ON;
+		}
+		else {
+			update.asRcOut[0].abSrcOnOff[0] = MCDRV_SRC0_MIC2_OFF;
+		}
+		break;
+	case MC1N2_RC_MIC3_SW:
+		if (value) {
+			update.asRcOut[0].abSrcOnOff[0] = MCDRV_SRC0_MIC3_ON;
+		}
+		else {
+			update.asRcOut[0].abSrcOnOff[0] = MCDRV_SRC0_MIC3_OFF;
+		}
+		break;
+	case MC1N2_RC_LINEMONO_SW:
+		if (value) {
+			update.asRcOut[0].abSrcOnOff[1] = MCDRV_SRC1_LINE1_M_ON;
+		}
+		else {
+			update.asRcOut[0].abSrcOnOff[1] = MCDRV_SRC1_LINE1_M_OFF;
+		}
+		break;
+	case MC1N2_RC_DACL_SW:
+		if (value) {
+			update.asRcOut[0].abSrcOnOff[5] = MCDRV_SRC5_DAC_L_ON;
+		}
+		else {
+			update.asRcOut[0].abSrcOnOff[5] = MCDRV_SRC5_DAC_L_OFF;
+		}
+		break;
+	case MC1N2_RC_DACR_SW:
+		if (value) {
+			update.asRcOut[0].abSrcOnOff[5] = MCDRV_SRC5_DAC_R_ON;
+		}
+		else {
+			update.asRcOut[0].abSrcOnOff[5] = MCDRV_SRC5_DAC_R_OFF;
+		}
+		break;
+	case MC1N2_LOUT1L_MIC1_SW:
+		if (value) {
+			update.asLout1[0].abSrcOnOff[0] = MCDRV_SRC0_MIC1_ON;
+		}
+		else {
+			update.asLout1[0].abSrcOnOff[0] = MCDRV_SRC0_MIC1_OFF;
+		}
+		break;
+	case MC1N2_LOUT1L_MIC2_SW:
+		if (value) {
+			update.asLout1[0].abSrcOnOff[0] = MCDRV_SRC0_MIC2_ON;
+		}
+		else {
+			update.asLout1[0].abSrcOnOff[0] = MCDRV_SRC0_MIC2_OFF;
+		}
+		break;
+	case MC1N2_LOUT1L_MIC3_SW:
+		if (value) {
+			update.asLout1[0].abSrcOnOff[0] = MCDRV_SRC0_MIC3_ON;
+		}
+		else {
+			update.asLout1[0].abSrcOnOff[0] = MCDRV_SRC0_MIC3_OFF;
+		}
+		break;
+	case MC1N2_LOUT1L_LINE_SW:
+	case MC1N2_LOUT1L_LINE_SRC:
+		if (REG_CACHE_READ(MC1N2_LOUT1L_LINE_SRC) == 0) {
+			if (REG_CACHE_READ(MC1N2_LOUT1L_LINE_SW)) {
+				update.asLout1[0].abSrcOnOff[1] = MCDRV_SRC1_LINE1_L_ON;
+			}
+			else {
+				update.asLout1[0].abSrcOnOff[1] = MCDRV_SRC1_LINE1_L_OFF;
+			}
+		}
+		else {
+			if (REG_CACHE_READ(MC1N2_LOUT1L_LINE_SW)) {
+				update.asLout1[0].abSrcOnOff[1] = MCDRV_SRC1_LINE1_M_ON;
+			}
+			else {
+				update.asLout1[0].abSrcOnOff[1] = MCDRV_SRC1_LINE1_M_OFF;
+			}
+		}
+		break;
+	case MC1N2_LOUT1L_DAC_SW:
+	case MC1N2_LOUT1L_DAC_SRC:
+		if (REG_CACHE_READ(MC1N2_LOUT1L_DAC_SRC) == 0) {
+			if (REG_CACHE_READ(MC1N2_LOUT1L_DAC_SW)) {
+				update.asLout1[0].abSrcOnOff[5] = MCDRV_SRC5_DAC_L_ON;
+			}
+			else {
+				update.asLout1[0].abSrcOnOff[5] = MCDRV_SRC5_DAC_L_OFF;
+			}
+		}
+		else {
+			if (value) {
+				update.asLout1[0].abSrcOnOff[5] = MCDRV_SRC5_DAC_M_ON;
+			}
+			else {
+				update.asLout1[0].abSrcOnOff[5] = MCDRV_SRC5_DAC_M_OFF;
+			}
+		}
+		break;
+	case MC1N2_LOUT1R_MIC1_SW:
+		if (value) {
+			update.asLout1[1].abSrcOnOff[0] = MCDRV_SRC0_MIC1_ON;
+		}
+		else {
+			update.asLout1[1].abSrcOnOff[0] = MCDRV_SRC0_MIC1_OFF;
+		}
+		break;
+	case MC1N2_LOUT1R_MIC2_SW:
+		if (value) {
+			update.asLout1[1].abSrcOnOff[0] = MCDRV_SRC0_MIC2_ON;
+		}
+		else {
+			update.asLout1[1].abSrcOnOff[0] = MCDRV_SRC0_MIC2_OFF;
+		}
+		break;
+	case MC1N2_LOUT1R_MIC3_SW:
+		if (value) {
+			update.asLout1[1].abSrcOnOff[0] = MCDRV_SRC0_MIC3_ON;
+		}
+		else {
+			update.asLout1[1].abSrcOnOff[0] = MCDRV_SRC0_MIC3_OFF;
+		}
+		break;
+	case MC1N2_LOUT1R_LINER_SW:
+		if (value) {
+			update.asLout1[1].abSrcOnOff[1] = MCDRV_SRC1_LINE1_R_ON;
+		}
+		else {
+			update.asLout1[1].abSrcOnOff[1] = MCDRV_SRC1_LINE1_R_OFF;
+		}
+		break;
+	case MC1N2_LOUT1R_DACR_SW:
+		if (value) {
+			update.asLout1[1].abSrcOnOff[5] = MCDRV_SRC5_DAC_R_ON;
+		}
+		else {
+			update.asLout1[1].abSrcOnOff[5] = MCDRV_SRC5_DAC_R_OFF;
+		}
+		break;
+	case MC1N2_LOUT2L_MIC1_SW:
+		if (value) {
+			update.asLout2[0].abSrcOnOff[0] = MCDRV_SRC0_MIC1_ON;
+		}
+		else {
+			update.asLout2[0].abSrcOnOff[0] = MCDRV_SRC0_MIC1_OFF;
+		}
+		break;
+	case MC1N2_LOUT2L_MIC2_SW:
+		if (value) {
+			update.asLout2[0].abSrcOnOff[0] = MCDRV_SRC0_MIC2_ON;
+		}
+		else {
+			update.asLout2[0].abSrcOnOff[0] = MCDRV_SRC0_MIC2_OFF;
+		}
+		break;
+	case MC1N2_LOUT2L_MIC3_SW:
+		if (value) {
+			update.asLout2[0].abSrcOnOff[0] = MCDRV_SRC0_MIC3_ON;
+		}
+		else {
+			update.asLout2[0].abSrcOnOff[0] = MCDRV_SRC0_MIC3_OFF;
+		}
+		break;
+	case MC1N2_LOUT2L_LINE_SW:
+	case MC1N2_LOUT2L_LINE_SRC:
+		if (REG_CACHE_READ(MC1N2_LOUT2L_LINE_SRC) == 0) {
+			if (REG_CACHE_READ(MC1N2_LOUT2L_LINE_SW)) {
+				update.asLout2[0].abSrcOnOff[1] = MCDRV_SRC1_LINE1_L_ON;
+			}
+			else {
+				update.asLout2[0].abSrcOnOff[1] = MCDRV_SRC1_LINE1_L_OFF;
+			}
+		}
+		else {
+			if (REG_CACHE_READ(MC1N2_LOUT2L_LINE_SW)) {
+				update.asLout2[0].abSrcOnOff[1] = MCDRV_SRC1_LINE1_M_ON;
+			}
+			else {
+				update.asLout2[0].abSrcOnOff[1] = MCDRV_SRC1_LINE1_M_OFF;
+			}
+		}
+		break;
+	case MC1N2_LOUT2L_DAC_SW:
+	case MC1N2_LOUT2L_DAC_SRC:
+		if (REG_CACHE_READ(MC1N2_LOUT2L_DAC_SRC) == 0) {
+			if (REG_CACHE_READ(MC1N2_LOUT2L_DAC_SW)) {
+				update.asLout2[0].abSrcOnOff[5] = MCDRV_SRC5_DAC_L_ON;
+			}
+			else {
+				update.asLout2[0].abSrcOnOff[5] = MCDRV_SRC5_DAC_L_OFF;
+			}
+		}
+		else {
+			if (REG_CACHE_READ(MC1N2_LOUT2L_DAC_SW)) {
+				update.asLout2[0].abSrcOnOff[5] = MCDRV_SRC5_DAC_M_ON;
+			}
+			else {
+				update.asLout2[0].abSrcOnOff[5] = MCDRV_SRC5_DAC_M_OFF;
+			}
+		}
+		break;
+	case MC1N2_LOUT2R_MIC1_SW:
+		if (value) {
+			update.asLout2[1].abSrcOnOff[0] = MCDRV_SRC0_MIC1_ON;
+		}
+		else {
+			update.asLout2[1].abSrcOnOff[0] = MCDRV_SRC0_MIC1_OFF;
+		}
+		break;
+	case MC1N2_LOUT2R_MIC2_SW:
+		if (value) {
+			update.asLout2[1].abSrcOnOff[0] = MCDRV_SRC0_MIC2_ON;
+		}
+		else {
+			update.asLout2[1].abSrcOnOff[0] = MCDRV_SRC0_MIC2_OFF;
+		}
+		break;
+	case MC1N2_LOUT2R_MIC3_SW:
+		if (value) {
+			update.asLout2[1].abSrcOnOff[0] = MCDRV_SRC0_MIC3_ON;
+		}
+		else {
+			update.asLout2[1].abSrcOnOff[0] = MCDRV_SRC0_MIC3_OFF;
+		}
+		break;
+	case MC1N2_LOUT2R_LINER_SW:
+		if (value) {
+			update.asLout2[1].abSrcOnOff[1] = MCDRV_SRC1_LINE1_R_ON;
+		}
+		else {
+			update.asLout2[1].abSrcOnOff[1] = MCDRV_SRC1_LINE1_R_OFF;
+		}
+		break;
+	case MC1N2_LOUT2R_DACR_SW:
+		if (value) {
+			update.asLout2[1].abSrcOnOff[5] = MCDRV_SRC5_DAC_R_ON;
+		}
+		else {
+			update.asLout2[1].abSrcOnOff[5] = MCDRV_SRC5_DAC_R_OFF;
+		}
+		break;
+	case MC1N2_DACMAIN_SRC:
+	case MC1N2_DACVOICE_SRC:
+	case MC1N2_DIT0_SRC:
+	case MC1N2_DIT1_SRC:
+	case MC1N2_DIT2_SRC:
+		if (reg == MC1N2_DACMAIN_SRC) {
+			pch = &update.asDac[0];
+		}
+		else if (reg == MC1N2_DACVOICE_SRC) {
+			pch = &update.asDac[1];
+		}
+		else if (reg == MC1N2_DIT0_SRC) {
+			pch = &update.asDit0[0];
+		}
+		else if (reg == MC1N2_DIT1_SRC) {
+			pch = &update.asDit1[0];
+		}
+		else if (reg == MC1N2_DIT2_SRC) {
+			pch = &update.asDit2[0];
+		}
+
+		switch (value) {
+		case MC1N2_DSOURCE_OFF:
+			pch->abSrcOnOff[3] =
+				MCDRV_SRC3_DIR0_OFF | MCDRV_SRC3_DIR1_OFF | MCDRV_SRC3_DIR2_OFF;
+			pch->abSrcOnOff[4] = MCDRV_SRC4_ADC0_OFF | MCDRV_SRC4_PDM_OFF;
+			pch->abSrcOnOff[6] = MCDRV_SRC6_MIX_OFF | MCDRV_SRC6_AE_OFF;
+			break;
+		case MC1N2_DSOURCE_ADC: /* ADC */
+			pch->abSrcOnOff[3] =
+				MCDRV_SRC3_DIR0_OFF | MCDRV_SRC3_DIR1_OFF | MCDRV_SRC3_DIR2_OFF;
+			if (REG_CACHE_READ(MC1N2_AE_SRC) == MC1N2_DSOURCE_ADC) {
+				pch->abSrcOnOff[4] = MCDRV_SRC4_ADC0_OFF | MCDRV_SRC4_PDM_OFF;
+				pch->abSrcOnOff[6] = MCDRV_SRC6_MIX_OFF | MCDRV_SRC6_AE_ON;
+			}
+			else {
+				if (REG_CACHE_READ(MC1N2_ADC_PDM_SEL)) {
+					pch->abSrcOnOff[4] = MCDRV_SRC4_ADC0_OFF | MCDRV_SRC4_PDM_ON;
+				}
+				else {
+					pch->abSrcOnOff[4] = MCDRV_SRC4_ADC0_ON | MCDRV_SRC4_PDM_OFF;
+				}
+				pch->abSrcOnOff[6] = MCDRV_SRC6_MIX_OFF | MCDRV_SRC6_AE_OFF;
+			}
+			break;
+		case MC1N2_DSOURCE_DIR0: /* DIR0 */
+			pch->abSrcOnOff[4] = MCDRV_SRC4_ADC0_OFF | MCDRV_SRC4_PDM_OFF;
+			if (REG_CACHE_READ(MC1N2_AE_SRC) == MC1N2_DSOURCE_DIR0) {
+				pch->abSrcOnOff[3] =
+					MCDRV_SRC3_DIR0_OFF | MCDRV_SRC3_DIR1_OFF | MCDRV_SRC3_DIR2_OFF;
+				pch->abSrcOnOff[6] = MCDRV_SRC6_MIX_OFF | MCDRV_SRC6_AE_ON;
+			}
+			else {
+				pch->abSrcOnOff[3] =
+					MCDRV_SRC3_DIR0_ON | MCDRV_SRC3_DIR1_OFF | MCDRV_SRC3_DIR2_OFF;
+				pch->abSrcOnOff[6] = MCDRV_SRC6_MIX_OFF | MCDRV_SRC6_AE_OFF;
+			}
+			break;
+		case MC1N2_DSOURCE_DIR1: /* DIR1 */
+			pch->abSrcOnOff[4] = MCDRV_SRC4_ADC0_OFF | MCDRV_SRC4_PDM_OFF;
+			if (REG_CACHE_READ(MC1N2_AE_SRC) == MC1N2_DSOURCE_DIR1) {
+				pch->abSrcOnOff[3] =
+					MCDRV_SRC3_DIR0_OFF | MCDRV_SRC3_DIR1_OFF | MCDRV_SRC3_DIR2_OFF;
+				pch->abSrcOnOff[6] = MCDRV_SRC6_MIX_OFF | MCDRV_SRC6_AE_ON;
+			}
+			else {
+				pch->abSrcOnOff[3] =
+					MCDRV_SRC3_DIR0_OFF | MCDRV_SRC3_DIR1_ON | MCDRV_SRC3_DIR2_OFF;
+				pch->abSrcOnOff[6] = MCDRV_SRC6_MIX_OFF | MCDRV_SRC6_AE_OFF;
+			}
+			break;
+		case MC1N2_DSOURCE_DIR2: /* DIR2 */
+			pch->abSrcOnOff[4] = MCDRV_SRC4_ADC0_OFF | MCDRV_SRC4_PDM_OFF;
+			if (REG_CACHE_READ(MC1N2_AE_SRC) == MC1N2_DSOURCE_DIR2) {
+				pch->abSrcOnOff[3] =
+					MCDRV_SRC3_DIR0_OFF | MCDRV_SRC3_DIR1_OFF | MCDRV_SRC3_DIR2_OFF;
+				pch->abSrcOnOff[6] = MCDRV_SRC6_MIX_OFF | MCDRV_SRC6_AE_ON;
+			}
+			else {
+				pch->abSrcOnOff[3] =
+					MCDRV_SRC3_DIR0_OFF | MCDRV_SRC3_DIR1_OFF | MCDRV_SRC3_DIR2_ON;
+				pch->abSrcOnOff[6] = MCDRV_SRC6_MIX_OFF | MCDRV_SRC6_AE_OFF;
+			}
+			break;
+		case MC1N2_DSOURCE_MIX: /* MIX */
+			pch->abSrcOnOff[4] = MCDRV_SRC4_ADC0_OFF | MCDRV_SRC4_PDM_OFF;
+			pch->abSrcOnOff[3] =
+				MCDRV_SRC3_DIR0_OFF | MCDRV_SRC3_DIR1_OFF | MCDRV_SRC3_DIR2_OFF;
+			if (REG_CACHE_READ(MC1N2_AE_SRC) == MC1N2_DSOURCE_MIX) {
+				pch->abSrcOnOff[6] = MCDRV_SRC6_MIX_OFF | MCDRV_SRC6_AE_ON;
+			}
+			else {
+				pch->abSrcOnOff[6] = MCDRV_SRC6_MIX_ON | MCDRV_SRC6_AE_OFF;
+			}
+			break;
+		}
+		break;
+	case MC1N2_AE_SRC:
+	case MC1N2_ADC_PDM_SEL:
+		switch (REG_CACHE_READ(MC1N2_AE_SRC)) {
+		case MC1N2_DSOURCE_OFF:
+			update.asAe[0].abSrcOnOff[4] = MCDRV_SRC4_ADC0_OFF | MCDRV_SRC4_PDM_OFF;
+			update.asAe[0].abSrcOnOff[3] =
+				MCDRV_SRC3_DIR0_OFF | MCDRV_SRC3_DIR1_OFF | MCDRV_SRC3_DIR2_OFF;
+			update.asAe[0].abSrcOnOff[6] = MCDRV_SRC6_MIX_OFF;
+			break;
+		case MC1N2_DSOURCE_ADC: /* ADC */
+			if (REG_CACHE_READ(MC1N2_ADC_PDM_SEL)) {
+				update.asAe[0].abSrcOnOff[4] = MCDRV_SRC4_ADC0_OFF | MCDRV_SRC4_PDM_ON;
+			}
+			else {
+				update.asAe[0].abSrcOnOff[4] = MCDRV_SRC4_ADC0_ON | MCDRV_SRC4_PDM_OFF;
+			}
+			update.asAe[0].abSrcOnOff[3] =
+				MCDRV_SRC3_DIR0_OFF | MCDRV_SRC3_DIR1_OFF | MCDRV_SRC3_DIR2_OFF;
+			update.asAe[0].abSrcOnOff[6] = MCDRV_SRC6_MIX_OFF;
+			break;
+		case MC1N2_DSOURCE_DIR0: /* DIR0 */
+			update.asAe[0].abSrcOnOff[4] = MCDRV_SRC4_ADC0_OFF | MCDRV_SRC4_PDM_OFF;
+			update.asAe[0].abSrcOnOff[3] =
+				MCDRV_SRC3_DIR0_ON | MCDRV_SRC3_DIR1_OFF | MCDRV_SRC3_DIR2_OFF;
+			update.asAe[0].abSrcOnOff[6] = MCDRV_SRC6_MIX_OFF;
+			break;
+		case MC1N2_DSOURCE_DIR1:/* DIR1 */
+			update.asAe[0].abSrcOnOff[4] = MCDRV_SRC4_ADC0_OFF | MCDRV_SRC4_PDM_OFF;
+			update.asAe[0].abSrcOnOff[3] =
+				MCDRV_SRC3_DIR0_OFF | MCDRV_SRC3_DIR1_ON | MCDRV_SRC3_DIR2_OFF;
+			update.asAe[0].abSrcOnOff[6] = MCDRV_SRC6_MIX_OFF;
+			break;
+		case MC1N2_DSOURCE_DIR2:/* DIR2 */
+			update.asAe[0].abSrcOnOff[4] = MCDRV_SRC4_ADC0_OFF | MCDRV_SRC4_PDM_OFF;
+			update.asAe[0].abSrcOnOff[3] =
+				MCDRV_SRC3_DIR0_OFF | MCDRV_SRC3_DIR1_OFF | MCDRV_SRC3_DIR2_ON;
+			update.asAe[0].abSrcOnOff[6] = MCDRV_SRC6_MIX_OFF;
+			break;
+		case MC1N2_DSOURCE_MIX: /* MIX */
+			update.asAe[0].abSrcOnOff[4] = MCDRV_SRC4_ADC0_OFF | MCDRV_SRC4_PDM_OFF;
+			update.asAe[0].abSrcOnOff[3] =
+				MCDRV_SRC3_DIR0_OFF | MCDRV_SRC3_DIR1_OFF | MCDRV_SRC3_DIR2_OFF;
+			update.asAe[0].abSrcOnOff[6] = MCDRV_SRC6_MIX_ON;
+			break;
+		}
+
+		switch (REG_CACHE_READ(MC1N2_DACMAIN_SRC)) {
+		case MC1N2_DSOURCE_ADC: /* ADC */
+			if (REG_CACHE_READ(MC1N2_AE_SRC) == MC1N2_DSOURCE_ADC) {
+				update.asDac[0].abSrcOnOff[4] = MCDRV_SRC4_ADC0_OFF | MCDRV_SRC4_PDM_OFF;
+				update.asDac[0].abSrcOnOff[6] = MCDRV_SRC6_MIX_OFF | MCDRV_SRC6_AE_ON;
+			}
+			else {
+				if (REG_CACHE_READ(MC1N2_ADC_PDM_SEL)) {
+					update.asDac[0].abSrcOnOff[4] = MCDRV_SRC4_ADC0_OFF | MCDRV_SRC4_PDM_ON;
+				}
+				else {
+					update.asDac[0].abSrcOnOff[4] = MCDRV_SRC4_ADC0_ON | MCDRV_SRC4_PDM_OFF;
+				}
+				update.asDac[0].abSrcOnOff[6] = MCDRV_SRC6_MIX_OFF | MCDRV_SRC6_AE_OFF;
+			}
+			break;
+		case MC1N2_DSOURCE_DIR0: /* DIR0 */
+			if (REG_CACHE_READ(MC1N2_AE_SRC) == MC1N2_DSOURCE_DIR0) {
+				update.asDac[0].abSrcOnOff[3] =
+					MCDRV_SRC3_DIR0_OFF | MCDRV_SRC3_DIR1_OFF | MCDRV_SRC3_DIR2_OFF;
+				update.asDac[0].abSrcOnOff[6] = MCDRV_SRC6_MIX_OFF | MCDRV_SRC6_AE_ON;
+			}
+			else {
+				update.asDac[0].abSrcOnOff[3] =
+					MCDRV_SRC3_DIR0_ON | MCDRV_SRC3_DIR1_OFF | MCDRV_SRC3_DIR2_OFF;
+				update.asDac[0].abSrcOnOff[6] = MCDRV_SRC6_MIX_OFF | MCDRV_SRC6_AE_OFF;
+			}
+			break;
+		case MC1N2_DSOURCE_DIR1: /* DIR1 */
+			if (REG_CACHE_READ(MC1N2_AE_SRC) == MC1N2_DSOURCE_DIR1) {
+				update.asDac[0].abSrcOnOff[3] =
+					MCDRV_SRC3_DIR0_OFF | MCDRV_SRC3_DIR1_OFF | MCDRV_SRC3_DIR2_OFF;
+				update.asDac[0].abSrcOnOff[6] = MCDRV_SRC6_MIX_OFF | MCDRV_SRC6_AE_ON;
+			}
+			else {
+				update.asDac[0].abSrcOnOff[3] =
+					MCDRV_SRC3_DIR0_OFF | MCDRV_SRC3_DIR1_ON | MCDRV_SRC3_DIR2_OFF;
+				update.asDac[0].abSrcOnOff[6] = MCDRV_SRC6_MIX_OFF | MCDRV_SRC6_AE_OFF;
+			}
+			break;
+		case MC1N2_DSOURCE_DIR2: /* DIR2 */
+			if (REG_CACHE_READ(MC1N2_AE_SRC) == MC1N2_DSOURCE_DIR2) {
+				update.asDac[0].abSrcOnOff[3] =
+					MCDRV_SRC3_DIR0_OFF | MCDRV_SRC3_DIR1_OFF | MCDRV_SRC3_DIR2_OFF;
+				update.asDac[0].abSrcOnOff[6] = MCDRV_SRC6_MIX_OFF | MCDRV_SRC6_AE_ON;
+			}
+			else {
+				update.asDac[0].abSrcOnOff[3] =
+					MCDRV_SRC3_DIR0_OFF | MCDRV_SRC3_DIR1_OFF | MCDRV_SRC3_DIR2_ON;
+				update.asDac[0].abSrcOnOff[6] = MCDRV_SRC6_MIX_OFF | MCDRV_SRC6_AE_OFF;
+			}
+			break;
+		case MC1N2_DSOURCE_MIX: /* MIX */
+			if (REG_CACHE_READ(MC1N2_AE_SRC) == MC1N2_DSOURCE_MIX) {
+				update.asDac[0].abSrcOnOff[6] = MCDRV_SRC6_MIX_OFF | MCDRV_SRC6_AE_ON;
+			}
+			else {
+				update.asDac[0].abSrcOnOff[6] = MCDRV_SRC6_MIX_ON | MCDRV_SRC6_AE_OFF;
+			}
+			break;
+		}
+
+		switch (REG_CACHE_READ(MC1N2_DACVOICE_SRC)) {
+		case MC1N2_DSOURCE_ADC: /* ADC */
+			if (REG_CACHE_READ(MC1N2_AE_SRC) == MC1N2_DSOURCE_ADC) {
+				update.asDac[1].abSrcOnOff[4] = MCDRV_SRC4_ADC0_OFF | MCDRV_SRC4_PDM_OFF;
+				update.asDac[1].abSrcOnOff[6] = MCDRV_SRC6_MIX_OFF | MCDRV_SRC6_AE_ON;
+			}
+			else {
+				if (REG_CACHE_READ(MC1N2_ADC_PDM_SEL)) {
+					update.asDac[1].abSrcOnOff[4] = MCDRV_SRC4_ADC0_OFF | MCDRV_SRC4_PDM_ON;
+				}
+				else {
+					update.asDac[1].abSrcOnOff[4] = MCDRV_SRC4_ADC0_ON | MCDRV_SRC4_PDM_OFF;
+				}
+				update.asDac[1].abSrcOnOff[6] = MCDRV_SRC6_MIX_OFF | MCDRV_SRC6_AE_OFF;
+			}
+			break;
+		case MC1N2_DSOURCE_DIR0: /* DIR0 */
+			if (REG_CACHE_READ(MC1N2_AE_SRC) == MC1N2_DSOURCE_DIR0) {
+				update.asDac[1].abSrcOnOff[3] =
+					MCDRV_SRC3_DIR0_OFF | MCDRV_SRC3_DIR1_OFF | MCDRV_SRC3_DIR2_OFF;
+				update.asDac[1].abSrcOnOff[6] = MCDRV_SRC6_MIX_OFF | MCDRV_SRC6_AE_ON;
+			}
+			else {
+				update.asDac[1].abSrcOnOff[3] =
+					MCDRV_SRC3_DIR0_ON | MCDRV_SRC3_DIR1_OFF | MCDRV_SRC3_DIR2_OFF;
+				update.asDac[1].abSrcOnOff[6] = MCDRV_SRC6_MIX_OFF | MCDRV_SRC6_AE_OFF;
+			}
+			break;
+		case MC1N2_DSOURCE_DIR1: /* DIR1 */
+			if (REG_CACHE_READ(MC1N2_AE_SRC) == MC1N2_DSOURCE_DIR1) {
+				update.asDac[1].abSrcOnOff[3] =
+					MCDRV_SRC3_DIR0_OFF | MCDRV_SRC3_DIR1_OFF | MCDRV_SRC3_DIR2_OFF;
+				update.asDac[1].abSrcOnOff[6] = MCDRV_SRC6_MIX_OFF | MCDRV_SRC6_AE_ON;
+			}
+			else {
+				update.asDac[1].abSrcOnOff[3] =
+					MCDRV_SRC3_DIR0_OFF | MCDRV_SRC3_DIR1_ON | MCDRV_SRC3_DIR2_OFF;
+				update.asDac[1].abSrcOnOff[6] = MCDRV_SRC6_MIX_OFF | MCDRV_SRC6_AE_OFF;
+			}
+			break;
+		case MC1N2_DSOURCE_DIR2: /* DIR2 */
+			if (REG_CACHE_READ(MC1N2_AE_SRC) == MC1N2_DSOURCE_DIR2) {
+				update.asDac[1].abSrcOnOff[3] =
+					MCDRV_SRC3_DIR0_OFF | MCDRV_SRC3_DIR1_OFF | MCDRV_SRC3_DIR2_OFF;
+				update.asDac[1].abSrcOnOff[6] = MCDRV_SRC6_MIX_OFF | MCDRV_SRC6_AE_ON;
+			}
+			else {
+				update.asDac[1].abSrcOnOff[3] =
+					MCDRV_SRC3_DIR0_OFF | MCDRV_SRC3_DIR1_OFF | MCDRV_SRC3_DIR2_ON;
+				update.asDac[1].abSrcOnOff[6] = MCDRV_SRC6_MIX_OFF | MCDRV_SRC6_AE_OFF;
+			}
+			break;
+		case MC1N2_DSOURCE_MIX: /* MIX */
+			if (REG_CACHE_READ(MC1N2_AE_SRC) == MC1N2_DSOURCE_MIX) {
+				update.asDac[1].abSrcOnOff[6] = MCDRV_SRC6_MIX_OFF | MCDRV_SRC6_AE_ON;
+			}
+			else {
+				update.asDac[1].abSrcOnOff[6] = MCDRV_SRC6_MIX_ON | MCDRV_SRC6_AE_OFF;
+			}
+			break;
+		}
+
+		switch (REG_CACHE_READ(MC1N2_DIT0_SRC)) {
+		case MC1N2_DSOURCE_ADC: /* ADC */
+			if (REG_CACHE_READ(MC1N2_AE_SRC) == MC1N2_DSOURCE_ADC) {
+				update.asDit0[0].abSrcOnOff[4] = MCDRV_SRC4_ADC0_OFF | MCDRV_SRC4_PDM_OFF;
+				update.asDit0[0].abSrcOnOff[6] = MCDRV_SRC6_MIX_OFF | MCDRV_SRC6_AE_ON;
+			}
+			else {
+				if (REG_CACHE_READ(MC1N2_ADC_PDM_SEL)) {
+					update.asDit0[0].abSrcOnOff[4] = MCDRV_SRC4_ADC0_OFF | MCDRV_SRC4_PDM_ON;
+				}
+				else {
+					update.asDit0[0].abSrcOnOff[4] = MCDRV_SRC4_ADC0_ON | MCDRV_SRC4_PDM_OFF;
+				}
+				update.asDit0[0].abSrcOnOff[6] = MCDRV_SRC6_MIX_OFF | MCDRV_SRC6_AE_OFF;
+			}
+			break;
+		case MC1N2_DSOURCE_DIR0: /* DIR0 */
+			if (REG_CACHE_READ(MC1N2_AE_SRC) == MC1N2_DSOURCE_DIR0) {
+				update.asDit0[0].abSrcOnOff[3] =
+					MCDRV_SRC3_DIR0_OFF | MCDRV_SRC3_DIR1_OFF | MCDRV_SRC3_DIR2_OFF;
+				update.asDit0[0].abSrcOnOff[6] = MCDRV_SRC6_MIX_OFF | MCDRV_SRC6_AE_ON;
+			}
+			else {
+				update.asDit0[0].abSrcOnOff[3] =
+					MCDRV_SRC3_DIR0_ON | MCDRV_SRC3_DIR1_OFF | MCDRV_SRC3_DIR2_OFF;
+				update.asDit0[0].abSrcOnOff[6] = MCDRV_SRC6_MIX_OFF | MCDRV_SRC6_AE_OFF;
+			}
+			break;
+		case MC1N2_DSOURCE_DIR1: /* DIR1 */
+			if (REG_CACHE_READ(MC1N2_AE_SRC) == MC1N2_DSOURCE_DIR1) {
+				update.asDit0[0].abSrcOnOff[3] =
+					MCDRV_SRC3_DIR0_OFF | MCDRV_SRC3_DIR1_OFF | MCDRV_SRC3_DIR2_OFF;
+				update.asDit0[0].abSrcOnOff[6] = MCDRV_SRC6_MIX_OFF | MCDRV_SRC6_AE_ON;
+			}
+			else {
+				update.asDit0[0].abSrcOnOff[3] =
+					MCDRV_SRC3_DIR0_OFF | MCDRV_SRC3_DIR1_ON | MCDRV_SRC3_DIR2_OFF;
+				update.asDit0[0].abSrcOnOff[6] = MCDRV_SRC6_MIX_OFF | MCDRV_SRC6_AE_OFF;
+			}
+			break;
+		case MC1N2_DSOURCE_DIR2: /* DIR2 */
+			if (REG_CACHE_READ(MC1N2_AE_SRC) == MC1N2_DSOURCE_DIR2) {
+				update.asDit0[0].abSrcOnOff[3] =
+					MCDRV_SRC3_DIR0_OFF | MCDRV_SRC3_DIR1_OFF | MCDRV_SRC3_DIR2_OFF;
+				update.asDit0[0].abSrcOnOff[6] = MCDRV_SRC6_MIX_OFF | MCDRV_SRC6_AE_ON;
+			}
+			else {
+				update.asDit0[0].abSrcOnOff[3] =
+					MCDRV_SRC3_DIR0_OFF | MCDRV_SRC3_DIR1_OFF | MCDRV_SRC3_DIR2_ON;
+				update.asDit0[0].abSrcOnOff[6] = MCDRV_SRC6_MIX_OFF | MCDRV_SRC6_AE_OFF;
+			}
+			break;
+		case MC1N2_DSOURCE_MIX: /* MIX */
+			if (REG_CACHE_READ(MC1N2_AE_SRC) == MC1N2_DSOURCE_MIX) {
+				update.asDit0[0].abSrcOnOff[6] = MCDRV_SRC6_MIX_OFF | MCDRV_SRC6_AE_ON;
+			}
+			else {
+				update.asDit0[0].abSrcOnOff[6] = MCDRV_SRC6_MIX_ON | MCDRV_SRC6_AE_OFF;
+			}
+			break;
+		}
+
+		switch (REG_CACHE_READ(MC1N2_DIT1_SRC)) {
+		case MC1N2_DSOURCE_ADC: /* ADC */
+			if (REG_CACHE_READ(MC1N2_AE_SRC) == MC1N2_DSOURCE_ADC) {
+				update.asDit1[0].abSrcOnOff[4] = MCDRV_SRC4_ADC0_OFF | MCDRV_SRC4_PDM_OFF;
+				update.asDit1[0].abSrcOnOff[6] = MCDRV_SRC6_MIX_OFF | MCDRV_SRC6_AE_ON;
+			}
+			else {
+				if (REG_CACHE_READ(MC1N2_ADC_PDM_SEL)) {
+					update.asDit1[0].abSrcOnOff[4] = MCDRV_SRC4_ADC0_OFF | MCDRV_SRC4_PDM_ON;
+				}
+				else {
+					update.asDit1[0].abSrcOnOff[4] = MCDRV_SRC4_ADC0_ON | MCDRV_SRC4_PDM_OFF;
+				}
+				update.asDit1[0].abSrcOnOff[6] = MCDRV_SRC6_MIX_OFF | MCDRV_SRC6_AE_OFF;
+			}
+			break;
+		case MC1N2_DSOURCE_DIR0: /* DIR0 */
+			if (REG_CACHE_READ(MC1N2_AE_SRC) == MC1N2_DSOURCE_DIR0) {
+				update.asDit1[0].abSrcOnOff[3] =
+					MCDRV_SRC3_DIR0_OFF | MCDRV_SRC3_DIR1_OFF | MCDRV_SRC3_DIR2_OFF;
+				update.asDit1[0].abSrcOnOff[6] = MCDRV_SRC6_MIX_OFF | MCDRV_SRC6_AE_ON;
+			}
+			else {
+				update.asDit1[0].abSrcOnOff[3] =
+					MCDRV_SRC3_DIR0_ON | MCDRV_SRC3_DIR1_OFF | MCDRV_SRC3_DIR2_OFF;
+				update.asDit1[0].abSrcOnOff[6] = MCDRV_SRC6_MIX_OFF | MCDRV_SRC6_AE_OFF;
+			}
+			break;
+		case MC1N2_DSOURCE_DIR1: /* DIR1 */
+			if (REG_CACHE_READ(MC1N2_AE_SRC) == MC1N2_DSOURCE_DIR1) {
+				update.asDit1[0].abSrcOnOff[3] =
+					MCDRV_SRC3_DIR0_OFF | MCDRV_SRC3_DIR1_OFF | MCDRV_SRC3_DIR2_OFF;
+				update.asDit1[0].abSrcOnOff[6] = MCDRV_SRC6_MIX_OFF | MCDRV_SRC6_AE_ON;
+			}
+			else {
+				update.asDit1[0].abSrcOnOff[3] =
+					MCDRV_SRC3_DIR0_OFF | MCDRV_SRC3_DIR1_ON | MCDRV_SRC3_DIR2_OFF;
+				update.asDit1[0].abSrcOnOff[6] = MCDRV_SRC6_MIX_OFF | MCDRV_SRC6_AE_OFF;
+			}
+			break;
+		case MC1N2_DSOURCE_DIR2: /* DIR2 */
+			if (REG_CACHE_READ(MC1N2_AE_SRC) == MC1N2_DSOURCE_DIR2) {
+				update.asDit1[0].abSrcOnOff[3] =
+					MCDRV_SRC3_DIR0_OFF | MCDRV_SRC3_DIR1_OFF | MCDRV_SRC3_DIR2_OFF;
+				update.asDit1[0].abSrcOnOff[6] = MCDRV_SRC6_MIX_OFF | MCDRV_SRC6_AE_ON;
+			}
+			else {
+				update.asDit1[0].abSrcOnOff[3] =
+					MCDRV_SRC3_DIR0_OFF | MCDRV_SRC3_DIR1_OFF | MCDRV_SRC3_DIR2_ON;
+				update.asDit1[0].abSrcOnOff[6] = MCDRV_SRC6_MIX_OFF | MCDRV_SRC6_AE_OFF;
+			}
+			break;
+		case MC1N2_DSOURCE_MIX: /* MIX */
+			if (REG_CACHE_READ(MC1N2_AE_SRC) == MC1N2_DSOURCE_MIX) {
+				update.asDit1[0].abSrcOnOff[6] = MCDRV_SRC6_MIX_OFF | MCDRV_SRC6_AE_ON;
+			}
+			else {
+				update.asDit1[0].abSrcOnOff[6] = MCDRV_SRC6_MIX_ON | MCDRV_SRC6_AE_OFF;
+			}
+			break;
+		}
+
+		switch (REG_CACHE_READ(MC1N2_DIT2_SRC)) {
+		case MC1N2_DSOURCE_ADC: /* ADC */
+			if (REG_CACHE_READ(MC1N2_AE_SRC) == MC1N2_DSOURCE_ADC) {
+				update.asDit2[0].abSrcOnOff[4] = MCDRV_SRC4_ADC0_OFF | MCDRV_SRC4_PDM_OFF;
+				update.asDit2[0].abSrcOnOff[6] = MCDRV_SRC6_MIX_OFF | MCDRV_SRC6_AE_ON;
+			}
+			else {
+				if (REG_CACHE_READ(MC1N2_ADC_PDM_SEL)) {
+					update.asDit2[0].abSrcOnOff[4] = MCDRV_SRC4_ADC0_OFF | MCDRV_SRC4_PDM_ON;
+				}
+				else {
+					update.asDit2[0].abSrcOnOff[4] = MCDRV_SRC4_ADC0_ON | MCDRV_SRC4_PDM_OFF;
+				}
+				update.asDit2[0].abSrcOnOff[6] = MCDRV_SRC6_MIX_OFF | MCDRV_SRC6_AE_OFF;
+			}
+			break;
+		case MC1N2_DSOURCE_DIR0: /* DIR0 */
+			if (REG_CACHE_READ(MC1N2_AE_SRC) == MC1N2_DSOURCE_DIR0) {
+				update.asDit2[0].abSrcOnOff[3] =
+					MCDRV_SRC3_DIR0_OFF | MCDRV_SRC3_DIR1_OFF | MCDRV_SRC3_DIR2_OFF;
+				update.asDit2[0].abSrcOnOff[6] = MCDRV_SRC6_MIX_OFF | MCDRV_SRC6_AE_ON;
+			}
+			else {
+				update.asDit2[0].abSrcOnOff[3] =
+					MCDRV_SRC3_DIR0_ON | MCDRV_SRC3_DIR1_OFF | MCDRV_SRC3_DIR2_OFF;
+				update.asDit2[0].abSrcOnOff[6] = MCDRV_SRC6_MIX_OFF | MCDRV_SRC6_AE_OFF;
+			}
+			break;
+		case MC1N2_DSOURCE_DIR1: /* DIR1 */
+			if (REG_CACHE_READ(MC1N2_AE_SRC) == MC1N2_DSOURCE_DIR1) {
+				update.asDit2[0].abSrcOnOff[3] =
+					MCDRV_SRC3_DIR0_OFF | MCDRV_SRC3_DIR1_OFF | MCDRV_SRC3_DIR2_OFF;
+				update.asDit2[0].abSrcOnOff[6] = MCDRV_SRC6_MIX_OFF | MCDRV_SRC6_AE_ON;
+			}
+			else {
+				update.asDit2[0].abSrcOnOff[3] =
+					MCDRV_SRC3_DIR0_OFF | MCDRV_SRC3_DIR1_ON | MCDRV_SRC3_DIR2_OFF;
+				update.asDit2[0].abSrcOnOff[6] = MCDRV_SRC6_MIX_OFF | MCDRV_SRC6_AE_OFF;
+			}
+			break;
+		case MC1N2_DSOURCE_DIR2: /* DIR2 */
+			if (REG_CACHE_READ(MC1N2_AE_SRC) == MC1N2_DSOURCE_DIR2) {
+				update.asDit2[0].abSrcOnOff[3] =
+					MCDRV_SRC3_DIR0_OFF | MCDRV_SRC3_DIR1_OFF | MCDRV_SRC3_DIR2_OFF;
+				update.asDit2[0].abSrcOnOff[6] = MCDRV_SRC6_MIX_OFF | MCDRV_SRC6_AE_ON;
+			}
+			else {
+				update.asDit2[0].abSrcOnOff[3] =
+					MCDRV_SRC3_DIR0_OFF | MCDRV_SRC3_DIR1_OFF | MCDRV_SRC3_DIR2_ON;
+				update.asDit2[0].abSrcOnOff[6] = MCDRV_SRC6_MIX_OFF | MCDRV_SRC6_AE_OFF;
+			}
+			break;
+		case MC1N2_DSOURCE_MIX: /* MIX */
+			if (REG_CACHE_READ(MC1N2_AE_SRC) == MC1N2_DSOURCE_MIX) {
+				update.asDit2[0].abSrcOnOff[6] = MCDRV_SRC6_MIX_OFF | MCDRV_SRC6_AE_ON;
+			}
+			else {
+				update.asDit2[0].abSrcOnOff[6] = MCDRV_SRC6_MIX_ON | MCDRV_SRC6_AE_OFF;
+			}
+			break;
+		}
+
+		break;
+	case MC1N2_DMIX_ADC_SW:
+		if (value) {
+			if (REG_CACHE_READ(MC1N2_ADC_PDM_SEL)) {
+				update.asMix[0].abSrcOnOff[4] = MCDRV_SRC4_ADC0_OFF | MCDRV_SRC4_PDM_ON;
+			}
+			else {
+				update.asMix[0].abSrcOnOff[4] = MCDRV_SRC4_ADC0_ON | MCDRV_SRC4_PDM_OFF;
+			}
+		}
+		else {
+			update.asMix[0].abSrcOnOff[4] = MCDRV_SRC4_ADC0_OFF | MCDRV_SRC4_PDM_OFF;
+		}
+		break;
+	case MC1N2_DMIX_DIR0_SW:
+		if (value) {
+			update.asMix[0].abSrcOnOff[3] = MCDRV_SRC3_DIR0_ON;
+		}
+		else {
+			update.asMix[0].abSrcOnOff[3] = MCDRV_SRC3_DIR0_OFF;
+		}
+		break;
+	case MC1N2_DMIX_DIR1_SW:
+		if (value) {
+			update.asMix[0].abSrcOnOff[3] = MCDRV_SRC3_DIR1_ON;
+		}
+		else {
+			update.asMix[0].abSrcOnOff[3] = MCDRV_SRC3_DIR1_OFF;
+		}
+		break;
+	case MC1N2_DMIX_DIR2_SW:
+		if (value) {
+			update.asMix[0].abSrcOnOff[3] = MCDRV_SRC3_DIR2_ON;
+		}
+		else {
+			update.asMix[0].abSrcOnOff[3] = MCDRV_SRC3_DIR2_OFF;
+		}
+		break;
+	case MC1N2_AE_PARAM_SEL:
+		switch (value) {
+		case MC1N2_AE_PARAM_1:
+			pae = &sAeInfo_1;
+			break;
+		case MC1N2_AE_PARAM_2:
+			pae = &sAeInfo_2;
+			break;
+		case MC1N2_AE_PARAM_3:
+			pae = &sAeInfo_3;
+			break;
+		case MC1N2_AE_PARAM_4:
+			pae = &sAeInfo_4;
+			break;
+		case MC1N2_AE_PARAM_5:
+			pae = &sAeInfo_5;
+			break;
+		default:
+			pae = NULL;
+			break;
+		}
+		err = _McDrv_Ctrl(MCDRV_SET_AUDIOENGINE, pae, 0x1FF);
+		return err;
+		break;
+	case MC1N2_MICBIAS1:
+		if (value) {
+			update.asBias[0].abSrcOnOff[0] = MCDRV_SRC0_MIC1_ON;
+		}
+		else {
+			update.asBias[0].abSrcOnOff[0] = MCDRV_SRC0_MIC1_OFF;
+		}
+		break;
+	case MC1N2_MICBIAS2:
+		if (value) {
+			update.asBias[0].abSrcOnOff[0] = MCDRV_SRC0_MIC2_ON;
+		}
+		else {
+			update.asBias[0].abSrcOnOff[0] = MCDRV_SRC0_MIC2_OFF;
+		}
+		break;
+	case MC1N2_MICBIAS3:
+		if (value) {
+			update.asBias[0].abSrcOnOff[0] = MCDRV_SRC0_MIC3_ON;
+		}
+		else {
+			update.asBias[0].abSrcOnOff[0] = MCDRV_SRC0_MIC3_OFF;
+		}
+		break;
+	}
+
+	mc1n2_hwdep_ioctl_set_path(codec, &update, 0);
+	err = _McDrv_Ctrl(MCDRV_SET_PATH, &update, 0);
+
+	return err;
+}
+
+static int mc1n2_write_reg(struct snd_soc_codec *codec,
+			   unsigned int reg, unsigned int value)
+{
+	int err;
+
+#ifdef CONFIG_SND_SOC_PM_RUNTIME
+	pm_runtime_get_sync(codec->dev);
+#endif
+
+	if (reg < MC1N2_N_VOL_REG) {
+		err = write_reg_vol(codec, reg, value);
+	}
+	else {
+		err = write_reg_path(codec, reg, value);
+	}
+#ifdef CONFIG_SND_SOC_PM_RUNTIME
+	pm_runtime_mark_last_busy(codec->dev);
+	pm_runtime_put_autosuspend(codec->dev);
+#endif
+
+	return err;
+}
+
+static int mc1n2_get_codec_status(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol)
+{
+
+	return 0;
+}
+
+static int mc1n2_set_codec_status(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
+	struct mc1n2_data *mc1n2 = snd_soc_codec_get_drvdata(codec);
+	SINT16 *vol = (SINT16 *)&mc1n2->vol_store;
+
+	int control_data = ucontrol->value.integer.value[0];
+	int err, i;
+
+	dev_info(codec->dev, "%s: Recovery [%d]\n", __func__, control_data);
+
+	switch(control_data)
+	{
+	case CMD_CODEC_EMERGENCY_RECOVERY:
+		mutex_lock(&mc1n2->mutex);
+
+		mc1n2_set_mclk_source(1);
+
+		/* store parameters */
+		for (i = 0; i < MC1N2_N_INFO_STORE; i++) {
+			struct mc1n2_info_store *store
+						= &mc1n2_info_store_tbl[i];
+			if (store->get) {
+				err = _McDrv_Ctrl(store->get,
+					(void *)mc1n2 + store->offset, 0);
+				if (err != MCDRV_SUCCESS) {
+					dev_err(codec->dev,
+						"%d: Error in MCDRV_GET\n",
+						err);
+				}
+			}
+		}
+
+		err = _McDrv_Ctrl(MCDRV_TERM, NULL, 0);
+		if (err != MCDRV_SUCCESS)
+			dev_err(codec->dev, "%d: Error in MCDRV_TERM\n", err);
+
+		err = _McDrv_Ctrl(MCDRV_INIT, &mc1n2->setup.init, 0);
+		if (err != MCDRV_SUCCESS)
+			dev_err(codec->dev, "%d: Error in MCDRV_INIT\n", err);
+
+		/* restore parameters */
+		for (i = 0; i < sizeof(MCDRV_VOL_INFO)/sizeof(SINT16);
+								i++, vol++) {
+			*vol |= 0x0001;
+		}
+
+		for (i = 0; i < MC1N2_N_INFO_STORE; i++) {
+			struct mc1n2_info_store *store =
+						&mc1n2_info_store_tbl[i];
+			if (store->set) {
+				err = _McDrv_Ctrl(store->set,
+					(void *) mc1n2 + store->offset,
+					 store->flags);
+
+				if (err != MCDRV_SUCCESS) {
+					dev_err(codec->dev,
+						"%d: Error in MCDRV_Set\n",
+						err);
+				}
+			}
+		}
+
+		err = mc1n2_update_clock(mc1n2);
+		if (err != MCDRV_SUCCESS) {
+			dev_err(codec->dev,
+				"%d: Error in mc1n2_update_clock\n", err);
+		}
+
+		mutex_unlock(&mc1n2->mutex);
+
+		dev_info(codec->dev, "%s: Recovery Done\n", __func__);
+		break;
+
+	default:
+		break;
+	}
+
+	return 0;
+}
+
+static const DECLARE_TLV_DB_SCALE(mc1n2_tlv_digital, -7500, 100, 1);
+static const DECLARE_TLV_DB_SCALE(mc1n2_tlv_adc, -2850, 150, 1);
+static const DECLARE_TLV_DB_SCALE(mc1n2_tlv_ain, -3150, 150, 1);
+static const DECLARE_TLV_DB_SCALE(mc1n2_tlv_aout, -3100, 100, 1);
+static const DECLARE_TLV_DB_SCALE(mc1n2_tlv_micgain, 1500, 500, 0);
+
+static unsigned int mc1n2_tlv_hpsp[] = {
+	TLV_DB_RANGE_HEAD(5),
+	0, 2, TLV_DB_SCALE_ITEM(-4400, 800, 1),
+	2, 3, TLV_DB_SCALE_ITEM(-2800, 400, 0),
+	3, 7, TLV_DB_SCALE_ITEM(-2400, 200, 0),
+	7, 15, TLV_DB_SCALE_ITEM(-1600, 100, 0),
+	15, 31, TLV_DB_SCALE_ITEM(-800, 50, 0),
+};
+
+static unsigned int mc1n2_tlv_hpgain[] = {
+	TLV_DB_RANGE_HEAD(2),
+	0, 2, TLV_DB_SCALE_ITEM(0, 150, 0),
+	2, 3, TLV_DB_SCALE_ITEM(300, 300, 0),
+};
+
+static const char *codec_status_control[] = {
+        "REC_OFF", "REC_ON", "RESET_ON", "RESET_OFF"
+};
+
+static const struct soc_enum path_control_enum[] = {
+        SOC_ENUM_SINGLE_EXT(ARRAY_SIZE(codec_status_control), codec_status_control),
+};
+
+static const struct snd_kcontrol_new mc1n2_snd_controls[] = {
+	/*
+	 * digital volumes and mute switches
+	 */
+	SOC_DOUBLE_TLV("AD Digital Volume",
+		       MC1N2_DVOL_AD0, 0, 8, 93, 0, mc1n2_tlv_digital),
+	SOC_DOUBLE("AD Digital Switch",
+		   MC1N2_DVOL_AD0, 7, 15, 1, 0),
+
+	SOC_DOUBLE_TLV("AENG6 Volume",
+		       MC1N2_DVOL_AENG6, 0, 8, 93, 0, mc1n2_tlv_digital),
+	SOC_DOUBLE("AENG6 Switch",
+		   MC1N2_DVOL_AENG6, 7, 15, 1, 0),
+
+	SOC_DOUBLE_TLV("PDM Volume",
+		       MC1N2_DVOL_PDM, 0, 8, 93, 0, mc1n2_tlv_digital),
+	SOC_DOUBLE("PDM Switch",
+		   MC1N2_DVOL_PDM, 7, 15, 1, 0),
+
+	SOC_DOUBLE_TLV("DIR#0 Volume",
+		       MC1N2_DVOL_DIR0, 0, 8, 93, 0, mc1n2_tlv_digital),
+	SOC_DOUBLE("DIR#0 Switch",
+		   MC1N2_DVOL_DIR0, 7, 15, 1, 0),
+
+	SOC_DOUBLE_TLV("DIR#1 Volume",
+		       MC1N2_DVOL_DIR1, 0, 8, 93, 0, mc1n2_tlv_digital),
+	SOC_DOUBLE("DIR#1 Switch",
+		   MC1N2_DVOL_DIR1, 7, 15, 1, 0),
+
+	SOC_DOUBLE_TLV("DIR#2 Volume",
+		       MC1N2_DVOL_DIR2, 0, 8, 93, 0, mc1n2_tlv_digital),
+	SOC_DOUBLE("DIR#2 Switch",
+		   MC1N2_DVOL_DIR2, 7, 15, 1, 0),
+
+	SOC_DOUBLE_TLV("AD ATT Volume",
+		       MC1N2_DVOL_AD0_ATT, 0, 8, 93, 0, mc1n2_tlv_digital),
+	SOC_DOUBLE("AD ATT Switch",
+		   MC1N2_DVOL_AD0_ATT, 7, 15, 1, 0),
+
+	SOC_DOUBLE_TLV("DIR#0 ATT Volume",
+		       MC1N2_DVOL_DIR0_ATT, 0, 8, 93, 0, mc1n2_tlv_digital),
+	SOC_DOUBLE("DIR#0 ATT Switch",
+		   MC1N2_DVOL_DIR0_ATT, 7, 15, 1, 0),
+
+	SOC_DOUBLE_TLV("DIR#1 ATT Volume",
+		       MC1N2_DVOL_DIR1_ATT, 0, 8, 93, 0, mc1n2_tlv_digital),
+	SOC_DOUBLE("DIR#1 ATT Switch",
+		   MC1N2_DVOL_DIR1_ATT, 7, 15, 1, 0),
+
+	SOC_DOUBLE_TLV("DIR#2 ATT Volume",
+		       MC1N2_DVOL_DIR2_ATT, 0, 8, 93, 0, mc1n2_tlv_digital),
+	SOC_DOUBLE("DIR#2 ATT Switch",
+		   MC1N2_DVOL_DIR2_ATT, 7, 15, 1, 0),
+
+	SOC_DOUBLE_TLV("Side Tone Playback Volume",
+		       MC1N2_DVOL_SIDETONE, 0, 8, 93, 0, mc1n2_tlv_digital),
+	SOC_DOUBLE("Side Tone Playback Switch",
+		   MC1N2_DVOL_SIDETONE, 7, 15, 1, 0),
+
+	SOC_DOUBLE_TLV("Master Playback Volume",
+		       MC1N2_DVOL_DAC_MASTER, 0, 8, 93, 0, mc1n2_tlv_digital),
+	SOC_DOUBLE("Master Playback Switch",
+		   MC1N2_DVOL_DAC_MASTER, 7, 15, 1, 0),
+
+	SOC_DOUBLE_TLV("Voice Playback Volume",
+		       MC1N2_DVOL_DAC_VOICE, 0, 8, 93, 0, mc1n2_tlv_digital),
+	SOC_DOUBLE("Voice Playback Switch",
+		   MC1N2_DVOL_DAC_VOICE, 7, 15, 1, 0),
+
+	SOC_DOUBLE_TLV("DAC Playback Volume",
+		       MC1N2_DVOL_DAC_ATT, 0, 8, 93, 0, mc1n2_tlv_digital),
+	SOC_DOUBLE("DAC Playback Switch",
+		   MC1N2_DVOL_DAC_ATT, 7, 15, 1, 0),
+
+	SOC_DOUBLE_TLV("DIT#0 Capture Volume",
+		       MC1N2_DVOL_DIT0, 0, 8, 93, 0, mc1n2_tlv_digital),
+	SOC_DOUBLE("DIT#0 Capture Switch",
+		   MC1N2_DVOL_DIT0, 7, 15, 1, 0),
+
+	SOC_DOUBLE_TLV("DIT#1 Capture Volume",
+		       MC1N2_DVOL_DIT1, 0, 8, 93, 0, mc1n2_tlv_digital),
+	SOC_DOUBLE("DIT#1 Capture Switch",
+		   MC1N2_DVOL_DIT1, 7, 15, 1, 0),
+
+	SOC_DOUBLE_TLV("DIT#2 Capture Volume",
+		       MC1N2_DVOL_DIT2, 0, 8, 93, 0, mc1n2_tlv_digital),
+	SOC_DOUBLE("DIT#2 Capture Switch",
+		   MC1N2_DVOL_DIT2, 7, 15, 1, 0),
+
+	/*
+	 * analog volumes and mute switches
+	 */
+	SOC_DOUBLE_TLV("AD Analog Volume",
+		       MC1N2_AVOL_AD0, 0, 8, 31, 0, mc1n2_tlv_adc),
+	SOC_DOUBLE("AD Analog Switch",
+		   MC1N2_AVOL_AD0, 7, 15, 1, 0),
+
+	SOC_DOUBLE_TLV("Line Bypass Playback Volume",
+		       MC1N2_AVOL_LIN1, 0, 8, 31, 0, mc1n2_tlv_ain),
+	SOC_DOUBLE("Line Bypass Playback Switch",
+		   MC1N2_AVOL_LIN1, 7, 15, 1, 0),
+
+	SOC_SINGLE_TLV("Mic 1 Bypass Playback Volume",
+		       MC1N2_AVOL_MIC1, 0, 31, 0, mc1n2_tlv_ain),
+	SOC_SINGLE("Mic 1 Bypass Playback Switch",
+		   MC1N2_AVOL_MIC1, 7, 1, 0),
+
+	SOC_SINGLE_TLV("Mic 2 Bypass Playback Volume",
+		       MC1N2_AVOL_MIC2, 0, 31, 0, mc1n2_tlv_ain),
+	SOC_SINGLE("Mic 2 Bypass Playback Switch",
+		   MC1N2_AVOL_MIC2, 7, 1, 0),
+
+	SOC_SINGLE_TLV("Mic 3 Bypass Playback Volume",
+		       MC1N2_AVOL_MIC3, 0, 31, 0, mc1n2_tlv_ain),
+	SOC_SINGLE("Mic 3 Bypass Playback Switch",
+		   MC1N2_AVOL_MIC3, 7, 1, 0),
+
+	SOC_DOUBLE_TLV("Headphone Playback Volume",
+		       MC1N2_AVOL_HP, 0, 8, 31, 0, mc1n2_tlv_hpsp),
+	SOC_DOUBLE("Headphone Playback Switch",
+		   MC1N2_AVOL_HP, 7, 15, 1, 0),
+
+	SOC_DOUBLE_TLV("Speaker Playback Volume",
+		       MC1N2_AVOL_SP, 0, 8, 31, 0, mc1n2_tlv_hpsp),
+	SOC_DOUBLE("Speaker Playback Switch",
+		   MC1N2_AVOL_SP, 7, 15, 1, 0),
+
+	SOC_SINGLE_TLV("Receiver Playback Volume",
+		       MC1N2_AVOL_RC, 0, 31, 0, mc1n2_tlv_hpsp),
+	SOC_SINGLE("Receiver Playback Switch",
+		   MC1N2_AVOL_RC, 7, 1, 0),
+
+	SOC_DOUBLE_TLV("Line 1 Playback Volume",
+		       MC1N2_AVOL_LOUT1, 0, 8, 31, 0, mc1n2_tlv_aout),
+	SOC_DOUBLE("Line 1 Playback Switch",
+		   MC1N2_AVOL_LOUT1, 7, 15, 1, 0),
+
+	SOC_DOUBLE_TLV("Line 2 Playback Volume",
+		       MC1N2_AVOL_LOUT2, 0, 8, 31, 0, mc1n2_tlv_aout),
+	SOC_DOUBLE("Line 2 Playback Switch",
+		   MC1N2_AVOL_LOUT2, 7, 15, 1, 0),
+
+	SOC_SINGLE_TLV("Mic 1 Gain Volume",
+		       MC1N2_AVOL_MIC1_GAIN, 0, 3, 0, mc1n2_tlv_micgain),
+
+	SOC_SINGLE_TLV("Mic 2 Gain Volume",
+		       MC1N2_AVOL_MIC2_GAIN, 0, 3, 0, mc1n2_tlv_micgain),
+
+	SOC_SINGLE_TLV("Mic 3 Gain Volume",
+		       MC1N2_AVOL_MIC3_GAIN, 0, 3, 0, mc1n2_tlv_micgain),
+
+	SOC_SINGLE_TLV("HP Gain Playback Volume",
+		       MC1N2_AVOL_HP_GAIN, 0, 3, 0, mc1n2_tlv_hpgain),
+
+	SOC_ENUM_EXT("Codec Status", path_control_enum[0],
+				mc1n2_get_codec_status, mc1n2_set_codec_status),
+};
+
+/*
+ * Same as snd_soc_add_controls supported in alsa-driver 1.0.19 or later.
+ * This function is implimented for compatibility with linux 2.6.29.
+ */
+static int mc1n2_add_controls(struct snd_soc_codec *codec,
+			      const struct snd_kcontrol_new *controls, int n)
+{
+	int err, i;
+
+	for (i = 0; i < n; i++, controls++) {
+#ifdef ALSA_VER_ANDROID_3_0
+		if ((err = snd_ctl_add((struct snd_card *)codec->card->snd_card,
+					snd_soc_cnew(controls, codec, NULL, NULL))) < 0) {
+			return err;
+		}
+#else
+		if ((err = snd_ctl_add(codec->card,
+				       snd_soc_cnew(controls, codec, NULL))) < 0) {
+			return err;
+		}
+#endif
+	}
+
+	return 0;
+}
+
+static const struct snd_kcontrol_new adcl_mix[] = {
+	SOC_DAPM_SINGLE("Mic1 Switch", MC1N2_ADCL_MIC1_SW, 0, 1, 0),
+	SOC_DAPM_SINGLE("Mic2 Switch", MC1N2_ADCL_MIC2_SW, 0, 1, 0),
+	SOC_DAPM_SINGLE("Mic3 Switch", MC1N2_ADCL_MIC3_SW, 0, 1, 0),
+	SOC_DAPM_SINGLE("Line Switch", MC1N2_ADCL_LINE_SW, 0, 1, 0),
+};
+
+static const struct snd_kcontrol_new adcr_mix[] = {
+	SOC_DAPM_SINGLE("Mic1 Switch", MC1N2_ADCR_MIC1_SW, 0, 1, 0),
+	SOC_DAPM_SINGLE("Mic2 Switch", MC1N2_ADCR_MIC2_SW, 0, 1, 0),
+	SOC_DAPM_SINGLE("Mic3 Switch", MC1N2_ADCR_MIC3_SW, 0, 1, 0),
+	SOC_DAPM_SINGLE("Line Switch", MC1N2_ADCR_LINE_SW, 0, 1, 0),
+};
+
+static const struct snd_kcontrol_new hpl_mix[] = {
+	SOC_DAPM_SINGLE("Mic1 Switch", MC1N2_HPL_MIC1_SW, 0, 1, 0),
+	SOC_DAPM_SINGLE("Mic2 Switch", MC1N2_HPL_MIC2_SW, 0, 1, 0),
+	SOC_DAPM_SINGLE("Mic3 Switch", MC1N2_HPL_MIC3_SW, 0, 1, 0),
+	SOC_DAPM_SINGLE("Line Switch", MC1N2_HPL_LINE_SW, 0, 1, 0),
+	SOC_DAPM_SINGLE("Dac Switch", MC1N2_HPL_DAC_SW, 0, 1, 0),
+};
+
+static const struct snd_kcontrol_new hpr_mix[] = {
+	SOC_DAPM_SINGLE("Mic1 Switch", MC1N2_HPR_MIC1_SW, 0, 1, 0),
+	SOC_DAPM_SINGLE("Mic2 Switch", MC1N2_HPR_MIC2_SW, 0, 1, 0),
+	SOC_DAPM_SINGLE("Mic3 Switch", MC1N2_HPR_MIC3_SW, 0, 1, 0),
+	SOC_DAPM_SINGLE("LineR Switch", MC1N2_HPR_LINER_SW, 0, 1, 0),
+	SOC_DAPM_SINGLE("DacR Switch", MC1N2_HPR_DACR_SW, 0, 1, 0),
+};
+
+static const struct snd_kcontrol_new spl_mix[] = {
+	SOC_DAPM_SINGLE("Line Switch", MC1N2_SPL_LINE_SW, 0, 1, 0),
+	SOC_DAPM_SINGLE("Dac Switch", MC1N2_SPL_DAC_SW, 0, 1, 0),
+};
+
+static const struct snd_kcontrol_new spr_mix[] = {
+	SOC_DAPM_SINGLE("Line Switch", MC1N2_SPR_LINE_SW, 0, 1, 0),
+	SOC_DAPM_SINGLE("Dac Switch", MC1N2_SPR_DAC_SW, 0, 1, 0),
+};
+
+static const struct snd_kcontrol_new rc_mix[] = {
+	SOC_DAPM_SINGLE("Mic1 Switch", MC1N2_RC_MIC1_SW, 0, 1, 0),
+	SOC_DAPM_SINGLE("Mic2 Switch", MC1N2_RC_MIC2_SW, 0, 1, 0),
+	SOC_DAPM_SINGLE("Mic3 Switch", MC1N2_RC_MIC3_SW, 0, 1, 0),
+	SOC_DAPM_SINGLE("LineMono Switch", MC1N2_RC_LINEMONO_SW, 0, 1, 0),
+	SOC_DAPM_SINGLE("DacL Switch", MC1N2_RC_DACL_SW, 0, 1, 0),
+	SOC_DAPM_SINGLE("DacR Switch", MC1N2_RC_DACR_SW, 0, 1, 0),
+};
+
+static const struct snd_kcontrol_new lout1l_mix[] = {
+	SOC_DAPM_SINGLE("Mic1 Switch", MC1N2_LOUT1L_MIC1_SW, 0, 1, 0),
+	SOC_DAPM_SINGLE("Mic2 Switch", MC1N2_LOUT1L_MIC2_SW, 0, 1, 0),
+	SOC_DAPM_SINGLE("Mic3 Switch", MC1N2_LOUT1L_MIC3_SW, 0, 1, 0),
+	SOC_DAPM_SINGLE("Line Switch", MC1N2_LOUT1L_LINE_SW, 0, 1, 0),
+	SOC_DAPM_SINGLE("Dac Switch", MC1N2_LOUT1L_DAC_SW, 0, 1, 0),
+};
+
+static const struct snd_kcontrol_new lout1r_mix[] = {
+	SOC_DAPM_SINGLE("Mic1 Switch", MC1N2_LOUT1R_MIC1_SW, 0, 1, 0),
+	SOC_DAPM_SINGLE("Mic2 Switch", MC1N2_LOUT1R_MIC2_SW, 0, 1, 0),
+	SOC_DAPM_SINGLE("Mic3 Switch", MC1N2_LOUT1R_MIC3_SW, 0, 1, 0),
+	SOC_DAPM_SINGLE("LineR Switch", MC1N2_LOUT1R_LINER_SW, 0, 1, 0),
+	SOC_DAPM_SINGLE("DacR Switch", MC1N2_LOUT1R_DACR_SW, 0, 1, 0),
+};
+
+static const struct snd_kcontrol_new lout2l_mix[] = {
+	SOC_DAPM_SINGLE("Mic1 Switch", MC1N2_LOUT2L_MIC1_SW, 0, 1, 0),
+	SOC_DAPM_SINGLE("Mic2 Switch", MC1N2_LOUT2L_MIC2_SW, 0, 1, 0),
+	SOC_DAPM_SINGLE("Mic3 Switch", MC1N2_LOUT2L_MIC3_SW, 0, 1, 0),
+	SOC_DAPM_SINGLE("Line Switch", MC1N2_LOUT2L_LINE_SW, 0, 1, 0),
+	SOC_DAPM_SINGLE("Dac Switch", MC1N2_LOUT2L_DAC_SW, 0, 1, 0),
+};
+
+static const struct snd_kcontrol_new lout2r_mix[] = {
+	SOC_DAPM_SINGLE("Mic1 Switch", MC1N2_LOUT2R_MIC1_SW, 0, 1, 0),
+	SOC_DAPM_SINGLE("Mic2 Switch", MC1N2_LOUT2R_MIC2_SW, 0, 1, 0),
+	SOC_DAPM_SINGLE("Mic3 Switch", MC1N2_LOUT2R_MIC3_SW, 0, 1, 0),
+	SOC_DAPM_SINGLE("LineR Switch", MC1N2_LOUT2R_LINER_SW, 0, 1, 0),
+	SOC_DAPM_SINGLE("DacR Switch", MC1N2_LOUT2R_DACR_SW, 0, 1, 0),
+};
+
+static const struct snd_kcontrol_new digital_mix[] = {
+	SOC_DAPM_SINGLE("Adc Switch", MC1N2_DMIX_ADC_SW, 0, 1, 0),
+	SOC_DAPM_SINGLE("Dir0 Switch", MC1N2_DMIX_DIR0_SW, 0, 1, 0),
+	SOC_DAPM_SINGLE("Dir1 Switch", MC1N2_DMIX_DIR1_SW, 0, 1, 0),
+	SOC_DAPM_SINGLE("Dir2 Switch", MC1N2_DMIX_DIR2_SW, 0, 1, 0),
+};
+
+static const char *dsource_text[] = {
+	"OFF", "ADC", "DIR0", "DIR1", "DIR2", "MIX",
+};
+
+static const char *linel_mode_text[] = {
+	"LINEL", "LINEMONO",
+};
+
+static const char *liner_mode_text[] = {
+	"LINER", "LINEMONO",
+};
+
+static const char *dacl_mode_text[] = {
+	"DACL", "DACMONO",
+};
+
+static const char *dacr_mode_text[] = {
+	"DACR", "DACMONO",
+};
+
+static const char *ae_param_text[] = {
+	"PARAM1", "PARAM2", "PARAM3", "PARAM4", "PARAM5",
+};
+
+static const char *adc_pdm_text[] = {
+	"ADC", "PDM",
+};
+
+static const struct soc_enum dacmain_source_enum =
+	SOC_ENUM_SINGLE(MC1N2_DACMAIN_SRC, 0, 6, dsource_text);
+
+static const struct soc_enum dacvoice_source_enum =
+	SOC_ENUM_SINGLE(MC1N2_DACVOICE_SRC, 0, 6, dsource_text);
+
+static const struct soc_enum dit0_source_enum =
+	SOC_ENUM_SINGLE(MC1N2_DIT0_SRC, 0, 6, dsource_text);
+
+static const struct soc_enum dit1_source_enum =
+	SOC_ENUM_SINGLE(MC1N2_DIT1_SRC, 0, 6, dsource_text);
+
+static const struct soc_enum dit2_source_enum =
+	SOC_ENUM_SINGLE(MC1N2_DIT2_SRC, 0, 6, dsource_text);
+
+static const struct soc_enum ae_source_enum =
+	SOC_ENUM_SINGLE(MC1N2_AE_SRC, 0, 6, dsource_text);
+
+static const struct soc_enum adcl_line_enum =
+	SOC_ENUM_SINGLE(MC1N2_ADCL_LINE_SRC, 0, 2, linel_mode_text);
+
+static const struct soc_enum adcr_line_enum =
+	SOC_ENUM_SINGLE(MC1N2_ADCR_LINE_SRC, 0, 2, liner_mode_text);
+
+static const struct soc_enum hpl_line_enum =
+	SOC_ENUM_SINGLE(MC1N2_HPL_LINE_SRC, 0, 2, linel_mode_text);
+
+static const struct soc_enum hpl_dac_enum =
+	SOC_ENUM_SINGLE(MC1N2_HPL_DAC_SRC, 0, 2, dacl_mode_text);
+
+static const struct soc_enum spl_line_enum =
+	SOC_ENUM_SINGLE(MC1N2_SPL_LINE_SRC, 0, 2, linel_mode_text);
+
+static const struct soc_enum spl_dac_enum =
+	SOC_ENUM_SINGLE(MC1N2_SPL_DAC_SRC, 0, 2, dacl_mode_text);
+
+static const struct soc_enum spr_line_enum =
+	SOC_ENUM_SINGLE(MC1N2_SPR_LINE_SRC, 0, 2, liner_mode_text);
+
+static const struct soc_enum spr_dac_enum =
+	SOC_ENUM_SINGLE(MC1N2_SPR_DAC_SRC, 0, 2, dacr_mode_text);
+
+static const struct soc_enum lout1l_line_enum =
+	SOC_ENUM_SINGLE(MC1N2_LOUT1L_LINE_SRC, 0, 2, linel_mode_text);
+
+static const struct soc_enum lout1l_dac_enum =
+	SOC_ENUM_SINGLE(MC1N2_LOUT1L_DAC_SRC, 0, 2, dacl_mode_text);
+
+static const struct soc_enum lout2l_line_enum =
+	SOC_ENUM_SINGLE(MC1N2_LOUT2L_LINE_SRC, 0, 2, linel_mode_text);
+
+static const struct soc_enum lout2l_dac_enum =
+	SOC_ENUM_SINGLE(MC1N2_LOUT2L_DAC_SRC, 0, 2, dacl_mode_text);
+
+static const struct soc_enum ae_param_enum =
+	SOC_ENUM_SINGLE(MC1N2_AE_PARAM_SEL, 0, 5, ae_param_text);
+
+static const struct soc_enum adc_pdm_enum =
+	SOC_ENUM_SINGLE(MC1N2_ADC_PDM_SEL, 0, 2, adc_pdm_text);
+
+static const struct snd_kcontrol_new dacmain_mux =
+	SOC_DAPM_ENUM("DACMAIN SRC MUX", dacmain_source_enum);
+
+static const struct snd_kcontrol_new dacvoice_mux =
+	SOC_DAPM_ENUM("DACVOICE SRC MUX", dacvoice_source_enum);
+
+static const struct snd_kcontrol_new dit0_mux =
+	SOC_DAPM_ENUM("DIT0 SRC MUX", dit0_source_enum);
+
+static const struct snd_kcontrol_new dit1_mux =
+	SOC_DAPM_ENUM("DIT1 SRC MUX", dit1_source_enum);
+
+static const struct snd_kcontrol_new dit2_mux =
+	SOC_DAPM_ENUM("DIT2 SRC MUX", dit2_source_enum);
+
+static const struct snd_kcontrol_new ae_mux =
+	SOC_DAPM_ENUM("AE SRC MUX", ae_source_enum);
+
+static const struct snd_kcontrol_new adcl_line_mux =
+	SOC_DAPM_ENUM("ADCL LINE MUX", adcl_line_enum);
+
+static const struct snd_kcontrol_new adcr_line_mux =
+	SOC_DAPM_ENUM("ADCR LINE MUX", adcr_line_enum);
+
+static const struct snd_kcontrol_new hpl_line_mux =
+	SOC_DAPM_ENUM("HPL LINE MUX", hpl_line_enum);
+
+static const struct snd_kcontrol_new hpl_dac_mux =
+	SOC_DAPM_ENUM("HPL DAC MUX", hpl_dac_enum);
+
+static const struct snd_kcontrol_new spl_line_mux =
+	SOC_DAPM_ENUM("SPL LINE MUX", spl_line_enum);
+
+static const struct snd_kcontrol_new spl_dac_mux =
+	SOC_DAPM_ENUM("SPL DAC MUX", spl_dac_enum);
+
+static const struct snd_kcontrol_new spr_line_mux =
+	SOC_DAPM_ENUM("SPR LINE MUX", spr_line_enum);
+
+static const struct snd_kcontrol_new spr_dac_mux =
+	SOC_DAPM_ENUM("SPR DAC MUX", spr_dac_enum);
+
+static const struct snd_kcontrol_new lout1l_line_mux =
+	SOC_DAPM_ENUM("LOUT1L LINE MUX", lout1l_line_enum);
+
+static const struct snd_kcontrol_new lout1l_dac_mux =
+	SOC_DAPM_ENUM("LOUT1L DAC MUX", lout1l_dac_enum);
+
+static const struct snd_kcontrol_new lout2l_line_mux =
+	SOC_DAPM_ENUM("LOUT2L LINE MUX", lout2l_line_enum);
+
+static const struct snd_kcontrol_new lout2l_dac_mux =
+	SOC_DAPM_ENUM("LOUT2L DAC MUX", lout2l_dac_enum);
+
+static const struct snd_kcontrol_new ae_param_mux =
+	SOC_DAPM_ENUM("AE PARAMETER", ae_param_enum);
+
+static const struct snd_kcontrol_new adc_pdm_mux =
+	SOC_DAPM_ENUM("ADC PDM MUX", adc_pdm_enum);
+
+static const struct snd_kcontrol_new bias1_sw =
+	SOC_DAPM_SINGLE("Switch", MC1N2_MICBIAS1, 0, 1, 0);
+
+static const struct snd_kcontrol_new bias2_sw =
+	SOC_DAPM_SINGLE("Switch", MC1N2_MICBIAS2, 0, 1, 0);
+
+static const struct snd_kcontrol_new bias3_sw =
+	SOC_DAPM_SINGLE("Switch", MC1N2_MICBIAS3, 0, 1, 0);
+
+static const struct snd_soc_dapm_widget mc1n2_widgets[] = {
+SND_SOC_DAPM_INPUT("MIC1"),
+SND_SOC_DAPM_INPUT("MIC2"),
+SND_SOC_DAPM_INPUT("MIC3"),
+SND_SOC_DAPM_INPUT("LINEIN"),
+
+SND_SOC_DAPM_INPUT("DIR0"),
+SND_SOC_DAPM_INPUT("DIR1"),
+SND_SOC_DAPM_INPUT("DIR2"),
+
+SND_SOC_DAPM_INPUT("PDM"),
+
+SND_SOC_DAPM_INPUT("AE1"),
+SND_SOC_DAPM_INPUT("AE2"),
+SND_SOC_DAPM_INPUT("AE3"),
+SND_SOC_DAPM_INPUT("AE4"),
+SND_SOC_DAPM_INPUT("AE5"),
+
+SND_SOC_DAPM_INPUT("BIAS1"),
+SND_SOC_DAPM_INPUT("BIAS2"),
+SND_SOC_DAPM_INPUT("BIAS3"),
+
+SND_SOC_DAPM_OUTPUT("DIT0"),
+SND_SOC_DAPM_OUTPUT("DIT1"),
+SND_SOC_DAPM_OUTPUT("DIT2"),
+
+SND_SOC_DAPM_ADC("ADC", NULL, SND_SOC_NOPM, 0, 0),
+SND_SOC_DAPM_DAC("DAC", NULL, SND_SOC_NOPM, 0, 0),
+
+SND_SOC_DAPM_MIXER("ADCL MIXER", SND_SOC_NOPM, 0, 0, adcl_mix, ARRAY_SIZE(adcl_mix)),
+SND_SOC_DAPM_MIXER("ADCR MIXER", SND_SOC_NOPM, 0, 0, adcr_mix, ARRAY_SIZE(adcr_mix)),
+SND_SOC_DAPM_MIXER("HPL MIXER", SND_SOC_NOPM, 0, 0, hpl_mix, ARRAY_SIZE(hpl_mix)),
+SND_SOC_DAPM_MIXER("HPR MIXER", SND_SOC_NOPM, 0, 0, hpr_mix, ARRAY_SIZE(hpr_mix)),
+SND_SOC_DAPM_MIXER("SPL MIXER", SND_SOC_NOPM, 0, 0, spl_mix, ARRAY_SIZE(spl_mix)),
+SND_SOC_DAPM_MIXER("SPR MIXER", SND_SOC_NOPM, 0, 0, spr_mix, ARRAY_SIZE(spr_mix)),
+SND_SOC_DAPM_MIXER("RC MIXER", SND_SOC_NOPM, 0, 0, rc_mix, ARRAY_SIZE(rc_mix)),
+SND_SOC_DAPM_MIXER("LINEOUT1L MIXER", SND_SOC_NOPM, 0, 0, lout1l_mix, ARRAY_SIZE(lout1l_mix)),
+SND_SOC_DAPM_MIXER("LINEOUT1R MIXER", SND_SOC_NOPM, 0, 0, lout1r_mix, ARRAY_SIZE(lout1r_mix)),
+SND_SOC_DAPM_MIXER("LINEOUT2L MIXER", SND_SOC_NOPM, 0, 0, lout2l_mix, ARRAY_SIZE(lout2l_mix)),
+SND_SOC_DAPM_MIXER("LINEOUT2R MIXER", SND_SOC_NOPM, 0, 0, lout2r_mix, ARRAY_SIZE(lout2r_mix)),
+
+SND_SOC_DAPM_MIXER("DIGITAL MIXER", SND_SOC_NOPM, 0, 0, digital_mix, ARRAY_SIZE(digital_mix)),
+
+SND_SOC_DAPM_MUX("DACMAIN SRC", SND_SOC_NOPM, 0, 0, &dacmain_mux),
+SND_SOC_DAPM_MUX("DACVOICE SRC", SND_SOC_NOPM, 0, 0, &dacvoice_mux),
+SND_SOC_DAPM_MUX("DIT0 SRC", SND_SOC_NOPM, 0, 0, &dit0_mux),
+SND_SOC_DAPM_MUX("DIT1 SRC", SND_SOC_NOPM, 0, 0, &dit1_mux),
+SND_SOC_DAPM_MUX("DIT2 SRC", SND_SOC_NOPM, 0, 0, &dit2_mux),
+
+SND_SOC_DAPM_MUX("AE SRC", SND_SOC_NOPM, 0, 0, &ae_mux),
+
+SND_SOC_DAPM_MUX("ADCL LINE MIXMODE", SND_SOC_NOPM, 0, 0, &adcl_line_mux),
+SND_SOC_DAPM_MUX("ADCR LINE MIXMODE", SND_SOC_NOPM, 0, 0, &adcr_line_mux),
+
+SND_SOC_DAPM_MUX("HPL LINE MIXMODE", SND_SOC_NOPM, 0, 0, &hpl_line_mux),
+SND_SOC_DAPM_MUX("HPL DAC MIXMODE", SND_SOC_NOPM, 0, 0, &hpl_dac_mux),
+
+SND_SOC_DAPM_MUX("SPL LINE MIXMODE", SND_SOC_NOPM, 0, 0, &spl_line_mux),
+SND_SOC_DAPM_MUX("SPL DAC MIXMODE", SND_SOC_NOPM, 0, 0, &spl_dac_mux),
+SND_SOC_DAPM_MUX("SPR LINE MIXMODE", SND_SOC_NOPM, 0, 0, &spr_line_mux),
+SND_SOC_DAPM_MUX("SPR DAC MIXMODE", SND_SOC_NOPM, 0, 0, &spr_dac_mux),
+
+SND_SOC_DAPM_MUX("LINEOUT1L LINE MIXMODE", SND_SOC_NOPM, 0, 0, &lout1l_line_mux),
+SND_SOC_DAPM_MUX("LINEOUT1L DAC MIXMODE", SND_SOC_NOPM, 0, 0, &lout1l_dac_mux),
+
+SND_SOC_DAPM_MUX("LINEOUT2L LINE MIXMODE", SND_SOC_NOPM, 0, 0, &lout2l_line_mux),
+SND_SOC_DAPM_MUX("LINEOUT2L DAC MIXMODE", SND_SOC_NOPM, 0, 0, &lout2l_dac_mux),
+
+SND_SOC_DAPM_MUX("AE PARAMETER SEL", SND_SOC_NOPM, 0, 0, &ae_param_mux),
+
+SND_SOC_DAPM_MUX("ADC PDM SEL", SND_SOC_NOPM, 0, 0, &adc_pdm_mux),
+
+SND_SOC_DAPM_SWITCH("MB1", SND_SOC_NOPM, 0, 0, &bias1_sw),
+SND_SOC_DAPM_SWITCH("MB2", SND_SOC_NOPM, 0, 0, &bias2_sw),
+SND_SOC_DAPM_SWITCH("MB3", SND_SOC_NOPM, 0, 0, &bias3_sw),
+};
+
+static const struct snd_soc_dapm_route intercon[] = {
+	{"ADCL LINE MIXMODE", "LINEL", "LINEIN"},
+	{"ADCL LINE MIXMODE", "LINEMONO", "LINEIN"},
+	{"ADCR LINE MIXMODE", "LINER", "LINEIN"},
+	{"ADCR LINE MIXMODE", "LINEMONO", "LINEIN"},
+
+	{"HPL LINE MIXMODE", "LINEL", "LINEIN"},
+	{"HPL LINE MIXMODE", "LINEMONO", "LINEIN"},
+	{"HPL DAC MIXMODE", "DACL", "DAC"},
+	{"HPL DAC MIXMODE", "DACMONO", "DAC"},
+
+	{"SPL LINE MIXMODE", "LINEL", "LINEIN"},
+	{"SPL LINE MIXMODE", "LINEMONO", "LINEIN"},
+	{"SPL DAC MIXMODE", "DACL", "DAC"},
+	{"SPL DAC MIXMODE", "DACMONO", "DAC"},
+
+	{"SPR LINE MIXMODE", "LINER", "LINEIN"},
+	{"SPR LINE MIXMODE", "LINEMONO", "LINEIN"},
+	{"SPR DAC MIXMODE", "DACR", "DAC"},
+	{"SPR DAC MIXMODE", "DACMONO", "DAC"},
+
+	{"LINEOUT1L LINE MIXMODE", "LINEL", "LINEIN"},
+	{"LINEOUT1L LINE MIXMODE", "LINEMONO", "LINEIN"},
+	{"LINEOUT1L DAC MIXMODE", "DACL", "DAC"},
+	{"LINEOUT1L DAC MIXMODE", "DACMONO", "DAC"},
+
+	{"LINEOUT2L LINE MIXMODE", "LINEL", "LINEIN"},
+	{"LINEOUT2L LINE MIXMODE", "LINEMONO", "LINEIN"},
+	{"LINEOUT2L DAC MIXMODE", "DACL", "DAC"},
+	{"LINEOUT2L DAC MIXMODE", "DACMONO", "DAC"},
+
+	{"ADCL MIXER", "Mic1 Switch", "MIC1"},
+	{"ADCL MIXER", "Mic2 Switch", "MIC2"},
+	{"ADCL MIXER", "Mic3 Switch", "MIC3"},
+	{"ADCL MIXER", "Line Switch", "ADCL LINE MIXMODE"},
+
+	{"ADCR MIXER", "Mic1 Switch", "MIC1"},
+	{"ADCR MIXER", "Mic2 Switch", "MIC2"},
+	{"ADCR MIXER", "Mic3 Switch", "MIC3"},
+	{"ADCR MIXER", "Line Switch", "ADCR LINE MIXMODE"},
+
+	{"HPL MIXER", "Mic1 Switch", "MIC1"},
+	{"HPL MIXER", "Mic2 Switch", "MIC2"},
+	{"HPL MIXER", "Mic3 Switch", "MIC3"},
+	{"HPL MIXER", "Line Switch", "HPL LINE MIXMODE"},
+	{"HPL MIXER", "Dac Switch", "HPL DAC MIXMODE"},
+
+	{"HPR MIXER", "Mic1 Switch", "MIC1"},
+	{"HPR MIXER", "Mic2 Switch", "MIC2"},
+	{"HPR MIXER", "Mic3 Switch", "MIC3"},
+	{"HPR MIXER", "LineR Switch", "LINEIN"},
+	{"HPR MIXER", "DacR Switch", "DAC"},
+
+	{"SPL MIXER", "Line Switch", "SPL LINE MIXMODE"},
+	{"SPL MIXER", "Dac Switch", "SPL DAC MIXMODE"},
+
+	{"SPR MIXER", "Line Switch", "SPR LINE MIXMODE"},
+	{"SPR MIXER", "Dac Switch", "SPR DAC MIXMODE"},
+
+	{"RC MIXER", "Mic1 Switch", "MIC1"},
+	{"RC MIXER", "Mic2 Switch", "MIC2"},
+	{"RC MIXER", "Mic3 Switch", "MIC3"},
+	{"RC MIXER", "LineMono Switch", "LINEIN"},
+	{"RC MIXER", "DacL Switch", "DAC"},
+	{"RC MIXER", "DacR Switch", "DAC"},
+
+	{"LINEOUT1L MIXER", "Mic1 Switch", "MIC1"},
+	{"LINEOUT1L MIXER", "Mic2 Switch", "MIC2"},
+	{"LINEOUT1L MIXER", "Mic3 Switch", "MIC3"},
+	{"LINEOUT1L MIXER", "Line Switch", "LINEOUT1L LINE MIXMODE"},
+	{"LINEOUT1L MIXER", "Dac Switch", "LINEOUT1L DAC MIXMODE"},
+
+	{"LINEOUT1R MIXER", "Mic1 Switch", "MIC1"},
+	{"LINEOUT1R MIXER", "Mic2 Switch", "MIC2"},
+	{"LINEOUT1R MIXER", "Mic3 Switch", "MIC3"},
+	{"LINEOUT1R MIXER", "LineR Switch", "LINEIN"},
+	{"LINEOUT1R MIXER", "DacR Switch", "DAC"},
+
+	{"LINEOUT2L MIXER", "Mic1 Switch", "MIC1"},
+	{"LINEOUT2L MIXER", "Mic2 Switch", "MIC2"},
+	{"LINEOUT2L MIXER", "Mic3 Switch", "MIC3"},
+
+	{"LINEOUT2L MIXER", "Line Switch", "LINEOUT2L LINE MIXMODE"},
+	{"LINEOUT2L MIXER", "Dac Switch", "LINEOUT2L DAC MIXMODE"},
+
+	{"LINEOUT2R MIXER", "Mic1 Switch", "MIC1"},
+	{"LINEOUT2R MIXER", "Mic2 Switch", "MIC2"},
+	{"LINEOUT2R MIXER", "Mic3 Switch", "MIC3"},
+	{"LINEOUT2R MIXER", "LineR Switch", "LINEIN"},
+	{"LINEOUT2R MIXER", "DacR Switch", "DAC"},
+
+	{"ADC", NULL, "ADCL MIXER"},
+	{"ADC", NULL, "ADCR MIXER"},
+
+	{"DIGITAL MIXER", "Adc Switch", "ADC PDM SEL"},
+	{"DIGITAL MIXER", "Dir0 Switch", "DIR0"},
+	{"DIGITAL MIXER", "Dir1 Switch", "DIR1"},
+	{"DIGITAL MIXER", "Dir2 Switch", "DIR2"},
+
+	{"AE SRC", "ADC", "ADCL MIXER"},
+	{"AE SRC", "ADC", "ADCR MIXER"},
+	{"AE SRC", "DIR0", "DIR0"},
+	{"AE SRC", "DIR1", "DIR1"},
+	{"AE SRC", "DIR2", "DIR2"},
+	{"AE SRC", "MIX", "DIGITAL MIXER"},
+
+	{"DACMAIN SRC", "ADC", "ADC PDM SEL"},
+	{"DACMAIN SRC", "DIR0", "DIR0"},
+	{"DACMAIN SRC", "DIR1", "DIR1"},
+	{"DACMAIN SRC", "DIR2", "DIR2"},
+	{"DACMAIN SRC", "MIX", "DIGITAL MIXER"},
+
+	{"DACVOICE SRC", "ADC", "ADC PDM SEL"},
+	{"DACVOICE SRC", "DIR0", "DIR0"},
+	{"DACVOICE SRC", "DIR1", "DIR1"},
+	{"DACVOICE SRC", "DIR2", "DIR2"},
+	{"DACVOICE SRC", "MIX", "DIGITAL MIXER"},
+
+	{"DIT0 SRC", "ADC", "ADC PDM SEL"},
+	{"DIT0 SRC", "DIR0", "DIR0"},
+	{"DIT0 SRC", "DIR1", "DIR1"},
+	{"DIT0 SRC", "DIR2", "DIR2"},
+	{"DIT0 SRC", "MIX", "DIGITAL MIXER"},
+
+	{"DIT1 SRC", "ADC", "ADC PDM SEL"},
+	{"DIT1 SRC", "DIR0", "DIR0"},
+	{"DIT1 SRC", "DIR1", "DIR1"},
+	{"DIT1 SRC", "DIR2", "DIR2"},
+	{"DIT1 SRC", "MIX", "DIGITAL MIXER"},
+
+	{"DIT2 SRC", "ADC", "ADC PDM SEL"},
+	{"DIT2 SRC", "DIR0", "DIR0"},
+	{"DIT2 SRC", "DIR1", "DIR1"},
+	{"DIT2 SRC", "DIR2", "DIR2"},
+	{"DIT2 SRC", "MIX", "DIGITAL MIXER"},
+
+	{"AE PARAMETER SEL", "PARAM1", "AE1"},
+	{"AE PARAMETER SEL", "PARAM2", "AE2"},
+	{"AE PARAMETER SEL", "PARAM3", "AE3"},
+	{"AE PARAMETER SEL", "PARAM4", "AE4"},
+	{"AE PARAMETER SEL", "PARAM5", "AE5"},
+
+	{"ADC PDM SEL", "ADC", "ADC"},
+	{"ADC PDM SEL", "PDM", "PDM"},
+
+	{"MB1", "Switch", "BIAS1"},
+	{"MB2", "Switch", "BIAS2"},
+	{"MB3", "Switch", "BIAS3"},
+
+	{"MIC1", NULL, "MB1"},
+	{"MIC2", NULL, "MB2"},
+	{"MIC3", NULL, "MB3"},
+};
+
+#ifdef ALSA_VER_ANDROID_3_0
+static int mc1n2_add_widgets(struct snd_soc_codec *codec)
+{
+	int err;
+
+	err = snd_soc_dapm_new_controls(&codec->dapm, mc1n2_widgets,
+				  ARRAY_SIZE(mc1n2_widgets));
+	if(err < 0) {
+		return err;
+	}
+
+	err = snd_soc_dapm_add_routes(&codec->dapm, intercon, ARRAY_SIZE(intercon));
+	if(err < 0) {
+		return err;
+	}
+
+	err = snd_soc_dapm_new_widgets(&codec->dapm);
+	if(err < 0) {
+		return err;
+	}
+
+	return 0;
+}
+#else
+static int mc1n2_add_widgets(struct snd_soc_codec *codec)
+{
+	int err;
+
+	err = snd_soc_dapm_new_controls(codec, mc1n2_widgets,
+				  ARRAY_SIZE(mc1n2_widgets));
+	if(err < 0) {
+		return err;
+	}
+
+	err = snd_soc_dapm_add_routes(codec, intercon, ARRAY_SIZE(intercon));
+	if(err < 0) {
+		return err;
+	}
+
+	err = snd_soc_dapm_new_widgets(codec);
+	if(err < 0) {
+		return err;
+	}
+
+	return 0;
+}
+#endif
+
+/*
+ * Hwdep interface
+ */
+static int mc1n2_hwdep_open(struct snd_hwdep * hw, struct file *file)
+{
+	/* Nothing to do */
+	return 0;
+}
+
+static int mc1n2_hwdep_release(struct snd_hwdep *hw, struct file *file)
+{
+	/* Nothing to do */
+	return 0;
+}
+
+static int mc1n2_hwdep_map_error(int err)
+{
+	switch (err) {
+	case MCDRV_SUCCESS:
+		return 0;
+	case MCDRV_ERROR_ARGUMENT:
+		return -EINVAL;
+	case MCDRV_ERROR_STATE:
+		return -EBUSY;
+	case MCDRV_ERROR_TIMEOUT:
+		return -EIO;
+	default:
+		/* internal error */
+		return -EIO;
+	}
+}
+
+static int mc1n2_hwdep_ioctl_set_path(struct snd_soc_codec *codec,
+				      void *info, unsigned int update)
+{
+#if (defined ALSA_VER_ANDROID_2_6_35) || (defined ALSA_VER_ANDROID_3_0)
+	struct mc1n2_data *mc1n2 = snd_soc_codec_get_drvdata(codec);
+#else
+	struct mc1n2_data *mc1n2 = codec->private_data;
+#endif
+	MCDRV_CHANNEL *ch;
+	int i, j;
+	MCDRV_PATH_INFO *path = (MCDRV_PATH_INFO *) info;
+
+	mutex_lock(&mc1n2->mutex);
+
+	/* preserve DIR settings */
+	for (i = 0; i < MC1N2_N_PATH_CHANNELS; i++) {
+		ch = (MCDRV_CHANNEL *)(info + mc1n2_path_channel_tbl[i]);
+#ifdef DIO0_DAI_ENABLE
+		switch ((ch->abSrcOnOff[3]) & 0x3) {
+		case 1:
+			mc1n2->port[0].dir[i] = 1;
+			break;
+		case 2:
+			mc1n2->port[0].dir[i] = 0;
+			break;
+		}
+#endif
+#ifdef DIO1_DAI_ENABLE
+		switch ((ch->abSrcOnOff[3] >> 2) & 0x3) {
+		case 1:
+			mc1n2->port[1].dir[i] = 1;
+			break;
+		case 2:
+			mc1n2->port[1].dir[i] = 0;
+			break;
+		}
+#endif
+#ifdef DIO2_DAI_ENABLE
+		switch ((ch->abSrcOnOff[3] >> 4) & 0x3) {
+		case 1:
+			mc1n2->port[2].dir[i] = 1;
+			break;
+		case 2:
+			mc1n2->port[2].dir[i] = 0;
+			break;
+		}
+#endif
+	}
+
+	/* preserve DIT settings */
+#ifdef DIO0_DAI_ENABLE
+	ch = (MCDRV_CHANNEL *)(info + mc1n2_path_channel_tbl[0]);
+	for (j = 0; j < SOURCE_BLOCK_NUM; j++) {
+		mc1n2->port[0].dit.abSrcOnOff[j] |=
+			ch->abSrcOnOff[j] & 0x55;
+		mc1n2->port[0].dit.abSrcOnOff[j] &=
+			~((ch->abSrcOnOff[j] & 0xaa) >> 1);
+	}
+#endif
+#ifdef DIO1_DAI_ENABLE
+	ch = (MCDRV_CHANNEL *)(info + mc1n2_path_channel_tbl[1]);
+	for (j = 0; j < SOURCE_BLOCK_NUM; j++) {
+		mc1n2->port[1].dit.abSrcOnOff[j] |=
+			ch->abSrcOnOff[j] & 0x55;
+		mc1n2->port[1].dit.abSrcOnOff[j] &=
+			~((ch->abSrcOnOff[j] & 0xaa) >> 1);
+	}
+#endif
+#ifdef DIO2_DAI_ENABLE
+	ch = (MCDRV_CHANNEL *)(info + mc1n2_path_channel_tbl[2]);
+	for (j = 0; j < SOURCE_BLOCK_NUM; j++) {
+		mc1n2->port[2].dit.abSrcOnOff[j] |=
+			ch->abSrcOnOff[j] & 0x55;
+		mc1n2->port[2].dit.abSrcOnOff[j] &=
+			~((ch->abSrcOnOff[j] & 0xaa) >> 1);
+	}
+#endif
+
+	/* modify path */
+	for (i = 0; i < MC1N2_N_PATH_CHANNELS; i++) {
+		ch = (MCDRV_CHANNEL *)(info + mc1n2_path_channel_tbl[i]);
+
+#ifdef DIO0_DAI_ENABLE
+		if (!mc1n2_is_in_playback(&mc1n2->port[0])) {
+			ch->abSrcOnOff[3] &= ~(0x3);
+		}
+#endif
+#ifdef DIO1_DAI_ENABLE
+		if (!mc1n2_is_in_playback(&mc1n2->port[1])) {
+			ch->abSrcOnOff[3] &= ~(0x3 << 2);
+		}
+#endif
+#ifdef DIO2_DAI_ENABLE
+		if (!mc1n2_is_in_playback(&mc1n2->port[2])) {
+			ch->abSrcOnOff[3] &= ~(0x3 << 4);
+		}
+#endif
+	}
+
+#ifdef DIO0_DAI_ENABLE
+	ch = (MCDRV_CHANNEL *)(info + mc1n2_path_channel_tbl[0]);
+	for (j = 0; j < SOURCE_BLOCK_NUM; j++) {
+		if (!mc1n2_is_in_capture(&mc1n2->port[0])) {
+			ch->abSrcOnOff[j] = 0;
+		}
+	}
+#endif
+#ifdef DIO1_DAI_ENABLE
+	ch = (MCDRV_CHANNEL *)(info + mc1n2_path_channel_tbl[1]);
+	for (j = 0; j < SOURCE_BLOCK_NUM; j++) {
+		if (!mc1n2_is_in_capture(&mc1n2->port[1])) {
+			ch->abSrcOnOff[j] = 0;
+		}
+	}
+#endif
+#ifdef DIO2_DAI_ENABLE
+	ch = (MCDRV_CHANNEL *)(info + mc1n2_path_channel_tbl[2]);
+	for (j = 0; j < SOURCE_BLOCK_NUM; j++) {
+		if (!mc1n2_is_in_capture(&mc1n2->port[2])) {
+			ch->abSrcOnOff[j] = 0;
+		}
+	}
+#endif
+
+	/* select mic path */
+	if ((path->asAdc0[0].abSrcOnOff[0] & MCDRV_SRC0_MIC1_OFF) && (path->asAdc0[1].abSrcOnOff[0] & MCDRV_SRC0_MIC1_OFF)) {
+		audio_ctrl_mic_bias_gpio(mc1n2->pdata, MAIN_MIC, 0);
+	} else {
+		audio_ctrl_mic_bias_gpio(mc1n2->pdata, MAIN_MIC, 1);
+		mdelay(mc1n2->delay_mic1in);
+	}
+
+	if ((path->asAdc0[0].abSrcOnOff[0] & MCDRV_SRC0_MIC3_OFF) && (path->asAdc0[1].abSrcOnOff[0] & MCDRV_SRC0_MIC3_OFF)) {
+		audio_ctrl_mic_bias_gpio(mc1n2->pdata, SUB_MIC, 0);
+	} else
+		audio_ctrl_mic_bias_gpio(mc1n2->pdata, SUB_MIC, 1);
+
+	mutex_unlock(&mc1n2->mutex);
+
+	return 0;
+}
+
+static int mc1n2_hwdep_ioctl_set_ae(struct snd_soc_codec *codec,
+				    void *info, unsigned int update)
+{
+#if (defined ALSA_VER_ANDROID_2_6_35) || (defined ALSA_VER_ANDROID_3_0)
+	struct mc1n2_data *mc1n2 = snd_soc_codec_get_drvdata(codec);
+#else
+	struct mc1n2_data *mc1n2 = codec->private_data;
+#endif
+	UINT8 onoff = ((MCDRV_AE_INFO *)info)->bOnOff;
+	unsigned int mask = update & 0x0f;      /* bit mask for bOnOff */
+	int i;
+
+	struct mc1n2_ae_copy {
+		UINT32 flag;
+		size_t offset;
+		size_t size;
+	};
+
+	struct mc1n2_ae_copy tbl[] = {
+		{MCDRV_AEUPDATE_FLAG_BEX,
+		 offsetof(MCDRV_AE_INFO, abBex), BEX_PARAM_SIZE},
+		{MCDRV_AEUPDATE_FLAG_WIDE,
+		 offsetof(MCDRV_AE_INFO, abWide), WIDE_PARAM_SIZE},
+		{MCDRV_AEUPDATE_FLAG_DRC,
+		 offsetof(MCDRV_AE_INFO, abDrc), DRC_PARAM_SIZE},
+		{MCDRV_AEUPDATE_FLAG_EQ5,
+		 offsetof(MCDRV_AE_INFO, abEq5), EQ5_PARAM_SIZE},
+		{MCDRV_AEUPDATE_FLAG_EQ3,
+		 offsetof(MCDRV_AE_INFO, abEq3), EQ3_PARAM_SIZE},
+	};
+
+	mutex_lock(&mc1n2->mutex);
+
+	mc1n2->ae_store.bOnOff = (mc1n2->ae_store.bOnOff & ~mask) | onoff;
+
+	for (i = 0; i < sizeof(tbl)/sizeof(struct mc1n2_ae_copy); i++) {
+		if (update & tbl[i].flag) {
+			memcpy((void *)&mc1n2->ae_store + tbl[i].offset,
+			       info + tbl[i].offset, tbl[i].size);
+		}
+	}
+
+	mutex_unlock(&mc1n2->mutex);
+
+	return 0;
+}
+
+struct mc1n2_hwdep_func {
+	int cmd;
+	size_t size;
+	int (*callback)(struct snd_soc_codec *, void *, unsigned int);
+};
+
+struct mc1n2_hwdep_func mc1n2_hwdep_func_map[] = {
+	{0, 0, NULL},                                         /* INIT */
+	{0, 0, NULL},                                         /* TERM */
+	{MC1N2_IOCTL_NR_BOTH, sizeof(MCDRV_REG_INFO), NULL},  /* READ_REG */
+	{0, 0, NULL},                                         /* WRITE_REG */
+	{MC1N2_IOCTL_NR_GET, sizeof(MCDRV_PATH_INFO), NULL},  /* GET_PATH */
+	{MC1N2_IOCTL_NR_SET, sizeof(MCDRV_PATH_INFO),
+	 mc1n2_hwdep_ioctl_set_path},                         /* SET_PATH */
+	{0, 0, NULL},                                         /* GET_VOLUME */
+	{0, 0, NULL},                                         /* SET_VOLUME */
+	{MC1N2_IOCTL_NR_GET, sizeof(MCDRV_DIO_INFO), NULL},   /* GET_DIGITALIO */
+	{MC1N2_IOCTL_NR_SET, sizeof(MCDRV_DIO_INFO), NULL},   /* SET_DIGITALIO */
+	{MC1N2_IOCTL_NR_GET, sizeof(MCDRV_DAC_INFO), NULL},   /* GET_DAC */
+	{MC1N2_IOCTL_NR_SET, sizeof(MCDRV_DAC_INFO), NULL},   /* SET_DAC */
+	{MC1N2_IOCTL_NR_GET, sizeof(MCDRV_ADC_INFO), NULL},   /* GET_ADC */
+	{MC1N2_IOCTL_NR_SET, sizeof(MCDRV_ADC_INFO), NULL},   /* SET_ADC */
+	{MC1N2_IOCTL_NR_GET, sizeof(MCDRV_SP_INFO), NULL},    /* GET_SP */
+	{MC1N2_IOCTL_NR_SET, sizeof(MCDRV_SP_INFO), NULL},    /* SET_SP */
+	{MC1N2_IOCTL_NR_GET, sizeof(MCDRV_DNG_INFO), NULL},   /* GET_DNG */
+	{MC1N2_IOCTL_NR_SET, sizeof(MCDRV_DNG_INFO), NULL},   /* SET_DNG */
+	{MC1N2_IOCTL_NR_SET, sizeof(MCDRV_AE_INFO),
+	 mc1n2_hwdep_ioctl_set_ae},                           /* SET_AE */
+	{0, 0, NULL},                                         /* SET_AE_EX */
+	{0, 0, NULL},                                         /* SET_CDSP */
+	{0, 0, NULL},                                         /* GET_CDSP_PARAM */
+	{0, 0, NULL},                                         /* SET_CDSP_PARAM */
+	{0, 0, NULL},                                         /* REG_CDSP_CB */
+	{MC1N2_IOCTL_NR_GET, sizeof(MCDRV_PDM_INFO), NULL},   /* GET PDM */
+	{MC1N2_IOCTL_NR_SET, sizeof(MCDRV_PDM_INFO), NULL},   /* SET_PDM */
+	{0, 0, NULL},                                         /* SET_DTMF */
+	{0, 0, NULL},                                         /* CONFIG_GP */
+	{0, 0, NULL},                                         /* MASK_GP */
+	{0, 0, NULL},                                         /* GETSET_GP */
+	{0, 0, NULL},                                         /* GET_PEAK */
+	{0, 0, NULL},                                         /* IRQ */
+	{0, 0, NULL},                                         /* UPDATE_CLOCK */
+	{MC1N2_IOCTL_NR_SET, sizeof(MCDRV_CLKSW_INFO), NULL}, /* SWITCH_CLOCK */
+	{MC1N2_IOCTL_NR_GET, sizeof(MCDRV_SYSEQ_INFO), NULL}, /* GET SYSEQ */
+	{MC1N2_IOCTL_NR_SET, sizeof(MCDRV_SYSEQ_INFO), NULL}, /* SET_SYSEQ */
+};
+#define MC1N2_HWDEP_N_FUNC_MAP \
+	(sizeof(mc1n2_hwdep_func_map)/sizeof(struct mc1n2_hwdep_func))
+
+static int mc1n2_hwdep_ioctl_get_ctrl(struct snd_soc_codec *codec,
+				      struct mc1n2_ctrl_args *args)
+{
+	struct mc1n2_hwdep_func *func = &mc1n2_hwdep_func_map[args->dCmd];
+	void *info;
+	int err;
+
+	if (func->cmd != MC1N2_IOCTL_NR_GET) {
+		return -EINVAL;
+	}
+
+	if (!access_ok(VERIFY_WRITE, args->pvPrm, func->size)) {
+		return -EFAULT;
+	}
+
+	if (!(info = kzalloc(func->size, GFP_KERNEL))) {
+		return -ENOMEM;
+	}
+
+	err = _McDrv_Ctrl(args->dCmd, info, args->dPrm);
+	err = mc1n2_hwdep_map_error(err);
+	if (err < 0) {
+		goto error;
+	}
+
+	if (func->callback) {                   /* call post-process */
+		func->callback(codec, info, args->dPrm);
+	}
+
+	if (copy_to_user(args->pvPrm, info, func->size) != 0) {
+		err = -EFAULT;
+		goto error;
+	}
+
+error:
+	kfree(info);
+	return err;
+}
+
+static int mc1n2_hwdep_ioctl_set_ctrl(struct snd_soc_codec *codec,
+				      struct mc1n2_ctrl_args *args)
+{
+	struct mc1n2_hwdep_func *func = &mc1n2_hwdep_func_map[args->dCmd];
+	void *info;
+	int err;
+
+	if (func->cmd != MC1N2_IOCTL_NR_SET) {
+		return -EINVAL;
+	}
+
+	if (!access_ok(VERIFY_READ, args->pvPrm, func->size)) {
+		return -EFAULT;
+	}
+
+	if (!(info = kzalloc(func->size, GFP_KERNEL))) {
+		return -ENOMEM;
+	}
+
+	if (copy_from_user(info, args->pvPrm, func->size) != 0) {
+		kfree(info);
+		return -EFAULT;
+	}
+
+	if (func->callback) {                   /* call pre-process */
+		func->callback(codec, info, args->dPrm);
+	}
+
+	if (args->dCmd == MCDRV_SET_DIGITALIO) {
+#ifdef DIO0_DAI_ENABLE
+		args->dPrm &= ~(MCDRV_DIO0_COM_UPDATE_FLAG | MCDRV_DIO0_DIR_UPDATE_FLAG | MCDRV_DIO0_DIT_UPDATE_FLAG);
+#endif
+#ifdef DIO1_DAI_ENABLE
+		args->dPrm &= ~(MCDRV_DIO1_COM_UPDATE_FLAG | MCDRV_DIO1_DIR_UPDATE_FLAG | MCDRV_DIO1_DIT_UPDATE_FLAG);
+#endif
+#ifdef DIO2_DAI_ENABLE
+		args->dPrm &= ~(MCDRV_DIO2_COM_UPDATE_FLAG | MCDRV_DIO2_DIR_UPDATE_FLAG | MCDRV_DIO2_DIT_UPDATE_FLAG);
+#endif
+	}
+
+	err = _McDrv_Ctrl(args->dCmd, info, args->dPrm);
+
+	kfree(info);
+
+	return mc1n2_hwdep_map_error(err);
+}
+
+static int mc1n2_hwdep_ioctl_read_reg(struct mc1n2_ctrl_args *args)
+{
+	struct mc1n2_hwdep_func *func = &mc1n2_hwdep_func_map[args->dCmd];
+	MCDRV_REG_INFO info;
+	int err;
+
+	if (func->cmd != MC1N2_IOCTL_NR_BOTH) {
+		return -EINVAL;
+	}
+
+	if (!access_ok(VERIFY_WRITE, args->pvPrm, sizeof(MCDRV_REG_INFO))) {
+		return -EFAULT;
+	}
+
+	if (copy_from_user(&info, args->pvPrm, sizeof(MCDRV_REG_INFO)) != 0) {
+		return -EFAULT;
+	}
+
+	err = _McDrv_Ctrl(args->dCmd, &info, args->dPrm);
+	if (err != MCDRV_SUCCESS) {
+		return mc1n2_hwdep_map_error(err);
+	}
+
+	if (copy_to_user(args->pvPrm, &info, sizeof(MCDRV_REG_INFO)) != 0) {
+		return -EFAULT;
+	}
+
+	return 0;
+}
+
+static int mc1n2_hwdep_ioctl_notify(struct snd_soc_codec *codec,
+				      struct mc1n2_ctrl_args *args)
+{
+	MCDRV_PATH_INFO path;
+	int err;
+
+#if (defined ALSA_VER_ANDROID_2_6_35) || (defined ALSA_VER_ANDROID_3_0)
+	struct mc1n2_data *mc1n2 = snd_soc_codec_get_drvdata(codec);
+#else
+	struct mc1n2_data *mc1n2 = codec->private_data;
+#endif
+
+	switch (args->dCmd) {
+	case MCDRV_NOTIFY_CALL_START:
+	case MCDRV_NOTIFY_2MIC_CALL_START:
+		mc1n2_current_mode |= MC1N2_MODE_CALL_ON;
+		err = mc1n2->pdata->set_adc_power_constraints(&mc1n2_i2c->dev, 0);
+		if (err < 0) {
+			dev_err(codec->dev,
+				"%s:%d:Error VADC_3.3V[On]\n", __func__, err);
+		}
+		break;
+	case MCDRV_NOTIFY_CALL_STOP:
+		mc1n2_current_mode &= ~MC1N2_MODE_CALL_ON;
+		err = mc1n2->pdata->set_adc_power_constraints(&mc1n2_i2c->dev, 1);
+		if (err < 0) {
+			dev_err(codec->dev,
+				"%s:%d:Error VADC_3.3V[Off]\n", __func__, err);
+		}
+		break;
+	case MCDRV_NOTIFY_MEDIA_PLAY_START:
+		break;
+	case MCDRV_NOTIFY_MEDIA_PLAY_STOP:
+		break;
+	case MCDRV_NOTIFY_FM_PLAY_START:
+		mc1n2_current_mode |= MC1N2_MODE_FM_ON;
+		break;
+	case MCDRV_NOTIFY_FM_PLAY_STOP:
+		mc1n2_current_mode &= ~MC1N2_MODE_FM_ON;
+		break;
+	case MCDRV_NOTIFY_BT_SCO_ENABLE:
+		break;
+	case MCDRV_NOTIFY_BT_SCO_DISABLE:
+		break;
+	case MCDRV_NOTIFY_VOICE_REC_START:
+		mc1n2->delay_mic1in = MC1N2_WAITTIME_MICIN;
+		break;
+	case MCDRV_NOTIFY_VOICE_REC_STOP:
+		mc1n2->delay_mic1in = 0;
+		break;
+	case MCDRV_NOTIFY_HDMI_START:
+		if (mc1n2->hdmicount == 0) {
+			memset(&path, 0, sizeof(path));
+			path.asDit0[0].abSrcOnOff[3] = MCDRV_SRC3_DIR0_OFF;
+			path.asDit1[0].abSrcOnOff[3] = MCDRV_SRC3_DIR0_OFF;
+			path.asDit2[0].abSrcOnOff[3] = MCDRV_SRC3_DIR0_OFF;
+			path.asDac[0].abSrcOnOff[3] = MCDRV_SRC3_DIR0_OFF;
+			path.asDac[1].abSrcOnOff[3] = MCDRV_SRC3_DIR0_OFF;
+			path.asAe[0].abSrcOnOff[3] = MCDRV_SRC3_DIR0_OFF;
+			path.asMix[0].abSrcOnOff[3] = MCDRV_SRC3_DIR0_OFF;
+			_McDrv_Ctrl(MCDRV_SET_PATH, &path, 0);
+		}
+
+		(mc1n2->hdmicount)++;
+		break;
+	case MCDRV_NOTIFY_HDMI_STOP:
+		if (mc1n2->hdmicount != 0) {
+			if (mc1n2->hdmicount == 1) {
+				memset(&path, 0, sizeof(path));
+				path.asDit0[0].abSrcOnOff[3] = MCDRV_SRC3_DIR0_OFF;
+				path.asDit1[0].abSrcOnOff[3] = MCDRV_SRC3_DIR0_OFF;
+				path.asDit2[0].abSrcOnOff[3] = MCDRV_SRC3_DIR0_OFF;
+				path.asDac[0].abSrcOnOff[3] = MCDRV_SRC3_DIR0_OFF;
+				path.asDac[1].abSrcOnOff[3] = MCDRV_SRC3_DIR0_OFF;
+				path.asAe[0].abSrcOnOff[3] = MCDRV_SRC3_DIR0_OFF;
+				path.asMix[0].abSrcOnOff[3] = MCDRV_SRC3_DIR0_OFF;
+				_McDrv_Ctrl(MCDRV_SET_PATH, &path, 0);
+			}
+
+			(mc1n2->hdmicount)--;
+		}
+		break;
+	case MCDRV_NOTIFY_LINEOUT_START:
+		mc1n2->lineoutenable = 1;
+		break;
+	case MCDRV_NOTIFY_LINEOUT_STOP:
+		mc1n2->lineoutenable = 0;
+		break;
+	case MCDRV_NOTIFY_RECOVER:
+		{
+			int err, i;
+			SINT16 *vol = (SINT16 *)&mc1n2->vol_store;
+
+			mutex_lock(&mc1n2->mutex);
+
+			/* store parameters */
+			for (i = 0; i < MC1N2_N_INFO_STORE; i++) {
+				struct mc1n2_info_store *store = &mc1n2_info_store_tbl[i];
+				if (store->get) {
+					err = _McDrv_Ctrl(store->get, (void *)mc1n2 + store->offset, 0);
+					if (err != MCDRV_SUCCESS) {
+						dev_err(codec->dev,
+							"%d: Error in MCDRV_GET_xxx\n", err);
+						err = -EIO;
+						goto error_recover;
+					} else {
+						err = 0;
+					}
+				}
+			}
+
+			err = _McDrv_Ctrl(MCDRV_TERM, NULL, 0);
+			if (err != MCDRV_SUCCESS) {
+				dev_err(codec->dev, "%d: Error in MCDRV_TERM\n", err);
+				err = -EIO;
+			} else {
+				err = 0;
+			}
+
+			err = _McDrv_Ctrl(MCDRV_INIT, &mc1n2->setup.init, 0);
+			if (err != MCDRV_SUCCESS) {
+				dev_err(codec->dev, "%d: Error in MCDRV_INIT\n", err);
+				err = -EIO;
+				goto error_recover;
+			} else {
+				err = 0;
+			}
+
+			/* restore parameters */
+			for (i = 0; i < sizeof(MCDRV_VOL_INFO)/sizeof(SINT16); i++, vol++) {
+				*vol |= 0x0001;
+			}
+
+			for (i = 0; i < MC1N2_N_INFO_STORE; i++) {
+				struct mc1n2_info_store *store = &mc1n2_info_store_tbl[i];
+				if (store->set) {
+					err = _McDrv_Ctrl(store->set, (void *)mc1n2 + store->offset,
+							  store->flags);
+					if (err != MCDRV_SUCCESS) {
+						dev_err(codec->dev,
+							"%d: Error in MCDRV_SET_xxx\n", err);
+						err = -EIO;
+						goto error_recover;
+					} else {
+						err = 0;
+					}
+				}
+			}
+
+error_recover:
+			mutex_unlock(&mc1n2->mutex);
+			return err;
+			break;
+		}
+	}
+
+	return 0;
+}
+
+static int mc1n2_hwdep_ioctl(struct snd_hwdep *hw, struct file *file,
+			     unsigned int cmd, unsigned long arg)
+{
+	struct mc1n2_ctrl_args ctrl_args;
+	struct snd_soc_codec *codec = hw->private_data;
+	int err;
+
+	if (!access_ok(VERIFY_READ, (struct mc1n2_ctrl_args *)arg,
+		       sizeof(struct mc1n2_ctrl_args))) {
+		return -EFAULT;
+	}
+
+	if (copy_from_user(&ctrl_args, (struct mc1n2_ctrl_args *)arg,
+			   sizeof(struct mc1n2_ctrl_args)) != 0) {
+		return -EFAULT;
+	}
+
+	if (cmd == MC1N2_IOCTL_NOTIFY) {
+		return mc1n2_hwdep_ioctl_notify(codec, &ctrl_args);
+	}
+
+	if (ctrl_args.dCmd >= MC1N2_HWDEP_N_FUNC_MAP) {
+		return -EINVAL;
+	}
+
+	switch (cmd) {
+	case MC1N2_IOCTL_GET_CTRL:
+		err = mc1n2_hwdep_ioctl_get_ctrl(codec, &ctrl_args);
+		break;
+	case MC1N2_IOCTL_SET_CTRL:
+		err = mc1n2_hwdep_ioctl_set_ctrl(codec, &ctrl_args);
+		break;
+	case MC1N2_IOCTL_READ_REG:
+		err = mc1n2_hwdep_ioctl_read_reg(&ctrl_args);
+		break;
+	default:
+		err = -EINVAL;
+	}
+
+	return err;
+}
+
+static int mc1n2_add_hwdep(struct snd_soc_codec *codec)
+{
+	struct snd_hwdep *hw;
+#if (defined ALSA_VER_ANDROID_2_6_35) || (defined ALSA_VER_ANDROID_3_0)
+	struct mc1n2_data *mc1n2 = snd_soc_codec_get_drvdata(codec);
+#else
+	struct mc1n2_data *mc1n2 = codec->private_data;
+#endif
+	int err;
+
+#ifdef ALSA_VER_ANDROID_3_0
+	err = snd_hwdep_new((struct snd_card *)codec->card->snd_card,
+						MC1N2_HWDEP_ID, 0, &hw);
+#else
+	err = snd_hwdep_new(codec->card, MC1N2_HWDEP_ID, 0, &hw);
+#endif
+	if (err < 0) {
+		return err;
+	}
+
+	hw->iface = SNDRV_HWDEP_IFACE_MC1N2;
+	hw->private_data = codec;
+	hw->ops.open = mc1n2_hwdep_open;
+	hw->ops.release = mc1n2_hwdep_release;
+	hw->ops.ioctl = mc1n2_hwdep_ioctl;
+	hw->exclusive = 1;
+	strcpy(hw->name, MC1N2_HWDEP_ID);
+	mc1n2->hwdep = hw;
+
+	return 0;
+}
+
+/*
+ * Codec device
+ */
+#ifdef ALSA_VER_ANDROID_3_0
+static int mc1n2_probe(struct snd_soc_codec *codec)
+#else
+static int mc1n2_probe(struct platform_device *pdev)
+#endif
+{
+#ifdef ALSA_VER_ANDROID_3_0
+	struct mc1n2_data *mc1n2 = snd_soc_codec_get_drvdata(codec);
+	struct device *dev = codec->dev;
+	struct mc1n2_setup *setup = &mc1n2_cfg_setup;
+#else
+	struct snd_soc_device *socdev = platform_get_drvdata(pdev);
+	struct snd_soc_codec *codec = mc1n2_get_codec_data();
+#ifdef ALSA_VER_ANDROID_2_6_35
+	struct mc1n2_data *mc1n2 = snd_soc_codec_get_drvdata(codec);
+#else
+	struct mc1n2_data *mc1n2 = codec->private_data;
+#endif
+	struct mc1n2_setup *setup = socdev->codec_data;
+	struct device *dev = socdev->dev;
+#endif
+	int err;
+	UINT32 update = 0;
+
+	TRACE_FUNC();
+
+	if (!codec) {
+		dev_err(dev, "I2C bus is not probed successfully\n");
+		err = -ENODEV;
+		goto error_codec_data;
+	}
+#ifndef ALSA_VER_ANDROID_3_0
+#ifdef ALSA_VER_1_0_19
+	socdev->codec = codec;
+#else
+	socdev->card->codec = codec;
+#endif
+#endif
+
+	/* init hardware */
+	if (!setup) {
+		dev_err(dev, "No initialization parameters given\n");
+		err = -EINVAL;
+		goto error_init_hw;
+	}
+	memcpy(&mc1n2->setup, setup, sizeof(struct mc1n2_setup));
+	err = _McDrv_Ctrl(MCDRV_INIT, &mc1n2->setup.init, 0);
+	if (err != MCDRV_SUCCESS) {
+		dev_err(dev, "%d: Error in MCDRV_INIT\n", err);
+		err = -EIO;
+		goto error_init_hw;
+	}
+
+	/* pcm */
+#ifndef ALSA_VER_ANDROID_3_0
+	err = snd_soc_new_pcms(socdev, SNDRV_DEFAULT_IDX1, SNDRV_DEFAULT_STR1);
+	if (err < 0) {
+		dev_err(dev, "%d: Error in snd_soc_new_pcms\n", err);
+		goto error_new_pcm;
+	}
+#endif
+
+	/* controls */
+	err = mc1n2_add_controls(codec, mc1n2_snd_controls,
+				 ARRAY_SIZE(mc1n2_snd_controls));
+	if (err < 0) {
+		dev_err(dev, "%d: Error in mc1n2_add_controls\n", err);
+		goto error_add_ctl;
+	}
+
+	err = mc1n2_add_widgets(codec);
+	if (err < 0) {
+		dev_err(dev, "%d: Error in mc1n2_add_widgets\n", err);
+		goto error_add_ctl;
+	}
+
+	/* hwdep */
+	err = mc1n2_add_hwdep(codec);
+	if (err < 0) {
+		dev_err(dev, "%d: Error in mc1n2_add_hwdep\n", err);
+		goto error_add_hwdep;
+	}
+
+#if (defined ALSA_VER_1_0_19) || (defined ALSA_VER_1_0_21)
+	err = snd_soc_init_card(socdev);
+	if (err < 0) {
+		dev_err(dev, "%d: Error in snd_soc_init_card\n", err);
+		goto error_init_card;
+	}
+#endif
+
+#ifndef DIO0_DAI_ENABLE
+	update |= (MCDRV_DIO0_COM_UPDATE_FLAG | MCDRV_DIO0_DIR_UPDATE_FLAG | MCDRV_DIO0_DIT_UPDATE_FLAG);
+#endif
+
+#ifndef DIO1_DAI_ENABLE
+	update |= (MCDRV_DIO1_COM_UPDATE_FLAG | MCDRV_DIO1_DIR_UPDATE_FLAG | MCDRV_DIO1_DIT_UPDATE_FLAG);
+#endif
+
+#ifndef DIO2_DAI_ENABLE
+	update |= (MCDRV_DIO2_COM_UPDATE_FLAG | MCDRV_DIO2_DIR_UPDATE_FLAG | MCDRV_DIO2_DIT_UPDATE_FLAG);
+#endif
+
+	err = _McDrv_Ctrl(MCDRV_SET_DIGITALIO, (void *)&stDioInfo_Default, update);
+	if (err < 0) {
+		dev_err(dev, "%d: Error in MCDRV_SET_DIGITALIO\n", err);
+		goto error_set_mode;
+	}
+
+	err = _McDrv_Ctrl(MCDRV_SET_DAC, (void *)&stDacInfo_Default, 0x7);
+	if (err < 0) {
+		dev_err(dev, "%d: Error in MCDRV_SET_DAC\n", err);
+		goto error_set_mode;
+	}
+
+	err = _McDrv_Ctrl(MCDRV_SET_ADC, (void *)&stAdcInfo_Default, 0x7);
+	if (err < 0) {
+		dev_err(dev, "%d: Error in MCDRV_SET_ADC\n", err);
+		goto error_set_mode;
+	}
+
+	err = _McDrv_Ctrl(MCDRV_SET_SP, (void *)&stSpInfo_Default, 0);
+	if (err < 0) {
+		dev_err(dev, "%d: Error in MCDRV_SET_SP\n", err);
+		goto error_set_mode;
+	}
+
+	err = _McDrv_Ctrl(MCDRV_SET_DNG, (void *)&stDngInfo_Default, 0x3F3F3F);
+	if (err < 0) {
+		dev_err(dev, "%d: Error in MCDRV_SET_DNG\n", err);
+		goto error_set_mode;
+	}
+
+	if (mc1n2_hwid == MC1N2_HW_ID_AB) {
+		err = _McDrv_Ctrl(MCDRV_SET_SYSEQ, (void *)&stSyseqInfo_Default, 0x3);
+
+		if (err < 0) {
+			dev_err(dev, "%d: Error in MCDRV_SET_SYSEQ\n", err);
+			goto error_set_mode;
+		}
+	}
+#ifdef CONFIG_SND_SOC_PM_RUNTIME
+	pm_runtime_set_active(codec->dev);
+	pm_runtime_get_noresume(codec->dev);
+	pm_runtime_use_autosuspend(codec->dev);
+	pm_runtime_set_autosuspend_delay(codec->dev, MC1N2_PM_RUNTIME_DELAY_MS);
+	pm_runtime_enable(codec->dev);
+	pm_runtime_mark_last_busy(codec->dev);
+	pm_runtime_put_sync_autosuspend(codec->dev);
+#endif
+
+	return 0;
+
+error_set_mode:
+#if (defined ALSA_VER_1_0_19) || (defined ALSA_VER_1_0_21)
+error_init_card:
+#endif
+error_add_hwdep:
+error_add_ctl:
+#ifndef ALSA_VER_ANDROID_3_0
+	snd_soc_free_pcms(socdev);
+error_new_pcm:
+#endif
+	_McDrv_Ctrl(MCDRV_TERM, NULL, 0);
+error_init_hw:
+#ifndef ALSA_VER_ANDROID_3_0
+#ifdef ALSA_VER_1_0_19
+	socdev->codec = NULL;
+#else
+	socdev->card->codec = NULL;
+#endif
+#endif
+error_codec_data:
+	return err;
+}
+
+#ifdef ALSA_VER_ANDROID_3_0
+static int mc1n2_remove(struct snd_soc_codec *codec)
+{
+	int err;
+
+	TRACE_FUNC();
+
+	if (codec) {
+		err = _McDrv_Ctrl(MCDRV_TERM, NULL, 0);
+		if (err != MCDRV_SUCCESS) {
+			dev_err(codec->dev, "%d: Error in MCDRV_TERM\n", err);
+			return -EIO;
+		}
+	}
+	return 0;
+}
+#else
+static int mc1n2_remove(struct platform_device *pdev)
+{
+	struct snd_soc_device *socdev = platform_get_drvdata(pdev);
+	int err;
+
+	TRACE_FUNC();
+
+#ifdef ALSA_VER_1_0_19
+	if (socdev->codec) {
+#else
+	if (socdev->card->codec) {
+#endif
+		snd_soc_free_pcms(socdev);
+
+		err = _McDrv_Ctrl(MCDRV_TERM, NULL, 0);
+		if (err != MCDRV_SUCCESS) {
+			dev_err(socdev->dev, "%d: Error in MCDRV_TERM\n", err);
+			return -EIO;
+		}
+	}
+
+	return 0;
+}
+#endif
+
+#ifdef ALSA_VER_ANDROID_3_0
+static int mc1n2_suspend(struct snd_soc_codec *codec, pm_message_t state)
+#else
+static int mc1n2_suspend(struct platform_device *pdev, pm_message_t state)
+#endif
+{
+#ifdef ALSA_VER_ANDROID_3_0
+	struct mc1n2_data *mc1n2 = snd_soc_codec_get_drvdata(codec);
+#else
+	struct snd_soc_device *socdev = platform_get_drvdata(pdev);
+#ifdef ALSA_VER_1_0_19
+	struct snd_soc_codec *codec = socdev->codec;
+#else
+	struct snd_soc_codec *codec = socdev->card->codec;
+#endif
+#ifdef ALSA_VER_ANDROID_2_6_35
+	struct mc1n2_data *mc1n2 = snd_soc_codec_get_drvdata(codec);
+#else
+	struct mc1n2_data *mc1n2 = codec->private_data;
+#endif
+#endif
+	int err, i;
+
+	TRACE_FUNC();
+
+#ifdef CONFIG_SND_SOC_PM_RUNTIME
+	if (state.event == PM_EVENT_SUSPEND)
+		dev_dbg(codec->dev, "Suspend From ASoC suspend\n");
+	else if (state.event == PM_EVENT_AUTO_SUSPEND)
+		dev_dbg(codec->dev, "Suspend From Runtime suspend\n");
+#endif
+
+	mutex_lock(&mc1n2->mutex);
+#ifdef CONFIG_SND_SOC_PM_RUNTIME
+	if (mc1n2->suspended) {
+		dev_info(codec->dev, "Already suspended\n");
+		err = 0;
+		goto suspend_done;
+	} else
+		dev_info(codec->dev, "Suspending...\n");
+#endif
+
+	/* store parameters */
+	for (i = 0; i < MC1N2_N_INFO_STORE; i++) {
+		struct mc1n2_info_store *store = &mc1n2_info_store_tbl[i];
+		if (store->get) {
+			err = _McDrv_Ctrl(store->get, (void *)mc1n2 + store->offset, 0);
+			if (err != MCDRV_SUCCESS) {
+				dev_err(codec->dev,
+					"%d: Error in mc1n2_suspend\n", err);
+				err = -EIO;
+				goto error;
+			} else {
+				err = 0;
+			}
+		}
+	}
+
+	/* Do not enter suspend mode for voice call */
+	if(mc1n2_current_mode != MC1N2_MODE_IDLE) {
+		err = 0;
+		goto error;
+	}
+
+	err = _McDrv_Ctrl(MCDRV_TERM, NULL, 0);
+	if (err != MCDRV_SUCCESS) {
+		dev_err(codec->dev, "%d: Error in MCDRV_TERM\n", err);
+		err = -EIO;
+	} else {
+		err = 0;
+	}
+
+	/* Suepend MCLK */
+	mc1n2_set_mclk_source(0);
+#ifdef CONFIG_SND_SOC_PM_RUNTIME
+	mc1n2->suspended = 1;
+suspend_done:
+#endif
+error:
+	mutex_unlock(&mc1n2->mutex);
+
+	return err;
+}
+
+
+#ifdef ALSA_VER_ANDROID_3_0
+static int mc1n2_resume(struct snd_soc_codec *codec)
+#else
+static int mc1n2_resume(struct platform_device *pdev)
+#endif
+{
+#ifdef ALSA_VER_ANDROID_3_0
+	struct mc1n2_data *mc1n2 = snd_soc_codec_get_drvdata(codec);
+#else
+	struct snd_soc_device *socdev = platform_get_drvdata(pdev);
+#ifdef ALSA_VER_1_0_19
+	struct snd_soc_codec *codec = socdev->codec;
+#else
+	struct snd_soc_codec *codec = socdev->card->codec;
+#endif
+#ifdef ALSA_VER_ANDROID_2_6_35
+	struct mc1n2_data *mc1n2 = snd_soc_codec_get_drvdata(codec);
+#else
+	struct mc1n2_data *mc1n2 = codec->private_data;
+#endif
+#endif
+	SINT16 *vol = (SINT16 *)&mc1n2->vol_store;
+	int err, i;
+
+	TRACE_FUNC();
+
+	mutex_lock(&mc1n2->mutex);
+#ifdef CONFIG_SND_SOC_PM_RUNTIME
+	if (!mc1n2->suspended) {
+		dev_info(codec->dev, "Already resumed\n");
+		err = 0;
+		goto resume_done;
+	} else
+		dev_info(codec->dev, "Resuming...\n");
+#endif
+
+	/* Resume MCLK */
+	mc1n2_set_mclk_source(1);
+
+	err = _McDrv_Ctrl(MCDRV_INIT, &mc1n2->setup.init, 0);
+	if (err != MCDRV_SUCCESS) {
+		dev_err(codec->dev, "%d: Error in MCDRV_INIT\n", err);
+		err = -EIO;
+		goto error;
+	} else {
+		err = 0;
+	}
+
+	/* restore parameters */
+	for (i = 0; i < sizeof(MCDRV_VOL_INFO)/sizeof(SINT16); i++, vol++) {
+		*vol |= 0x0001;
+	}
+
+	for (i = 0; i < MC1N2_N_INFO_STORE; i++) {
+		struct mc1n2_info_store *store = &mc1n2_info_store_tbl[i];
+		if (store->set) {
+			err = _McDrv_Ctrl(store->set, (void *)mc1n2 + store->offset,
+					  store->flags);
+			if (err != MCDRV_SUCCESS) {
+				dev_err(codec->dev,
+					"%d: Error in mc1n2_resume\n", err);
+				err = -EIO;
+				goto error;
+			} else {
+				err = 0;
+			}
+		}
+	}
+#ifdef CONFIG_SND_SOC_PM_RUNTIME
+	mc1n2->suspended = 0;
+resume_done:
+#endif
+error:
+	mutex_unlock(&mc1n2->mutex);
+
+	return err;
+}
+
+#ifdef CONFIG_SND_SOC_PM_RUNTIME
+static int mc1n2_runtime_suspend(struct device *dev)
+{
+	struct snd_soc_codec *codec = mc1n2_get_codec_data();
+	int err = 0;
+
+	err = mc1n2_suspend(codec, PMSG_AUTO_SUSPEND);
+	if (err)
+		dev_err(dev, "%s failed\n", __func__);
+
+	return err;
+}
+
+static int mc1n2_runtime_resume(struct device *dev)
+{
+	struct snd_soc_codec *codec = mc1n2_get_codec_data();
+	int err = 0;
+
+	err = mc1n2_resume(codec);
+	if (err)
+		dev_err(dev, "%s failed\n", __func__);
+
+	return err;
+}
+
+static int mc1n2_set_bias_level(struct snd_soc_codec *codec,
+				enum snd_soc_bias_level level)
+{
+	/* just update bias level flag */
+	pr_info("MC1N2: bias_level: %d\n", level);
+	codec->dapm.bias_level = level;
+	return 0;
+}
+#endif
+
+#ifdef ALSA_VER_ANDROID_3_0
+struct snd_soc_codec_driver soc_codec_dev_mc1n2 = {
+	.probe = mc1n2_probe,
+	.remove = mc1n2_remove,
+	.suspend = mc1n2_suspend,
+	.resume = mc1n2_resume,
+	.read = mc1n2_read_reg,
+	.write = mc1n2_write_reg,
+	.reg_cache_size = MC1N2_N_REG,
+	.reg_word_size = sizeof(u16),
+	.reg_cache_step = 1,
+#ifdef CONFIG_SND_SOC_PM_RUNTIME
+	.set_bias_level = mc1n2_set_bias_level,
+#endif
+};
+#else
+struct snd_soc_codec_device soc_codec_dev_mc1n2 = {
+	.probe = mc1n2_probe,
+	.remove = mc1n2_remove,
+	.suspend = mc1n2_suspend,
+	.resume = mc1n2_resume
+};
+EXPORT_SYMBOL_GPL(soc_codec_dev_mc1n2);
+#endif
+
+/*
+ * I2C client
+ */
+static int mc1n2_i2c_detect(struct i2c_client *client, struct i2c_board_info *info)
+{
+	UINT8	bHwid = mc1n2_i2c_read_byte(client, 8);
+
+	if (bHwid != MC1N2_HW_ID_AB && bHwid != MC1N2_HW_ID_AA) {
+		return -ENODEV;
+	}
+	mc1n2_hwid = bHwid;
+
+	return 0;
+}
+
+static void mc1n2_dt_set_sub_mic_bias(struct device *dev, bool on)
+{
+	struct mc1n2_data *data = dev_get_drvdata(dev);
+
+	gpio_set_value(data->gpio_sub_mic_bias, on);
+}
+
+static void mc1n2_dt_set_main_mic_bias(struct device *dev, bool on)
+{
+	struct mc1n2_data *data = dev_get_drvdata(dev);
+
+	gpio_set_value(data->gpio_main_mic_bias, on);
+}
+
+static int mc1n2_dt_set_adc_power_constraints(struct device *dev, int disabled)
+{
+	struct mc1n2_data *data = dev_get_drvdata(dev);
+
+	if (!disabled)
+		regulator_enable(data->regulator);
+	else if (regulator_is_enabled(data->regulator))
+		regulator_force_disable(data->regulator);
+
+	return 0;
+}
+
+static struct mc1n2_platform_data *mc1n2_parse_dt(struct mc1n2_data *data,
+							struct device *dev)
+{
+	struct device_node *np = dev->of_node;
+	struct mc1n2_platform_data *pdata;
+
+	pdata = devm_kzalloc(dev, sizeof(*pdata), GFP_KERNEL);
+	if (!pdata) {
+		dev_err(dev, "failed to allocate platform data\n");
+		return ERR_PTR(-ENOMEM);
+	}
+
+	data->regulator = devm_regulator_get(dev, "vadc");
+	if (IS_ERR(data->regulator)) {
+		dev_err(dev, "failed to get regulator\n");
+		return ERR_PTR(PTR_ERR(data->regulator));
+	}
+
+	data->gpio_main_mic_bias = of_get_gpio(np, 0);
+	if (!gpio_is_valid(data->gpio_main_mic_bias)) {
+		dev_err(dev, "failed to get main mic bias GPIO\n");
+		return ERR_PTR(data->gpio_main_mic_bias);
+	}
+
+	data->gpio_sub_mic_bias = of_get_gpio(np, 1);
+	if (!gpio_is_valid(data->gpio_sub_mic_bias)) {
+		dev_err(dev, "failed to get sub mic bias GPIO\n");
+		return ERR_PTR(data->gpio_sub_mic_bias);
+	}
+
+	pdata->set_main_mic_bias = mc1n2_dt_set_main_mic_bias;
+	pdata->set_sub_mic_bias = mc1n2_dt_set_sub_mic_bias;
+	pdata->set_adc_power_constraints = mc1n2_dt_set_adc_power_constraints;
+
+	return pdata;
+}
+
+static int mc1n2_i2c_probe(struct i2c_client *client,
+			   const struct i2c_device_id *id)
+{
+	struct snd_soc_codec *codec;
+	struct mc1n2_data *mc1n2;
+	int err;
+
+	TRACE_FUNC();
+
+	/* setup codec data */
+	if (!(codec = kzalloc(sizeof(struct snd_soc_codec), GFP_KERNEL))) {
+		err = -ENOMEM;
+		goto err_alloc_codec;
+	}
+	codec->name = MC1N2_NAME;
+//	codec->owner = THIS_MODULE;
+	mutex_init(&codec->mutex);
+	codec->dev = &client->dev;
+
+	if (!(mc1n2 = kzalloc(sizeof(struct mc1n2_data), GFP_KERNEL))) {
+		err = -ENOMEM;
+		goto err_alloc_data;
+	}
+	mutex_init(&mc1n2->mutex);
+#if (defined ALSA_VER_ANDROID_2_6_35) || (defined ALSA_VER_ANDROID_3_0)
+	snd_soc_codec_set_drvdata(codec, mc1n2);
+#else
+	codec->private_data = mc1n2;
+#endif
+
+	mc1n2->hdmicount = 0;
+	mc1n2->lineoutenable = 0;
+	mc1n2->pdata = client->dev.platform_data;
+
+	if (client->dev.of_node) {
+		mc1n2->pdata = mc1n2_parse_dt(mc1n2, &client->dev);
+		if (IS_ERR(mc1n2->pdata)) {
+			dev_err(&client->dev, "failed to parse DT data\n");
+			return PTR_ERR(mc1n2->pdata);
+		}
+	}
+
+	/* setup i2c client data */
+	if (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C)) {
+		err = -ENODEV;
+		goto err_i2c;
+	}
+
+	if ((err = mc1n2_i2c_detect(client, NULL)) < 0) {
+		goto err_i2c;
+	}
+
+
+#ifdef ALSA_VER_ANDROID_3_0
+	i2c_set_clientdata(client, mc1n2);
+#ifdef CONFIG_SND_SOC_PM_RUNTIME
+	mc1n2_set_codec_data(codec);
+#endif
+#else
+	i2c_set_clientdata(client, codec);
+
+	codec->control_data = client;
+	codec->read = mc1n2_read_reg;
+	codec->write = mc1n2_write_reg;
+	codec->hw_write = NULL;
+	codec->hw_read = NULL;
+	codec->reg_cache = kzalloc(sizeof(u16) * MC1N2_N_REG, GFP_KERNEL);
+	if (codec->reg_cache == NULL) {
+		err = -ENOMEM;
+		goto err_alloc_cache;
+	}
+	codec->reg_cache_size = MC1N2_N_REG;
+	codec->reg_cache_step = 1;
+	INIT_LIST_HEAD(&codec->dapm_widgets);
+	INIT_LIST_HEAD(&codec->dapm_paths);
+	codec->dai = mc1n2_dai;
+	codec->num_dai = ARRAY_SIZE(mc1n2_dai);
+	mc1n2_set_codec_data(codec);
+#endif
+
+#ifdef ALSA_VER_ANDROID_3_0
+	if ((err = snd_soc_register_codec(&client->dev, &soc_codec_dev_mc1n2,
+									  mc1n2_dai, ARRAY_SIZE(mc1n2_dai))) < 0) {
+		goto err_reg_codec;
+	}
+
+	mc1n2_i2c = client;
+#else
+	if ((err = snd_soc_register_codec(codec)) < 0) {
+		goto err_reg_codec;
+	}
+
+	/* setup DAI data */
+	for (i = 0; i < ARRAY_SIZE(mc1n2_dai); i++) {
+		mc1n2_dai[i].dev = &client->dev;
+	}
+        if ((err = snd_soc_register_dais(mc1n2_dai, ARRAY_SIZE(mc1n2_dai))) < 0) {
+		goto err_reg_dai;
+	}
+#endif
+
+	return 0;
+
+#ifndef ALSA_VER_ANDROID_3_0
+err_reg_dai:
+	snd_soc_unregister_codec(codec);
+#endif
+err_reg_codec:
+#ifndef ALSA_VER_ANDROID_3_0
+	kfree(codec->reg_cache);
+err_alloc_cache:
+#endif
+	i2c_set_clientdata(client, NULL);
+err_i2c:
+	kfree(mc1n2);
+err_alloc_data:
+	kfree(codec);
+err_alloc_codec:
+	dev_err(&client->dev, "err=%d: failed to probe MC-1N2\n", err);
+	return err;
+}
+
+static int mc1n2_i2c_remove(struct i2c_client *client)
+{
+#ifndef ALSA_VER_ANDROID_3_0
+	struct snd_soc_codec *codec = i2c_get_clientdata(client);
+#endif
+	struct mc1n2_data *mc1n2;
+
+	TRACE_FUNC();
+
+#ifdef ALSA_VER_ANDROID_3_0
+	mc1n2 = (struct mc1n2_data*)(i2c_get_clientdata(client));
+	mutex_destroy(&mc1n2->mutex);
+	snd_soc_unregister_codec(&client->dev);
+#else
+	if (codec) {
+#ifdef ALSA_VER_ANDROID_2_6_35
+		mc1n2 = snd_soc_codec_get_drvdata(codec);
+#else
+		mc1n2 = codec->private_data;
+#endif
+		snd_soc_unregister_dais(mc1n2_dai, ARRAY_SIZE(mc1n2_dai));
+		snd_soc_unregister_codec(codec);
+
+		mutex_destroy(&mc1n2->mutex);
+		kfree(mc1n2);
+
+		mutex_destroy(&codec->mutex);
+		kfree(codec);
+	}
+#endif
+
+	return 0;
+}
+
+/*
+ * Function to prevent tick-noise when reboot menu selected.
+ * if you have Power-Off sound and same problem, use this function
+ */
+static void mc1n2_i2c_shutdown(struct i2c_client *client)
+{
+#ifndef ALSA_VER_ANDROID_3_0
+	struct snd_soc_codec *codec = i2c_get_clientdata(client);
+#endif
+	struct mc1n2_data *mc1n2;
+	int err, i;
+
+	pr_info("%s\n", __func__);
+
+	TRACE_FUNC();
+
+#ifdef ALSA_VER_ANDROID_3_0
+	mc1n2 = (struct mc1n2_data *)(i2c_get_clientdata(client));
+#else
+#ifdef ALSA_VER_ANDROID_2_6_35
+	mc1n2 = snd_soc_codec_get_drvdata(codec);
+#else
+	mc1n2 = codec->private_data;
+#endif
+#endif
+
+	mutex_lock(&mc1n2->mutex);
+#ifdef CONFIG_SND_SOC_PM_RUNTIME
+	if (mc1n2->suspended) {
+		err = 0;
+		goto error;
+	}
+#endif
+
+	/* store parameters */
+	for (i = 0; i < MC1N2_N_INFO_STORE; i++) {
+		struct mc1n2_info_store *store = &mc1n2_info_store_tbl[i];
+		if (store->get) {
+			err = _McDrv_Ctrl(store->get,
+				(void *)mc1n2 + store->offset, 0);
+			if (err != MCDRV_SUCCESS) {
+				pr_err("%d: Error in mc1n2_suspend\n", err);
+				err = -EIO;
+				goto error;
+			} else {
+				err = 0;
+			}
+		}
+	}
+
+	/* Do not enter suspend mode for voice call */
+	if (mc1n2_current_mode != MC1N2_MODE_IDLE) {
+		err = 0;
+		goto error;
+	}
+
+	err = _McDrv_Ctrl(MCDRV_TERM, NULL, 0);
+	if (err != MCDRV_SUCCESS) {
+		pr_err("%d: Error in MCDRV_TERM\n", err);
+		err = -EIO;
+	} else {
+		err = 0;
+	}
+
+	/* Suepend MCLK */
+	mc1n2_set_mclk_source(0);
+
+	pr_info("%s done\n", __func__);
+
+error:
+	mutex_unlock(&mc1n2->mutex);
+
+	if (err != 0)
+		pr_err("%s: err = %d\n", __func__, err);
+
+	return;
+}
+
+static const struct i2c_device_id mc1n2_i2c_id[] = {
+	{MC1N2_NAME, 0},
+	{},
+};
+MODULE_DEVICE_TABLE(i2c, mc1n2_i2c_id);
+
+static struct of_device_id mc1n2_of_matches[] = {
+	{ .compatible = "yamaha,mc1n2", },
+	{},
+};
+
+#ifdef CONFIG_SND_SOC_PM_RUNTIME
+static const struct dev_pm_ops mc1n2_i2c_pm_ops = {
+	.runtime_suspend = mc1n2_runtime_suspend,
+	.runtime_resume = mc1n2_runtime_resume,
+};
+#endif
+static struct i2c_driver mc1n2_i2c_driver = {
+	.driver = {
+		.name = MC1N2_NAME,
+		.owner = THIS_MODULE,
+		.of_match_table = mc1n2_of_matches,
+#ifdef CONFIG_SND_SOC_PM_RUNTIME
+		.pm = &mc1n2_i2c_pm_ops,
+#endif
+	},
+	.probe = mc1n2_i2c_probe,
+	.remove = mc1n2_i2c_remove,
+	.shutdown = mc1n2_i2c_shutdown,
+	.id_table = mc1n2_i2c_id,
+};
+
+/*
+ * Module init and exit
+ */
+static int __init mc1n2_init(void)
+{
+	return i2c_add_driver(&mc1n2_i2c_driver);
+}
+module_init(mc1n2_init);
+
+static void __exit mc1n2_exit(void)
+{
+	i2c_del_driver(&mc1n2_i2c_driver);
+}
+module_exit(mc1n2_exit);
+
+MODULE_AUTHOR("Yamaha Corporation");
+MODULE_DESCRIPTION("Yamaha MC-1N2 ALSA SoC codec driver");
+MODULE_LICENSE("GPL");
+MODULE_VERSION(MC1N2_DRIVER_VERSION);
diff --git a/sound/soc/codecs/mc1n2/mc1n2.h b/sound/soc/codecs/mc1n2/mc1n2.h
new file mode 100644
index 0000000..8167f7c
--- /dev/null
+++ b/sound/soc/codecs/mc1n2/mc1n2.h
@@ -0,0 +1,126 @@
+/*
+ * MC-1N2 ASoC codec driver
+ *
+ * Copyright (c) 2010-2011 Yamaha Corporation
+ *
+ * This software is provided 'as-is', without any express or implied
+ * warranty.  In no event will the authors be held liable for any damages
+ * arising from the use of this software.
+ *
+ * Permission is granted to anyone to use this software for any purpose,
+ * including commercial applications, and to alter it and redistribute it
+ * freely, subject to the following restrictions:
+ *
+ * 1. The origin of this software must not be misrepresented; you must not
+ *    claim that you wrote the original software. If you use this software
+ *    in a product, an acknowledgment in the product documentation would be
+ *    appreciated but is not required.
+ * 2. Altered source versions must be plainly marked as such, and must not be
+ *    misrepresented as being the original software.
+ * 3. This notice may not be removed or altered from any source distribution.
+ */
+
+#ifndef MC1N2_H
+#define MC1N2_H
+
+#include "mcdriver.h"
+#include <linux/mfd/mc1n2_pdata.h>
+
+/*
+ * dai: set_sysclk
+ */
+/* clk_id */
+#define MC1N2_CLKI              0
+
+/* default freq for MC1N2_CLKI */
+#define MC1N2_DEFAULT_CLKI      19200000
+
+/*
+ * dai: set_clkdiv
+ */
+/* div_id */
+#define MC1N2_CKSEL             0
+#define MC1N2_DIVR0             1
+#define MC1N2_DIVF0             2
+#define MC1N2_DIVR1             3
+#define MC1N2_DIVF1             4
+#define MC1N2_BCLK_MULT         5
+
+/* div for MC1N2_BCLK_MULT */
+#define MC1N2_LRCK_X8           0
+#define MC1N2_LRCK_X16          1
+#define MC1N2_LRCK_X24          2
+#define MC1N2_LRCK_X32          3
+#define MC1N2_LRCK_X48          4
+#define MC1N2_LRCK_X64          5
+#define MC1N2_LRCK_X128         6
+#define MC1N2_LRCK_X256         7
+#define MC1N2_LRCK_X512         8
+
+/*
+ * hwdep: ioctl
+ */
+#define MC1N2_MAGIC             'N'
+#define MC1N2_IOCTL_NR_GET      1
+#define MC1N2_IOCTL_NR_SET      2
+#define MC1N2_IOCTL_NR_BOTH     3
+#define MC1N2_IOCTL_NR_NOTIFY   4
+
+#define MC1N2_IOCTL_GET_CTRL \
+	_IOR(MC1N2_MAGIC, MC1N2_IOCTL_NR_GET, struct mc1n2_ctrl_args)
+#define MC1N2_IOCTL_SET_CTRL \
+	_IOW(MC1N2_MAGIC, MC1N2_IOCTL_NR_SET, struct mc1n2_ctrl_args)
+
+#define MC1N2_IOCTL_READ_REG \
+	_IOWR(MC1N2_MAGIC, MC1N2_IOCTL_NR_BOTH, struct mc1n2_ctrl_args)
+
+#define MC1N2_IOCTL_NOTIFY \
+	_IOW(MC1N2_MAGIC, MC1N2_IOCTL_NR_NOTIFY, struct mc1n2_ctrl_args)
+
+struct mc1n2_ctrl_args {
+	unsigned long dCmd;
+	void *pvPrm;
+	unsigned long dPrm;
+};
+
+/*
+ * MC1N2_IOCTL_NOTIFY dCmd definitions
+ */
+#define MCDRV_NOTIFY_CALL_START		0x00000000
+#define MCDRV_NOTIFY_CALL_STOP		0x00000001
+#define MCDRV_NOTIFY_MEDIA_PLAY_START	0x00000002
+#define MCDRV_NOTIFY_MEDIA_PLAY_STOP	0x00000003
+#define MCDRV_NOTIFY_FM_PLAY_START	0x00000004
+#define MCDRV_NOTIFY_FM_PLAY_STOP	0x00000005
+#define MCDRV_NOTIFY_BT_SCO_ENABLE	0x00000006
+#define MCDRV_NOTIFY_BT_SCO_DISABLE	0x00000007
+#define MCDRV_NOTIFY_VOICE_REC_START	0x00000008
+#define MCDRV_NOTIFY_VOICE_REC_STOP	0x00000009
+#define MCDRV_NOTIFY_HDMI_START		0x0000000A
+#define MCDRV_NOTIFY_HDMI_STOP		0x0000000B
+#define	MCDRV_NOTIFY_RECOVER		0x0000000C
+#define MCDRV_NOTIFY_2MIC_CALL_START	0x0000000D
+#define MCDRV_NOTIFY_LINEOUT_START	0x00000010
+#define MCDRV_NOTIFY_LINEOUT_STOP	0x00000011
+
+#define MC1N2_MODE_IDLE			(0x00)
+#define MC1N2_MODE_CALL_ON		(0x1<<0)
+#define MC1N2_MODE_FM_ON		(0x1<<1)
+
+/*
+ * Setup parameters
+ */
+struct mc1n2_setup {
+	MCDRV_INIT_INFO init;
+	unsigned char pcm_extend[IOPORT_NUM];
+	unsigned char pcm_hiz_redge[IOPORT_NUM];
+	unsigned char pcm_hperiod[IOPORT_NUM];
+	unsigned char slot[IOPORT_NUM][SNDRV_PCM_STREAM_LAST+1][DIO_CHANNELS];
+};
+
+/*
+ * Codec Status definitions (for backward compatibility)
+ */
+#define CMD_CODEC_EMERGENCY_RECOVERY 9 // Emergency recovery for Error like -EIO, -ESTRPIPE, and etc.
+
+#endif
diff --git a/sound/soc/codecs/mc1n2/mc1n2_cfg.h b/sound/soc/codecs/mc1n2/mc1n2_cfg.h
new file mode 100644
index 0000000..dc7ce48
--- /dev/null
+++ b/sound/soc/codecs/mc1n2/mc1n2_cfg.h
@@ -0,0 +1,1199 @@
+/*
+ * MC-1N2 ASoC codec driver
+ *
+ * Copyright (c) 2010-2011 Yamaha Corporation
+ *
+ * This software is provided 'as-is', without any express or implied
+ * warranty.  In no event will the authors be held liable for any damages
+ * arising from the use of this software.
+ *
+ * Permission is granted to anyone to use this software for any purpose,
+ * including commercial applications, and to alter it and redistribute it
+ * freely, subject to the following restrictions:
+ *
+ * 1. The origin of this software must not be misrepresented; you must not
+ *    claim that you wrote the original software. If you use this software
+ *    in a product, an acknowledgment in the product documentation would be
+ *    appreciated but is not required.
+ * 2. Altered source versions must be plainly marked as such, and must not be
+ *    misrepresented as being the original software.
+ * 3. This notice may not be removed or altered from any source distribution.
+ */
+
+#ifndef MC1N2_CFG_H
+#define MC1N2_CFG_H
+
+#include "mcdriver.h"
+
+/*
+ * ALSA Version
+ */
+/* #define ALSA_VER_1_0_19 */
+/* #define ALSA_VER_1_0_21 */
+/* #define ALSA_VER_1_0_23 */
+/* #define ALSA_VER_ANDROID_2_6_35 */
+#define ALSA_VER_ANDROID_3_0
+
+#define DIO0_DAI_ENABLE
+/* #define DIO1_DAI_ENABLE */
+/* #define DIO2_DAI_ENABLE */
+
+#ifdef ALSA_VER_ANDROID_3_0
+static struct mc1n2_setup mc1n2_cfg_setup = {
+	{  /* MCDRV_INIT_INFO */
+		MCDRV_CKSEL_CMOS, /* bCkSel */
+		41,               /* bDivR0 */
+		126,              /* bDivF0 */
+		41,               /* bDivR1 */
+		126,              /* bDivF1 */
+		0,                /* bRange0*/
+		0,                /* bRange1*/
+		0,                /* bBypass*/
+		MCDRV_DAHIZ_LOW,  /* bDioSdo0Hiz */
+		MCDRV_DAHIZ_LOW,  /* bDioSdo1Hiz */
+		MCDRV_DAHIZ_LOW,  /* bDioSdo2Hiz */
+		MCDRV_DAHIZ_HIZ,  /* bDioClk0Hiz */
+		MCDRV_DAHIZ_HIZ,  /* bDioClk1Hiz */
+		MCDRV_DAHIZ_HIZ,  /* bDioClk2Hiz */
+		MCDRV_PCMHIZ_HIZ, /* bPcmHiz */
+		MCDRV_LINE_STEREO,/* bLineIn1Dif */
+		0,                /* bLineIn2Dif */
+		MCDRV_LINE_STEREO,/* bLineOut1Dif */
+		MCDRV_LINE_STEREO,/* bLineOUt2Dif */
+		MCDRV_SPMN_ON,    /* bSpmn */
+		MCDRV_MIC_DIF,    /* bMic1Sng */
+		MCDRV_MIC_DIF,    /* bMic2Sng */
+		MCDRV_MIC_DIF,    /* bMic3Sng */
+		MCDRV_POWMODE_NORMAL, /* bPowerMode */
+		MCDRV_SPHIZ_PULLDOWN, /* bSpHiz */
+		MCDRV_LDO_ON,     /* bLdo */
+		MCDRV_PAD_GPIO,   /* bPad0Func */
+		MCDRV_PAD_GPIO,   /* bPad1Func */
+		MCDRV_PAD_GPIO,   /* bPad2Func */
+		MCDRV_OUTLEV_4,   /* bAvddLev */
+		0,                /* bVrefLev */
+		MCDRV_DCLGAIN_12, /* bDclGain */
+		MCDRV_DCLLIMIT_0, /* bDclLimit */
+		1,                   /* set Hi-power mode 0: HP mode 1: normal */
+		0,                /* bReserved1 */
+		0,                /* bReserved2 */
+		0,                /* bReserved3 */
+		0,                /* bReserved4 */
+		0,                /* bReserved5 */
+		{                 /* sWaitTime */
+			130000,         /* dAdHpf */
+			25000,          /* dMic1Cin */
+			25000,          /* dMic2Cin */
+			25000,          /* dMic3Cin */
+			25000,          /* dLine1Cin */
+			25000,          /* dLine2Cin */
+			5000,           /* dVrefRdy1 */
+			15000,          /* dVrefRdy2 */
+			9000,           /* dHpRdy */
+			13000,          /* dSpRdy */
+			0,              /* dPdm */
+			1000,           /* dAnaRdyInterval */
+			1000,           /* dSvolInterval */
+			1000,           /* dAnaRdyTimeOut */
+			1000            /* dSvolTimeOut */
+		}
+	}, /* MCDRV_INIT_INFO end */
+	{  /* pcm_extend */
+		0, 0, 0
+	}, /* pcm_extend end */
+	{  /* pcm_hiz_redge */
+		MCDRV_PCMHIZTIM_FALLING, MCDRV_PCMHIZTIM_FALLING, MCDRV_PCMHIZTIM_FALLING
+	}, /* pcm_hiz_redge end */
+	{  /* pcm_hperiod */
+		1, 1, 1
+	}, /* pcm_hperiod end */
+	{  /* slot */
+		{ {0, 1}, {0, 1} },
+		{ {0, 1}, {0, 1} },
+		{ {0, 1}, {0, 1} }
+	}  /* slot end */
+};
+#endif
+
+static const MCDRV_DIO_INFO stDioInfo_Default = {
+	{
+		/* DIO port 0 */
+		{
+			/* sDioCommon */
+			{
+				/* bMasterSlave : Master / Slave Setting */
+				/*     MCDRV_DIO_SLAVE (0)  : Slave      */
+				/*     MCDRV_DIO_MASTER(1)  : Master     */
+				MCDRV_DIO_MASTER,
+				/* bAutoFs : Sampling frequency automatic measurement ON/OFF Setting in slave mode */
+				/*     MCDRV_AUTOFS_OFF(0)  : OFF */
+				/*     MCDRV_AUTOFS_ON (1)  : ON  */
+				MCDRV_AUTOFS_ON ,
+				/* bFs : Sampling Rate Setting        */
+				/*     MCDRV_FS_48000(0)  : 48kHz     */
+				/*     MCDRV_FS_44100(1)  : 44.1kHz   */
+				/*     MCDRV_FS_32000(2)  : 32kHz     */
+				/*     MCDRV_FS_24000(4)  : 24kHz     */
+				/*     MCDRV_FS_22050(5)  : 22.05kHz  */
+				/*     MCDRV_FS_16000(6)  : 16kHz     */
+				/*     MCDRV_FS_12000(8)  : 12kHz     */
+				/*     MCDRV_FS_11025(9)  : 11.025kHz */
+				/*     MCDRV_FS_8000 (10) : 8kHz      */
+				MCDRV_FS_44100,
+				/* bBckFs : Bit Clock Frequency Setting */
+				/*     MCDRV_BCKFS_64 (0)  : LRCK x  64 */
+				/*     MCDRV_BCKFS_48 (1)  : LRCK x  48 */
+				/*     MCDRV_BCKFS_32 (2)  : LRCK x  32 */
+				/*     MCDRV_BCKFS_512(4)  : LRCK x 512 */
+				/*     MCDRV_BCKFS_256(5)  : LRCK x 256 */
+				/*     MCDRV_BCKFS_128(6)  : LRCK x 128 */
+				/*     MCDRV_BCKFS_16 (7)  : LRCK x  16 */
+				MCDRV_BCKFS_32,
+				/* bInterface : Interface Selection      */
+				/*     MCDRV_DIO_DA (0)  : Digital Audio */
+				/*     MCDRV_DIO_PCM(1)  : PCM           */
+				MCDRV_DIO_DA,
+				/* bBckInvert : Bit Clock Inversion Setting     */
+				/*     MCDRV_BCLK_NORMAL(0)  : Normal Operation */
+				/*     MCDRV_BCLK_INVERT(1)  : Clock Inverted   */
+				MCDRV_BCLK_NORMAL,
+				/* bPcmHizTim : High Impedance transition timing after transmitting the last PCM I/F data */
+				/*     MCDRV_PCMHIZTIM_FALLING(0)  : BCLK#* Falling Edge */
+				/*     MCDRV_PCMHIZTIM_RISING (1)  : BCLK#* Rising Edge  */
+				MCDRV_PCMHIZTIM_FALLING,
+				/* bPcmClkDown : Bit Clock Setting with PCM selected and Master selected                */
+				/*     MCDRV_PCM_CLKDOWN_OFF (0)  : A bit clock value specified with bBckFs             */
+				/*     MCDRV_PCM_CLKDOWN_HALF(1)  : A half of the bit clock value specified with bBckFs */
+				MCDRV_PCM_CLKDOWN_OFF,
+				/* bPcmFrame : Frame Mode Setting with PCM interface */
+				/*     MCDRV_PCM_SHORTFRAME(0)  : Short Frame        */
+				/*     MCDRV_PCM_LONGFRAME (1)  : Long Frame         */
+				MCDRV_PCM_SHORTFRAME,
+				/* bPcmHighPeriod : LR clock High time setting with PCM selected and Master selected */
+				/*     0 to 31  : High level keeps during the period of time of         */
+				/*                (setting value + 1) of the bit clock.                 */
+				0,
+			},
+			/* sDir       */
+			{
+				/* wSrcRate : Sampling Rate Converter Setting */
+				0,
+				/* sDaFormat : Digital Audio Format Information */
+				{
+					/* bBitSel : Bit Width Setting     */
+					/*     MCDRV_BITSEL_16(0)  : 16bit */
+					/*     MCDRV_BITSEL_20(1)  : 20bit */
+					/*     MCDRV_BITSEL_24(2)  : 24bit */
+					MCDRV_BITSEL_16,
+					/* bMode : Data Format Setting                             */
+					/*     MCDRV_DAMODE_HEADALIGN(0)  : Left-justified Format  */
+					/*     MCDRV_DAMODE_I2S      (1)  : I2S                    */
+					/*     MCDRV_DAMODE_TAILALIGN(2)  : Right-justified Format */
+					MCDRV_DAMODE_I2S
+				},
+				/* sPcmFormat : PCM Format Information */
+				{
+					/* bMono : Mono / Stereo Setting  */
+					/*     MCDRV_PCM_STEREO(0) Stereo */
+					/*     MCDRV_PCM_MONO  (1) Mono   */
+					MCDRV_PCM_MONO ,
+					/* bOrder : Bit Order Setting                                     */
+					/*     MCDRV_PCM_MSB_FIRST      (0)  : MSB First                  */
+					/*     MCDRV_PCM_LSB_FIRST      (1)  : LSB First                  */
+					/*     MCDRV_PCM_MSB_FIRST_SIGN (2)  : MSB First (Sign Extension) */
+					/*     MCDRV_PCM_LSB_FIRST_SIGN (3)  : LSB First (Sign Extension) */
+					/*     MCDRV_PCM_MSB_FIRST_ZERO (4)  : MSB First (Zeros Padding)  */
+					/*     MCDRV_PCM_LSB_FIRST_ZERO (5)  : LSB First (Zeros Padding)  */
+					MCDRV_PCM_MSB_FIRST,
+					/* bLaw : Data Format Setting        */
+					/*     MCDRV_PCM_LINEAR(0)  : Linear */
+					/*     MCDRV_PCM_ALAW  (1)  : A-Law  */
+					/*     MCDRV_PCM_MULAW (2)  : u-Law */
+					MCDRV_PCM_LINEAR,
+					/* bBitSel : Bit Width Setting        */
+					/*     MCDRV_PCM_BITSEL_8 (0)  8 bits */
+					/*     MCDRV_PCM_BITSEL_13(1) 13 bits */
+					/*     MCDRV_PCM_BITSEL_14(2) 14 bits */
+					/*     MCDRV_PCM_BITSEL_16(3) 16 bits */
+					MCDRV_PCM_BITSEL_8
+				},
+				/* asSlot : Setting of a slot number of data to be fed to each channel */
+				{0, 1}
+			},
+			/* sDit       */
+			{
+				/* wSrcRate : Sampling Rate Converter Setting */
+				0,
+				/* sDaFormat : Digital Audio Format Information */
+				{
+					/* bBitSel : Bit Width Setting     */
+					/*     MCDRV_BITSEL_16(0)  : 16bit */
+					/*     MCDRV_BITSEL_20(1)  : 20bit */
+					/*     MCDRV_BITSEL_24(2)  : 24bit */
+					MCDRV_BITSEL_16,
+					/* bMode : Data Format Setting                             */
+					/*     MCDRV_DAMODE_HEADALIGN(0)  : Left-justified Format  */
+					/*     MCDRV_DAMODE_I2S      (1)  : I2S                    */
+					/*     MCDRV_DAMODE_TAILALIGN(2)  : Right-justified Format */
+					MCDRV_DAMODE_I2S
+				},
+				/* sPcmFormat : PCM Format Information */
+				{
+					/* bMono : Mono / Stereo Setting  */
+					/*     MCDRV_PCM_STEREO(0) Stereo */
+					/*     MCDRV_PCM_MONO  (1) Mono   */
+					MCDRV_PCM_MONO ,
+					/* bOrder : Bit Order Setting                                     */
+					/*     MCDRV_PCM_MSB_FIRST      (0)  : MSB First                  */
+					/*     MCDRV_PCM_LSB_FIRST      (1)  : LSB First                  */
+					/*     MCDRV_PCM_MSB_FIRST_SIGN (2)  : MSB First (Sign Extension) */
+					/*     MCDRV_PCM_LSB_FIRST_SIGN (3)  : LSB First (Sign Extension) */
+					/*     MCDRV_PCM_MSB_FIRST_ZERO (4)  : MSB First (Zeros Padding)  */
+					/*     MCDRV_PCM_LSB_FIRST_ZERO (5)  : LSB First (Zeros Padding)  */
+					MCDRV_PCM_MSB_FIRST,
+					/* bLaw : Data Format Setting        */
+					/*     MCDRV_PCM_LINEAR(0)  : Linear */
+					/*     MCDRV_PCM_ALAW  (1)  : A-Law  */
+					/*     MCDRV_PCM_MULAW (2)  : u-Law */
+					MCDRV_PCM_LINEAR,
+					/* bBitSel : Bit Width Setting        */
+					/*     MCDRV_PCM_BITSEL_8 (0)  8 bits */
+					/*     MCDRV_PCM_BITSEL_13(1) 13 bits */
+					/*     MCDRV_PCM_BITSEL_14(2) 14 bits */
+					/*     MCDRV_PCM_BITSEL_16(3) 16 bits */
+					MCDRV_PCM_BITSEL_8
+				},
+				/* asSlot Setting of a slot number of data to be transmitted from each channel */
+				{0, 1}
+			}
+		},
+		/* DIO port 1 */
+		{
+			/* sDioCommon */
+			{
+				/* bMasterSlave : Master / Slave Setting */
+				/*     MCDRV_DIO_SLAVE (0)  : Slave      */
+				/*     MCDRV_DIO_MASTER(1)  : Master     */
+				MCDRV_DIO_SLAVE,
+				/* bAutoFs : Sampling frequency automatic measurement ON/OFF Setting in slave mode */
+				/*     MCDRV_AUTOFS_OFF(0)  : OFF */
+				/*     MCDRV_AUTOFS_ON (1)  : ON  */
+				MCDRV_AUTOFS_ON ,
+				/* bFs : Sampling Rate Setting        */
+				/*     MCDRV_FS_48000(0)  : 48kHz     */
+				/*     MCDRV_FS_44100(1)  : 44.1kHz   */
+				/*     MCDRV_FS_32000(2)  : 32kHz     */
+				/*     MCDRV_FS_24000(4)  : 24kHz     */
+				/*     MCDRV_FS_22050(5)  : 22.05kHz  */
+				/*     MCDRV_FS_16000(6)  : 16kHz     */
+				/*     MCDRV_FS_12000(8)  : 12kHz     */
+				/*     MCDRV_FS_11025(9)  : 11.025kHz */
+				/*     MCDRV_FS_8000 (10) : 8kHz      */
+				MCDRV_FS_8000,
+				/* bBckFs : Bit Clock Frequency Setting */
+				/*     MCDRV_BCKFS_64 (0)  : LRCK x  64 */
+				/*     MCDRV_BCKFS_48 (1)  : LRCK x  48 */
+				/*     MCDRV_BCKFS_32 (2)  : LRCK x  32 */
+				/*     MCDRV_BCKFS_512(4)  : LRCK x 512 */
+				/*     MCDRV_BCKFS_256(5)  : LRCK x 256 */
+				/*     MCDRV_BCKFS_128(6)  : LRCK x 128 */
+				/*     MCDRV_BCKFS_16 (7)  : LRCK x  16 */
+				MCDRV_BCKFS_32,
+				/* bInterface : Interface Selection      */
+				/*     MCDRV_DIO_DA (0)  : Digital Audio */
+				/*     MCDRV_DIO_PCM(1)  : PCM           */
+				MCDRV_DIO_DA,
+				/* bBckInvert : Bit Clock Inversion Setting     */
+				/*     MCDRV_BCLK_NORMAL(0)  : Normal Operation */
+				/*     MCDRV_BCLK_INVERT(1)  : Clock Inverted   */
+				MCDRV_BCLK_INVERT,
+				/* bPcmHizTim : High Impedance transition timing after transmitting the last PCM I/F data */
+				/*     MCDRV_PCMHIZTIM_FALLING(0)  : BCLK#* Falling Edge */
+				/*     MCDRV_PCMHIZTIM_RISING (1)  : BCLK#* Rising Edge  */
+				MCDRV_PCMHIZTIM_FALLING,
+				/* bPcmClkDown : Bit Clock Setting with PCM selected and Master selected                */
+				/*     MCDRV_PCM_CLKDOWN_OFF (0)  : A bit clock value specified with bBckFs             */
+				/*     MCDRV_PCM_CLKDOWN_HALF(1)  : A half of the bit clock value specified with bBckFs */
+				MCDRV_PCM_CLKDOWN_OFF,
+				/* bPcmFrame : Frame Mode Setting with PCM interface */
+				/*     MCDRV_PCM_SHORTFRAME(0)  : Short Frame        */
+				/*     MCDRV_PCM_LONGFRAME (1)  : Long Frame         */
+				MCDRV_PCM_SHORTFRAME,
+				/* bPcmHighPeriod : LR clock High time setting with PCM selected and Master selected */
+				/*     0 to 31  : High level keeps during the period of time of         */
+				/*                (setting value + 1) of the bit clock.                 */
+				0,
+			},
+			/* sDir       */
+			{
+				/* wSrcRate : Sampling Rate Converter Setting */
+				0,
+				/* sDaFormat : Digital Audio Format Information */
+				{
+					/* bBitSel : Bit Width Setting     */
+					/*     MCDRV_BITSEL_16(0)  : 16bit */
+					/*     MCDRV_BITSEL_20(1)  : 20bit */
+					/*     MCDRV_BITSEL_24(2)  : 24bit */
+					MCDRV_BITSEL_16,
+					/* bMode : Data Format Setting                             */
+					/*     MCDRV_DAMODE_HEADALIGN(0)  : Left-justified Format  */
+					/*     MCDRV_DAMODE_I2S      (1)  : I2S                    */
+					/*     MCDRV_DAMODE_TAILALIGN(2)  : Right-justified Format */
+					MCDRV_DAMODE_I2S
+				},
+				/* sPcmFormat : PCM Format Information */
+				{
+					/* bMono : Mono / Stereo Setting  */
+					/*     MCDRV_PCM_STEREO(0) Stereo */
+					/*     MCDRV_PCM_MONO  (1) Mono   */
+					MCDRV_PCM_STEREO ,
+					/* bOrder : Bit Order Setting                                     */
+					/*     MCDRV_PCM_MSB_FIRST      (0)  : MSB First                  */
+					/*     MCDRV_PCM_LSB_FIRST      (1)  : LSB First                  */
+					/*     MCDRV_PCM_MSB_FIRST_SIGN (2)  : MSB First (Sign Extension) */
+					/*     MCDRV_PCM_LSB_FIRST_SIGN (3)  : LSB First (Sign Extension) */
+					/*     MCDRV_PCM_MSB_FIRST_ZERO (4)  : MSB First (Zeros Padding)  */
+					/*     MCDRV_PCM_LSB_FIRST_ZERO (5)  : LSB First (Zeros Padding)  */
+					MCDRV_PCM_MSB_FIRST,
+					/* bLaw : Data Format Setting        */
+					/*     MCDRV_PCM_LINEAR(0)  : Linear */
+					/*     MCDRV_PCM_ALAW  (1)  : A-Law  */
+					/*     MCDRV_PCM_MULAW (2)  : u-Law */
+					MCDRV_PCM_LINEAR,
+					/* bBitSel : Bit Width Setting        */
+					/*     MCDRV_PCM_BITSEL_8 (0)  8 bits */
+					/*     MCDRV_PCM_BITSEL_13(1) 13 bits */
+					/*     MCDRV_PCM_BITSEL_14(2) 14 bits */
+					/*     MCDRV_PCM_BITSEL_16(3) 16 bits */
+					MCDRV_PCM_BITSEL_16
+				},
+				/* asSlot : Setting of a slot number of data to be fed to each channel */
+				{1, 1}
+			},
+			/* sDit       */
+			{
+				/* wSrcRate : Sampling Rate Converter Setting */
+				0,
+				/* sDaFormat : Digital Audio Format Information */
+				{
+					/* bBitSel : Bit Width Setting     */
+					/*     MCDRV_BITSEL_16(0)  : 16bit */
+					/*     MCDRV_BITSEL_20(1)  : 20bit */
+					/*     MCDRV_BITSEL_24(2)  : 24bit */
+					MCDRV_BITSEL_16,
+					/* bMode : Data Format Setting                             */
+					/*     MCDRV_DAMODE_HEADALIGN(0)  : Left-justified Format  */
+					/*     MCDRV_DAMODE_I2S      (1)  : I2S                    */
+					/*     MCDRV_DAMODE_TAILALIGN(2)  : Right-justified Format */
+					MCDRV_DAMODE_I2S
+				},
+				/* sPcmFormat : PCM Format Information */
+				{
+					/* bMono : Mono / Stereo Setting  */
+					/*     MCDRV_PCM_STEREO(0) Stereo */
+					/*     MCDRV_PCM_MONO  (1) Mono   */
+					MCDRV_PCM_STEREO ,
+					/* bOrder : Bit Order Setting                                     */
+					/*     MCDRV_PCM_MSB_FIRST      (0)  : MSB First                  */
+					/*     MCDRV_PCM_LSB_FIRST      (1)  : LSB First                  */
+					/*     MCDRV_PCM_MSB_FIRST_SIGN (2)  : MSB First (Sign Extension) */
+					/*     MCDRV_PCM_LSB_FIRST_SIGN (3)  : LSB First (Sign Extension) */
+					/*     MCDRV_PCM_MSB_FIRST_ZERO (4)  : MSB First (Zeros Padding)  */
+					/*     MCDRV_PCM_LSB_FIRST_ZERO (5)  : LSB First (Zeros Padding)  */
+					MCDRV_PCM_MSB_FIRST,
+					/* bLaw : Data Format Setting        */
+					/*     MCDRV_PCM_LINEAR(0)  : Linear */
+					/*     MCDRV_PCM_ALAW  (1)  : A-Law  */
+					/*     MCDRV_PCM_MULAW (2)  : u-Law */
+					MCDRV_PCM_LINEAR,
+					/* bBitSel : Bit Width Setting        */
+					/*     MCDRV_PCM_BITSEL_8 (0)  8 bits */
+					/*     MCDRV_PCM_BITSEL_13(1) 13 bits */
+					/*     MCDRV_PCM_BITSEL_14(2) 14 bits */
+					/*     MCDRV_PCM_BITSEL_16(3) 16 bits */
+					MCDRV_PCM_BITSEL_16
+				},
+				/* asSlot Setting of a slot number of data to be transmitted from each channel */
+				{1, 0}
+			}
+		},
+		/* DIO port 2 */
+		{
+			/* sDioCommon */
+			{
+				/* bMasterSlave : Master / Slave Setting */
+				/*     MCDRV_DIO_SLAVE (0)  : Slave      */
+				/*     MCDRV_DIO_MASTER(1)  : Master     */
+				MCDRV_DIO_MASTER,
+				/* bAutoFs : Sampling frequency automatic measurement ON/OFF Setting in slave mode */
+				/*     MCDRV_AUTOFS_OFF(0)  : OFF */
+				/*     MCDRV_AUTOFS_ON (1)  : ON  */
+				MCDRV_AUTOFS_ON ,
+				/* bFs : Sampling Rate Setting        */
+				/*     MCDRV_FS_48000(0)  : 48kHz     */
+				/*     MCDRV_FS_44100(1)  : 44.1kHz   */
+				/*     MCDRV_FS_32000(2)  : 32kHz     */
+				/*     MCDRV_FS_24000(4)  : 24kHz     */
+				/*     MCDRV_FS_22050(5)  : 22.05kHz  */
+				/*     MCDRV_FS_16000(6)  : 16kHz     */
+				/*     MCDRV_FS_12000(8)  : 12kHz     */
+				/*     MCDRV_FS_11025(9)  : 11.025kHz */
+				/*     MCDRV_FS_8000 (10) : 8kHz      */
+				MCDRV_FS_8000,
+				/* bBckFs : Bit Clock Frequency Setting */
+				/*     MCDRV_BCKFS_64 (0)  : LRCK x  64 */
+				/*     MCDRV_BCKFS_48 (1)  : LRCK x  48 */
+				/*     MCDRV_BCKFS_32 (2)  : LRCK x  32 */
+				/*     MCDRV_BCKFS_512(4)  : LRCK x 512 */
+				/*     MCDRV_BCKFS_256(5)  : LRCK x 256 */
+				/*     MCDRV_BCKFS_128(6)  : LRCK x 128 */
+				/*     MCDRV_BCKFS_16 (7)  : LRCK x  16 */
+				MCDRV_BCKFS_32,
+				/* bInterface : Interface Selection      */
+				/*     MCDRV_DIO_DA (0)  : Digital Audio */
+				/*     MCDRV_DIO_PCM(1)  : PCM           */
+				MCDRV_DIO_PCM,
+				/* bBckInvert : Bit Clock Inversion Setting     */
+				/*     MCDRV_BCLK_NORMAL(0)  : Normal Operation */
+				/*     MCDRV_BCLK_INVERT(1)  : Clock Inverted   */
+				MCDRV_BCLK_NORMAL,
+				/* bPcmHizTim : High Impedance transition timing after transmitting the last PCM I/F data */
+				/*     MCDRV_PCMHIZTIM_FALLING(0)  : BCLK#* Falling Edge */
+				/*     MCDRV_PCMHIZTIM_RISING (1)  : BCLK#* Rising Edge  */
+				MCDRV_PCMHIZTIM_FALLING,
+				/* bPcmClkDown : Bit Clock Setting with PCM selected and Master selected                */
+				/*     MCDRV_PCM_CLKDOWN_OFF (0)  : A bit clock value specified with bBckFs             */
+				/*     MCDRV_PCM_CLKDOWN_HALF(1)  : A half of the bit clock value specified with bBckFs */
+				MCDRV_PCM_CLKDOWN_OFF,
+				/* bPcmFrame : Frame Mode Setting with PCM interface */
+				/*     MCDRV_PCM_SHORTFRAME(0)  : Short Frame        */
+				/*     MCDRV_PCM_LONGFRAME (1)  : Long Frame         */
+				MCDRV_PCM_SHORTFRAME,
+				/* bPcmHighPeriod : LR clock High time setting with PCM selected and Master selected */
+				/*     0 to 31  : High level keeps during the period of time of         */
+				/*                (setting value + 1) of the bit clock.                 */
+				0,
+			},
+			/* sDir       */
+			{
+				/* wSrcRate : Sampling Rate Converter Setting */
+				0,
+				/* sDaFormat : Digital Audio Format Information */
+				{
+					/* bBitSel : Bit Width Setting     */
+					/*     MCDRV_BITSEL_16(0)  : 16bit */
+					/*     MCDRV_BITSEL_20(1)  : 20bit */
+					/*     MCDRV_BITSEL_24(2)  : 24bit */
+					MCDRV_BITSEL_16,
+					/* bMode : Data Format Setting                             */
+					/*     MCDRV_DAMODE_HEADALIGN(0)  : Left-justified Format  */
+					/*     MCDRV_DAMODE_I2S      (1)  : I2S                    */
+					/*     MCDRV_DAMODE_TAILALIGN(2)  : Right-justified Format */
+					MCDRV_DAMODE_HEADALIGN
+				},
+				/* sPcmFormat : PCM Format Information */
+				{
+					/* bMono : Mono / Stereo Setting  */
+					/*     MCDRV_PCM_STEREO(0) Stereo */
+					/*     MCDRV_PCM_MONO  (1) Mono   */
+					MCDRV_PCM_STEREO ,
+					/* bOrder : Bit Order Setting                                     */
+					/*     MCDRV_PCM_MSB_FIRST      (0)  : MSB First                  */
+					/*     MCDRV_PCM_LSB_FIRST      (1)  : LSB First                  */
+					/*     MCDRV_PCM_MSB_FIRST_SIGN (2)  : MSB First (Sign Extension) */
+					/*     MCDRV_PCM_LSB_FIRST_SIGN (3)  : LSB First (Sign Extension) */
+					/*     MCDRV_PCM_MSB_FIRST_ZERO (4)  : MSB First (Zeros Padding)  */
+					/*     MCDRV_PCM_LSB_FIRST_ZERO (5)  : LSB First (Zeros Padding)  */
+					MCDRV_PCM_MSB_FIRST,
+					/* bLaw : Data Format Setting        */
+					/*     MCDRV_PCM_LINEAR(0)  : Linear */
+					/*     MCDRV_PCM_ALAW  (1)  : A-Law  */
+					/*     MCDRV_PCM_MULAW (2)  : u-Law */
+					MCDRV_PCM_LINEAR,
+					/* bBitSel : Bit Width Setting        */
+					/*     MCDRV_PCM_BITSEL_8 (0)  8 bits */
+					/*     MCDRV_PCM_BITSEL_13(1) 13 bits */
+					/*     MCDRV_PCM_BITSEL_14(2) 14 bits */
+					/*     MCDRV_PCM_BITSEL_16(3) 16 bits */
+					MCDRV_PCM_BITSEL_16
+				},
+				/* asSlot : Setting of a slot number of data to be fed to each channel */
+				{0, 0}
+			},
+			/* sDit       */
+			{
+				/* wSrcRate : Sampling Rate Converter Setting */
+				0,
+				/* sDaFormat : Digital Audio Format Information */
+				{
+					/* bBitSel : Bit Width Setting     */
+					/*     MCDRV_BITSEL_16(0)  : 16bit */
+					/*     MCDRV_BITSEL_20(1)  : 20bit */
+					/*     MCDRV_BITSEL_24(2)  : 24bit */
+					MCDRV_BITSEL_16,
+					/* bMode : Data Format Setting                             */
+					/*     MCDRV_DAMODE_HEADALIGN(0)  : Left-justified Format  */
+					/*     MCDRV_DAMODE_I2S      (1)  : I2S                    */
+					/*     MCDRV_DAMODE_TAILALIGN(2)  : Right-justified Format */
+					MCDRV_DAMODE_HEADALIGN
+				},
+				/* sPcmFormat : PCM Format Information */
+				{
+					/* bMono : Mono / Stereo Setting  */
+					/*     MCDRV_PCM_STEREO(0) Stereo */
+					/*     MCDRV_PCM_MONO  (1) Mono   */
+					MCDRV_PCM_MONO ,
+					/* bOrder : Bit Order Setting                                     */
+					/*     MCDRV_PCM_MSB_FIRST      (0)  : MSB First                  */
+					/*     MCDRV_PCM_LSB_FIRST      (1)  : LSB First                  */
+					/*     MCDRV_PCM_MSB_FIRST_SIGN (2)  : MSB First (Sign Extension) */
+					/*     MCDRV_PCM_LSB_FIRST_SIGN (3)  : LSB First (Sign Extension) */
+					/*     MCDRV_PCM_MSB_FIRST_ZERO (4)  : MSB First (Zeros Padding)  */
+					/*     MCDRV_PCM_LSB_FIRST_ZERO (5)  : LSB First (Zeros Padding)  */
+					MCDRV_PCM_MSB_FIRST,
+					/* bLaw : Data Format Setting        */
+					/*     MCDRV_PCM_LINEAR(0)  : Linear */
+					/*     MCDRV_PCM_ALAW  (1)  : A-Law  */
+					/*     MCDRV_PCM_MULAW (2)  : u-Law */
+					MCDRV_PCM_LINEAR,
+					/* bBitSel : Bit Width Setting        */
+					/*     MCDRV_PCM_BITSEL_8 (0)  8 bits */
+					/*     MCDRV_PCM_BITSEL_13(1) 13 bits */
+					/*     MCDRV_PCM_BITSEL_14(2) 14 bits */
+					/*     MCDRV_PCM_BITSEL_16(3) 16 bits */
+					MCDRV_PCM_BITSEL_16
+				},
+				/* asSlot Setting of a slot number of data to be transmitted from each channel */
+				{0, 1}
+			}
+		}
+	}
+};
+
+/* ========================================
+   DAC settings
+   ========================================*/
+static const MCDRV_DAC_INFO stDacInfo_Default = {
+	/* bMasterSwap : DAC Master Path SWAP Setting                          */
+	/*     MCDRV_DSWAP_OFF      (0)  : No SWAP                             */
+	/*     MCDRV_DSWAP_SWAP     (1)  : SWAP                                */
+	/*     MCDRV_DSWAP_MUTE     (2)  : MUTE                                */
+	/*     MCDRV_DSWAP_RMVCENTER(3)  : Center Removed                      */
+	/*     MCDRV_DSWAP_MONO     (4)  : Mono                                */
+	/*     MCDRV_DSWAP_MONOHALF (5)  : Reserved (do not use this setting)  */
+	/*     MCDRV_DSWAP_BOTHL    (6)  : Lch data output in both Lch and Rch */
+	/*     MCDRV_DSWAP_BOTHR    (7)  : Rch data output in both Lch and Rch */
+	MCDRV_DSWAP_OFF,
+	/* bVoiceSwap : DAC Voice Path SWAP Setting                            */
+	/*     MCDRV_DSWAP_OFF      (0)  : No SWAP                             */
+	/*     MCDRV_DSWAP_SWAP     (1)  : SWAP                                */
+	/*     MCDRV_DSWAP_MUTE     (2)  : MUTE                                */
+	/*     MCDRV_DSWAP_RMVCENTER(3)  : Center Removed                      */
+	/*     MCDRV_DSWAP_MONO     (4)  : Mono (-6dB)                         */
+	/*     MCDRV_DSWAP_MONOHALF (5)  : Reserved (do not use this setting)  */
+	/*     MCDRV_DSWAP_BOTHL    (6)  : Lch data output in both Lch and Rch */
+	/*     MCDRV_DSWAP_BOTHR    (7)  : Rch data output in both Lch and Rch */
+	MCDRV_DSWAP_OFF,
+	/* bDcCut : HP, SP Protection DC-ct Filter Setting  */
+	/*     MCDRV_DCCUT_ON (0)  : DC-cut Filter ON       */
+	/*     MCDRV_DCCUT_OFF(1)  : DC-cut Filter OFF      */
+	MCDRV_DCCUT_ON
+};
+
+/* ========================================
+   ADC settings
+   ========================================*/
+
+static const MCDRV_ADC_INFO stAdcInfo_Default = {
+	/* bAgcAdjust : AGC Gain Control Range     */
+	/*     MCDRV_AGCADJ_24(0)  : -3dB to +24dB */
+	/*     MCDRV_AGCADJ_18(1)  : -3dB to +18dB */
+	/*     MCDRV_AGCADJ_12(2)  : -3dB to +12dB */
+	/*     MCDRV_AGCADJ_0 (3)  : -3dB to  +0dB */
+	MCDRV_AGCADJ_0,
+	/* bAgcOn : AGC ON/OFF Setting */
+	/*     MCDRV_AGC_OFF(0)  : OFF */
+	/*     MCDRV_AGC_ON (1)  : ON  */
+	MCDRV_AGC_OFF,
+	/* bMonot : Mono / Stereo Setting    */
+	/*     MCDRV_ADC_STEREO(0)  : Stereo */
+	/*     MCDRV_ADC_MONO  (1)  : Mono   */
+	MCDRV_ADC_STEREO
+};
+
+/* ========================================
+   SP settings
+   ========================================*/
+static const MCDRV_SP_INFO stSpInfo_Default = {
+	/* bSwap : Swap setting                */
+	/*     MCDRV_SPSWAP_OFF (0)  : No SWAP */
+	/*     MCDRV_SPSWAP_SWAP(1)  : SWAP    */
+	MCDRV_SPSWAP_OFF
+};
+
+/* ========================================
+   DNG settings
+   ========================================*/
+static const MCDRV_DNG_INFO stDngInfo_Default = {
+	/* bOnOff[] : Digital Noise Gate On/Off Setting */
+	/*     MCDRV_DNG_OFF(0)  : OFF                */
+	/*     MCDRV_DNG_ON (1)  : ON                 */
+	{MCDRV_DNG_OFF, MCDRV_DNG_OFF, MCDRV_DNG_OFF},
+
+	/* bThreshold[] : Threshold Setting    */
+	/*     MCDRV_DNG_THRES_30    (0) */
+	/*     MCDRV_DNG_THRES_36    (1) */
+	/*     MCDRV_DNG_THRES_42    (2) */
+	/*     MCDRV_DNG_THRES_48    (3) */
+	/*     MCDRV_DNG_THRES_54    (4) */
+	/*     MCDRV_DNG_THRES_60    (5) */
+	/*     MCDRV_DNG_THRES_66    (6) */
+	/*     MCDRV_DNG_THRES_72    (7) */
+	/*     MCDRV_DNG_THRES_78    (8) */
+	/*     MCDRV_DNG_THRES_84    (9) */
+	{MCDRV_DNG_THRES_60, MCDRV_DNG_THRES_60, MCDRV_DNG_THRES_60},
+
+	/* bHold[] : Hold Time Setting         */
+	/*     MCDRV_DNG_HOLD_30 (0)  :  30ms */
+	/*     MCDRV_DNG_HOLD_120(1)  : 120ms */
+	/*     MCDRV_DNG_HOLD_500(2)  : 500ms */
+	{MCDRV_DNG_HOLD_500, MCDRV_DNG_HOLD_500, MCDRV_DNG_HOLD_500},
+
+	/* bAttack[] : Attack Time Setting        */
+	/*     MCDRV_DNG_ATTACK_25   (0)  :   25ms */
+	/*     MCDRV_DNG_ATTACK_100  (1)  :  100ms */
+	/*     MCDRV_DNG_ATTACK_400  (2)  :  400ms */
+	/*     MCDRV_DNG_ATTACK_800  (3)  :  800ms */
+	{MCDRV_DNG_ATTACK_100, MCDRV_DNG_ATTACK_100, MCDRV_DNG_ATTACK_100},
+
+	/* bRelease[] : Release Time Setting        */
+	/*     MCDRV_DNG_RELEASE_7950(0)  : 7.95ms */
+	/*     MCDRV_DNG_RELEASE_470 (1)  : 0.47ms */
+	/*     MCDRV_DNG_RELEASE_940 (2)  : 0.94ms */
+	{MCDRV_DNG_RELEASE_940, MCDRV_DNG_RELEASE_940, MCDRV_DNG_RELEASE_940},
+
+	/* bTarget[] : Target Volume Setting        */
+	/*     MCDRV_DNG_TARGET_6    (0)  : -6dB  */
+	/*     MCDRV_DNG_TARGET_9    (1)  : -9dB  */
+	/*     MCDRV_DNG_TARGET_12   (2)  : -12dB */
+	/*     MCDRV_DNG_TARGET_15   (3)  : -15dB */
+	/*     MCDRV_DNG_TARGET_18   (4)  : -18dB */
+	/*     MCDRV_DNG_TARGET_MUTE (5)  : Mute  */
+	{MCDRV_DNG_TARGET_MUTE, MCDRV_DNG_TARGET_MUTE, MCDRV_DNG_TARGET_MUTE},
+};
+#if 0
+static const MCDRV_DNG_INFO stDngInfo_Default = {
+	/* bOnOff : Digital Noise Gate On/Off Setting */
+	/*     MCDRV_DNG_OFF(0)  : OFF                */
+	/*     MCDRV_DNG_ON (1)  : ON                 */
+	MCDRV_DNG_OFF,
+
+	/* bThreshold : Threshold Setting    */
+	/*     MCDRV_DNG_THRES_5BIT  (0) */
+	/*     MCDRV_DNG_THRES_7BIT  (1) */
+	/*     MCDRV_DNG_THRES_9BIT  (2) */
+	/*     MCDRV_DNG_THRES_11BIT (3) */
+	/*     MCDRV_DNG_THRES_13BIT (4) */
+	/*     MCDRV_DNG_THRES_15BIT (5) */
+	/*     MCDRV_DNG_THRES_17BIT (6) */
+	/*     MCDRV_DNG_THRES_21BIT (7) */
+	MCDRV_DNG_THRES_11BIT,
+
+	/* bHold : Hold Time Setting         */
+	/*     MCDRV_DNG_HOLD_30 (0)  :  30ms */
+	/*     MCDRV_DNG_HOLD_120(1)  : 120ms */
+	/*     MCDRV_DNG_HOLD_500(2)  : 500ms */
+	MCDRV_DNG_HOLD_500,
+
+	/* bAttack : Attack Time Setting        */
+	/*     MCDRV_DNG_ATTACK_25   (0)  :   25ms */
+	/*     MCDRV_DNG_ATTACK_800  (1)  :  800ms */
+	/*     MCDRV_DNG_ATTACK_1100 (2)  : 1100ms */
+	MCDRV_DNG_ATTACK_1100,
+
+	/* bRelease : Release Time Setting        */
+	/*     MCDRV_DNG_RELEASE_7950(0)  : 7.95ms */
+	/*     MCDRV_DNG_RELEASE_470 (1)  : 0.47ms */
+	/*     MCDRV_DNG_RELEASE_940 (2)  : 0.94ms */
+	MCDRV_DNG_RELEASE_940,
+
+};
+#endif
+
+/* ========================================
+   AudioEngine settings
+   ========================================*/
+static MCDRV_AE_INFO sAeInfo_1 = {
+	/* On/Off */
+	0x00,
+	/* BEX */
+	{
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
+	},
+	/* WIDE */
+	{
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00
+	},
+	/* DRC */
+	{
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
+	},
+	/* EQ5 */
+	{
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00
+	},
+	/* EQ3 */
+	{
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00
+	}
+};
+
+static MCDRV_AE_INFO sAeInfo_2 = {
+	/* On/Off */
+	0x00,
+	/* BEX */
+	{
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
+	},
+	/* WIDE */
+	{
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00
+	},
+	/* DRC */
+	{
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
+	},
+	/* EQ5 */
+	{
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00
+	},
+	/* EQ3 */
+	{
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00
+	}
+};
+
+static MCDRV_AE_INFO sAeInfo_3 = {
+	/* On/Off */
+	0x00,
+	/* BEX */
+	{
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
+	},
+	/* WIDE */
+	{
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00
+	},
+	/* DRC */
+	{
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
+	},
+	/* EQ5 */
+	{
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00
+	},
+	/* EQ3 */
+	{
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00
+	}
+};
+
+static MCDRV_AE_INFO sAeInfo_4 = {
+	/* On/Off */
+	0x00,
+	/* BEX */
+	{
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
+	},
+	/* WIDE */
+	{
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00
+	},
+	/* DRC */
+	{
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
+	},
+	/* EQ5 */
+	{
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00
+	},
+	/* EQ3 */
+	{
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00
+	}
+};
+
+static MCDRV_AE_INFO sAeInfo_5 = {
+	/* On/Off */
+	0x00,
+	/* BEX */
+	{
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
+	},
+	/* WIDE */
+	{
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00
+	},
+	/* DRC */
+	{
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
+	},
+	/* EQ5 */
+	{
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00
+	},
+	/* EQ3 */
+	{
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00
+	}
+};
+
+/* ========================================
+   System EQ settings
+   ========================================*/
+static MCDRV_SYSEQ_INFO stSyseqInfo_Default = {
+	/* On/Off */
+	0x00,
+	/* EQ */
+	{
+		0x10,0xc4,0x50,0x12,0xc4,0x40,0x02,0xa9,
+		0x60,0xed,0x3b,0xc0,0xfc,0x92,0x40,
+	},
+};
+
+#endif
diff --git a/sound/soc/codecs/mc1n2/mc1n2_cfg_gsm.h b/sound/soc/codecs/mc1n2/mc1n2_cfg_gsm.h
new file mode 100755
index 0000000..7ec50a7
--- /dev/null
+++ b/sound/soc/codecs/mc1n2/mc1n2_cfg_gsm.h
@@ -0,0 +1,1159 @@
+/*
+ * MC-1N2 ASoC codec driver
+ *
+ * Copyright (c) 2010 Yamaha Corporation
+ *
+ * This software is provided 'as-is', without any express or implied
+ * warranty.  In no event will the authors be held liable for any damages
+ * arising from the use of this software.
+ *
+ * Permission is granted to anyone to use this software for any purpose,
+ * including commercial applications, and to alter it and redistribute it
+ * freely, subject to the following restrictions:
+ *
+ * 1. The origin of this software must not be misrepresented; you must not
+ *    claim that you wrote the original software. If you use this software
+ *    in a product, an acknowledgment in the product documentation would be
+ *    appreciated but is not required.
+ * 2. Altered source versions must be plainly marked as such, and must not be
+ *    misrepresented as being the original software.
+ * 3. This notice may not be removed or altered from any source distribution.
+ */
+
+#ifndef MC1N2_CFG_H
+#define MC1N2_CFG_H
+
+#include "mcdriver.h"
+
+/*
+ * ALSA Version
+ */
+/* #define ALSA_VER_1_0_19 */
+/* #define ALSA_VER_1_0_21 */
+/* #define ALSA_VER_1_0_23 */
+#define ALSA_VER_ANDROID_3_0
+
+#define DIO0_DAI_ENABLE
+/* #define DIO1_DAI_ENABLE */
+/* #define DIO2_DAI_ENABLE */
+
+#ifdef ALSA_VER_ANDROID_3_0
+static struct mc1n2_setup mc1n2_cfg_setup = {
+	{							/* MCDRV_INIT_INFO */
+	 MCDRV_CKSEL_CMOS,			/* bCkSel */
+	 28,						/* bDivR0 20MHz *//* 28 for 24, 19 for 20 */
+	 86,						/* bDivF0 20MHz *//* 86 for 24, 70 for 20 */
+	 28,						/* bDivR1 */
+	 86,						/* bDivF1 */
+	 0,							/* bRange0 */
+	 0,							/* bRange1 */
+	 0,							/* bBypass */
+	 MCDRV_DAHIZ_LOW,			/* bDioSdo0Hiz */
+	 MCDRV_DAHIZ_LOW,			/* bDioSdo1Hiz */
+	 MCDRV_DAHIZ_LOW,			/* bDioSdo2Hiz */
+	 MCDRV_DAHIZ_HIZ,			/* bDioClk0Hiz */
+	 MCDRV_DAHIZ_HIZ,			/* bDioClk1Hiz */
+	 MCDRV_DAHIZ_HIZ,			/* bDioClk2Hiz */
+	 MCDRV_PCMHIZ_HIZ,			/* bPcmHiz */
+	 MCDRV_LINE_STEREO,			/* bLineIn1Dif */
+	 0,							/* bLineIn2Dif */
+	 MCDRV_LINE_STEREO,			/* bLineOut1Dif */
+	 MCDRV_LINE_STEREO,			/* bLineOUt2Dif */
+	 MCDRV_SPMN_ON,				/* bSpmn */
+	 MCDRV_MIC_DIF,				/* bMic1Sng */
+	 MCDRV_MIC_DIF,				/* bMic2Sng */
+	 MCDRV_MIC_DIF,				/* bMic3Sng */
+	 MCDRV_POWMODE_NORMAL,		/* bPowerMode */
+	 MCDRV_SPHIZ_PULLDOWN,		/* bSpHiz */
+	 MCDRV_LDO_ON,				/* bLdo */
+	 MCDRV_PAD_GPIO,			/* bPad0Func */
+	 MCDRV_PAD_GPIO,			/* bPad1Func */
+	 MCDRV_PAD_GPIO,			/* bPad2Func */
+	 MCDRV_OUTLEV_4,			/* bAvddLev */
+	 0,							/* bVrefLev */
+	 MCDRV_DCLGAIN_12,			/* bDclGain */
+	 MCDRV_DCLLIMIT_0,			/* bDclLimit */
+	 1,							/* set Hi-power mode 0: HP mode 1: normal */
+	 0,							/* bReserved1 */
+	 0,							/* bReserved2 */
+	 0,							/* bReserved3 */
+	 0,							/* bReserved4 */
+	 0,							/* bReserved5 */
+	 {							/* sWaitTime */
+	  130000,					/* dAdHpf */
+	  25000,					/* dMic1Cin */
+	  25000,					/* dMic2Cin */
+	  25000,					/* dMic3Cin */
+	  25000,					/* dLine1Cin */
+	  25000,					/* dLine2Cin */
+	  5000,						/* dVrefRdy1 */
+	  15000,					/* dVrefRdy2 */
+	  9000,						/* dHpRdy */
+	  13000,					/* dSpRdy */
+	  0,						/* dPdm */
+	  1000,						/* dAnaRdyInterval */
+	  1000,						/* dSvolInterval */
+	  1000,						/* dAnaRdyTimeOut */
+	  1000						/* dSvolTimeOut */
+	  }
+	 },							/* MCDRV_INIT_INFO end */
+	{							/* pcm_extend */
+	 0, 0, 0},					/* pcm_extend end */
+	{							/* pcm_hiz_redge */
+	 MCDRV_PCMHIZTIM_FALLING, MCDRV_PCMHIZTIM_FALLING, MCDRV_PCMHIZTIM_FALLING},	/* pcm_hiz_redge end */
+	{							/* pcm_hperiod */
+	 1, 1, 1},					/* pcm_hperiod end */
+	{							/* slot */
+	 {{0, 1}, {0, 1} },
+	 {{0, 1}, {0, 1} },
+	 {{0, 1}, {0, 1} }
+	 },
+};
+#endif
+
+static const MCDRV_DIO_INFO stDioInfo_Default = {
+	{
+	 /* DIO port 0 */
+	 {
+	  /* sDioCommon */
+	  {
+	   /* bMasterSlave : Master / Slave Setting */
+	   /*     MCDRV_DIO_SLAVE (0)  : Slave      */
+	   /*     MCDRV_DIO_MASTER(1)  : Master     */
+	   MCDRV_DIO_MASTER,
+	   /* bAutoFs : Sampling frequency automatic measurement ON/OFF Setting in slave mode */
+	   /*     MCDRV_AUTOFS_OFF(0)  : OFF */
+	   /*     MCDRV_AUTOFS_ON (1)  : ON  */
+	   MCDRV_AUTOFS_ON,
+	   /* bFs : Sampling Rate Setting        */
+	   /*     MCDRV_FS_48000(0)  : 48kHz     */
+	   /*     MCDRV_FS_44100(1)  : 44.1kHz   */
+	   /*     MCDRV_FS_32000(2)  : 32kHz     */
+	   /*     MCDRV_FS_24000(4)  : 24kHz     */
+	   /*     MCDRV_FS_22050(5)  : 22.05kHz  */
+	   /*     MCDRV_FS_16000(6)  : 16kHz     */
+	   /*     MCDRV_FS_12000(8)  : 12kHz     */
+	   /*     MCDRV_FS_11025(9)  : 11.025kHz */
+	   /*     MCDRV_FS_8000 (10) : 8kHz      */
+	   MCDRV_FS_44100,
+	   /* bBckFs : Bit Clock Frequency Setting */
+	   /*     MCDRV_BCKFS_64 (0)  : LRCK x  64 */
+	   /*     MCDRV_BCKFS_48 (1)  : LRCK x  48 */
+	   /*     MCDRV_BCKFS_32 (2)  : LRCK x  32 */
+	   /*     MCDRV_BCKFS_512(4)  : LRCK x 512 */
+	   /*     MCDRV_BCKFS_256(5)  : LRCK x 256 */
+	   /*     MCDRV_BCKFS_128(6)  : LRCK x 128 */
+	   /*     MCDRV_BCKFS_16 (7)  : LRCK x  16 */
+	   MCDRV_BCKFS_32,
+	   /* bInterface : Interface Selection      */
+	   /*     MCDRV_DIO_DA (0)  : Digital Audio */
+	   /*     MCDRV_DIO_PCM(1)  : PCM           */
+	   MCDRV_DIO_DA,
+	   /* bBckInvert : Bit Clock Inversion Setting     */
+	   /*     MCDRV_BCLK_NORMAL(0)  : Normal Operation */
+	   /*     MCDRV_BCLK_INVERT(1)  : Clock Inverted   */
+	   MCDRV_BCLK_NORMAL,
+	   /* bPcmHizTim : High Impedance transition timing after transmitting the last PCM I/F data */
+	   /*     MCDRV_PCMHIZTIM_FALLING(0)  : BCLK#* Falling Edge */
+	   /*     MCDRV_PCMHIZTIM_RISING (1)  : BCLK#* Rising Edge  */
+	   MCDRV_PCMHIZTIM_FALLING,
+	   /* bPcmClkDown : Bit Clock Setting with PCM selected and Master selected                */
+	   /*     MCDRV_PCM_CLKDOWN_OFF (0)  : A bit clock value specified with bBckFs             */
+	   /*     MCDRV_PCM_CLKDOWN_HALF(1)  : A half of the bit clock value specified with bBckFs */
+	   MCDRV_PCM_CLKDOWN_OFF,
+	   /* bPcmFrame : Frame Mode Setting with PCM interface */
+	   /*     MCDRV_PCM_SHORTFRAME(0)  : Short Frame        */
+	   /*     MCDRV_PCM_LONGFRAME (1)  : Long Frame         */
+	   MCDRV_PCM_SHORTFRAME,
+	   /* bPcmHighPeriod : LR clock High time setting with PCM selected and Master selected */
+	   /*     0 to 31  : High level keeps during the period of time of         */
+	   /*                (setting value + 1) of the bit clock.                 */
+	   0,
+	   },
+	  /* sDir       */
+	  {
+	   /* wSrcRate : Sampling Rate Converter Setting */
+	   0,
+	   /* sDaFormat : Digital Audio Format Information */
+	   {
+		/* bBitSel : Bit Width Setting     */
+		/*     MCDRV_BITSEL_16(0)  : 16bit */
+		/*     MCDRV_BITSEL_20(1)  : 20bit */
+		/*     MCDRV_BITSEL_24(2)  : 24bit */
+		MCDRV_BITSEL_16,
+		/* bMode : Data Format Setting                             */
+		/*     MCDRV_DAMODE_HEADALIGN(0)  : Left-justified Format  */
+		/*     MCDRV_DAMODE_I2S      (1)  : I2S                    */
+		/*     MCDRV_DAMODE_TAILALIGN(2)  : Right-justified Format */
+		MCDRV_DAMODE_I2S},
+	   /* sPcmFormat : PCM Format Information */
+	   {
+		/* bMono : Mono / Stereo Setting  */
+		/*     MCDRV_PCM_STEREO(0) Stereo */
+		/*     MCDRV_PCM_MONO  (1) Mono   */
+		MCDRV_PCM_MONO,
+		/* bOrder : Bit Order Setting                                     */
+		/*     MCDRV_PCM_MSB_FIRST      (0)  : MSB First                  */
+		/*     MCDRV_PCM_LSB_FIRST      (1)  : LSB First                  */
+		/*     MCDRV_PCM_MSB_FIRST_SIGN (2)  : MSB First (Sign Extension) */
+		/*     MCDRV_PCM_LSB_FIRST_SIGN (3)  : LSB First (Sign Extension) */
+		/*     MCDRV_PCM_MSB_FIRST_ZERO (4)  : MSB First (Zeros Padding)  */
+		/*     MCDRV_PCM_LSB_FIRST_ZERO (5)  : LSB First (Zeros Padding)  */
+		MCDRV_PCM_MSB_FIRST,
+		/* bLaw : Data Format Setting        */
+		/*     MCDRV_PCM_LINEAR(0)  : Linear */
+		/*     MCDRV_PCM_ALAW  (1)  : A-Law  */
+		/*     MCDRV_PCM_MULAW (2)  : u-Law */
+		MCDRV_PCM_LINEAR,
+		/* bBitSel : Bit Width Setting        */
+		/*     MCDRV_PCM_BITSEL_8 (0)  8 bits */
+		/*     MCDRV_PCM_BITSEL_13(1) 13 bits */
+		/*     MCDRV_PCM_BITSEL_14(2) 14 bits */
+		/*     MCDRV_PCM_BITSEL_16(3) 16 bits */
+		MCDRV_PCM_BITSEL_8},
+	   /* asSlot : Setting of a slot number of data to be fed to each channel */
+	   {0, 1}
+	   },
+	  /* sDit       */
+	  {
+	   /* wSrcRate : Sampling Rate Converter Setting */
+	   0,
+	   /* sDaFormat : Digital Audio Format Information */
+	   {
+		/* bBitSel : Bit Width Setting     */
+		/*     MCDRV_BITSEL_16(0)  : 16bit */
+		/*     MCDRV_BITSEL_20(1)  : 20bit */
+		/*     MCDRV_BITSEL_24(2)  : 24bit */
+		MCDRV_BITSEL_16,
+		/* bMode : Data Format Setting                             */
+		/*     MCDRV_DAMODE_HEADALIGN(0)  : Left-justified Format  */
+		/*     MCDRV_DAMODE_I2S      (1)  : I2S                    */
+		/*     MCDRV_DAMODE_TAILALIGN(2)  : Right-justified Format */
+		MCDRV_DAMODE_I2S},
+	   /* sPcmFormat : PCM Format Information */
+	   {
+		/* bMono : Mono / Stereo Setting  */
+		/*     MCDRV_PCM_STEREO(0) Stereo */
+		/*     MCDRV_PCM_MONO  (1) Mono   */
+		MCDRV_PCM_MONO,
+		/* bOrder : Bit Order Setting                                     */
+		/*     MCDRV_PCM_MSB_FIRST      (0)  : MSB First                  */
+		/*     MCDRV_PCM_LSB_FIRST      (1)  : LSB First                  */
+		/*     MCDRV_PCM_MSB_FIRST_SIGN (2)  : MSB First (Sign Extension) */
+		/*     MCDRV_PCM_LSB_FIRST_SIGN (3)  : LSB First (Sign Extension) */
+		/*     MCDRV_PCM_MSB_FIRST_ZERO (4)  : MSB First (Zeros Padding)  */
+		/*     MCDRV_PCM_LSB_FIRST_ZERO (5)  : LSB First (Zeros Padding)  */
+		MCDRV_PCM_MSB_FIRST,
+		/* bLaw : Data Format Setting        */
+		/*     MCDRV_PCM_LINEAR(0)  : Linear */
+		/*     MCDRV_PCM_ALAW  (1)  : A-Law  */
+		/*     MCDRV_PCM_MULAW (2)  : u-Law */
+		MCDRV_PCM_LINEAR,
+		/* bBitSel : Bit Width Setting        */
+		/*     MCDRV_PCM_BITSEL_8 (0)  8 bits */
+		/*     MCDRV_PCM_BITSEL_13(1) 13 bits */
+		/*     MCDRV_PCM_BITSEL_14(2) 14 bits */
+		/*     MCDRV_PCM_BITSEL_16(3) 16 bits */
+		MCDRV_PCM_BITSEL_8},
+	   /* asSlot Setting of a slot number of data to be transmitted from each channel */
+	   {0, 1}
+	   }
+	  },
+	 /* DIO port 1 */
+	 {
+	  /* sDioCommon */
+	  {
+	   /* bMasterSlave : Master / Slave Setting */
+	   /*     MCDRV_DIO_SLAVE (0)  : Slave      */
+	   /*     MCDRV_DIO_MASTER(1)  : Master     */
+	   MCDRV_DIO_MASTER,
+	   /* bAutoFs : Sampling frequency automatic measurement ON/OFF Setting in slave mode */
+	   /*     MCDRV_AUTOFS_OFF(0)  : OFF */
+	   /*     MCDRV_AUTOFS_ON (1)  : ON  */
+	   MCDRV_AUTOFS_ON,
+	   /* bFs : Sampling Rate Setting        */
+	   /*     MCDRV_FS_48000(0)  : 48kHz     */
+	   /*     MCDRV_FS_44100(1)  : 44.1kHz   */
+	   /*     MCDRV_FS_32000(2)  : 32kHz     */
+	   /*     MCDRV_FS_24000(4)  : 24kHz     */
+	   /*     MCDRV_FS_22050(5)  : 22.05kHz  */
+	   /*     MCDRV_FS_16000(6)  : 16kHz     */
+	   /*     MCDRV_FS_12000(8)  : 12kHz     */
+	   /*     MCDRV_FS_11025(9)  : 11.025kHz */
+	   /*     MCDRV_FS_8000 (10) : 8kHz      */
+	   MCDRV_FS_16000,
+	   /* bBckFs : Bit Clock Frequency Setting */
+	   /*     MCDRV_BCKFS_64 (0)  : LRCK x  64 */
+	   /*     MCDRV_BCKFS_48 (1)  : LRCK x  48 */
+	   /*     MCDRV_BCKFS_32 (2)  : LRCK x  32 */
+	   /*     MCDRV_BCKFS_512(4)  : LRCK x 512 */
+	   /*     MCDRV_BCKFS_256(5)  : LRCK x 256 */
+	   /*     MCDRV_BCKFS_128(6)  : LRCK x 128 */
+	   /*     MCDRV_BCKFS_16 (7)  : LRCK x  16 */
+	   MCDRV_BCKFS_32,
+	   /* bInterface : Interface Selection      */
+	   /*     MCDRV_DIO_DA (0)  : Digital Audio */
+	   /*     MCDRV_DIO_PCM(1)  : PCM           */
+	   MCDRV_DIO_DA,
+	   /* bBckInvert : Bit Clock Inversion Setting     */
+	   /*     MCDRV_BCLK_NORMAL(0)  : Normal Operation */
+	   /*     MCDRV_BCLK_INVERT(1)  : Clock Inverted   */
+	   MCDRV_BCLK_NORMAL,
+	   /* bPcmHizTim : High Impedance transition timing after transmitting the last PCM I/F data */
+	   /*     MCDRV_PCMHIZTIM_FALLING(0)  : BCLK#* Falling Edge */
+	   /*     MCDRV_PCMHIZTIM_RISING (1)  : BCLK#* Rising Edge  */
+	   MCDRV_PCMHIZTIM_FALLING,
+	   /* bPcmClkDown : Bit Clock Setting with PCM selected and Master selected                */
+	   /*     MCDRV_PCM_CLKDOWN_OFF (0)  : A bit clock value specified with bBckFs             */
+	   /*     MCDRV_PCM_CLKDOWN_HALF(1)  : A half of the bit clock value specified with bBckFs */
+	   MCDRV_PCM_CLKDOWN_OFF,
+	   /* bPcmFrame : Frame Mode Setting with PCM interface */
+	   /*     MCDRV_PCM_SHORTFRAME(0)  : Short Frame        */
+	   /*     MCDRV_PCM_LONGFRAME (1)  : Long Frame         */
+	   MCDRV_PCM_SHORTFRAME,
+	   /* bPcmHighPeriod : LR clock High time setting with PCM selected and Master selected */
+	   /*     0 to 31  : High level keeps during the period of time of         */
+	   /*                (setting value + 1) of the bit clock.                 */
+	   0,
+	   },
+	  /* sDir       */
+	  {
+	   /* wSrcRate : Sampling Rate Converter Setting */
+	   0,
+	   /* sDaFormat : Digital Audio Format Information */
+	   {
+		/* bBitSel : Bit Width Setting     */
+		/*     MCDRV_BITSEL_16(0)  : 16bit */
+		/*     MCDRV_BITSEL_20(1)  : 20bit */
+		/*     MCDRV_BITSEL_24(2)  : 24bit */
+		MCDRV_BITSEL_16,
+		/* bMode : Data Format Setting                             */
+		/*     MCDRV_DAMODE_HEADALIGN(0)  : Left-justified Format  */
+		/*     MCDRV_DAMODE_I2S      (1)  : I2S                    */
+		/*     MCDRV_DAMODE_TAILALIGN(2)  : Right-justified Format */
+		MCDRV_DAMODE_I2S},
+	   /* sPcmFormat : PCM Format Information */
+	   {
+		/* bMono : Mono / Stereo Setting  */
+		/*     MCDRV_PCM_STEREO(0) Stereo */
+		/*     MCDRV_PCM_MONO  (1) Mono   */
+		MCDRV_PCM_STEREO,
+		/* bOrder : Bit Order Setting                                     */
+		/*     MCDRV_PCM_MSB_FIRST      (0)  : MSB First                  */
+		/*     MCDRV_PCM_LSB_FIRST      (1)  : LSB First                  */
+		/*     MCDRV_PCM_MSB_FIRST_SIGN (2)  : MSB First (Sign Extension) */
+		/*     MCDRV_PCM_LSB_FIRST_SIGN (3)  : LSB First (Sign Extension) */
+		/*     MCDRV_PCM_MSB_FIRST_ZERO (4)  : MSB First (Zeros Padding)  */
+		/*     MCDRV_PCM_LSB_FIRST_ZERO (5)  : LSB First (Zeros Padding)  */
+		MCDRV_PCM_MSB_FIRST,
+		/* bLaw : Data Format Setting        */
+		/*     MCDRV_PCM_LINEAR(0)  : Linear */
+		/*     MCDRV_PCM_ALAW  (1)  : A-Law  */
+		/*     MCDRV_PCM_MULAW (2)  : u-Law */
+		MCDRV_PCM_LINEAR,
+		/* bBitSel : Bit Width Setting        */
+		/*     MCDRV_PCM_BITSEL_8 (0)  8 bits */
+		/*     MCDRV_PCM_BITSEL_13(1) 13 bits */
+		/*     MCDRV_PCM_BITSEL_14(2) 14 bits */
+		/*     MCDRV_PCM_BITSEL_16(3) 16 bits */
+		MCDRV_PCM_BITSEL_16},
+	   /* asSlot : Setting of a slot number of data to be fed to each channel */
+	   {0, 0}
+	   },
+	  /* sDit       */
+	  {
+	   /* wSrcRate : Sampling Rate Converter Setting */
+	   0,
+	   /* sDaFormat : Digital Audio Format Information */
+	   {
+		/* bBitSel : Bit Width Setting     */
+		/*     MCDRV_BITSEL_16(0)  : 16bit */
+		/*     MCDRV_BITSEL_20(1)  : 20bit */
+		/*     MCDRV_BITSEL_24(2)  : 24bit */
+		MCDRV_BITSEL_16,
+		/* bMode : Data Format Setting                             */
+		/*     MCDRV_DAMODE_HEADALIGN(0)  : Left-justified Format  */
+		/*     MCDRV_DAMODE_I2S      (1)  : I2S                    */
+		/*     MCDRV_DAMODE_TAILALIGN(2)  : Right-justified Format */
+		MCDRV_DAMODE_I2S},
+	   /* sPcmFormat : PCM Format Information */
+	   {
+		/* bMono : Mono / Stereo Setting  */
+		/*     MCDRV_PCM_STEREO(0) Stereo */
+		/*     MCDRV_PCM_MONO  (1) Mono   */
+		MCDRV_PCM_STEREO,
+		/* bOrder : Bit Order Setting                                     */
+		/*     MCDRV_PCM_MSB_FIRST      (0)  : MSB First                  */
+		/*     MCDRV_PCM_LSB_FIRST      (1)  : LSB First                  */
+		/*     MCDRV_PCM_MSB_FIRST_SIGN (2)  : MSB First (Sign Extension) */
+		/*     MCDRV_PCM_LSB_FIRST_SIGN (3)  : LSB First (Sign Extension) */
+		/*     MCDRV_PCM_MSB_FIRST_ZERO (4)  : MSB First (Zeros Padding)  */
+		/*     MCDRV_PCM_LSB_FIRST_ZERO (5)  : LSB First (Zeros Padding)  */
+		MCDRV_PCM_MSB_FIRST,
+		/* bLaw : Data Format Setting        */
+		/*     MCDRV_PCM_LINEAR(0)  : Linear */
+		/*     MCDRV_PCM_ALAW  (1)  : A-Law  */
+		/*     MCDRV_PCM_MULAW (2)  : u-Law */
+		MCDRV_PCM_LINEAR,
+		/* bBitSel : Bit Width Setting        */
+		/*     MCDRV_PCM_BITSEL_8 (0)  8 bits */
+		/*     MCDRV_PCM_BITSEL_13(1) 13 bits */
+		/*     MCDRV_PCM_BITSEL_14(2) 14 bits */
+		/*     MCDRV_PCM_BITSEL_16(3) 16 bits */
+		MCDRV_PCM_BITSEL_16},
+	   /* asSlot Setting of a slot number of data to be transmitted from each channel */
+	   {1, 0}
+	   }
+	  },
+	 /* DIO port 2 */
+	 {
+	  /* sDioCommon */
+	  {
+	   /* bMasterSlave : Master / Slave Setting */
+	   /*     MCDRV_DIO_SLAVE (0)  : Slave      */
+	   /*     MCDRV_DIO_MASTER(1)  : Master     */
+	   MCDRV_DIO_MASTER,
+	   /* bAutoFs : Sampling frequency automatic measurement ON/OFF Setting in slave mode */
+	   /*     MCDRV_AUTOFS_OFF(0)  : OFF */
+	   /*     MCDRV_AUTOFS_ON (1)  : ON  */
+	   MCDRV_AUTOFS_ON,
+	   /* bFs : Sampling Rate Setting        */
+	   /*     MCDRV_FS_48000(0)  : 48kHz     */
+	   /*     MCDRV_FS_44100(1)  : 44.1kHz   */
+	   /*     MCDRV_FS_32000(2)  : 32kHz     */
+	   /*     MCDRV_FS_24000(4)  : 24kHz     */
+	   /*     MCDRV_FS_22050(5)  : 22.05kHz  */
+	   /*     MCDRV_FS_16000(6)  : 16kHz     */
+	   /*     MCDRV_FS_12000(8)  : 12kHz     */
+	   /*     MCDRV_FS_11025(9)  : 11.025kHz */
+	   /*     MCDRV_FS_8000 (10) : 8kHz      */
+	   MCDRV_FS_8000,
+	   /* bBckFs : Bit Clock Frequency Setting */
+	   /*     MCDRV_BCKFS_64 (0)  : LRCK x  64 */
+	   /*     MCDRV_BCKFS_48 (1)  : LRCK x  48 */
+	   /*     MCDRV_BCKFS_32 (2)  : LRCK x  32 */
+	   /*     MCDRV_BCKFS_512(4)  : LRCK x 512 */
+	   /*     MCDRV_BCKFS_256(5)  : LRCK x 256 */
+	   /*     MCDRV_BCKFS_128(6)  : LRCK x 128 */
+	   /*     MCDRV_BCKFS_16 (7)  : LRCK x  16 */
+	   MCDRV_BCKFS_32,
+	   /* bInterface : Interface Selection      */
+	   /*     MCDRV_DIO_DA (0)  : Digital Audio */
+	   /*     MCDRV_DIO_PCM(1)  : PCM           */
+	   MCDRV_DIO_PCM,
+	   /* bBckInvert : Bit Clock Inversion Setting     */
+	   /*     MCDRV_BCLK_NORMAL(0)  : Normal Operation */
+	   /*     MCDRV_BCLK_INVERT(1)  : Clock Inverted   */
+	   MCDRV_BCLK_NORMAL,
+	   /* bPcmHizTim : High Impedance transition timing after transmitting the last PCM I/F data */
+	   /*     MCDRV_PCMHIZTIM_FALLING(0)  : BCLK#* Falling Edge */
+	   /*     MCDRV_PCMHIZTIM_RISING (1)  : BCLK#* Rising Edge  */
+	   MCDRV_PCMHIZTIM_FALLING,
+	   /* bPcmClkDown : Bit Clock Setting with PCM selected and Master selected                */
+	   /*     MCDRV_PCM_CLKDOWN_OFF (0)  : A bit clock value specified with bBckFs             */
+	   /*     MCDRV_PCM_CLKDOWN_HALF(1)  : A half of the bit clock value specified with bBckFs */
+	   MCDRV_PCM_CLKDOWN_OFF,
+	   /* bPcmFrame : Frame Mode Setting with PCM interface */
+	   /*     MCDRV_PCM_SHORTFRAME(0)  : Short Frame        */
+	   /*     MCDRV_PCM_LONGFRAME (1)  : Long Frame         */
+	   MCDRV_PCM_SHORTFRAME,
+	   /* bPcmHighPeriod : LR clock High time setting with PCM selected and Master selected */
+	   /*     0 to 31  : High level keeps during the period of time of         */
+	   /*                (setting value + 1) of the bit clock.                 */
+	   0,
+	   },
+	  /* sDir       */
+	  {
+	   /* wSrcRate : Sampling Rate Converter Setting */
+	   0,
+	   /* sDaFormat : Digital Audio Format Information */
+	   {
+		/* bBitSel : Bit Width Setting     */
+		/*     MCDRV_BITSEL_16(0)  : 16bit */
+		/*     MCDRV_BITSEL_20(1)  : 20bit */
+		/*     MCDRV_BITSEL_24(2)  : 24bit */
+		MCDRV_BITSEL_16,
+		/* bMode : Data Format Setting                             */
+		/*     MCDRV_DAMODE_HEADALIGN(0)  : Left-justified Format  */
+		/*     MCDRV_DAMODE_I2S      (1)  : I2S                    */
+		/*     MCDRV_DAMODE_TAILALIGN(2)  : Right-justified Format */
+		MCDRV_DAMODE_HEADALIGN},
+	   /* sPcmFormat : PCM Format Information */
+	   {
+		/* bMono : Mono / Stereo Setting  */
+		/*     MCDRV_PCM_STEREO(0) Stereo */
+		/*     MCDRV_PCM_MONO  (1) Mono   */
+		MCDRV_PCM_STEREO,
+		/* bOrder : Bit Order Setting                                     */
+		/*     MCDRV_PCM_MSB_FIRST      (0)  : MSB First                  */
+		/*     MCDRV_PCM_LSB_FIRST      (1)  : LSB First                  */
+		/*     MCDRV_PCM_MSB_FIRST_SIGN (2)  : MSB First (Sign Extension) */
+		/*     MCDRV_PCM_LSB_FIRST_SIGN (3)  : LSB First (Sign Extension) */
+		/*     MCDRV_PCM_MSB_FIRST_ZERO (4)  : MSB First (Zeros Padding)  */
+		/*     MCDRV_PCM_LSB_FIRST_ZERO (5)  : LSB First (Zeros Padding)  */
+		MCDRV_PCM_MSB_FIRST,
+		/* bLaw : Data Format Setting        */
+		/*     MCDRV_PCM_LINEAR(0)  : Linear */
+		/*     MCDRV_PCM_ALAW  (1)  : A-Law  */
+		/*     MCDRV_PCM_MULAW (2)  : u-Law */
+		MCDRV_PCM_LINEAR,
+		/* bBitSel : Bit Width Setting        */
+		/*     MCDRV_PCM_BITSEL_8 (0)  8 bits */
+		/*     MCDRV_PCM_BITSEL_13(1) 13 bits */
+		/*     MCDRV_PCM_BITSEL_14(2) 14 bits */
+		/*     MCDRV_PCM_BITSEL_16(3) 16 bits */
+		MCDRV_PCM_BITSEL_16},
+	   /* asSlot : Setting of a slot number of data to be fed to each channel */
+	   {0, 0}
+	   },
+	  /* sDit       */
+	  {
+	   /* wSrcRate : Sampling Rate Converter Setting */
+	   0,
+	   /* sDaFormat : Digital Audio Format Information */
+	   {
+		/* bBitSel : Bit Width Setting     */
+		/*     MCDRV_BITSEL_16(0)  : 16bit */
+		/*     MCDRV_BITSEL_20(1)  : 20bit */
+		/*     MCDRV_BITSEL_24(2)  : 24bit */
+		MCDRV_BITSEL_16,
+		/* bMode : Data Format Setting                             */
+		/*     MCDRV_DAMODE_HEADALIGN(0)  : Left-justified Format  */
+		/*     MCDRV_DAMODE_I2S      (1)  : I2S                    */
+		/*     MCDRV_DAMODE_TAILALIGN(2)  : Right-justified Format */
+		MCDRV_DAMODE_HEADALIGN},
+	   /* sPcmFormat : PCM Format Information */
+	   {
+		/* bMono : Mono / Stereo Setting  */
+		/*     MCDRV_PCM_STEREO(0) Stereo */
+		/*     MCDRV_PCM_MONO  (1) Mono   */
+		MCDRV_PCM_MONO,
+		/* bOrder : Bit Order Setting                                     */
+		/*     MCDRV_PCM_MSB_FIRST      (0)  : MSB First                  */
+		/*     MCDRV_PCM_LSB_FIRST      (1)  : LSB First                  */
+		/*     MCDRV_PCM_MSB_FIRST_SIGN (2)  : MSB First (Sign Extension) */
+		/*     MCDRV_PCM_LSB_FIRST_SIGN (3)  : LSB First (Sign Extension) */
+		/*     MCDRV_PCM_MSB_FIRST_ZERO (4)  : MSB First (Zeros Padding)  */
+		/*     MCDRV_PCM_LSB_FIRST_ZERO (5)  : LSB First (Zeros Padding)  */
+		MCDRV_PCM_MSB_FIRST,
+		/* bLaw : Data Format Setting        */
+		/*     MCDRV_PCM_LINEAR(0)  : Linear */
+		/*     MCDRV_PCM_ALAW  (1)  : A-Law  */
+		/*     MCDRV_PCM_MULAW (2)  : u-Law */
+		MCDRV_PCM_LINEAR,
+		/* bBitSel : Bit Width Setting        */
+		/*     MCDRV_PCM_BITSEL_8 (0)  8 bits */
+		/*     MCDRV_PCM_BITSEL_13(1) 13 bits */
+		/*     MCDRV_PCM_BITSEL_14(2) 14 bits */
+		/*     MCDRV_PCM_BITSEL_16(3) 16 bits */
+		MCDRV_PCM_BITSEL_16},
+	   /* asSlot Setting of a slot number of data to be transmitted from each channel */
+	   {0, 1}
+	   }
+	  }
+	 }
+};
+
+/* ========================================
+   DAC settings
+   ========================================*/
+static const MCDRV_DAC_INFO stDacInfo_Default = {
+	/* bMasterSwap : DAC Master Path SWAP Setting                          */
+	/*     MCDRV_DSWAP_OFF      (0)  : No SWAP                             */
+	/*     MCDRV_DSWAP_SWAP     (1)  : SWAP                                */
+	/*     MCDRV_DSWAP_MUTE     (2)  : MUTE                                */
+	/*     MCDRV_DSWAP_RMVCENTER(3)  : Center Removed                      */
+	/*     MCDRV_DSWAP_MONO     (4)  : Mono                                */
+	/*     MCDRV_DSWAP_MONOHALF (5)  : Reserved (do not use this setting)  */
+	/*     MCDRV_DSWAP_BOTHL    (6)  : Lch data output in both Lch and Rch */
+	/*     MCDRV_DSWAP_BOTHR    (7)  : Rch data output in both Lch and Rch */
+	MCDRV_DSWAP_OFF,
+	/* bVoiceSwap : DAC Voice Path SWAP Setting                            */
+	/*     MCDRV_DSWAP_OFF      (0)  : No SWAP                             */
+	/*     MCDRV_DSWAP_SWAP     (1)  : SWAP                                */
+	/*     MCDRV_DSWAP_MUTE     (2)  : MUTE                                */
+	/*     MCDRV_DSWAP_RMVCENTER(3)  : Center Removed                      */
+	/*     MCDRV_DSWAP_MONO     (4)  : Mono (-6dB)                         */
+	/*     MCDRV_DSWAP_MONOHALF (5)  : Reserved (do not use this setting)  */
+	/*     MCDRV_DSWAP_BOTHL    (6)  : Lch data output in both Lch and Rch */
+	/*     MCDRV_DSWAP_BOTHR    (7)  : Rch data output in both Lch and Rch */
+	MCDRV_DSWAP_OFF,
+	/* bDcCut : HP, SP Protection DC-ct Filter Setting  */
+	/*     MCDRV_DCCUT_ON (0)  : DC-cut Filter ON       */
+	/*     MCDRV_DCCUT_OFF(1)  : DC-cut Filter OFF      */
+	MCDRV_DCCUT_ON
+};
+
+/* ========================================
+   ADC settings
+   ========================================*/
+
+static const MCDRV_ADC_INFO stAdcInfo_Default = {
+	/* bAgcAdjust : AGC Gain Control Range     */
+	/*     MCDRV_AGCADJ_24(0)  : -3dB to +24dB */
+	/*     MCDRV_AGCADJ_18(1)  : -3dB to +18dB */
+	/*     MCDRV_AGCADJ_12(2)  : -3dB to +12dB */
+	/*     MCDRV_AGCADJ_0 (3)  : -3dB to  +0dB */
+	MCDRV_AGCADJ_0,
+	/* bAgcOn : AGC ON/OFF Setting */
+	/*     MCDRV_AGC_OFF(0)  : OFF */
+	/*     MCDRV_AGC_ON (1)  : ON  */
+	MCDRV_AGC_OFF,
+	/* bMonot : Mono / Stereo Setting    */
+	/*     MCDRV_ADC_STEREO(0)  : Stereo */
+	/*     MCDRV_ADC_MONO  (1)  : Mono   */
+	MCDRV_ADC_STEREO
+};
+
+/* ========================================
+   SP settings
+   ========================================*/
+static const MCDRV_SP_INFO stSpInfo_Default = {
+	/* bSwap : Swap setting                */
+	/*     MCDRV_SPSWAP_OFF (0)  : No SWAP */
+	/*     MCDRV_SPSWAP_SWAP(1)  : SWAP    */
+	MCDRV_SPSWAP_OFF
+};
+
+/* ========================================
+   DNG settings
+   ========================================*/
+static const MCDRV_DNG_INFO stDngInfo_Default = {
+	/* bOnOff[] : Digital Noise Gate On/Off Setting */
+	/*     MCDRV_DNG_OFF(0)  : OFF                */
+	/*     MCDRV_DNG_ON (1)  : ON                 */
+	{MCDRV_DNG_OFF, MCDRV_DNG_OFF, MCDRV_DNG_OFF},
+
+	/* bThreshold[] : Threshold Setting    */
+	/*     MCDRV_DNG_THRES_30    (0) */
+	/*     MCDRV_DNG_THRES_36    (1) */
+	/*     MCDRV_DNG_THRES_42    (2) */
+	/*     MCDRV_DNG_THRES_48    (3) */
+	/*     MCDRV_DNG_THRES_54    (4) */
+	/*     MCDRV_DNG_THRES_60    (5) */
+	/*     MCDRV_DNG_THRES_66    (6) */
+	/*     MCDRV_DNG_THRES_72    (7) */
+	/*     MCDRV_DNG_THRES_78    (8) */
+	/*     MCDRV_DNG_THRES_84    (9) */
+	{MCDRV_DNG_THRES_60, MCDRV_DNG_THRES_60, MCDRV_DNG_THRES_60},
+
+	/* bHold[] : Hold Time Setting         */
+	/*     MCDRV_DNG_HOLD_30 (0)  :  30ms */
+	/*     MCDRV_DNG_HOLD_120(1)  : 120ms */
+	/*     MCDRV_DNG_HOLD_500(2)  : 500ms */
+	{MCDRV_DNG_HOLD_500, MCDRV_DNG_HOLD_500, MCDRV_DNG_HOLD_500},
+
+	/* bAttack[] : Attack Time Setting        */
+	/*     MCDRV_DNG_ATTACK_25   (0)  :   25ms */
+	/*     MCDRV_DNG_ATTACK_100  (1)  :  100ms */
+	/*     MCDRV_DNG_ATTACK_400  (2)  :  400ms */
+	/*     MCDRV_DNG_ATTACK_800  (3)  :  800ms */
+	{MCDRV_DNG_ATTACK_100, MCDRV_DNG_ATTACK_100, MCDRV_DNG_ATTACK_100},
+
+	/* bRelease[] : Release Time Setting        */
+	/*     MCDRV_DNG_RELEASE_7950(0)  : 7.95ms */
+	/*     MCDRV_DNG_RELEASE_470 (1)  : 0.47ms */
+	/*     MCDRV_DNG_RELEASE_940 (2)  : 0.94ms */
+	{MCDRV_DNG_RELEASE_940, MCDRV_DNG_RELEASE_940, MCDRV_DNG_RELEASE_940},
+
+	/* bTarget[] : Target Volume Setting        */
+	/*     MCDRV_DNG_TARGET_6    (0)  : -6dB  */
+	/*     MCDRV_DNG_TARGET_9    (1)  : -9dB  */
+	/*     MCDRV_DNG_TARGET_12   (2)  : -12dB */
+	/*     MCDRV_DNG_TARGET_15   (3)  : -15dB */
+	/*     MCDRV_DNG_TARGET_18   (4)  : -18dB */
+	/*     MCDRV_DNG_TARGET_MUTE (5)  : Mute  */
+	{MCDRV_DNG_TARGET_MUTE, MCDRV_DNG_TARGET_MUTE, MCDRV_DNG_TARGET_MUTE},
+};
+
+#if 0
+static const MCDRV_DNG_INFO stDngInfo_Default = {
+	/* bOnOff : Digital Noise Gate On/Off Setting */
+	/*     MCDRV_DNG_OFF(0)  : OFF                */
+	/*     MCDRV_DNG_ON (1)  : ON                 */
+	MCDRV_DNG_OFF,
+
+	/* bThreshold : Threshold Setting    */
+	/*     MCDRV_DNG_THRES_5BIT  (0) */
+	/*     MCDRV_DNG_THRES_7BIT  (1) */
+	/*     MCDRV_DNG_THRES_9BIT  (2) */
+	/*     MCDRV_DNG_THRES_11BIT (3) */
+	/*     MCDRV_DNG_THRES_13BIT (4) */
+	/*     MCDRV_DNG_THRES_15BIT (5) */
+	/*     MCDRV_DNG_THRES_17BIT (6) */
+	/*     MCDRV_DNG_THRES_21BIT (7) */
+	MCDRV_DNG_THRES_11BIT,
+
+	/* bHold : Hold Time Setting         */
+	/*     MCDRV_DNG_HOLD_30 (0)  :  30ms */
+	/*     MCDRV_DNG_HOLD_120(1)  : 120ms */
+	/*     MCDRV_DNG_HOLD_500(2)  : 500ms */
+	MCDRV_DNG_HOLD_500,
+
+	/* bAttack : Attack Time Setting        */
+	/*     MCDRV_DNG_ATTACK_25   (0)  :   25ms */
+	/*     MCDRV_DNG_ATTACK_800  (1)  :  800ms */
+	/*     MCDRV_DNG_ATTACK_1100 (2)  : 1100ms */
+	MCDRV_DNG_ATTACK_1100,
+
+	/* bRelease : Release Time Setting        */
+	/*     MCDRV_DNG_RELEASE_7950(0)  : 7.95ms */
+	/*     MCDRV_DNG_RELEASE_470 (1)  : 0.47ms */
+	/*     MCDRV_DNG_RELEASE_940 (2)  : 0.94ms */
+	MCDRV_DNG_RELEASE_940,
+
+};
+#endif
+
+/* ========================================
+   AudioEngine settings
+   ========================================*/
+static MCDRV_AE_INFO sAeInfo_1 = {
+	/* On/Off */
+	0x00,
+	/* BEX */
+	{
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
+	/* WIDE */
+	{
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00},
+	/* DRC */
+	{
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
+	/* EQ5 */
+	{
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00},
+	/* EQ3 */
+	{
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00}
+};
+
+static MCDRV_AE_INFO sAeInfo_2 = {
+	/* On/Off */
+	0x00,
+	/* BEX */
+	{
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
+	/* WIDE */
+	{
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00},
+	/* DRC */
+	{
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
+	/* EQ5 */
+	{
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00},
+	/* EQ3 */
+	{
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00}
+};
+
+static MCDRV_AE_INFO sAeInfo_3 = {
+	/* On/Off */
+	0x00,
+	/* BEX */
+	{
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
+	/* WIDE */
+	{
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00},
+	/* DRC */
+	{
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
+	/* EQ5 */
+	{
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00},
+	/* EQ3 */
+	{
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00}
+};
+
+static MCDRV_AE_INFO sAeInfo_4 = {
+	/* On/Off */
+	0x00,
+	/* BEX */
+	{
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
+	/* WIDE */
+	{
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00},
+	/* DRC */
+	{
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
+	/* EQ5 */
+	{
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00},
+	/* EQ3 */
+	{
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00}
+};
+
+static MCDRV_AE_INFO sAeInfo_5 = {
+	/* On/Off */
+	0x00,
+	/* BEX */
+	{
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
+	/* WIDE */
+	{
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00},
+	/* DRC */
+	{
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
+	/* EQ5 */
+	{
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00},
+	/* EQ3 */
+	{
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00}
+};
+
+/* ========================================
+   System EQ settings
+   ========================================*/
+static MCDRV_SYSEQ_INFO stSyseqInfo_Default = {
+	/* On/Off */
+	0x00,
+	/* EQ */
+	{
+	 0x10, 0xc4, 0x50, 0x12, 0xc4, 0x40, 0x02, 0xa9,
+	 0x60, 0xed, 0x3b, 0xc0, 0xfc, 0x92, 0x40,
+	 },
+};
+
+#endif
diff --git a/sound/soc/codecs/mc1n2/mc1n2_cfg_lgt.h b/sound/soc/codecs/mc1n2/mc1n2_cfg_lgt.h
new file mode 100644
index 0000000..b806d94
--- /dev/null
+++ b/sound/soc/codecs/mc1n2/mc1n2_cfg_lgt.h
@@ -0,0 +1,1199 @@
+/*
+ * MC-1N2 ASoC codec driver
+ *
+ * Copyright (c) 2010-2011 Yamaha Corporation
+ *
+ * This software is provided 'as-is', without any express or implied
+ * warranty.  In no event will the authors be held liable for any damages
+ * arising from the use of this software.
+ *
+ * Permission is granted to anyone to use this software for any purpose,
+ * including commercial applications, and to alter it and redistribute it
+ * freely, subject to the following restrictions:
+ *
+ * 1. The origin of this software must not be misrepresented; you must not
+ *    claim that you wrote the original software. If you use this software
+ *    in a product, an acknowledgment in the product documentation would be
+ *    appreciated but is not required.
+ * 2. Altered source versions must be plainly marked as such, and must not be
+ *    misrepresented as being the original software.
+ * 3. This notice may not be removed or altered from any source distribution.
+ */
+
+#ifndef MC1N2_CFG_H
+#define MC1N2_CFG_H
+
+#include "mcdriver.h"
+
+/*
+ * ALSA Version
+ */
+/* #define ALSA_VER_1_0_19 */
+/* #define ALSA_VER_1_0_21 */
+/* #define ALSA_VER_1_0_23 */
+/* #define ALSA_VER_ANDROID_2_6_35 */
+#define ALSA_VER_ANDROID_3_0
+
+#define DIO0_DAI_ENABLE
+/* #define DIO1_DAI_ENABLE */
+/* #define DIO2_DAI_ENABLE */
+
+#ifdef ALSA_VER_ANDROID_3_0
+static struct mc1n2_setup mc1n2_cfg_setup = {
+	{  /* MCDRV_INIT_INFO */
+		MCDRV_CKSEL_CMOS, /* bCkSel */
+		28,               /* bDivR0 20MHz*/ /* 28 for 24, 19 for 20 */
+		86,               /* bDivF0 20MHz*/ /* 86 for 24, 70 for 20 */
+		28,               /* bDivR1*/
+		86,               /* bDivF1*/
+		0,                /* bRange0*/
+		0,                /* bRange1*/
+		0,                /* bBypass*/
+		MCDRV_DAHIZ_LOW,  /* bDioSdo0Hiz */
+		MCDRV_DAHIZ_LOW,  /* bDioSdo1Hiz */
+		MCDRV_DAHIZ_LOW,  /* bDioSdo2Hiz */
+		MCDRV_DAHIZ_HIZ,  /* bDioClk0Hiz */
+		MCDRV_DAHIZ_HIZ,  /* bDioClk1Hiz */
+		MCDRV_DAHIZ_HIZ,  /* bDioClk2Hiz */
+		MCDRV_PCMHIZ_HIZ, /* bPcmHiz */
+		MCDRV_LINE_STEREO,/* bLineIn1Dif */
+		0,                /* bLineIn2Dif */
+		MCDRV_LINE_STEREO,/* bLineOut1Dif */
+		MCDRV_LINE_STEREO,/* bLineOUt2Dif */
+		MCDRV_SPMN_ON,    /* bSpmn */
+		MCDRV_MIC_DIF,    /* bMic1Sng */
+		MCDRV_MIC_DIF,    /* bMic2Sng */
+		MCDRV_MIC_DIF,    /* bMic3Sng */
+		MCDRV_POWMODE_NORMAL, /* bPowerMode */
+		MCDRV_SPHIZ_PULLDOWN, /* bSpHiz */
+		MCDRV_LDO_ON,     /* bLdo */
+		MCDRV_PAD_GPIO,   /* bPad0Func */
+		MCDRV_PAD_GPIO,   /* bPad1Func */
+		MCDRV_PAD_GPIO,   /* bPad2Func */
+		MCDRV_OUTLEV_4,   /* bAvddLev */
+		0,                /* bVrefLev */
+		MCDRV_DCLGAIN_12, /* bDclGain */
+		MCDRV_DCLLIMIT_0, /* bDclLimit */
+		1,                   /* set Hi-power mode 0: HP mode 1: normal */
+		0,                /* bReserved1 */
+		0,                /* bReserved2 */
+		0,                /* bReserved3 */
+		0,                /* bReserved4 */
+		0,                /* bReserved5 */
+		{                 /* sWaitTime */
+			130000,         /* dAdHpf */
+			25000,          /* dMic1Cin */
+			25000,          /* dMic2Cin */
+			25000,          /* dMic3Cin */
+			25000,          /* dLine1Cin */
+			25000,          /* dLine2Cin */
+			5000,           /* dVrefRdy1 */
+			15000,          /* dVrefRdy2 */
+			9000,           /* dHpRdy */
+			13000,          /* dSpRdy */
+			0,              /* dPdm */
+			1000,           /* dAnaRdyInterval */
+			1000,           /* dSvolInterval */
+			1000,           /* dAnaRdyTimeOut */
+			1000            /* dSvolTimeOut */
+		}
+	}, /* MCDRV_INIT_INFO end */
+	{  /* pcm_extend */
+		0, 0, 0
+	}, /* pcm_extend end */
+	{  /* pcm_hiz_redge */
+		MCDRV_PCMHIZTIM_FALLING, MCDRV_PCMHIZTIM_FALLING, MCDRV_PCMHIZTIM_FALLING
+	}, /* pcm_hiz_redge end */
+	{  /* pcm_hperiod */
+		1, 1, 1
+	}, /* pcm_hperiod end */
+	{  /* slot */
+		{ {0, 1}, {0, 1} },
+		{ {0, 1}, {0, 1} },
+		{ {0, 1}, {0, 1} }
+	},
+};
+#endif
+
+static const MCDRV_DIO_INFO stDioInfo_Default = {
+	{
+		/* DIO port 0 */
+		{
+			/* sDioCommon */
+			{
+				/* bMasterSlave : Master / Slave Setting */
+				/*     MCDRV_DIO_SLAVE (0)  : Slave      */
+				/*     MCDRV_DIO_MASTER(1)  : Master     */
+				MCDRV_DIO_MASTER,
+				/* bAutoFs : Sampling frequency automatic measurement ON/OFF Setting in slave mode */
+				/*     MCDRV_AUTOFS_OFF(0)  : OFF */
+				/*     MCDRV_AUTOFS_ON (1)  : ON  */
+				MCDRV_AUTOFS_ON ,
+				/* bFs : Sampling Rate Setting        */
+				/*     MCDRV_FS_48000(0)  : 48kHz     */
+				/*     MCDRV_FS_44100(1)  : 44.1kHz   */
+				/*     MCDRV_FS_32000(2)  : 32kHz     */
+				/*     MCDRV_FS_24000(4)  : 24kHz     */
+				/*     MCDRV_FS_22050(5)  : 22.05kHz  */
+				/*     MCDRV_FS_16000(6)  : 16kHz     */
+				/*     MCDRV_FS_12000(8)  : 12kHz     */
+				/*     MCDRV_FS_11025(9)  : 11.025kHz */
+				/*     MCDRV_FS_8000 (10) : 8kHz      */
+				MCDRV_FS_44100,
+				/* bBckFs : Bit Clock Frequency Setting */
+				/*     MCDRV_BCKFS_64 (0)  : LRCK x  64 */
+				/*     MCDRV_BCKFS_48 (1)  : LRCK x  48 */
+				/*     MCDRV_BCKFS_32 (2)  : LRCK x  32 */
+				/*     MCDRV_BCKFS_512(4)  : LRCK x 512 */
+				/*     MCDRV_BCKFS_256(5)  : LRCK x 256 */
+				/*     MCDRV_BCKFS_128(6)  : LRCK x 128 */
+				/*     MCDRV_BCKFS_16 (7)  : LRCK x  16 */
+				MCDRV_BCKFS_32,
+				/* bInterface : Interface Selection      */
+				/*     MCDRV_DIO_DA (0)  : Digital Audio */
+				/*     MCDRV_DIO_PCM(1)  : PCM           */
+				MCDRV_DIO_DA,
+				/* bBckInvert : Bit Clock Inversion Setting     */
+				/*     MCDRV_BCLK_NORMAL(0)  : Normal Operation */
+				/*     MCDRV_BCLK_INVERT(1)  : Clock Inverted   */
+				MCDRV_BCLK_NORMAL,
+				/* bPcmHizTim : High Impedance transition timing after transmitting the last PCM I/F data */
+				/*     MCDRV_PCMHIZTIM_FALLING(0)  : BCLK#* Falling Edge */
+				/*     MCDRV_PCMHIZTIM_RISING (1)  : BCLK#* Rising Edge  */
+				MCDRV_PCMHIZTIM_FALLING,
+				/* bPcmClkDown : Bit Clock Setting with PCM selected and Master selected                */
+				/*     MCDRV_PCM_CLKDOWN_OFF (0)  : A bit clock value specified with bBckFs             */
+				/*     MCDRV_PCM_CLKDOWN_HALF(1)  : A half of the bit clock value specified with bBckFs */
+				MCDRV_PCM_CLKDOWN_OFF,
+				/* bPcmFrame : Frame Mode Setting with PCM interface */
+				/*     MCDRV_PCM_SHORTFRAME(0)  : Short Frame        */
+				/*     MCDRV_PCM_LONGFRAME (1)  : Long Frame         */
+				MCDRV_PCM_SHORTFRAME,
+				/* bPcmHighPeriod : LR clock High time setting with PCM selected and Master selected */
+				/*     0 to 31  : High level keeps during the period of time of         */
+				/*                (setting value + 1) of the bit clock.                 */
+				0,
+			},
+			/* sDir       */
+			{
+				/* wSrcRate : Sampling Rate Converter Setting */
+				0,
+				/* sDaFormat : Digital Audio Format Information */
+				{
+					/* bBitSel : Bit Width Setting     */
+					/*     MCDRV_BITSEL_16(0)  : 16bit */
+					/*     MCDRV_BITSEL_20(1)  : 20bit */
+					/*     MCDRV_BITSEL_24(2)  : 24bit */
+					MCDRV_BITSEL_16,
+					/* bMode : Data Format Setting                             */
+					/*     MCDRV_DAMODE_HEADALIGN(0)  : Left-justified Format  */
+					/*     MCDRV_DAMODE_I2S      (1)  : I2S                    */
+					/*     MCDRV_DAMODE_TAILALIGN(2)  : Right-justified Format */
+					MCDRV_DAMODE_I2S
+				},
+				/* sPcmFormat : PCM Format Information */
+				{
+					/* bMono : Mono / Stereo Setting  */
+					/*     MCDRV_PCM_STEREO(0) Stereo */
+					/*     MCDRV_PCM_MONO  (1) Mono   */
+					MCDRV_PCM_MONO ,
+					/* bOrder : Bit Order Setting                                     */
+					/*     MCDRV_PCM_MSB_FIRST      (0)  : MSB First                  */
+					/*     MCDRV_PCM_LSB_FIRST      (1)  : LSB First                  */
+					/*     MCDRV_PCM_MSB_FIRST_SIGN (2)  : MSB First (Sign Extension) */
+					/*     MCDRV_PCM_LSB_FIRST_SIGN (3)  : LSB First (Sign Extension) */
+					/*     MCDRV_PCM_MSB_FIRST_ZERO (4)  : MSB First (Zeros Padding)  */
+					/*     MCDRV_PCM_LSB_FIRST_ZERO (5)  : LSB First (Zeros Padding)  */
+					MCDRV_PCM_MSB_FIRST,
+					/* bLaw : Data Format Setting        */
+					/*     MCDRV_PCM_LINEAR(0)  : Linear */
+					/*     MCDRV_PCM_ALAW  (1)  : A-Law  */
+					/*     MCDRV_PCM_MULAW (2)  : u-Law */
+					MCDRV_PCM_LINEAR,
+					/* bBitSel : Bit Width Setting        */
+					/*     MCDRV_PCM_BITSEL_8 (0)  8 bits */
+					/*     MCDRV_PCM_BITSEL_13(1) 13 bits */
+					/*     MCDRV_PCM_BITSEL_14(2) 14 bits */
+					/*     MCDRV_PCM_BITSEL_16(3) 16 bits */
+					MCDRV_PCM_BITSEL_8
+				},
+				/* asSlot : Setting of a slot number of data to be fed to each channel */
+				{0, 1}
+			},
+			/* sDit       */
+			{
+				/* wSrcRate : Sampling Rate Converter Setting */
+				0,
+				/* sDaFormat : Digital Audio Format Information */
+				{
+					/* bBitSel : Bit Width Setting     */
+					/*     MCDRV_BITSEL_16(0)  : 16bit */
+					/*     MCDRV_BITSEL_20(1)  : 20bit */
+					/*     MCDRV_BITSEL_24(2)  : 24bit */
+					MCDRV_BITSEL_16,
+					/* bMode : Data Format Setting                             */
+					/*     MCDRV_DAMODE_HEADALIGN(0)  : Left-justified Format  */
+					/*     MCDRV_DAMODE_I2S      (1)  : I2S                    */
+					/*     MCDRV_DAMODE_TAILALIGN(2)  : Right-justified Format */
+					MCDRV_DAMODE_I2S
+				},
+				/* sPcmFormat : PCM Format Information */
+				{
+					/* bMono : Mono / Stereo Setting  */
+					/*     MCDRV_PCM_STEREO(0) Stereo */
+					/*     MCDRV_PCM_MONO  (1) Mono   */
+					MCDRV_PCM_MONO ,
+					/* bOrder : Bit Order Setting                                     */
+					/*     MCDRV_PCM_MSB_FIRST      (0)  : MSB First                  */
+					/*     MCDRV_PCM_LSB_FIRST      (1)  : LSB First                  */
+					/*     MCDRV_PCM_MSB_FIRST_SIGN (2)  : MSB First (Sign Extension) */
+					/*     MCDRV_PCM_LSB_FIRST_SIGN (3)  : LSB First (Sign Extension) */
+					/*     MCDRV_PCM_MSB_FIRST_ZERO (4)  : MSB First (Zeros Padding)  */
+					/*     MCDRV_PCM_LSB_FIRST_ZERO (5)  : LSB First (Zeros Padding)  */
+					MCDRV_PCM_MSB_FIRST,
+					/* bLaw : Data Format Setting        */
+					/*     MCDRV_PCM_LINEAR(0)  : Linear */
+					/*     MCDRV_PCM_ALAW  (1)  : A-Law  */
+					/*     MCDRV_PCM_MULAW (2)  : u-Law */
+					MCDRV_PCM_LINEAR,
+					/* bBitSel : Bit Width Setting        */
+					/*     MCDRV_PCM_BITSEL_8 (0)  8 bits */
+					/*     MCDRV_PCM_BITSEL_13(1) 13 bits */
+					/*     MCDRV_PCM_BITSEL_14(2) 14 bits */
+					/*     MCDRV_PCM_BITSEL_16(3) 16 bits */
+					MCDRV_PCM_BITSEL_8
+				},
+				/* asSlot Setting of a slot number of data to be transmitted from each channel */
+				{0, 1}
+			}
+		},
+		/* DIO port 1 */
+		{
+			/* sDioCommon */
+			{
+				/* bMasterSlave : Master / Slave Setting */
+				/*     MCDRV_DIO_SLAVE (0)  : Slave      */
+				/*     MCDRV_DIO_MASTER(1)  : Master     */
+				MCDRV_DIO_SLAVE,
+				/* bAutoFs : Sampling frequency automatic measurement ON/OFF Setting in slave mode */
+				/*     MCDRV_AUTOFS_OFF(0)  : OFF */
+				/*     MCDRV_AUTOFS_ON (1)  : ON  */
+				MCDRV_AUTOFS_ON ,
+				/* bFs : Sampling Rate Setting        */
+				/*     MCDRV_FS_48000(0)  : 48kHz     */
+				/*     MCDRV_FS_44100(1)  : 44.1kHz   */
+				/*     MCDRV_FS_32000(2)  : 32kHz     */
+				/*     MCDRV_FS_24000(4)  : 24kHz     */
+				/*     MCDRV_FS_22050(5)  : 22.05kHz  */
+				/*     MCDRV_FS_16000(6)  : 16kHz     */
+				/*     MCDRV_FS_12000(8)  : 12kHz     */
+				/*     MCDRV_FS_11025(9)  : 11.025kHz */
+				/*     MCDRV_FS_8000 (10) : 8kHz      */
+				MCDRV_FS_8000,
+				/* bBckFs : Bit Clock Frequency Setting */
+				/*     MCDRV_BCKFS_64 (0)  : LRCK x  64 */
+				/*     MCDRV_BCKFS_48 (1)  : LRCK x  48 */
+				/*     MCDRV_BCKFS_32 (2)  : LRCK x  32 */
+				/*     MCDRV_BCKFS_512(4)  : LRCK x 512 */
+				/*     MCDRV_BCKFS_256(5)  : LRCK x 256 */
+				/*     MCDRV_BCKFS_128(6)  : LRCK x 128 */
+				/*     MCDRV_BCKFS_16 (7)  : LRCK x  16 */
+				MCDRV_BCKFS_32,
+				/* bInterface : Interface Selection      */
+				/*     MCDRV_DIO_DA (0)  : Digital Audio */
+				/*     MCDRV_DIO_PCM(1)  : PCM           */
+				MCDRV_DIO_PCM,
+				/* bBckInvert : Bit Clock Inversion Setting     */
+				/*     MCDRV_BCLK_NORMAL(0)  : Normal Operation */
+				/*     MCDRV_BCLK_INVERT(1)  : Clock Inverted   */
+				MCDRV_BCLK_NORMAL,
+				/* bPcmHizTim : High Impedance transition timing after transmitting the last PCM I/F data */
+				/*     MCDRV_PCMHIZTIM_FALLING(0)  : BCLK#* Falling Edge */
+				/*     MCDRV_PCMHIZTIM_RISING (1)  : BCLK#* Rising Edge  */
+				MCDRV_PCMHIZTIM_FALLING,
+				/* bPcmClkDown : Bit Clock Setting with PCM selected and Master selected                */
+				/*     MCDRV_PCM_CLKDOWN_OFF (0)  : A bit clock value specified with bBckFs             */
+				/*     MCDRV_PCM_CLKDOWN_HALF(1)  : A half of the bit clock value specified with bBckFs */
+				MCDRV_PCM_CLKDOWN_OFF,
+				/* bPcmFrame : Frame Mode Setting with PCM interface */
+				/*     MCDRV_PCM_SHORTFRAME(0)  : Short Frame        */
+				/*     MCDRV_PCM_LONGFRAME (1)  : Long Frame         */
+				MCDRV_PCM_SHORTFRAME,
+				/* bPcmHighPeriod : LR clock High time setting with PCM selected and Master selected */
+				/*     0 to 31  : High level keeps during the period of time of         */
+				/*                (setting value + 1) of the bit clock.                 */
+				0,
+			},
+			/* sDir       */
+			{
+				/* wSrcRate : Sampling Rate Converter Setting */
+				0,
+				/* sDaFormat : Digital Audio Format Information */
+				{
+					/* bBitSel : Bit Width Setting     */
+					/*     MCDRV_BITSEL_16(0)  : 16bit */
+					/*     MCDRV_BITSEL_20(1)  : 20bit */
+					/*     MCDRV_BITSEL_24(2)  : 24bit */
+					MCDRV_BITSEL_16,
+					/* bMode : Data Format Setting                             */
+					/*     MCDRV_DAMODE_HEADALIGN(0)  : Left-justified Format  */
+					/*     MCDRV_DAMODE_I2S      (1)  : I2S                    */
+					/*     MCDRV_DAMODE_TAILALIGN(2)  : Right-justified Format */
+					MCDRV_DAMODE_HEADALIGN
+				},
+				/* sPcmFormat : PCM Format Information */
+				{
+					/* bMono : Mono / Stereo Setting  */
+					/*     MCDRV_PCM_STEREO(0) Stereo */
+					/*     MCDRV_PCM_MONO  (1) Mono   */
+					MCDRV_PCM_STEREO ,
+					/* bOrder : Bit Order Setting                                     */
+					/*     MCDRV_PCM_MSB_FIRST      (0)  : MSB First                  */
+					/*     MCDRV_PCM_LSB_FIRST      (1)  : LSB First                  */
+					/*     MCDRV_PCM_MSB_FIRST_SIGN (2)  : MSB First (Sign Extension) */
+					/*     MCDRV_PCM_LSB_FIRST_SIGN (3)  : LSB First (Sign Extension) */
+					/*     MCDRV_PCM_MSB_FIRST_ZERO (4)  : MSB First (Zeros Padding)  */
+					/*     MCDRV_PCM_LSB_FIRST_ZERO (5)  : LSB First (Zeros Padding)  */
+					MCDRV_PCM_MSB_FIRST,
+					/* bLaw : Data Format Setting        */
+					/*     MCDRV_PCM_LINEAR(0)  : Linear */
+					/*     MCDRV_PCM_ALAW  (1)  : A-Law  */
+					/*     MCDRV_PCM_MULAW (2)  : u-Law */
+					MCDRV_PCM_LINEAR,
+					/* bBitSel : Bit Width Setting        */
+					/*     MCDRV_PCM_BITSEL_8 (0)  8 bits */
+					/*     MCDRV_PCM_BITSEL_13(1) 13 bits */
+					/*     MCDRV_PCM_BITSEL_14(2) 14 bits */
+					/*     MCDRV_PCM_BITSEL_16(3) 16 bits */
+					MCDRV_PCM_BITSEL_16
+				},
+				/* asSlot : Setting of a slot number of data to be fed to each channel */
+				{0, 0}
+			},
+			/* sDit       */
+			{
+				/* wSrcRate : Sampling Rate Converter Setting */
+				0,
+				/* sDaFormat : Digital Audio Format Information */
+				{
+					/* bBitSel : Bit Width Setting     */
+					/*     MCDRV_BITSEL_16(0)  : 16bit */
+					/*     MCDRV_BITSEL_20(1)  : 20bit */
+					/*     MCDRV_BITSEL_24(2)  : 24bit */
+					MCDRV_BITSEL_16,
+					/* bMode : Data Format Setting                             */
+					/*     MCDRV_DAMODE_HEADALIGN(0)  : Left-justified Format  */
+					/*     MCDRV_DAMODE_I2S      (1)  : I2S                    */
+					/*     MCDRV_DAMODE_TAILALIGN(2)  : Right-justified Format */
+					MCDRV_DAMODE_HEADALIGN
+				},
+				/* sPcmFormat : PCM Format Information */
+				{
+					/* bMono : Mono / Stereo Setting  */
+					/*     MCDRV_PCM_STEREO(0) Stereo */
+					/*     MCDRV_PCM_MONO  (1) Mono   */
+					MCDRV_PCM_STEREO ,
+					/* bOrder : Bit Order Setting                                     */
+					/*     MCDRV_PCM_MSB_FIRST      (0)  : MSB First                  */
+					/*     MCDRV_PCM_LSB_FIRST      (1)  : LSB First                  */
+					/*     MCDRV_PCM_MSB_FIRST_SIGN (2)  : MSB First (Sign Extension) */
+					/*     MCDRV_PCM_LSB_FIRST_SIGN (3)  : LSB First (Sign Extension) */
+					/*     MCDRV_PCM_MSB_FIRST_ZERO (4)  : MSB First (Zeros Padding)  */
+					/*     MCDRV_PCM_LSB_FIRST_ZERO (5)  : LSB First (Zeros Padding)  */
+					MCDRV_PCM_MSB_FIRST,
+					/* bLaw : Data Format Setting        */
+					/*     MCDRV_PCM_LINEAR(0)  : Linear */
+					/*     MCDRV_PCM_ALAW  (1)  : A-Law  */
+					/*     MCDRV_PCM_MULAW (2)  : u-Law */
+					MCDRV_PCM_LINEAR,
+					/* bBitSel : Bit Width Setting        */
+					/*     MCDRV_PCM_BITSEL_8 (0)  8 bits */
+					/*     MCDRV_PCM_BITSEL_13(1) 13 bits */
+					/*     MCDRV_PCM_BITSEL_14(2) 14 bits */
+					/*     MCDRV_PCM_BITSEL_16(3) 16 bits */
+					MCDRV_PCM_BITSEL_16
+				},
+				/* asSlot Setting of a slot number of data to be transmitted from each channel */
+				{0, 1}
+			}
+		},
+		/* DIO port 2 */
+		{
+			/* sDioCommon */
+			{
+				/* bMasterSlave : Master / Slave Setting */
+				/*     MCDRV_DIO_SLAVE (0)  : Slave      */
+				/*     MCDRV_DIO_MASTER(1)  : Master     */
+				MCDRV_DIO_MASTER,
+				/* bAutoFs : Sampling frequency automatic measurement ON/OFF Setting in slave mode */
+				/*     MCDRV_AUTOFS_OFF(0)  : OFF */
+				/*     MCDRV_AUTOFS_ON (1)  : ON  */
+				MCDRV_AUTOFS_ON ,
+				/* bFs : Sampling Rate Setting        */
+				/*     MCDRV_FS_48000(0)  : 48kHz     */
+				/*     MCDRV_FS_44100(1)  : 44.1kHz   */
+				/*     MCDRV_FS_32000(2)  : 32kHz     */
+				/*     MCDRV_FS_24000(4)  : 24kHz     */
+				/*     MCDRV_FS_22050(5)  : 22.05kHz  */
+				/*     MCDRV_FS_16000(6)  : 16kHz     */
+				/*     MCDRV_FS_12000(8)  : 12kHz     */
+				/*     MCDRV_FS_11025(9)  : 11.025kHz */
+				/*     MCDRV_FS_8000 (10) : 8kHz      */
+				MCDRV_FS_8000,
+				/* bBckFs : Bit Clock Frequency Setting */
+				/*     MCDRV_BCKFS_64 (0)  : LRCK x  64 */
+				/*     MCDRV_BCKFS_48 (1)  : LRCK x  48 */
+				/*     MCDRV_BCKFS_32 (2)  : LRCK x  32 */
+				/*     MCDRV_BCKFS_512(4)  : LRCK x 512 */
+				/*     MCDRV_BCKFS_256(5)  : LRCK x 256 */
+				/*     MCDRV_BCKFS_128(6)  : LRCK x 128 */
+				/*     MCDRV_BCKFS_16 (7)  : LRCK x  16 */
+				MCDRV_BCKFS_32,
+				/* bInterface : Interface Selection      */
+				/*     MCDRV_DIO_DA (0)  : Digital Audio */
+				/*     MCDRV_DIO_PCM(1)  : PCM           */
+				MCDRV_DIO_PCM,
+				/* bBckInvert : Bit Clock Inversion Setting     */
+				/*     MCDRV_BCLK_NORMAL(0)  : Normal Operation */
+				/*     MCDRV_BCLK_INVERT(1)  : Clock Inverted   */
+				MCDRV_BCLK_NORMAL,
+				/* bPcmHizTim : High Impedance transition timing after transmitting the last PCM I/F data */
+				/*     MCDRV_PCMHIZTIM_FALLING(0)  : BCLK#* Falling Edge */
+				/*     MCDRV_PCMHIZTIM_RISING (1)  : BCLK#* Rising Edge  */
+				MCDRV_PCMHIZTIM_FALLING,
+				/* bPcmClkDown : Bit Clock Setting with PCM selected and Master selected                */
+				/*     MCDRV_PCM_CLKDOWN_OFF (0)  : A bit clock value specified with bBckFs             */
+				/*     MCDRV_PCM_CLKDOWN_HALF(1)  : A half of the bit clock value specified with bBckFs */
+				MCDRV_PCM_CLKDOWN_OFF,
+				/* bPcmFrame : Frame Mode Setting with PCM interface */
+				/*     MCDRV_PCM_SHORTFRAME(0)  : Short Frame        */
+				/*     MCDRV_PCM_LONGFRAME (1)  : Long Frame         */
+				MCDRV_PCM_SHORTFRAME,
+				/* bPcmHighPeriod : LR clock High time setting with PCM selected and Master selected */
+				/*     0 to 31  : High level keeps during the period of time of         */
+				/*                (setting value + 1) of the bit clock.                 */
+				0,
+			},
+			/* sDir       */
+			{
+				/* wSrcRate : Sampling Rate Converter Setting */
+				0,
+				/* sDaFormat : Digital Audio Format Information */
+				{
+					/* bBitSel : Bit Width Setting     */
+					/*     MCDRV_BITSEL_16(0)  : 16bit */
+					/*     MCDRV_BITSEL_20(1)  : 20bit */
+					/*     MCDRV_BITSEL_24(2)  : 24bit */
+					MCDRV_BITSEL_16,
+					/* bMode : Data Format Setting                             */
+					/*     MCDRV_DAMODE_HEADALIGN(0)  : Left-justified Format  */
+					/*     MCDRV_DAMODE_I2S      (1)  : I2S                    */
+					/*     MCDRV_DAMODE_TAILALIGN(2)  : Right-justified Format */
+					MCDRV_DAMODE_HEADALIGN
+				},
+				/* sPcmFormat : PCM Format Information */
+				{
+					/* bMono : Mono / Stereo Setting  */
+					/*     MCDRV_PCM_STEREO(0) Stereo */
+					/*     MCDRV_PCM_MONO  (1) Mono   */
+					MCDRV_PCM_STEREO ,
+					/* bOrder : Bit Order Setting                                     */
+					/*     MCDRV_PCM_MSB_FIRST      (0)  : MSB First                  */
+					/*     MCDRV_PCM_LSB_FIRST      (1)  : LSB First                  */
+					/*     MCDRV_PCM_MSB_FIRST_SIGN (2)  : MSB First (Sign Extension) */
+					/*     MCDRV_PCM_LSB_FIRST_SIGN (3)  : LSB First (Sign Extension) */
+					/*     MCDRV_PCM_MSB_FIRST_ZERO (4)  : MSB First (Zeros Padding)  */
+					/*     MCDRV_PCM_LSB_FIRST_ZERO (5)  : LSB First (Zeros Padding)  */
+					MCDRV_PCM_MSB_FIRST,
+					/* bLaw : Data Format Setting        */
+					/*     MCDRV_PCM_LINEAR(0)  : Linear */
+					/*     MCDRV_PCM_ALAW  (1)  : A-Law  */
+					/*     MCDRV_PCM_MULAW (2)  : u-Law */
+					MCDRV_PCM_LINEAR,
+					/* bBitSel : Bit Width Setting        */
+					/*     MCDRV_PCM_BITSEL_8 (0)  8 bits */
+					/*     MCDRV_PCM_BITSEL_13(1) 13 bits */
+					/*     MCDRV_PCM_BITSEL_14(2) 14 bits */
+					/*     MCDRV_PCM_BITSEL_16(3) 16 bits */
+					MCDRV_PCM_BITSEL_16
+				},
+				/* asSlot : Setting of a slot number of data to be fed to each channel */
+				{0, 0}
+			},
+			/* sDit       */
+			{
+				/* wSrcRate : Sampling Rate Converter Setting */
+				0,
+				/* sDaFormat : Digital Audio Format Information */
+				{
+					/* bBitSel : Bit Width Setting     */
+					/*     MCDRV_BITSEL_16(0)  : 16bit */
+					/*     MCDRV_BITSEL_20(1)  : 20bit */
+					/*     MCDRV_BITSEL_24(2)  : 24bit */
+					MCDRV_BITSEL_16,
+					/* bMode : Data Format Setting                             */
+					/*     MCDRV_DAMODE_HEADALIGN(0)  : Left-justified Format  */
+					/*     MCDRV_DAMODE_I2S      (1)  : I2S                    */
+					/*     MCDRV_DAMODE_TAILALIGN(2)  : Right-justified Format */
+					MCDRV_DAMODE_HEADALIGN
+				},
+				/* sPcmFormat : PCM Format Information */
+				{
+					/* bMono : Mono / Stereo Setting  */
+					/*     MCDRV_PCM_STEREO(0) Stereo */
+					/*     MCDRV_PCM_MONO  (1) Mono   */
+					MCDRV_PCM_MONO ,
+					/* bOrder : Bit Order Setting                                     */
+					/*     MCDRV_PCM_MSB_FIRST      (0)  : MSB First                  */
+					/*     MCDRV_PCM_LSB_FIRST      (1)  : LSB First                  */
+					/*     MCDRV_PCM_MSB_FIRST_SIGN (2)  : MSB First (Sign Extension) */
+					/*     MCDRV_PCM_LSB_FIRST_SIGN (3)  : LSB First (Sign Extension) */
+					/*     MCDRV_PCM_MSB_FIRST_ZERO (4)  : MSB First (Zeros Padding)  */
+					/*     MCDRV_PCM_LSB_FIRST_ZERO (5)  : LSB First (Zeros Padding)  */
+					MCDRV_PCM_MSB_FIRST,
+					/* bLaw : Data Format Setting        */
+					/*     MCDRV_PCM_LINEAR(0)  : Linear */
+					/*     MCDRV_PCM_ALAW  (1)  : A-Law  */
+					/*     MCDRV_PCM_MULAW (2)  : u-Law */
+					MCDRV_PCM_LINEAR,
+					/* bBitSel : Bit Width Setting        */
+					/*     MCDRV_PCM_BITSEL_8 (0)  8 bits */
+					/*     MCDRV_PCM_BITSEL_13(1) 13 bits */
+					/*     MCDRV_PCM_BITSEL_14(2) 14 bits */
+					/*     MCDRV_PCM_BITSEL_16(3) 16 bits */
+					MCDRV_PCM_BITSEL_16
+				},
+				/* asSlot Setting of a slot number of data to be transmitted from each channel */
+				{0, 1}
+			}
+		}
+	}
+};
+
+/* ========================================
+   DAC settings
+   ========================================*/
+static const MCDRV_DAC_INFO stDacInfo_Default = {
+	/* bMasterSwap : DAC Master Path SWAP Setting                          */
+	/*     MCDRV_DSWAP_OFF      (0)  : No SWAP                             */
+	/*     MCDRV_DSWAP_SWAP     (1)  : SWAP                                */
+	/*     MCDRV_DSWAP_MUTE     (2)  : MUTE                                */
+	/*     MCDRV_DSWAP_RMVCENTER(3)  : Center Removed                      */
+	/*     MCDRV_DSWAP_MONO     (4)  : Mono                                */
+	/*     MCDRV_DSWAP_MONOHALF (5)  : Reserved (do not use this setting)  */
+	/*     MCDRV_DSWAP_BOTHL    (6)  : Lch data output in both Lch and Rch */
+	/*     MCDRV_DSWAP_BOTHR    (7)  : Rch data output in both Lch and Rch */
+	MCDRV_DSWAP_OFF,
+	/* bVoiceSwap : DAC Voice Path SWAP Setting                            */
+	/*     MCDRV_DSWAP_OFF      (0)  : No SWAP                             */
+	/*     MCDRV_DSWAP_SWAP     (1)  : SWAP                                */
+	/*     MCDRV_DSWAP_MUTE     (2)  : MUTE                                */
+	/*     MCDRV_DSWAP_RMVCENTER(3)  : Center Removed                      */
+	/*     MCDRV_DSWAP_MONO     (4)  : Mono (-6dB)                         */
+	/*     MCDRV_DSWAP_MONOHALF (5)  : Reserved (do not use this setting)  */
+	/*     MCDRV_DSWAP_BOTHL    (6)  : Lch data output in both Lch and Rch */
+	/*     MCDRV_DSWAP_BOTHR    (7)  : Rch data output in both Lch and Rch */
+	MCDRV_DSWAP_OFF,
+	/* bDcCut : HP, SP Protection DC-ct Filter Setting  */
+	/*     MCDRV_DCCUT_ON (0)  : DC-cut Filter ON       */
+	/*     MCDRV_DCCUT_OFF(1)  : DC-cut Filter OFF      */
+	MCDRV_DCCUT_ON
+};
+
+/* ========================================
+   ADC settings
+   ========================================*/
+
+static const MCDRV_ADC_INFO stAdcInfo_Default = {
+	/* bAgcAdjust : AGC Gain Control Range     */
+	/*     MCDRV_AGCADJ_24(0)  : -3dB to +24dB */
+	/*     MCDRV_AGCADJ_18(1)  : -3dB to +18dB */
+	/*     MCDRV_AGCADJ_12(2)  : -3dB to +12dB */
+	/*     MCDRV_AGCADJ_0 (3)  : -3dB to  +0dB */
+	MCDRV_AGCADJ_0,
+	/* bAgcOn : AGC ON/OFF Setting */
+	/*     MCDRV_AGC_OFF(0)  : OFF */
+	/*     MCDRV_AGC_ON (1)  : ON  */
+	MCDRV_AGC_OFF,
+	/* bMonot : Mono / Stereo Setting    */
+	/*     MCDRV_ADC_STEREO(0)  : Stereo */
+	/*     MCDRV_ADC_MONO  (1)  : Mono   */
+	MCDRV_ADC_STEREO
+};
+
+/* ========================================
+   SP settings
+   ========================================*/
+static const MCDRV_SP_INFO stSpInfo_Default = {
+	/* bSwap : Swap setting                */
+	/*     MCDRV_SPSWAP_OFF (0)  : No SWAP */
+	/*     MCDRV_SPSWAP_SWAP(1)  : SWAP    */
+	MCDRV_SPSWAP_OFF
+};
+
+/* ========================================
+   DNG settings
+   ========================================*/
+static const MCDRV_DNG_INFO stDngInfo_Default = {
+	/* bOnOff[] : Digital Noise Gate On/Off Setting */
+	/*     MCDRV_DNG_OFF(0)  : OFF                */
+	/*     MCDRV_DNG_ON (1)  : ON                 */
+	{MCDRV_DNG_OFF, MCDRV_DNG_OFF, MCDRV_DNG_OFF},
+
+	/* bThreshold[] : Threshold Setting    */
+	/*     MCDRV_DNG_THRES_30    (0) */
+	/*     MCDRV_DNG_THRES_36    (1) */
+	/*     MCDRV_DNG_THRES_42    (2) */
+	/*     MCDRV_DNG_THRES_48    (3) */
+	/*     MCDRV_DNG_THRES_54    (4) */
+	/*     MCDRV_DNG_THRES_60    (5) */
+	/*     MCDRV_DNG_THRES_66    (6) */
+	/*     MCDRV_DNG_THRES_72    (7) */
+	/*     MCDRV_DNG_THRES_78    (8) */
+	/*     MCDRV_DNG_THRES_84    (9) */
+	{MCDRV_DNG_THRES_60, MCDRV_DNG_THRES_60, MCDRV_DNG_THRES_60},
+
+	/* bHold[] : Hold Time Setting         */
+	/*     MCDRV_DNG_HOLD_30 (0)  :  30ms */
+	/*     MCDRV_DNG_HOLD_120(1)  : 120ms */
+	/*     MCDRV_DNG_HOLD_500(2)  : 500ms */
+	{MCDRV_DNG_HOLD_500, MCDRV_DNG_HOLD_500, MCDRV_DNG_HOLD_500},
+
+	/* bAttack[] : Attack Time Setting        */
+	/*     MCDRV_DNG_ATTACK_25   (0)  :   25ms */
+	/*     MCDRV_DNG_ATTACK_100  (1)  :  100ms */
+	/*     MCDRV_DNG_ATTACK_400  (2)  :  400ms */
+	/*     MCDRV_DNG_ATTACK_800  (3)  :  800ms */
+	{MCDRV_DNG_ATTACK_100, MCDRV_DNG_ATTACK_100, MCDRV_DNG_ATTACK_100},
+
+	/* bRelease[] : Release Time Setting        */
+	/*     MCDRV_DNG_RELEASE_7950(0)  : 7.95ms */
+	/*     MCDRV_DNG_RELEASE_470 (1)  : 0.47ms */
+	/*     MCDRV_DNG_RELEASE_940 (2)  : 0.94ms */
+	{MCDRV_DNG_RELEASE_940, MCDRV_DNG_RELEASE_940, MCDRV_DNG_RELEASE_940},
+
+	/* bTarget[] : Target Volume Setting        */
+	/*     MCDRV_DNG_TARGET_6    (0)  : -6dB  */
+	/*     MCDRV_DNG_TARGET_9    (1)  : -9dB  */
+	/*     MCDRV_DNG_TARGET_12   (2)  : -12dB */
+	/*     MCDRV_DNG_TARGET_15   (3)  : -15dB */
+	/*     MCDRV_DNG_TARGET_18   (4)  : -18dB */
+	/*     MCDRV_DNG_TARGET_MUTE (5)  : Mute  */
+	{MCDRV_DNG_TARGET_MUTE, MCDRV_DNG_TARGET_MUTE, MCDRV_DNG_TARGET_MUTE},
+};
+#if 0
+static const MCDRV_DNG_INFO stDngInfo_Default = {
+	/* bOnOff : Digital Noise Gate On/Off Setting */
+	/*     MCDRV_DNG_OFF(0)  : OFF                */
+	/*     MCDRV_DNG_ON (1)  : ON                 */
+	MCDRV_DNG_OFF,
+
+	/* bThreshold : Threshold Setting    */
+	/*     MCDRV_DNG_THRES_5BIT  (0) */
+	/*     MCDRV_DNG_THRES_7BIT  (1) */
+	/*     MCDRV_DNG_THRES_9BIT  (2) */
+	/*     MCDRV_DNG_THRES_11BIT (3) */
+	/*     MCDRV_DNG_THRES_13BIT (4) */
+	/*     MCDRV_DNG_THRES_15BIT (5) */
+	/*     MCDRV_DNG_THRES_17BIT (6) */
+	/*     MCDRV_DNG_THRES_21BIT (7) */
+	MCDRV_DNG_THRES_11BIT,
+
+	/* bHold : Hold Time Setting         */
+	/*     MCDRV_DNG_HOLD_30 (0)  :  30ms */
+	/*     MCDRV_DNG_HOLD_120(1)  : 120ms */
+	/*     MCDRV_DNG_HOLD_500(2)  : 500ms */
+	MCDRV_DNG_HOLD_500,
+
+	/* bAttack : Attack Time Setting        */
+	/*     MCDRV_DNG_ATTACK_25   (0)  :   25ms */
+	/*     MCDRV_DNG_ATTACK_800  (1)  :  800ms */
+	/*     MCDRV_DNG_ATTACK_1100 (2)  : 1100ms */
+	MCDRV_DNG_ATTACK_1100,
+
+	/* bRelease : Release Time Setting        */
+	/*     MCDRV_DNG_RELEASE_7950(0)  : 7.95ms */
+	/*     MCDRV_DNG_RELEASE_470 (1)  : 0.47ms */
+	/*     MCDRV_DNG_RELEASE_940 (2)  : 0.94ms */
+	MCDRV_DNG_RELEASE_940,
+
+};
+#endif
+
+/* ========================================
+   AudioEngine settings
+   ========================================*/
+static MCDRV_AE_INFO sAeInfo_1 = {
+	/* On/Off */
+	0x00,
+	/* BEX */
+	{
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
+	},
+	/* WIDE */
+	{
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00
+	},
+	/* DRC */
+	{
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
+	},
+	/* EQ5 */
+	{
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00
+	},
+	/* EQ3 */
+	{
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00
+	}
+};
+
+static MCDRV_AE_INFO sAeInfo_2 = {
+	/* On/Off */
+	0x00,
+	/* BEX */
+	{
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
+	},
+	/* WIDE */
+	{
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00
+	},
+	/* DRC */
+	{
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
+	},
+	/* EQ5 */
+	{
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00
+	},
+	/* EQ3 */
+	{
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00
+	}
+};
+
+static MCDRV_AE_INFO sAeInfo_3 = {
+	/* On/Off */
+	0x00,
+	/* BEX */
+	{
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
+	},
+	/* WIDE */
+	{
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00
+	},
+	/* DRC */
+	{
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
+	},
+	/* EQ5 */
+	{
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00
+	},
+	/* EQ3 */
+	{
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00
+	}
+};
+
+static MCDRV_AE_INFO sAeInfo_4 = {
+	/* On/Off */
+	0x00,
+	/* BEX */
+	{
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
+	},
+	/* WIDE */
+	{
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00
+	},
+	/* DRC */
+	{
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
+	},
+	/* EQ5 */
+	{
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00
+	},
+	/* EQ3 */
+	{
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00
+	}
+};
+
+static MCDRV_AE_INFO sAeInfo_5 = {
+	/* On/Off */
+	0x00,
+	/* BEX */
+	{
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
+	},
+	/* WIDE */
+	{
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00
+	},
+	/* DRC */
+	{
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
+	},
+	/* EQ5 */
+	{
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00
+	},
+	/* EQ3 */
+	{
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00
+	}
+};
+
+/* ========================================
+   System EQ settings
+   ========================================*/
+static MCDRV_SYSEQ_INFO stSyseqInfo_Default = {
+	/* On/Off */
+	0x00,
+	/* EQ */
+	{
+		0x10,0xc4,0x50,0x12,0xc4,0x40,0x02,0xa9,
+		0x60,0xed,0x3b,0xc0,0xfc,0x92,0x40,
+	},
+};
+
+#endif
diff --git a/sound/soc/codecs/mc1n2/mc1n2_cfg_px.h b/sound/soc/codecs/mc1n2/mc1n2_cfg_px.h
new file mode 100644
index 0000000..2d159af
--- /dev/null
+++ b/sound/soc/codecs/mc1n2/mc1n2_cfg_px.h
@@ -0,0 +1,1199 @@
+/*
+ * MC-1N2 ASoC codec driver
+ *
+ * Copyright (c) 2010-2011 Yamaha Corporation
+ *
+ * This software is provided 'as-is', without any express or implied
+ * warranty.  In no event will the authors be held liable for any damages
+ * arising from the use of this software.
+ *
+ * Permission is granted to anyone to use this software for any purpose,
+ * including commercial applications, and to alter it and redistribute it
+ * freely, subject to the following restrictions:
+ *
+ * 1. The origin of this software must not be misrepresented; you must not
+ *    claim that you wrote the original software. If you use this software
+ *    in a product, an acknowledgment in the product documentation would be
+ *    appreciated but is not required.
+ * 2. Altered source versions must be plainly marked as such, and must not be
+ *    misrepresented as being the original software.
+ * 3. This notice may not be removed or altered from any source distribution.
+ */
+
+#ifndef MC1N2_CFG_H
+#define MC1N2_CFG_H
+
+#include "mcdriver.h"
+
+/*
+ * ALSA Version
+ */
+/* #define ALSA_VER_1_0_19 */
+/* #define ALSA_VER_1_0_21 */
+/* #define ALSA_VER_1_0_23 */
+/* #define ALSA_VER_ANDROID_2_6_35 */
+#define ALSA_VER_ANDROID_3_0
+
+#define DIO0_DAI_ENABLE
+/* #define DIO1_DAI_ENABLE */
+/* #define DIO2_DAI_ENABLE */
+
+#ifdef ALSA_VER_ANDROID_3_0
+static struct mc1n2_setup mc1n2_cfg_setup = {
+	{  /* MCDRV_INIT_INFO */
+		MCDRV_CKSEL_CMOS, /* bCkSel */
+		41,               /* bDivR0 */
+		126,              /* bDivF0 */
+		41,               /* bDivR1 */
+		126,              /* bDivF1 */
+		0,                /* bRange0*/
+		0,                /* bRange1*/
+		0,                /* bBypass*/
+		MCDRV_DAHIZ_LOW,  /* bDioSdo0Hiz */
+		MCDRV_DAHIZ_LOW,  /* bDioSdo1Hiz */
+		MCDRV_DAHIZ_LOW,  /* bDioSdo2Hiz */
+		MCDRV_DAHIZ_HIZ,  /* bDioClk0Hiz */
+		MCDRV_DAHIZ_HIZ,  /* bDioClk1Hiz */
+		MCDRV_DAHIZ_HIZ,  /* bDioClk2Hiz */
+		MCDRV_PCMHIZ_HIZ, /* bPcmHiz */
+		MCDRV_LINE_STEREO,/* bLineIn1Dif */
+		0,                /* bLineIn2Dif */
+		MCDRV_LINE_STEREO,/* bLineOut1Dif */
+		MCDRV_LINE_STEREO,/* bLineOUt2Dif */
+		MCDRV_SPMN_ON,    /* bSpmn */
+		MCDRV_MIC_DIF,    /* bMic1Sng */
+		MCDRV_MIC_DIF,    /* bMic2Sng */
+		MCDRV_MIC_DIF,    /* bMic3Sng */
+		MCDRV_POWMODE_NORMAL, /* bPowerMode */
+		MCDRV_SPHIZ_PULLDOWN, /* bSpHiz */
+		MCDRV_LDO_ON,     /* bLdo */
+		MCDRV_PAD_GPIO,   /* bPad0Func */
+		MCDRV_PAD_GPIO,   /* bPad1Func */
+		MCDRV_PAD_GPIO,   /* bPad2Func */
+		MCDRV_OUTLEV_4,   /* bAvddLev */
+		0,                /* bVrefLev */
+		MCDRV_DCLGAIN_12, /* bDclGain */
+		MCDRV_DCLLIMIT_0, /* bDclLimit */
+		1,                   /* set Hi-power mode 0: HP mode 1: normal */
+		0,                /* bReserved1 */
+		0,                /* bReserved2 */
+		0,                /* bReserved3 */
+		0,                /* bReserved4 */
+		0,                /* bReserved5 */
+		{                 /* sWaitTime */
+			130000,         /* dAdHpf */
+			25000,          /* dMic1Cin */
+			25000,          /* dMic2Cin */
+			25000,          /* dMic3Cin */
+			25000,          /* dLine1Cin */
+			25000,          /* dLine2Cin */
+			5000,           /* dVrefRdy1 */
+			15000,          /* dVrefRdy2 */
+			9000,           /* dHpRdy */
+			13000,          /* dSpRdy */
+			0,              /* dPdm */
+			1000,           /* dAnaRdyInterval */
+			1000,           /* dSvolInterval */
+			1000,           /* dAnaRdyTimeOut */
+			1000            /* dSvolTimeOut */
+		}
+	}, /* MCDRV_INIT_INFO end */
+	{  /* pcm_extend */
+		0, 0, 0
+	}, /* pcm_extend end */
+	{  /* pcm_hiz_redge */
+		MCDRV_PCMHIZTIM_FALLING, MCDRV_PCMHIZTIM_FALLING, MCDRV_PCMHIZTIM_FALLING
+	}, /* pcm_hiz_redge end */
+	{  /* pcm_hperiod */
+		1, 1, 1
+	}, /* pcm_hperiod end */
+	{  /* slot */
+		{ {0, 1}, {0, 1} },
+		{ {0, 1}, {0, 1} },
+		{ {0, 1}, {0, 1} }
+	}  /* slot end */
+};
+#endif
+
+static const MCDRV_DIO_INFO stDioInfo_Default = {
+	{
+		/* DIO port 0 */
+		{
+			/* sDioCommon */
+			{
+				/* bMasterSlave : Master / Slave Setting */
+				/*     MCDRV_DIO_SLAVE (0)  : Slave      */
+				/*     MCDRV_DIO_MASTER(1)  : Master     */
+				MCDRV_DIO_MASTER,
+				/* bAutoFs : Sampling frequency automatic measurement ON/OFF Setting in slave mode */
+				/*     MCDRV_AUTOFS_OFF(0)  : OFF */
+				/*     MCDRV_AUTOFS_ON (1)  : ON  */
+				MCDRV_AUTOFS_ON ,
+				/* bFs : Sampling Rate Setting        */
+				/*     MCDRV_FS_48000(0)  : 48kHz     */
+				/*     MCDRV_FS_44100(1)  : 44.1kHz   */
+				/*     MCDRV_FS_32000(2)  : 32kHz     */
+				/*     MCDRV_FS_24000(4)  : 24kHz     */
+				/*     MCDRV_FS_22050(5)  : 22.05kHz  */
+				/*     MCDRV_FS_16000(6)  : 16kHz     */
+				/*     MCDRV_FS_12000(8)  : 12kHz     */
+				/*     MCDRV_FS_11025(9)  : 11.025kHz */
+				/*     MCDRV_FS_8000 (10) : 8kHz      */
+				MCDRV_FS_44100,
+				/* bBckFs : Bit Clock Frequency Setting */
+				/*     MCDRV_BCKFS_64 (0)  : LRCK x  64 */
+				/*     MCDRV_BCKFS_48 (1)  : LRCK x  48 */
+				/*     MCDRV_BCKFS_32 (2)  : LRCK x  32 */
+				/*     MCDRV_BCKFS_512(4)  : LRCK x 512 */
+				/*     MCDRV_BCKFS_256(5)  : LRCK x 256 */
+				/*     MCDRV_BCKFS_128(6)  : LRCK x 128 */
+				/*     MCDRV_BCKFS_16 (7)  : LRCK x  16 */
+				MCDRV_BCKFS_32,
+				/* bInterface : Interface Selection      */
+				/*     MCDRV_DIO_DA (0)  : Digital Audio */
+				/*     MCDRV_DIO_PCM(1)  : PCM           */
+				MCDRV_DIO_DA,
+				/* bBckInvert : Bit Clock Inversion Setting     */
+				/*     MCDRV_BCLK_NORMAL(0)  : Normal Operation */
+				/*     MCDRV_BCLK_INVERT(1)  : Clock Inverted   */
+				MCDRV_BCLK_NORMAL,
+				/* bPcmHizTim : High Impedance transition timing after transmitting the last PCM I/F data */
+				/*     MCDRV_PCMHIZTIM_FALLING(0)  : BCLK#* Falling Edge */
+				/*     MCDRV_PCMHIZTIM_RISING (1)  : BCLK#* Rising Edge  */
+				MCDRV_PCMHIZTIM_FALLING,
+				/* bPcmClkDown : Bit Clock Setting with PCM selected and Master selected                */
+				/*     MCDRV_PCM_CLKDOWN_OFF (0)  : A bit clock value specified with bBckFs             */
+				/*     MCDRV_PCM_CLKDOWN_HALF(1)  : A half of the bit clock value specified with bBckFs */
+				MCDRV_PCM_CLKDOWN_OFF,
+				/* bPcmFrame : Frame Mode Setting with PCM interface */
+				/*     MCDRV_PCM_SHORTFRAME(0)  : Short Frame        */
+				/*     MCDRV_PCM_LONGFRAME (1)  : Long Frame         */
+				MCDRV_PCM_SHORTFRAME,
+				/* bPcmHighPeriod : LR clock High time setting with PCM selected and Master selected */
+				/*     0 to 31  : High level keeps during the period of time of         */
+				/*                (setting value + 1) of the bit clock.                 */
+				0,
+			},
+			/* sDir       */
+			{
+				/* wSrcRate : Sampling Rate Converter Setting */
+				0,
+				/* sDaFormat : Digital Audio Format Information */
+				{
+					/* bBitSel : Bit Width Setting     */
+					/*     MCDRV_BITSEL_16(0)  : 16bit */
+					/*     MCDRV_BITSEL_20(1)  : 20bit */
+					/*     MCDRV_BITSEL_24(2)  : 24bit */
+					MCDRV_BITSEL_16,
+					/* bMode : Data Format Setting                             */
+					/*     MCDRV_DAMODE_HEADALIGN(0)  : Left-justified Format  */
+					/*     MCDRV_DAMODE_I2S      (1)  : I2S                    */
+					/*     MCDRV_DAMODE_TAILALIGN(2)  : Right-justified Format */
+					MCDRV_DAMODE_I2S
+				},
+				/* sPcmFormat : PCM Format Information */
+				{
+					/* bMono : Mono / Stereo Setting  */
+					/*     MCDRV_PCM_STEREO(0) Stereo */
+					/*     MCDRV_PCM_MONO  (1) Mono   */
+					MCDRV_PCM_MONO ,
+					/* bOrder : Bit Order Setting                                     */
+					/*     MCDRV_PCM_MSB_FIRST      (0)  : MSB First                  */
+					/*     MCDRV_PCM_LSB_FIRST      (1)  : LSB First                  */
+					/*     MCDRV_PCM_MSB_FIRST_SIGN (2)  : MSB First (Sign Extension) */
+					/*     MCDRV_PCM_LSB_FIRST_SIGN (3)  : LSB First (Sign Extension) */
+					/*     MCDRV_PCM_MSB_FIRST_ZERO (4)  : MSB First (Zeros Padding)  */
+					/*     MCDRV_PCM_LSB_FIRST_ZERO (5)  : LSB First (Zeros Padding)  */
+					MCDRV_PCM_MSB_FIRST,
+					/* bLaw : Data Format Setting        */
+					/*     MCDRV_PCM_LINEAR(0)  : Linear */
+					/*     MCDRV_PCM_ALAW  (1)  : A-Law  */
+					/*     MCDRV_PCM_MULAW (2)  : u-Law */
+					MCDRV_PCM_LINEAR,
+					/* bBitSel : Bit Width Setting        */
+					/*     MCDRV_PCM_BITSEL_8 (0)  8 bits */
+					/*     MCDRV_PCM_BITSEL_13(1) 13 bits */
+					/*     MCDRV_PCM_BITSEL_14(2) 14 bits */
+					/*     MCDRV_PCM_BITSEL_16(3) 16 bits */
+					MCDRV_PCM_BITSEL_8
+				},
+				/* asSlot : Setting of a slot number of data to be fed to each channel */
+				{0, 1}
+			},
+			/* sDit       */
+			{
+				/* wSrcRate : Sampling Rate Converter Setting */
+				0,
+				/* sDaFormat : Digital Audio Format Information */
+				{
+					/* bBitSel : Bit Width Setting     */
+					/*     MCDRV_BITSEL_16(0)  : 16bit */
+					/*     MCDRV_BITSEL_20(1)  : 20bit */
+					/*     MCDRV_BITSEL_24(2)  : 24bit */
+					MCDRV_BITSEL_16,
+					/* bMode : Data Format Setting                             */
+					/*     MCDRV_DAMODE_HEADALIGN(0)  : Left-justified Format  */
+					/*     MCDRV_DAMODE_I2S      (1)  : I2S                    */
+					/*     MCDRV_DAMODE_TAILALIGN(2)  : Right-justified Format */
+					MCDRV_DAMODE_I2S
+				},
+				/* sPcmFormat : PCM Format Information */
+				{
+					/* bMono : Mono / Stereo Setting  */
+					/*     MCDRV_PCM_STEREO(0) Stereo */
+					/*     MCDRV_PCM_MONO  (1) Mono   */
+					MCDRV_PCM_MONO ,
+					/* bOrder : Bit Order Setting                                     */
+					/*     MCDRV_PCM_MSB_FIRST      (0)  : MSB First                  */
+					/*     MCDRV_PCM_LSB_FIRST      (1)  : LSB First                  */
+					/*     MCDRV_PCM_MSB_FIRST_SIGN (2)  : MSB First (Sign Extension) */
+					/*     MCDRV_PCM_LSB_FIRST_SIGN (3)  : LSB First (Sign Extension) */
+					/*     MCDRV_PCM_MSB_FIRST_ZERO (4)  : MSB First (Zeros Padding)  */
+					/*     MCDRV_PCM_LSB_FIRST_ZERO (5)  : LSB First (Zeros Padding)  */
+					MCDRV_PCM_MSB_FIRST,
+					/* bLaw : Data Format Setting        */
+					/*     MCDRV_PCM_LINEAR(0)  : Linear */
+					/*     MCDRV_PCM_ALAW  (1)  : A-Law  */
+					/*     MCDRV_PCM_MULAW (2)  : u-Law */
+					MCDRV_PCM_LINEAR,
+					/* bBitSel : Bit Width Setting        */
+					/*     MCDRV_PCM_BITSEL_8 (0)  8 bits */
+					/*     MCDRV_PCM_BITSEL_13(1) 13 bits */
+					/*     MCDRV_PCM_BITSEL_14(2) 14 bits */
+					/*     MCDRV_PCM_BITSEL_16(3) 16 bits */
+					MCDRV_PCM_BITSEL_8
+				},
+				/* asSlot Setting of a slot number of data to be transmitted from each channel */
+				{0, 1}
+			}
+		},
+		/* DIO port 1 */
+		{
+			/* sDioCommon */
+			{
+				/* bMasterSlave : Master / Slave Setting */
+				/*     MCDRV_DIO_SLAVE (0)  : Slave      */
+				/*     MCDRV_DIO_MASTER(1)  : Master     */
+				MCDRV_DIO_SLAVE,
+				/* bAutoFs : Sampling frequency automatic measurement ON/OFF Setting in slave mode */
+				/*     MCDRV_AUTOFS_OFF(0)  : OFF */
+				/*     MCDRV_AUTOFS_ON (1)  : ON  */
+				MCDRV_AUTOFS_ON ,
+				/* bFs : Sampling Rate Setting        */
+				/*     MCDRV_FS_48000(0)  : 48kHz     */
+				/*     MCDRV_FS_44100(1)  : 44.1kHz   */
+				/*     MCDRV_FS_32000(2)  : 32kHz     */
+				/*     MCDRV_FS_24000(4)  : 24kHz     */
+				/*     MCDRV_FS_22050(5)  : 22.05kHz  */
+				/*     MCDRV_FS_16000(6)  : 16kHz     */
+				/*     MCDRV_FS_12000(8)  : 12kHz     */
+				/*     MCDRV_FS_11025(9)  : 11.025kHz */
+				/*     MCDRV_FS_8000 (10) : 8kHz      */
+				MCDRV_FS_8000,
+				/* bBckFs : Bit Clock Frequency Setting */
+				/*     MCDRV_BCKFS_64 (0)  : LRCK x  64 */
+				/*     MCDRV_BCKFS_48 (1)  : LRCK x  48 */
+				/*     MCDRV_BCKFS_32 (2)  : LRCK x  32 */
+				/*     MCDRV_BCKFS_512(4)  : LRCK x 512 */
+				/*     MCDRV_BCKFS_256(5)  : LRCK x 256 */
+				/*     MCDRV_BCKFS_128(6)  : LRCK x 128 */
+				/*     MCDRV_BCKFS_16 (7)  : LRCK x  16 */
+				MCDRV_BCKFS_32,
+				/* bInterface : Interface Selection      */
+				/*     MCDRV_DIO_DA (0)  : Digital Audio */
+				/*     MCDRV_DIO_PCM(1)  : PCM           */
+				MCDRV_DIO_DA,
+				/* bBckInvert : Bit Clock Inversion Setting     */
+				/*     MCDRV_BCLK_NORMAL(0)  : Normal Operation */
+				/*     MCDRV_BCLK_INVERT(1)  : Clock Inverted   */
+				MCDRV_BCLK_NORMAL,
+				/* bPcmHizTim : High Impedance transition timing after transmitting the last PCM I/F data */
+				/*     MCDRV_PCMHIZTIM_FALLING(0)  : BCLK#* Falling Edge */
+				/*     MCDRV_PCMHIZTIM_RISING (1)  : BCLK#* Rising Edge  */
+				MCDRV_PCMHIZTIM_FALLING,
+				/* bPcmClkDown : Bit Clock Setting with PCM selected and Master selected                */
+				/*     MCDRV_PCM_CLKDOWN_OFF (0)  : A bit clock value specified with bBckFs             */
+				/*     MCDRV_PCM_CLKDOWN_HALF(1)  : A half of the bit clock value specified with bBckFs */
+				MCDRV_PCM_CLKDOWN_OFF,
+				/* bPcmFrame : Frame Mode Setting with PCM interface */
+				/*     MCDRV_PCM_SHORTFRAME(0)  : Short Frame        */
+				/*     MCDRV_PCM_LONGFRAME (1)  : Long Frame         */
+				MCDRV_PCM_SHORTFRAME,
+				/* bPcmHighPeriod : LR clock High time setting with PCM selected and Master selected */
+				/*     0 to 31  : High level keeps during the period of time of         */
+				/*                (setting value + 1) of the bit clock.                 */
+				0,
+			},
+			/* sDir       */
+			{
+				/* wSrcRate : Sampling Rate Converter Setting */
+				0,
+				/* sDaFormat : Digital Audio Format Information */
+				{
+					/* bBitSel : Bit Width Setting     */
+					/*     MCDRV_BITSEL_16(0)  : 16bit */
+					/*     MCDRV_BITSEL_20(1)  : 20bit */
+					/*     MCDRV_BITSEL_24(2)  : 24bit */
+					MCDRV_BITSEL_16,
+					/* bMode : Data Format Setting                             */
+					/*     MCDRV_DAMODE_HEADALIGN(0)  : Left-justified Format  */
+					/*     MCDRV_DAMODE_I2S      (1)  : I2S                    */
+					/*     MCDRV_DAMODE_TAILALIGN(2)  : Right-justified Format */
+					MCDRV_DAMODE_I2S
+				},
+				/* sPcmFormat : PCM Format Information */
+				{
+					/* bMono : Mono / Stereo Setting  */
+					/*     MCDRV_PCM_STEREO(0) Stereo */
+					/*     MCDRV_PCM_MONO  (1) Mono   */
+					MCDRV_PCM_STEREO ,
+					/* bOrder : Bit Order Setting                                     */
+					/*     MCDRV_PCM_MSB_FIRST      (0)  : MSB First                  */
+					/*     MCDRV_PCM_LSB_FIRST      (1)  : LSB First                  */
+					/*     MCDRV_PCM_MSB_FIRST_SIGN (2)  : MSB First (Sign Extension) */
+					/*     MCDRV_PCM_LSB_FIRST_SIGN (3)  : LSB First (Sign Extension) */
+					/*     MCDRV_PCM_MSB_FIRST_ZERO (4)  : MSB First (Zeros Padding)  */
+					/*     MCDRV_PCM_LSB_FIRST_ZERO (5)  : LSB First (Zeros Padding)  */
+					MCDRV_PCM_MSB_FIRST,
+					/* bLaw : Data Format Setting        */
+					/*     MCDRV_PCM_LINEAR(0)  : Linear */
+					/*     MCDRV_PCM_ALAW  (1)  : A-Law  */
+					/*     MCDRV_PCM_MULAW (2)  : u-Law */
+					MCDRV_PCM_LINEAR,
+					/* bBitSel : Bit Width Setting        */
+					/*     MCDRV_PCM_BITSEL_8 (0)  8 bits */
+					/*     MCDRV_PCM_BITSEL_13(1) 13 bits */
+					/*     MCDRV_PCM_BITSEL_14(2) 14 bits */
+					/*     MCDRV_PCM_BITSEL_16(3) 16 bits */
+					MCDRV_PCM_BITSEL_16
+				},
+				/* asSlot : Setting of a slot number of data to be fed to each channel */
+				{1, 1}
+			},
+			/* sDit       */
+			{
+				/* wSrcRate : Sampling Rate Converter Setting */
+				0,
+				/* sDaFormat : Digital Audio Format Information */
+				{
+					/* bBitSel : Bit Width Setting     */
+					/*     MCDRV_BITSEL_16(0)  : 16bit */
+					/*     MCDRV_BITSEL_20(1)  : 20bit */
+					/*     MCDRV_BITSEL_24(2)  : 24bit */
+					MCDRV_BITSEL_16,
+					/* bMode : Data Format Setting                             */
+					/*     MCDRV_DAMODE_HEADALIGN(0)  : Left-justified Format  */
+					/*     MCDRV_DAMODE_I2S      (1)  : I2S                    */
+					/*     MCDRV_DAMODE_TAILALIGN(2)  : Right-justified Format */
+					MCDRV_DAMODE_I2S
+				},
+				/* sPcmFormat : PCM Format Information */
+				{
+					/* bMono : Mono / Stereo Setting  */
+					/*     MCDRV_PCM_STEREO(0) Stereo */
+					/*     MCDRV_PCM_MONO  (1) Mono   */
+					MCDRV_PCM_STEREO ,
+					/* bOrder : Bit Order Setting                                     */
+					/*     MCDRV_PCM_MSB_FIRST      (0)  : MSB First                  */
+					/*     MCDRV_PCM_LSB_FIRST      (1)  : LSB First                  */
+					/*     MCDRV_PCM_MSB_FIRST_SIGN (2)  : MSB First (Sign Extension) */
+					/*     MCDRV_PCM_LSB_FIRST_SIGN (3)  : LSB First (Sign Extension) */
+					/*     MCDRV_PCM_MSB_FIRST_ZERO (4)  : MSB First (Zeros Padding)  */
+					/*     MCDRV_PCM_LSB_FIRST_ZERO (5)  : LSB First (Zeros Padding)  */
+					MCDRV_PCM_MSB_FIRST,
+					/* bLaw : Data Format Setting        */
+					/*     MCDRV_PCM_LINEAR(0)  : Linear */
+					/*     MCDRV_PCM_ALAW  (1)  : A-Law  */
+					/*     MCDRV_PCM_MULAW (2)  : u-Law */
+					MCDRV_PCM_LINEAR,
+					/* bBitSel : Bit Width Setting        */
+					/*     MCDRV_PCM_BITSEL_8 (0)  8 bits */
+					/*     MCDRV_PCM_BITSEL_13(1) 13 bits */
+					/*     MCDRV_PCM_BITSEL_14(2) 14 bits */
+					/*     MCDRV_PCM_BITSEL_16(3) 16 bits */
+					MCDRV_PCM_BITSEL_16
+				},
+				/* asSlot Setting of a slot number of data to be transmitted from each channel */
+				{1, 0}
+			}
+		},
+		/* DIO port 2 */
+		{
+			/* sDioCommon */
+			{
+				/* bMasterSlave : Master / Slave Setting */
+				/*     MCDRV_DIO_SLAVE (0)  : Slave      */
+				/*     MCDRV_DIO_MASTER(1)  : Master     */
+				MCDRV_DIO_MASTER,
+				/* bAutoFs : Sampling frequency automatic measurement ON/OFF Setting in slave mode */
+				/*     MCDRV_AUTOFS_OFF(0)  : OFF */
+				/*     MCDRV_AUTOFS_ON (1)  : ON  */
+				MCDRV_AUTOFS_ON ,
+				/* bFs : Sampling Rate Setting        */
+				/*     MCDRV_FS_48000(0)  : 48kHz     */
+				/*     MCDRV_FS_44100(1)  : 44.1kHz   */
+				/*     MCDRV_FS_32000(2)  : 32kHz     */
+				/*     MCDRV_FS_24000(4)  : 24kHz     */
+				/*     MCDRV_FS_22050(5)  : 22.05kHz  */
+				/*     MCDRV_FS_16000(6)  : 16kHz     */
+				/*     MCDRV_FS_12000(8)  : 12kHz     */
+				/*     MCDRV_FS_11025(9)  : 11.025kHz */
+				/*     MCDRV_FS_8000 (10) : 8kHz      */
+				MCDRV_FS_8000,
+				/* bBckFs : Bit Clock Frequency Setting */
+				/*     MCDRV_BCKFS_64 (0)  : LRCK x  64 */
+				/*     MCDRV_BCKFS_48 (1)  : LRCK x  48 */
+				/*     MCDRV_BCKFS_32 (2)  : LRCK x  32 */
+				/*     MCDRV_BCKFS_512(4)  : LRCK x 512 */
+				/*     MCDRV_BCKFS_256(5)  : LRCK x 256 */
+				/*     MCDRV_BCKFS_128(6)  : LRCK x 128 */
+				/*     MCDRV_BCKFS_16 (7)  : LRCK x  16 */
+				MCDRV_BCKFS_32,
+				/* bInterface : Interface Selection      */
+				/*     MCDRV_DIO_DA (0)  : Digital Audio */
+				/*     MCDRV_DIO_PCM(1)  : PCM           */
+				MCDRV_DIO_PCM,
+				/* bBckInvert : Bit Clock Inversion Setting     */
+				/*     MCDRV_BCLK_NORMAL(0)  : Normal Operation */
+				/*     MCDRV_BCLK_INVERT(1)  : Clock Inverted   */
+				MCDRV_BCLK_NORMAL,
+				/* bPcmHizTim : High Impedance transition timing after transmitting the last PCM I/F data */
+				/*     MCDRV_PCMHIZTIM_FALLING(0)  : BCLK#* Falling Edge */
+				/*     MCDRV_PCMHIZTIM_RISING (1)  : BCLK#* Rising Edge  */
+				MCDRV_PCMHIZTIM_FALLING,
+				/* bPcmClkDown : Bit Clock Setting with PCM selected and Master selected                */
+				/*     MCDRV_PCM_CLKDOWN_OFF (0)  : A bit clock value specified with bBckFs             */
+				/*     MCDRV_PCM_CLKDOWN_HALF(1)  : A half of the bit clock value specified with bBckFs */
+				MCDRV_PCM_CLKDOWN_OFF,
+				/* bPcmFrame : Frame Mode Setting with PCM interface */
+				/*     MCDRV_PCM_SHORTFRAME(0)  : Short Frame        */
+				/*     MCDRV_PCM_LONGFRAME (1)  : Long Frame         */
+				MCDRV_PCM_SHORTFRAME,
+				/* bPcmHighPeriod : LR clock High time setting with PCM selected and Master selected */
+				/*     0 to 31  : High level keeps during the period of time of         */
+				/*                (setting value + 1) of the bit clock.                 */
+				0,
+			},
+			/* sDir       */
+			{
+				/* wSrcRate : Sampling Rate Converter Setting */
+				0,
+				/* sDaFormat : Digital Audio Format Information */
+				{
+					/* bBitSel : Bit Width Setting     */
+					/*     MCDRV_BITSEL_16(0)  : 16bit */
+					/*     MCDRV_BITSEL_20(1)  : 20bit */
+					/*     MCDRV_BITSEL_24(2)  : 24bit */
+					MCDRV_BITSEL_16,
+					/* bMode : Data Format Setting                             */
+					/*     MCDRV_DAMODE_HEADALIGN(0)  : Left-justified Format  */
+					/*     MCDRV_DAMODE_I2S      (1)  : I2S                    */
+					/*     MCDRV_DAMODE_TAILALIGN(2)  : Right-justified Format */
+					MCDRV_DAMODE_HEADALIGN
+				},
+				/* sPcmFormat : PCM Format Information */
+				{
+					/* bMono : Mono / Stereo Setting  */
+					/*     MCDRV_PCM_STEREO(0) Stereo */
+					/*     MCDRV_PCM_MONO  (1) Mono   */
+					MCDRV_PCM_STEREO ,
+					/* bOrder : Bit Order Setting                                     */
+					/*     MCDRV_PCM_MSB_FIRST      (0)  : MSB First                  */
+					/*     MCDRV_PCM_LSB_FIRST      (1)  : LSB First                  */
+					/*     MCDRV_PCM_MSB_FIRST_SIGN (2)  : MSB First (Sign Extension) */
+					/*     MCDRV_PCM_LSB_FIRST_SIGN (3)  : LSB First (Sign Extension) */
+					/*     MCDRV_PCM_MSB_FIRST_ZERO (4)  : MSB First (Zeros Padding)  */
+					/*     MCDRV_PCM_LSB_FIRST_ZERO (5)  : LSB First (Zeros Padding)  */
+					MCDRV_PCM_MSB_FIRST,
+					/* bLaw : Data Format Setting        */
+					/*     MCDRV_PCM_LINEAR(0)  : Linear */
+					/*     MCDRV_PCM_ALAW  (1)  : A-Law  */
+					/*     MCDRV_PCM_MULAW (2)  : u-Law */
+					MCDRV_PCM_LINEAR,
+					/* bBitSel : Bit Width Setting        */
+					/*     MCDRV_PCM_BITSEL_8 (0)  8 bits */
+					/*     MCDRV_PCM_BITSEL_13(1) 13 bits */
+					/*     MCDRV_PCM_BITSEL_14(2) 14 bits */
+					/*     MCDRV_PCM_BITSEL_16(3) 16 bits */
+					MCDRV_PCM_BITSEL_16
+				},
+				/* asSlot : Setting of a slot number of data to be fed to each channel */
+				{0, 0}
+			},
+			/* sDit       */
+			{
+				/* wSrcRate : Sampling Rate Converter Setting */
+				0,
+				/* sDaFormat : Digital Audio Format Information */
+				{
+					/* bBitSel : Bit Width Setting     */
+					/*     MCDRV_BITSEL_16(0)  : 16bit */
+					/*     MCDRV_BITSEL_20(1)  : 20bit */
+					/*     MCDRV_BITSEL_24(2)  : 24bit */
+					MCDRV_BITSEL_16,
+					/* bMode : Data Format Setting                             */
+					/*     MCDRV_DAMODE_HEADALIGN(0)  : Left-justified Format  */
+					/*     MCDRV_DAMODE_I2S      (1)  : I2S                    */
+					/*     MCDRV_DAMODE_TAILALIGN(2)  : Right-justified Format */
+					MCDRV_DAMODE_HEADALIGN
+				},
+				/* sPcmFormat : PCM Format Information */
+				{
+					/* bMono : Mono / Stereo Setting  */
+					/*     MCDRV_PCM_STEREO(0) Stereo */
+					/*     MCDRV_PCM_MONO  (1) Mono   */
+					MCDRV_PCM_MONO ,
+					/* bOrder : Bit Order Setting                                     */
+					/*     MCDRV_PCM_MSB_FIRST      (0)  : MSB First                  */
+					/*     MCDRV_PCM_LSB_FIRST      (1)  : LSB First                  */
+					/*     MCDRV_PCM_MSB_FIRST_SIGN (2)  : MSB First (Sign Extension) */
+					/*     MCDRV_PCM_LSB_FIRST_SIGN (3)  : LSB First (Sign Extension) */
+					/*     MCDRV_PCM_MSB_FIRST_ZERO (4)  : MSB First (Zeros Padding)  */
+					/*     MCDRV_PCM_LSB_FIRST_ZERO (5)  : LSB First (Zeros Padding)  */
+					MCDRV_PCM_MSB_FIRST,
+					/* bLaw : Data Format Setting        */
+					/*     MCDRV_PCM_LINEAR(0)  : Linear */
+					/*     MCDRV_PCM_ALAW  (1)  : A-Law  */
+					/*     MCDRV_PCM_MULAW (2)  : u-Law */
+					MCDRV_PCM_LINEAR,
+					/* bBitSel : Bit Width Setting        */
+					/*     MCDRV_PCM_BITSEL_8 (0)  8 bits */
+					/*     MCDRV_PCM_BITSEL_13(1) 13 bits */
+					/*     MCDRV_PCM_BITSEL_14(2) 14 bits */
+					/*     MCDRV_PCM_BITSEL_16(3) 16 bits */
+					MCDRV_PCM_BITSEL_16
+				},
+				/* asSlot Setting of a slot number of data to be transmitted from each channel */
+				{0, 1}
+			}
+		}
+	}
+};
+
+/* ========================================
+   DAC settings
+   ========================================*/
+static const MCDRV_DAC_INFO stDacInfo_Default = {
+	/* bMasterSwap : DAC Master Path SWAP Setting                          */
+	/*     MCDRV_DSWAP_OFF      (0)  : No SWAP                             */
+	/*     MCDRV_DSWAP_SWAP     (1)  : SWAP                                */
+	/*     MCDRV_DSWAP_MUTE     (2)  : MUTE                                */
+	/*     MCDRV_DSWAP_RMVCENTER(3)  : Center Removed                      */
+	/*     MCDRV_DSWAP_MONO     (4)  : Mono                                */
+	/*     MCDRV_DSWAP_MONOHALF (5)  : Reserved (do not use this setting)  */
+	/*     MCDRV_DSWAP_BOTHL    (6)  : Lch data output in both Lch and Rch */
+	/*     MCDRV_DSWAP_BOTHR    (7)  : Rch data output in both Lch and Rch */
+	MCDRV_DSWAP_OFF,
+	/* bVoiceSwap : DAC Voice Path SWAP Setting                            */
+	/*     MCDRV_DSWAP_OFF      (0)  : No SWAP                             */
+	/*     MCDRV_DSWAP_SWAP     (1)  : SWAP                                */
+	/*     MCDRV_DSWAP_MUTE     (2)  : MUTE                                */
+	/*     MCDRV_DSWAP_RMVCENTER(3)  : Center Removed                      */
+	/*     MCDRV_DSWAP_MONO     (4)  : Mono (-6dB)                         */
+	/*     MCDRV_DSWAP_MONOHALF (5)  : Reserved (do not use this setting)  */
+	/*     MCDRV_DSWAP_BOTHL    (6)  : Lch data output in both Lch and Rch */
+	/*     MCDRV_DSWAP_BOTHR    (7)  : Rch data output in both Lch and Rch */
+	MCDRV_DSWAP_OFF,
+	/* bDcCut : HP, SP Protection DC-ct Filter Setting  */
+	/*     MCDRV_DCCUT_ON (0)  : DC-cut Filter ON       */
+	/*     MCDRV_DCCUT_OFF(1)  : DC-cut Filter OFF      */
+	MCDRV_DCCUT_ON
+};
+
+/* ========================================
+   ADC settings
+   ========================================*/
+
+static const MCDRV_ADC_INFO stAdcInfo_Default = {
+	/* bAgcAdjust : AGC Gain Control Range     */
+	/*     MCDRV_AGCADJ_24(0)  : -3dB to +24dB */
+	/*     MCDRV_AGCADJ_18(1)  : -3dB to +18dB */
+	/*     MCDRV_AGCADJ_12(2)  : -3dB to +12dB */
+	/*     MCDRV_AGCADJ_0 (3)  : -3dB to  +0dB */
+	MCDRV_AGCADJ_0,
+	/* bAgcOn : AGC ON/OFF Setting */
+	/*     MCDRV_AGC_OFF(0)  : OFF */
+	/*     MCDRV_AGC_ON (1)  : ON  */
+	MCDRV_AGC_OFF,
+	/* bMonot : Mono / Stereo Setting    */
+	/*     MCDRV_ADC_STEREO(0)  : Stereo */
+	/*     MCDRV_ADC_MONO  (1)  : Mono   */
+	MCDRV_ADC_STEREO
+};
+
+/* ========================================
+   SP settings
+   ========================================*/
+static const MCDRV_SP_INFO stSpInfo_Default = {
+	/* bSwap : Swap setting                */
+	/*     MCDRV_SPSWAP_OFF (0)  : No SWAP */
+	/*     MCDRV_SPSWAP_SWAP(1)  : SWAP    */
+	MCDRV_SPSWAP_OFF
+};
+
+/* ========================================
+   DNG settings
+   ========================================*/
+static const MCDRV_DNG_INFO stDngInfo_Default = {
+	/* bOnOff[] : Digital Noise Gate On/Off Setting */
+	/*     MCDRV_DNG_OFF(0)  : OFF                */
+	/*     MCDRV_DNG_ON (1)  : ON                 */
+	{MCDRV_DNG_OFF, MCDRV_DNG_OFF, MCDRV_DNG_OFF},
+
+	/* bThreshold[] : Threshold Setting    */
+	/*     MCDRV_DNG_THRES_30    (0) */
+	/*     MCDRV_DNG_THRES_36    (1) */
+	/*     MCDRV_DNG_THRES_42    (2) */
+	/*     MCDRV_DNG_THRES_48    (3) */
+	/*     MCDRV_DNG_THRES_54    (4) */
+	/*     MCDRV_DNG_THRES_60    (5) */
+	/*     MCDRV_DNG_THRES_66    (6) */
+	/*     MCDRV_DNG_THRES_72    (7) */
+	/*     MCDRV_DNG_THRES_78    (8) */
+	/*     MCDRV_DNG_THRES_84    (9) */
+	{MCDRV_DNG_THRES_60, MCDRV_DNG_THRES_60, MCDRV_DNG_THRES_60},
+
+	/* bHold[] : Hold Time Setting         */
+	/*     MCDRV_DNG_HOLD_30 (0)  :  30ms */
+	/*     MCDRV_DNG_HOLD_120(1)  : 120ms */
+	/*     MCDRV_DNG_HOLD_500(2)  : 500ms */
+	{MCDRV_DNG_HOLD_500, MCDRV_DNG_HOLD_500, MCDRV_DNG_HOLD_500},
+
+	/* bAttack[] : Attack Time Setting        */
+	/*     MCDRV_DNG_ATTACK_25   (0)  :   25ms */
+	/*     MCDRV_DNG_ATTACK_100  (1)  :  100ms */
+	/*     MCDRV_DNG_ATTACK_400  (2)  :  400ms */
+	/*     MCDRV_DNG_ATTACK_800  (3)  :  800ms */
+	{MCDRV_DNG_ATTACK_100, MCDRV_DNG_ATTACK_100, MCDRV_DNG_ATTACK_100},
+
+	/* bRelease[] : Release Time Setting        */
+	/*     MCDRV_DNG_RELEASE_7950(0)  : 7.95ms */
+	/*     MCDRV_DNG_RELEASE_470 (1)  : 0.47ms */
+	/*     MCDRV_DNG_RELEASE_940 (2)  : 0.94ms */
+	{MCDRV_DNG_RELEASE_940, MCDRV_DNG_RELEASE_940, MCDRV_DNG_RELEASE_940},
+
+	/* bTarget[] : Target Volume Setting        */
+	/*     MCDRV_DNG_TARGET_6    (0)  : -6dB  */
+	/*     MCDRV_DNG_TARGET_9    (1)  : -9dB  */
+	/*     MCDRV_DNG_TARGET_12   (2)  : -12dB */
+	/*     MCDRV_DNG_TARGET_15   (3)  : -15dB */
+	/*     MCDRV_DNG_TARGET_18   (4)  : -18dB */
+	/*     MCDRV_DNG_TARGET_MUTE (5)  : Mute  */
+	{MCDRV_DNG_TARGET_MUTE, MCDRV_DNG_TARGET_MUTE, MCDRV_DNG_TARGET_MUTE},
+};
+#if 0
+static const MCDRV_DNG_INFO stDngInfo_Default = {
+	/* bOnOff : Digital Noise Gate On/Off Setting */
+	/*     MCDRV_DNG_OFF(0)  : OFF                */
+	/*     MCDRV_DNG_ON (1)  : ON                 */
+	MCDRV_DNG_OFF,
+
+	/* bThreshold : Threshold Setting    */
+	/*     MCDRV_DNG_THRES_5BIT  (0) */
+	/*     MCDRV_DNG_THRES_7BIT  (1) */
+	/*     MCDRV_DNG_THRES_9BIT  (2) */
+	/*     MCDRV_DNG_THRES_11BIT (3) */
+	/*     MCDRV_DNG_THRES_13BIT (4) */
+	/*     MCDRV_DNG_THRES_15BIT (5) */
+	/*     MCDRV_DNG_THRES_17BIT (6) */
+	/*     MCDRV_DNG_THRES_21BIT (7) */
+	MCDRV_DNG_THRES_11BIT,
+
+	/* bHold : Hold Time Setting         */
+	/*     MCDRV_DNG_HOLD_30 (0)  :  30ms */
+	/*     MCDRV_DNG_HOLD_120(1)  : 120ms */
+	/*     MCDRV_DNG_HOLD_500(2)  : 500ms */
+	MCDRV_DNG_HOLD_500,
+
+	/* bAttack : Attack Time Setting        */
+	/*     MCDRV_DNG_ATTACK_25   (0)  :   25ms */
+	/*     MCDRV_DNG_ATTACK_800  (1)  :  800ms */
+	/*     MCDRV_DNG_ATTACK_1100 (2)  : 1100ms */
+	MCDRV_DNG_ATTACK_1100,
+
+	/* bRelease : Release Time Setting        */
+	/*     MCDRV_DNG_RELEASE_7950(0)  : 7.95ms */
+	/*     MCDRV_DNG_RELEASE_470 (1)  : 0.47ms */
+	/*     MCDRV_DNG_RELEASE_940 (2)  : 0.94ms */
+	MCDRV_DNG_RELEASE_940,
+
+};
+#endif
+
+/* ========================================
+   AudioEngine settings
+   ========================================*/
+static MCDRV_AE_INFO sAeInfo_1 = {
+	/* On/Off */
+	0x00,
+	/* BEX */
+	{
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
+	},
+	/* WIDE */
+	{
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00
+	},
+	/* DRC */
+	{
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
+	},
+	/* EQ5 */
+	{
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00
+	},
+	/* EQ3 */
+	{
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00
+	}
+};
+
+static MCDRV_AE_INFO sAeInfo_2 = {
+	/* On/Off */
+	0x00,
+	/* BEX */
+	{
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
+	},
+	/* WIDE */
+	{
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00
+	},
+	/* DRC */
+	{
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
+	},
+	/* EQ5 */
+	{
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00
+	},
+	/* EQ3 */
+	{
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00
+	}
+};
+
+static MCDRV_AE_INFO sAeInfo_3 = {
+	/* On/Off */
+	0x00,
+	/* BEX */
+	{
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
+	},
+	/* WIDE */
+	{
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00
+	},
+	/* DRC */
+	{
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
+	},
+	/* EQ5 */
+	{
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00
+	},
+	/* EQ3 */
+	{
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00
+	}
+};
+
+static MCDRV_AE_INFO sAeInfo_4 = {
+	/* On/Off */
+	0x00,
+	/* BEX */
+	{
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
+	},
+	/* WIDE */
+	{
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00
+	},
+	/* DRC */
+	{
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
+	},
+	/* EQ5 */
+	{
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00
+	},
+	/* EQ3 */
+	{
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00
+	}
+};
+
+static MCDRV_AE_INFO sAeInfo_5 = {
+	/* On/Off */
+	0x00,
+	/* BEX */
+	{
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
+	},
+	/* WIDE */
+	{
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00
+	},
+	/* DRC */
+	{
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
+	},
+	/* EQ5 */
+	{
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00
+	},
+	/* EQ3 */
+	{
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00
+	}
+};
+
+/* ========================================
+   System EQ settings
+   ========================================*/
+static MCDRV_SYSEQ_INFO stSyseqInfo_Default = {
+	/* On/Off */
+	0x00,
+	/* EQ */
+	{
+		0x10,0xc4,0x50,0x12,0xc4,0x40,0x02,0xa9,
+		0x60,0xed,0x3b,0xc0,0xfc,0x92,0x40,
+	},
+};
+
+#endif
diff --git a/sound/soc/codecs/mc1n2/mc1n2_cfg_q1.h b/sound/soc/codecs/mc1n2/mc1n2_cfg_q1.h
new file mode 100644
index 0000000..c90e9b5
--- /dev/null
+++ b/sound/soc/codecs/mc1n2/mc1n2_cfg_q1.h
@@ -0,0 +1,1199 @@
+/*
+ * MC-1N2 ASoC codec driver
+ *
+ * Copyright (c) 2010-2011 Yamaha Corporation
+ *
+ * This software is provided 'as-is', without any express or implied
+ * warranty.  In no event will the authors be held liable for any damages
+ * arising from the use of this software.
+ *
+ * Permission is granted to anyone to use this software for any purpose,
+ * including commercial applications, and to alter it and redistribute it
+ * freely, subject to the following restrictions:
+ *
+ * 1. The origin of this software must not be misrepresented; you must not
+ *    claim that you wrote the original software. If you use this software
+ *    in a product, an acknowledgment in the product documentation would be
+ *    appreciated but is not required.
+ * 2. Altered source versions must be plainly marked as such, and must not be
+ *    misrepresented as being the original software.
+ * 3. This notice may not be removed or altered from any source distribution.
+ */
+
+#ifndef MC1N2_CFG_H
+#define MC1N2_CFG_H
+
+#include "mcdriver.h"
+
+/*
+ * ALSA Version
+ */
+/* #define ALSA_VER_1_0_19 */
+/* #define ALSA_VER_1_0_21 */
+/* #define ALSA_VER_1_0_23 */
+/* #define ALSA_VER_ANDROID_2_6_35 */
+#define ALSA_VER_ANDROID_3_0
+
+#define DIO0_DAI_ENABLE
+/* #define DIO1_DAI_ENABLE */
+/* #define DIO2_DAI_ENABLE */
+
+#ifdef ALSA_VER_ANDROID_3_0
+static struct mc1n2_setup mc1n2_cfg_setup = {
+	{  /* MCDRV_INIT_INFO */
+		MCDRV_CKSEL_CMOS, /* bCkSel */
+		41,               /* bDivR0 */
+		126,              /* bDivF0 */
+		41,               /* bDivR1 */
+		126,              /* bDivF1 */
+		0,                /* bRange0*/
+		0,                /* bRange1*/
+		0,                /* bBypass*/
+		MCDRV_DAHIZ_LOW,  /* bDioSdo0Hiz */
+		MCDRV_DAHIZ_LOW,  /* bDioSdo1Hiz */
+		MCDRV_DAHIZ_LOW,  /* bDioSdo2Hiz */
+		MCDRV_DAHIZ_HIZ,  /* bDioClk0Hiz */
+		MCDRV_DAHIZ_HIZ,  /* bDioClk1Hiz */
+		MCDRV_DAHIZ_HIZ,  /* bDioClk2Hiz */
+		MCDRV_PCMHIZ_HIZ, /* bPcmHiz */
+		MCDRV_LINE_STEREO,/* bLineIn1Dif */
+		0,                /* bLineIn2Dif */
+		MCDRV_LINE_STEREO,/* bLineOut1Dif */
+		MCDRV_LINE_STEREO,/* bLineOUt2Dif */
+		MCDRV_SPMN_ON,    /* bSpmn */
+		MCDRV_MIC_DIF,    /* bMic1Sng */
+		MCDRV_MIC_DIF,    /* bMic2Sng */
+		MCDRV_MIC_DIF,    /* bMic3Sng */
+		MCDRV_POWMODE_NORMAL, /* bPowerMode */
+		MCDRV_SPHIZ_PULLDOWN, /* bSpHiz */
+		MCDRV_LDO_ON,     /* bLdo */
+		MCDRV_PAD_GPIO,   /* bPad0Func */
+		MCDRV_PAD_GPIO,   /* bPad1Func */
+		MCDRV_PAD_GPIO,   /* bPad2Func */
+		MCDRV_OUTLEV_4,   /* bAvddLev */
+		0,                /* bVrefLev */
+		MCDRV_DCLGAIN_12, /* bDclGain */
+		MCDRV_DCLLIMIT_0, /* bDclLimit */
+		1,                   /* set Hi-power mode 0: HP mode 1: normal */
+		0,                /* bReserved1 */
+		0,                /* bReserved2 */
+		0,                /* bReserved3 */
+		0,                /* bReserved4 */
+		0,                /* bReserved5 */
+		{                 /* sWaitTime */
+			130000,         /* dAdHpf */
+			25000,          /* dMic1Cin */
+			25000,          /* dMic2Cin */
+			25000,          /* dMic3Cin */
+			25000,          /* dLine1Cin */
+			25000,          /* dLine2Cin */
+			5000,           /* dVrefRdy1 */
+			15000,          /* dVrefRdy2 */
+			9000,           /* dHpRdy */
+			13000,          /* dSpRdy */
+			0,              /* dPdm */
+			1000,           /* dAnaRdyInterval */
+			1000,           /* dSvolInterval */
+			1000,           /* dAnaRdyTimeOut */
+			1000            /* dSvolTimeOut */
+		}
+	}, /* MCDRV_INIT_INFO end */
+	{  /* pcm_extend */
+		0, 0, 0
+	}, /* pcm_extend end */
+	{  /* pcm_hiz_redge */
+		MCDRV_PCMHIZTIM_FALLING, MCDRV_PCMHIZTIM_FALLING, MCDRV_PCMHIZTIM_FALLING
+	}, /* pcm_hiz_redge end */
+	{  /* pcm_hperiod */
+		1, 1, 1
+	}, /* pcm_hperiod end */
+	{  /* slot */
+		{ {0, 1}, {0, 1} },
+		{ {0, 1}, {0, 1} },
+		{ {0, 1}, {0, 1} }
+	}  /* slot end */
+};
+#endif
+
+static const MCDRV_DIO_INFO stDioInfo_Default = {
+	{
+		/* DIO port 0 */
+		{
+			/* sDioCommon */
+			{
+				/* bMasterSlave : Master / Slave Setting */
+				/*     MCDRV_DIO_SLAVE (0)  : Slave      */
+				/*     MCDRV_DIO_MASTER(1)  : Master     */
+				MCDRV_DIO_MASTER,
+				/* bAutoFs : Sampling frequency automatic measurement ON/OFF Setting in slave mode */
+				/*     MCDRV_AUTOFS_OFF(0)  : OFF */
+				/*     MCDRV_AUTOFS_ON (1)  : ON  */
+				MCDRV_AUTOFS_ON ,
+				/* bFs : Sampling Rate Setting        */
+				/*     MCDRV_FS_48000(0)  : 48kHz     */
+				/*     MCDRV_FS_44100(1)  : 44.1kHz   */
+				/*     MCDRV_FS_32000(2)  : 32kHz     */
+				/*     MCDRV_FS_24000(4)  : 24kHz     */
+				/*     MCDRV_FS_22050(5)  : 22.05kHz  */
+				/*     MCDRV_FS_16000(6)  : 16kHz     */
+				/*     MCDRV_FS_12000(8)  : 12kHz     */
+				/*     MCDRV_FS_11025(9)  : 11.025kHz */
+				/*     MCDRV_FS_8000 (10) : 8kHz      */
+				MCDRV_FS_44100,
+				/* bBckFs : Bit Clock Frequency Setting */
+				/*     MCDRV_BCKFS_64 (0)  : LRCK x  64 */
+				/*     MCDRV_BCKFS_48 (1)  : LRCK x  48 */
+				/*     MCDRV_BCKFS_32 (2)  : LRCK x  32 */
+				/*     MCDRV_BCKFS_512(4)  : LRCK x 512 */
+				/*     MCDRV_BCKFS_256(5)  : LRCK x 256 */
+				/*     MCDRV_BCKFS_128(6)  : LRCK x 128 */
+				/*     MCDRV_BCKFS_16 (7)  : LRCK x  16 */
+				MCDRV_BCKFS_32,
+				/* bInterface : Interface Selection      */
+				/*     MCDRV_DIO_DA (0)  : Digital Audio */
+				/*     MCDRV_DIO_PCM(1)  : PCM           */
+				MCDRV_DIO_DA,
+				/* bBckInvert : Bit Clock Inversion Setting     */
+				/*     MCDRV_BCLK_NORMAL(0)  : Normal Operation */
+				/*     MCDRV_BCLK_INVERT(1)  : Clock Inverted   */
+				MCDRV_BCLK_NORMAL,
+				/* bPcmHizTim : High Impedance transition timing after transmitting the last PCM I/F data */
+				/*     MCDRV_PCMHIZTIM_FALLING(0)  : BCLK#* Falling Edge */
+				/*     MCDRV_PCMHIZTIM_RISING (1)  : BCLK#* Rising Edge  */
+				MCDRV_PCMHIZTIM_FALLING,
+				/* bPcmClkDown : Bit Clock Setting with PCM selected and Master selected                */
+				/*     MCDRV_PCM_CLKDOWN_OFF (0)  : A bit clock value specified with bBckFs             */
+				/*     MCDRV_PCM_CLKDOWN_HALF(1)  : A half of the bit clock value specified with bBckFs */
+				MCDRV_PCM_CLKDOWN_OFF,
+				/* bPcmFrame : Frame Mode Setting with PCM interface */
+				/*     MCDRV_PCM_SHORTFRAME(0)  : Short Frame        */
+				/*     MCDRV_PCM_LONGFRAME (1)  : Long Frame         */
+				MCDRV_PCM_SHORTFRAME,
+				/* bPcmHighPeriod : LR clock High time setting with PCM selected and Master selected */
+				/*     0 to 31  : High level keeps during the period of time of         */
+				/*                (setting value + 1) of the bit clock.                 */
+				0,
+			},
+			/* sDir       */
+			{
+				/* wSrcRate : Sampling Rate Converter Setting */
+				0,
+				/* sDaFormat : Digital Audio Format Information */
+				{
+					/* bBitSel : Bit Width Setting     */
+					/*     MCDRV_BITSEL_16(0)  : 16bit */
+					/*     MCDRV_BITSEL_20(1)  : 20bit */
+					/*     MCDRV_BITSEL_24(2)  : 24bit */
+					MCDRV_BITSEL_16,
+					/* bMode : Data Format Setting                             */
+					/*     MCDRV_DAMODE_HEADALIGN(0)  : Left-justified Format  */
+					/*     MCDRV_DAMODE_I2S      (1)  : I2S                    */
+					/*     MCDRV_DAMODE_TAILALIGN(2)  : Right-justified Format */
+					MCDRV_DAMODE_I2S
+				},
+				/* sPcmFormat : PCM Format Information */
+				{
+					/* bMono : Mono / Stereo Setting  */
+					/*     MCDRV_PCM_STEREO(0) Stereo */
+					/*     MCDRV_PCM_MONO  (1) Mono   */
+					MCDRV_PCM_MONO ,
+					/* bOrder : Bit Order Setting                                     */
+					/*     MCDRV_PCM_MSB_FIRST      (0)  : MSB First                  */
+					/*     MCDRV_PCM_LSB_FIRST      (1)  : LSB First                  */
+					/*     MCDRV_PCM_MSB_FIRST_SIGN (2)  : MSB First (Sign Extension) */
+					/*     MCDRV_PCM_LSB_FIRST_SIGN (3)  : LSB First (Sign Extension) */
+					/*     MCDRV_PCM_MSB_FIRST_ZERO (4)  : MSB First (Zeros Padding)  */
+					/*     MCDRV_PCM_LSB_FIRST_ZERO (5)  : LSB First (Zeros Padding)  */
+					MCDRV_PCM_MSB_FIRST,
+					/* bLaw : Data Format Setting        */
+					/*     MCDRV_PCM_LINEAR(0)  : Linear */
+					/*     MCDRV_PCM_ALAW  (1)  : A-Law  */
+					/*     MCDRV_PCM_MULAW (2)  : u-Law */
+					MCDRV_PCM_LINEAR,
+					/* bBitSel : Bit Width Setting        */
+					/*     MCDRV_PCM_BITSEL_8 (0)  8 bits */
+					/*     MCDRV_PCM_BITSEL_13(1) 13 bits */
+					/*     MCDRV_PCM_BITSEL_14(2) 14 bits */
+					/*     MCDRV_PCM_BITSEL_16(3) 16 bits */
+					MCDRV_PCM_BITSEL_8
+				},
+				/* asSlot : Setting of a slot number of data to be fed to each channel */
+				{0, 1}
+			},
+			/* sDit       */
+			{
+				/* wSrcRate : Sampling Rate Converter Setting */
+				0,
+				/* sDaFormat : Digital Audio Format Information */
+				{
+					/* bBitSel : Bit Width Setting     */
+					/*     MCDRV_BITSEL_16(0)  : 16bit */
+					/*     MCDRV_BITSEL_20(1)  : 20bit */
+					/*     MCDRV_BITSEL_24(2)  : 24bit */
+					MCDRV_BITSEL_16,
+					/* bMode : Data Format Setting                             */
+					/*     MCDRV_DAMODE_HEADALIGN(0)  : Left-justified Format  */
+					/*     MCDRV_DAMODE_I2S      (1)  : I2S                    */
+					/*     MCDRV_DAMODE_TAILALIGN(2)  : Right-justified Format */
+					MCDRV_DAMODE_I2S
+				},
+				/* sPcmFormat : PCM Format Information */
+				{
+					/* bMono : Mono / Stereo Setting  */
+					/*     MCDRV_PCM_STEREO(0) Stereo */
+					/*     MCDRV_PCM_MONO  (1) Mono   */
+					MCDRV_PCM_MONO ,
+					/* bOrder : Bit Order Setting                                     */
+					/*     MCDRV_PCM_MSB_FIRST      (0)  : MSB First                  */
+					/*     MCDRV_PCM_LSB_FIRST      (1)  : LSB First                  */
+					/*     MCDRV_PCM_MSB_FIRST_SIGN (2)  : MSB First (Sign Extension) */
+					/*     MCDRV_PCM_LSB_FIRST_SIGN (3)  : LSB First (Sign Extension) */
+					/*     MCDRV_PCM_MSB_FIRST_ZERO (4)  : MSB First (Zeros Padding)  */
+					/*     MCDRV_PCM_LSB_FIRST_ZERO (5)  : LSB First (Zeros Padding)  */
+					MCDRV_PCM_MSB_FIRST,
+					/* bLaw : Data Format Setting        */
+					/*     MCDRV_PCM_LINEAR(0)  : Linear */
+					/*     MCDRV_PCM_ALAW  (1)  : A-Law  */
+					/*     MCDRV_PCM_MULAW (2)  : u-Law */
+					MCDRV_PCM_LINEAR,
+					/* bBitSel : Bit Width Setting        */
+					/*     MCDRV_PCM_BITSEL_8 (0)  8 bits */
+					/*     MCDRV_PCM_BITSEL_13(1) 13 bits */
+					/*     MCDRV_PCM_BITSEL_14(2) 14 bits */
+					/*     MCDRV_PCM_BITSEL_16(3) 16 bits */
+					MCDRV_PCM_BITSEL_8
+				},
+				/* asSlot Setting of a slot number of data to be transmitted from each channel */
+				{0, 1}
+			}
+		},
+		/* DIO port 1 */
+		{
+			/* sDioCommon */
+			{
+				/* bMasterSlave : Master / Slave Setting */
+				/*     MCDRV_DIO_SLAVE (0)  : Slave      */
+				/*     MCDRV_DIO_MASTER(1)  : Master     */
+				MCDRV_DIO_SLAVE,
+				/* bAutoFs : Sampling frequency automatic measurement ON/OFF Setting in slave mode */
+				/*     MCDRV_AUTOFS_OFF(0)  : OFF */
+				/*     MCDRV_AUTOFS_ON (1)  : ON  */
+				MCDRV_AUTOFS_ON ,
+				/* bFs : Sampling Rate Setting        */
+				/*     MCDRV_FS_48000(0)  : 48kHz     */
+				/*     MCDRV_FS_44100(1)  : 44.1kHz   */
+				/*     MCDRV_FS_32000(2)  : 32kHz     */
+				/*     MCDRV_FS_24000(4)  : 24kHz     */
+				/*     MCDRV_FS_22050(5)  : 22.05kHz  */
+				/*     MCDRV_FS_16000(6)  : 16kHz     */
+				/*     MCDRV_FS_12000(8)  : 12kHz     */
+				/*     MCDRV_FS_11025(9)  : 11.025kHz */
+				/*     MCDRV_FS_8000 (10) : 8kHz      */
+				MCDRV_FS_8000,
+				/* bBckFs : Bit Clock Frequency Setting */
+				/*     MCDRV_BCKFS_64 (0)  : LRCK x  64 */
+				/*     MCDRV_BCKFS_48 (1)  : LRCK x  48 */
+				/*     MCDRV_BCKFS_32 (2)  : LRCK x  32 */
+				/*     MCDRV_BCKFS_512(4)  : LRCK x 512 */
+				/*     MCDRV_BCKFS_256(5)  : LRCK x 256 */
+				/*     MCDRV_BCKFS_128(6)  : LRCK x 128 */
+				/*     MCDRV_BCKFS_16 (7)  : LRCK x  16 */
+				MCDRV_BCKFS_32,
+				/* bInterface : Interface Selection      */
+				/*     MCDRV_DIO_DA (0)  : Digital Audio */
+				/*     MCDRV_DIO_PCM(1)  : PCM           */
+				MCDRV_DIO_DA,
+				/* bBckInvert : Bit Clock Inversion Setting     */
+				/*     MCDRV_BCLK_NORMAL(0)  : Normal Operation */
+				/*     MCDRV_BCLK_INVERT(1)  : Clock Inverted   */
+				MCDRV_BCLK_NORMAL,
+				/* bPcmHizTim : High Impedance transition timing after transmitting the last PCM I/F data */
+				/*     MCDRV_PCMHIZTIM_FALLING(0)  : BCLK#* Falling Edge */
+				/*     MCDRV_PCMHIZTIM_RISING (1)  : BCLK#* Rising Edge  */
+				MCDRV_PCMHIZTIM_FALLING,
+				/* bPcmClkDown : Bit Clock Setting with PCM selected and Master selected                */
+				/*     MCDRV_PCM_CLKDOWN_OFF (0)  : A bit clock value specified with bBckFs             */
+				/*     MCDRV_PCM_CLKDOWN_HALF(1)  : A half of the bit clock value specified with bBckFs */
+				MCDRV_PCM_CLKDOWN_OFF,
+				/* bPcmFrame : Frame Mode Setting with PCM interface */
+				/*     MCDRV_PCM_SHORTFRAME(0)  : Short Frame        */
+				/*     MCDRV_PCM_LONGFRAME (1)  : Long Frame         */
+				MCDRV_PCM_SHORTFRAME,
+				/* bPcmHighPeriod : LR clock High time setting with PCM selected and Master selected */
+				/*     0 to 31  : High level keeps during the period of time of         */
+				/*                (setting value + 1) of the bit clock.                 */
+				0,
+			},
+			/* sDir       */
+			{
+				/* wSrcRate : Sampling Rate Converter Setting */
+				0,
+				/* sDaFormat : Digital Audio Format Information */
+				{
+					/* bBitSel : Bit Width Setting     */
+					/*     MCDRV_BITSEL_16(0)  : 16bit */
+					/*     MCDRV_BITSEL_20(1)  : 20bit */
+					/*     MCDRV_BITSEL_24(2)  : 24bit */
+					MCDRV_BITSEL_16,
+					/* bMode : Data Format Setting                             */
+					/*     MCDRV_DAMODE_HEADALIGN(0)  : Left-justified Format  */
+					/*     MCDRV_DAMODE_I2S      (1)  : I2S                    */
+					/*     MCDRV_DAMODE_TAILALIGN(2)  : Right-justified Format */
+					MCDRV_DAMODE_I2S
+				},
+				/* sPcmFormat : PCM Format Information */
+				{
+					/* bMono : Mono / Stereo Setting  */
+					/*     MCDRV_PCM_STEREO(0) Stereo */
+					/*     MCDRV_PCM_MONO  (1) Mono   */
+					MCDRV_PCM_STEREO ,
+					/* bOrder : Bit Order Setting                                     */
+					/*     MCDRV_PCM_MSB_FIRST      (0)  : MSB First                  */
+					/*     MCDRV_PCM_LSB_FIRST      (1)  : LSB First                  */
+					/*     MCDRV_PCM_MSB_FIRST_SIGN (2)  : MSB First (Sign Extension) */
+					/*     MCDRV_PCM_LSB_FIRST_SIGN (3)  : LSB First (Sign Extension) */
+					/*     MCDRV_PCM_MSB_FIRST_ZERO (4)  : MSB First (Zeros Padding)  */
+					/*     MCDRV_PCM_LSB_FIRST_ZERO (5)  : LSB First (Zeros Padding)  */
+					MCDRV_PCM_MSB_FIRST,
+					/* bLaw : Data Format Setting        */
+					/*     MCDRV_PCM_LINEAR(0)  : Linear */
+					/*     MCDRV_PCM_ALAW  (1)  : A-Law  */
+					/*     MCDRV_PCM_MULAW (2)  : u-Law */
+					MCDRV_PCM_LINEAR,
+					/* bBitSel : Bit Width Setting        */
+					/*     MCDRV_PCM_BITSEL_8 (0)  8 bits */
+					/*     MCDRV_PCM_BITSEL_13(1) 13 bits */
+					/*     MCDRV_PCM_BITSEL_14(2) 14 bits */
+					/*     MCDRV_PCM_BITSEL_16(3) 16 bits */
+					MCDRV_PCM_BITSEL_16
+				},
+				/* asSlot : Setting of a slot number of data to be fed to each channel */
+				{0, 0}
+			},
+			/* sDit       */
+			{
+				/* wSrcRate : Sampling Rate Converter Setting */
+				0,
+				/* sDaFormat : Digital Audio Format Information */
+				{
+					/* bBitSel : Bit Width Setting     */
+					/*     MCDRV_BITSEL_16(0)  : 16bit */
+					/*     MCDRV_BITSEL_20(1)  : 20bit */
+					/*     MCDRV_BITSEL_24(2)  : 24bit */
+					MCDRV_BITSEL_16,
+					/* bMode : Data Format Setting                             */
+					/*     MCDRV_DAMODE_HEADALIGN(0)  : Left-justified Format  */
+					/*     MCDRV_DAMODE_I2S      (1)  : I2S                    */
+					/*     MCDRV_DAMODE_TAILALIGN(2)  : Right-justified Format */
+					MCDRV_DAMODE_I2S
+				},
+				/* sPcmFormat : PCM Format Information */
+				{
+					/* bMono : Mono / Stereo Setting  */
+					/*     MCDRV_PCM_STEREO(0) Stereo */
+					/*     MCDRV_PCM_MONO  (1) Mono   */
+					MCDRV_PCM_STEREO ,
+					/* bOrder : Bit Order Setting                                     */
+					/*     MCDRV_PCM_MSB_FIRST      (0)  : MSB First                  */
+					/*     MCDRV_PCM_LSB_FIRST      (1)  : LSB First                  */
+					/*     MCDRV_PCM_MSB_FIRST_SIGN (2)  : MSB First (Sign Extension) */
+					/*     MCDRV_PCM_LSB_FIRST_SIGN (3)  : LSB First (Sign Extension) */
+					/*     MCDRV_PCM_MSB_FIRST_ZERO (4)  : MSB First (Zeros Padding)  */
+					/*     MCDRV_PCM_LSB_FIRST_ZERO (5)  : LSB First (Zeros Padding)  */
+					MCDRV_PCM_MSB_FIRST,
+					/* bLaw : Data Format Setting        */
+					/*     MCDRV_PCM_LINEAR(0)  : Linear */
+					/*     MCDRV_PCM_ALAW  (1)  : A-Law  */
+					/*     MCDRV_PCM_MULAW (2)  : u-Law */
+					MCDRV_PCM_LINEAR,
+					/* bBitSel : Bit Width Setting        */
+					/*     MCDRV_PCM_BITSEL_8 (0)  8 bits */
+					/*     MCDRV_PCM_BITSEL_13(1) 13 bits */
+					/*     MCDRV_PCM_BITSEL_14(2) 14 bits */
+					/*     MCDRV_PCM_BITSEL_16(3) 16 bits */
+					MCDRV_PCM_BITSEL_16
+				},
+				/* asSlot Setting of a slot number of data to be transmitted from each channel */
+				{0, 1}
+			}
+		},
+		/* DIO port 2 */
+		{
+			/* sDioCommon */
+			{
+				/* bMasterSlave : Master / Slave Setting */
+				/*     MCDRV_DIO_SLAVE (0)  : Slave      */
+				/*     MCDRV_DIO_MASTER(1)  : Master     */
+				MCDRV_DIO_MASTER,
+				/* bAutoFs : Sampling frequency automatic measurement ON/OFF Setting in slave mode */
+				/*     MCDRV_AUTOFS_OFF(0)  : OFF */
+				/*     MCDRV_AUTOFS_ON (1)  : ON  */
+				MCDRV_AUTOFS_ON ,
+				/* bFs : Sampling Rate Setting        */
+				/*     MCDRV_FS_48000(0)  : 48kHz     */
+				/*     MCDRV_FS_44100(1)  : 44.1kHz   */
+				/*     MCDRV_FS_32000(2)  : 32kHz     */
+				/*     MCDRV_FS_24000(4)  : 24kHz     */
+				/*     MCDRV_FS_22050(5)  : 22.05kHz  */
+				/*     MCDRV_FS_16000(6)  : 16kHz     */
+				/*     MCDRV_FS_12000(8)  : 12kHz     */
+				/*     MCDRV_FS_11025(9)  : 11.025kHz */
+				/*     MCDRV_FS_8000 (10) : 8kHz      */
+				MCDRV_FS_8000,
+				/* bBckFs : Bit Clock Frequency Setting */
+				/*     MCDRV_BCKFS_64 (0)  : LRCK x  64 */
+				/*     MCDRV_BCKFS_48 (1)  : LRCK x  48 */
+				/*     MCDRV_BCKFS_32 (2)  : LRCK x  32 */
+				/*     MCDRV_BCKFS_512(4)  : LRCK x 512 */
+				/*     MCDRV_BCKFS_256(5)  : LRCK x 256 */
+				/*     MCDRV_BCKFS_128(6)  : LRCK x 128 */
+				/*     MCDRV_BCKFS_16 (7)  : LRCK x  16 */
+				MCDRV_BCKFS_32,
+				/* bInterface : Interface Selection      */
+				/*     MCDRV_DIO_DA (0)  : Digital Audio */
+				/*     MCDRV_DIO_PCM(1)  : PCM           */
+				MCDRV_DIO_PCM,
+				/* bBckInvert : Bit Clock Inversion Setting     */
+				/*     MCDRV_BCLK_NORMAL(0)  : Normal Operation */
+				/*     MCDRV_BCLK_INVERT(1)  : Clock Inverted   */
+				MCDRV_BCLK_NORMAL,
+				/* bPcmHizTim : High Impedance transition timing after transmitting the last PCM I/F data */
+				/*     MCDRV_PCMHIZTIM_FALLING(0)  : BCLK#* Falling Edge */
+				/*     MCDRV_PCMHIZTIM_RISING (1)  : BCLK#* Rising Edge  */
+				MCDRV_PCMHIZTIM_FALLING,
+				/* bPcmClkDown : Bit Clock Setting with PCM selected and Master selected                */
+				/*     MCDRV_PCM_CLKDOWN_OFF (0)  : A bit clock value specified with bBckFs             */
+				/*     MCDRV_PCM_CLKDOWN_HALF(1)  : A half of the bit clock value specified with bBckFs */
+				MCDRV_PCM_CLKDOWN_OFF,
+				/* bPcmFrame : Frame Mode Setting with PCM interface */
+				/*     MCDRV_PCM_SHORTFRAME(0)  : Short Frame        */
+				/*     MCDRV_PCM_LONGFRAME (1)  : Long Frame         */
+				MCDRV_PCM_SHORTFRAME,
+				/* bPcmHighPeriod : LR clock High time setting with PCM selected and Master selected */
+				/*     0 to 31  : High level keeps during the period of time of         */
+				/*                (setting value + 1) of the bit clock.                 */
+				0,
+			},
+			/* sDir       */
+			{
+				/* wSrcRate : Sampling Rate Converter Setting */
+				0,
+				/* sDaFormat : Digital Audio Format Information */
+				{
+					/* bBitSel : Bit Width Setting     */
+					/*     MCDRV_BITSEL_16(0)  : 16bit */
+					/*     MCDRV_BITSEL_20(1)  : 20bit */
+					/*     MCDRV_BITSEL_24(2)  : 24bit */
+					MCDRV_BITSEL_16,
+					/* bMode : Data Format Setting                             */
+					/*     MCDRV_DAMODE_HEADALIGN(0)  : Left-justified Format  */
+					/*     MCDRV_DAMODE_I2S      (1)  : I2S                    */
+					/*     MCDRV_DAMODE_TAILALIGN(2)  : Right-justified Format */
+					MCDRV_DAMODE_HEADALIGN
+				},
+				/* sPcmFormat : PCM Format Information */
+				{
+					/* bMono : Mono / Stereo Setting  */
+					/*     MCDRV_PCM_STEREO(0) Stereo */
+					/*     MCDRV_PCM_MONO  (1) Mono   */
+					MCDRV_PCM_STEREO ,
+					/* bOrder : Bit Order Setting                                     */
+					/*     MCDRV_PCM_MSB_FIRST      (0)  : MSB First                  */
+					/*     MCDRV_PCM_LSB_FIRST      (1)  : LSB First                  */
+					/*     MCDRV_PCM_MSB_FIRST_SIGN (2)  : MSB First (Sign Extension) */
+					/*     MCDRV_PCM_LSB_FIRST_SIGN (3)  : LSB First (Sign Extension) */
+					/*     MCDRV_PCM_MSB_FIRST_ZERO (4)  : MSB First (Zeros Padding)  */
+					/*     MCDRV_PCM_LSB_FIRST_ZERO (5)  : LSB First (Zeros Padding)  */
+					MCDRV_PCM_MSB_FIRST,
+					/* bLaw : Data Format Setting        */
+					/*     MCDRV_PCM_LINEAR(0)  : Linear */
+					/*     MCDRV_PCM_ALAW  (1)  : A-Law  */
+					/*     MCDRV_PCM_MULAW (2)  : u-Law */
+					MCDRV_PCM_LINEAR,
+					/* bBitSel : Bit Width Setting        */
+					/*     MCDRV_PCM_BITSEL_8 (0)  8 bits */
+					/*     MCDRV_PCM_BITSEL_13(1) 13 bits */
+					/*     MCDRV_PCM_BITSEL_14(2) 14 bits */
+					/*     MCDRV_PCM_BITSEL_16(3) 16 bits */
+					MCDRV_PCM_BITSEL_16
+				},
+				/* asSlot : Setting of a slot number of data to be fed to each channel */
+				{0, 0}
+			},
+			/* sDit       */
+			{
+				/* wSrcRate : Sampling Rate Converter Setting */
+				0,
+				/* sDaFormat : Digital Audio Format Information */
+				{
+					/* bBitSel : Bit Width Setting     */
+					/*     MCDRV_BITSEL_16(0)  : 16bit */
+					/*     MCDRV_BITSEL_20(1)  : 20bit */
+					/*     MCDRV_BITSEL_24(2)  : 24bit */
+					MCDRV_BITSEL_16,
+					/* bMode : Data Format Setting                             */
+					/*     MCDRV_DAMODE_HEADALIGN(0)  : Left-justified Format  */
+					/*     MCDRV_DAMODE_I2S      (1)  : I2S                    */
+					/*     MCDRV_DAMODE_TAILALIGN(2)  : Right-justified Format */
+					MCDRV_DAMODE_HEADALIGN
+				},
+				/* sPcmFormat : PCM Format Information */
+				{
+					/* bMono : Mono / Stereo Setting  */
+					/*     MCDRV_PCM_STEREO(0) Stereo */
+					/*     MCDRV_PCM_MONO  (1) Mono   */
+					MCDRV_PCM_MONO ,
+					/* bOrder : Bit Order Setting                                     */
+					/*     MCDRV_PCM_MSB_FIRST      (0)  : MSB First                  */
+					/*     MCDRV_PCM_LSB_FIRST      (1)  : LSB First                  */
+					/*     MCDRV_PCM_MSB_FIRST_SIGN (2)  : MSB First (Sign Extension) */
+					/*     MCDRV_PCM_LSB_FIRST_SIGN (3)  : LSB First (Sign Extension) */
+					/*     MCDRV_PCM_MSB_FIRST_ZERO (4)  : MSB First (Zeros Padding)  */
+					/*     MCDRV_PCM_LSB_FIRST_ZERO (5)  : LSB First (Zeros Padding)  */
+					MCDRV_PCM_MSB_FIRST,
+					/* bLaw : Data Format Setting        */
+					/*     MCDRV_PCM_LINEAR(0)  : Linear */
+					/*     MCDRV_PCM_ALAW  (1)  : A-Law  */
+					/*     MCDRV_PCM_MULAW (2)  : u-Law */
+					MCDRV_PCM_LINEAR,
+					/* bBitSel : Bit Width Setting        */
+					/*     MCDRV_PCM_BITSEL_8 (0)  8 bits */
+					/*     MCDRV_PCM_BITSEL_13(1) 13 bits */
+					/*     MCDRV_PCM_BITSEL_14(2) 14 bits */
+					/*     MCDRV_PCM_BITSEL_16(3) 16 bits */
+					MCDRV_PCM_BITSEL_16
+				},
+				/* asSlot Setting of a slot number of data to be transmitted from each channel */
+				{0, 1}
+			}
+		}
+	}
+};
+
+/* ========================================
+   DAC settings
+   ========================================*/
+static const MCDRV_DAC_INFO stDacInfo_Default = {
+	/* bMasterSwap : DAC Master Path SWAP Setting                          */
+	/*     MCDRV_DSWAP_OFF      (0)  : No SWAP                             */
+	/*     MCDRV_DSWAP_SWAP     (1)  : SWAP                                */
+	/*     MCDRV_DSWAP_MUTE     (2)  : MUTE                                */
+	/*     MCDRV_DSWAP_RMVCENTER(3)  : Center Removed                      */
+	/*     MCDRV_DSWAP_MONO     (4)  : Mono                                */
+	/*     MCDRV_DSWAP_MONOHALF (5)  : Reserved (do not use this setting)  */
+	/*     MCDRV_DSWAP_BOTHL    (6)  : Lch data output in both Lch and Rch */
+	/*     MCDRV_DSWAP_BOTHR    (7)  : Rch data output in both Lch and Rch */
+	MCDRV_DSWAP_OFF,
+	/* bVoiceSwap : DAC Voice Path SWAP Setting                            */
+	/*     MCDRV_DSWAP_OFF      (0)  : No SWAP                             */
+	/*     MCDRV_DSWAP_SWAP     (1)  : SWAP                                */
+	/*     MCDRV_DSWAP_MUTE     (2)  : MUTE                                */
+	/*     MCDRV_DSWAP_RMVCENTER(3)  : Center Removed                      */
+	/*     MCDRV_DSWAP_MONO     (4)  : Mono (-6dB)                         */
+	/*     MCDRV_DSWAP_MONOHALF (5)  : Reserved (do not use this setting)  */
+	/*     MCDRV_DSWAP_BOTHL    (6)  : Lch data output in both Lch and Rch */
+	/*     MCDRV_DSWAP_BOTHR    (7)  : Rch data output in both Lch and Rch */
+	MCDRV_DSWAP_OFF,
+	/* bDcCut : HP, SP Protection DC-ct Filter Setting  */
+	/*     MCDRV_DCCUT_ON (0)  : DC-cut Filter ON       */
+	/*     MCDRV_DCCUT_OFF(1)  : DC-cut Filter OFF      */
+	MCDRV_DCCUT_ON
+};
+
+/* ========================================
+   ADC settings
+   ========================================*/
+
+static const MCDRV_ADC_INFO stAdcInfo_Default = {
+	/* bAgcAdjust : AGC Gain Control Range     */
+	/*     MCDRV_AGCADJ_24(0)  : -3dB to +24dB */
+	/*     MCDRV_AGCADJ_18(1)  : -3dB to +18dB */
+	/*     MCDRV_AGCADJ_12(2)  : -3dB to +12dB */
+	/*     MCDRV_AGCADJ_0 (3)  : -3dB to  +0dB */
+	MCDRV_AGCADJ_0,
+	/* bAgcOn : AGC ON/OFF Setting */
+	/*     MCDRV_AGC_OFF(0)  : OFF */
+	/*     MCDRV_AGC_ON (1)  : ON  */
+	MCDRV_AGC_OFF,
+	/* bMonot : Mono / Stereo Setting    */
+	/*     MCDRV_ADC_STEREO(0)  : Stereo */
+	/*     MCDRV_ADC_MONO  (1)  : Mono   */
+	MCDRV_ADC_STEREO
+};
+
+/* ========================================
+   SP settings
+   ========================================*/
+static const MCDRV_SP_INFO stSpInfo_Default = {
+	/* bSwap : Swap setting                */
+	/*     MCDRV_SPSWAP_OFF (0)  : No SWAP */
+	/*     MCDRV_SPSWAP_SWAP(1)  : SWAP    */
+	MCDRV_SPSWAP_OFF
+};
+
+/* ========================================
+   DNG settings
+   ========================================*/
+static const MCDRV_DNG_INFO stDngInfo_Default = {
+	/* bOnOff[] : Digital Noise Gate On/Off Setting */
+	/*     MCDRV_DNG_OFF(0)  : OFF                */
+	/*     MCDRV_DNG_ON (1)  : ON                 */
+	{MCDRV_DNG_OFF, MCDRV_DNG_OFF, MCDRV_DNG_OFF},
+
+	/* bThreshold[] : Threshold Setting    */
+	/*     MCDRV_DNG_THRES_30    (0) */
+	/*     MCDRV_DNG_THRES_36    (1) */
+	/*     MCDRV_DNG_THRES_42    (2) */
+	/*     MCDRV_DNG_THRES_48    (3) */
+	/*     MCDRV_DNG_THRES_54    (4) */
+	/*     MCDRV_DNG_THRES_60    (5) */
+	/*     MCDRV_DNG_THRES_66    (6) */
+	/*     MCDRV_DNG_THRES_72    (7) */
+	/*     MCDRV_DNG_THRES_78    (8) */
+	/*     MCDRV_DNG_THRES_84    (9) */
+	{MCDRV_DNG_THRES_60, MCDRV_DNG_THRES_60, MCDRV_DNG_THRES_60},
+
+	/* bHold[] : Hold Time Setting         */
+	/*     MCDRV_DNG_HOLD_30 (0)  :  30ms */
+	/*     MCDRV_DNG_HOLD_120(1)  : 120ms */
+	/*     MCDRV_DNG_HOLD_500(2)  : 500ms */
+	{MCDRV_DNG_HOLD_500, MCDRV_DNG_HOLD_500, MCDRV_DNG_HOLD_500},
+
+	/* bAttack[] : Attack Time Setting        */
+	/*     MCDRV_DNG_ATTACK_25   (0)  :   25ms */
+	/*     MCDRV_DNG_ATTACK_100  (1)  :  100ms */
+	/*     MCDRV_DNG_ATTACK_400  (2)  :  400ms */
+	/*     MCDRV_DNG_ATTACK_800  (3)  :  800ms */
+	{MCDRV_DNG_ATTACK_100, MCDRV_DNG_ATTACK_100, MCDRV_DNG_ATTACK_100},
+
+	/* bRelease[] : Release Time Setting        */
+	/*     MCDRV_DNG_RELEASE_7950(0)  : 7.95ms */
+	/*     MCDRV_DNG_RELEASE_470 (1)  : 0.47ms */
+	/*     MCDRV_DNG_RELEASE_940 (2)  : 0.94ms */
+	{MCDRV_DNG_RELEASE_940, MCDRV_DNG_RELEASE_940, MCDRV_DNG_RELEASE_940},
+
+	/* bTarget[] : Target Volume Setting        */
+	/*     MCDRV_DNG_TARGET_6    (0)  : -6dB  */
+	/*     MCDRV_DNG_TARGET_9    (1)  : -9dB  */
+	/*     MCDRV_DNG_TARGET_12   (2)  : -12dB */
+	/*     MCDRV_DNG_TARGET_15   (3)  : -15dB */
+	/*     MCDRV_DNG_TARGET_18   (4)  : -18dB */
+	/*     MCDRV_DNG_TARGET_MUTE (5)  : Mute  */
+	{MCDRV_DNG_TARGET_MUTE, MCDRV_DNG_TARGET_MUTE, MCDRV_DNG_TARGET_MUTE},
+};
+#if 0
+static const MCDRV_DNG_INFO stDngInfo_Default = {
+	/* bOnOff : Digital Noise Gate On/Off Setting */
+	/*     MCDRV_DNG_OFF(0)  : OFF                */
+	/*     MCDRV_DNG_ON (1)  : ON                 */
+	MCDRV_DNG_OFF,
+
+	/* bThreshold : Threshold Setting    */
+	/*     MCDRV_DNG_THRES_5BIT  (0) */
+	/*     MCDRV_DNG_THRES_7BIT  (1) */
+	/*     MCDRV_DNG_THRES_9BIT  (2) */
+	/*     MCDRV_DNG_THRES_11BIT (3) */
+	/*     MCDRV_DNG_THRES_13BIT (4) */
+	/*     MCDRV_DNG_THRES_15BIT (5) */
+	/*     MCDRV_DNG_THRES_17BIT (6) */
+	/*     MCDRV_DNG_THRES_21BIT (7) */
+	MCDRV_DNG_THRES_11BIT,
+
+	/* bHold : Hold Time Setting         */
+	/*     MCDRV_DNG_HOLD_30 (0)  :  30ms */
+	/*     MCDRV_DNG_HOLD_120(1)  : 120ms */
+	/*     MCDRV_DNG_HOLD_500(2)  : 500ms */
+	MCDRV_DNG_HOLD_500,
+
+	/* bAttack : Attack Time Setting        */
+	/*     MCDRV_DNG_ATTACK_25   (0)  :   25ms */
+	/*     MCDRV_DNG_ATTACK_800  (1)  :  800ms */
+	/*     MCDRV_DNG_ATTACK_1100 (2)  : 1100ms */
+	MCDRV_DNG_ATTACK_1100,
+
+	/* bRelease : Release Time Setting        */
+	/*     MCDRV_DNG_RELEASE_7950(0)  : 7.95ms */
+	/*     MCDRV_DNG_RELEASE_470 (1)  : 0.47ms */
+	/*     MCDRV_DNG_RELEASE_940 (2)  : 0.94ms */
+	MCDRV_DNG_RELEASE_940,
+
+};
+#endif
+
+/* ========================================
+   AudioEngine settings
+   ========================================*/
+static MCDRV_AE_INFO sAeInfo_1 = {
+	/* On/Off */
+	0x00,
+	/* BEX */
+	{
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
+	},
+	/* WIDE */
+	{
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00
+	},
+	/* DRC */
+	{
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
+	},
+	/* EQ5 */
+	{
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00
+	},
+	/* EQ3 */
+	{
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00
+	}
+};
+
+static MCDRV_AE_INFO sAeInfo_2 = {
+	/* On/Off */
+	0x00,
+	/* BEX */
+	{
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
+	},
+	/* WIDE */
+	{
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00
+	},
+	/* DRC */
+	{
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
+	},
+	/* EQ5 */
+	{
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00
+	},
+	/* EQ3 */
+	{
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00
+	}
+};
+
+static MCDRV_AE_INFO sAeInfo_3 = {
+	/* On/Off */
+	0x00,
+	/* BEX */
+	{
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
+	},
+	/* WIDE */
+	{
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00
+	},
+	/* DRC */
+	{
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
+	},
+	/* EQ5 */
+	{
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00
+	},
+	/* EQ3 */
+	{
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00
+	}
+};
+
+static MCDRV_AE_INFO sAeInfo_4 = {
+	/* On/Off */
+	0x00,
+	/* BEX */
+	{
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
+	},
+	/* WIDE */
+	{
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00
+	},
+	/* DRC */
+	{
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
+	},
+	/* EQ5 */
+	{
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00
+	},
+	/* EQ3 */
+	{
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00
+	}
+};
+
+static MCDRV_AE_INFO sAeInfo_5 = {
+	/* On/Off */
+	0x00,
+	/* BEX */
+	{
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
+	},
+	/* WIDE */
+	{
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00
+	},
+	/* DRC */
+	{
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
+	},
+	/* EQ5 */
+	{
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00
+	},
+	/* EQ3 */
+	{
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00
+	}
+};
+
+/* ========================================
+   System EQ settings
+   ========================================*/
+static MCDRV_SYSEQ_INFO stSyseqInfo_Default = {
+	/* On/Off */
+	0x00,
+	/* EQ */
+	{
+		0x10,0xc4,0x50,0x12,0xc4,0x40,0x02,0xa9,
+		0x60,0xed,0x3b,0xc0,0xfc,0x92,0x40,
+	},
+};
+
+#endif
diff --git a/sound/soc/codecs/mc1n2/mc1n2_dbg.c b/sound/soc/codecs/mc1n2/mc1n2_dbg.c
new file mode 100644
index 0000000..d454969
--- /dev/null
+++ b/sound/soc/codecs/mc1n2/mc1n2_dbg.c
@@ -0,0 +1,439 @@
+#include <sound/soc.h>
+#include "mc1n2_priv.h"
+
+#ifdef CONFIG_SND_SOC_MC1N2_DEBUG
+
+static void mc1n2_dump_reg_info(const void *pvPrm, UINT32 dPrm)
+{
+	MCDRV_REG_INFO *info = (MCDRV_REG_INFO *)pvPrm;
+
+	dbg_info("bRegType = 0x%02x\n", info->bRegType);
+	dbg_info("bAddress = 0x%02x\n", info->bAddress);
+}
+
+static void mc1n2_dump_array(const char *name,
+			     const unsigned char *data, size_t len)
+{
+	char str[2048], *p;
+	int n = (len <= 256) ? len : 256;
+	int i;
+
+	p = str;
+	for (i = 0; i < n; i++) {
+		p += sprintf(p, "0x%02x ", data[i]);
+	}
+
+	dbg_info("%s[] = {%s}\n", name, str);
+}
+
+#define DEF_PATH(p) {offsetof(MCDRV_PATH_INFO, p), #p}
+
+static void mc1n2_dump_path_info(const void *pvPrm, UINT32 dPrm)
+{
+	MCDRV_PATH_INFO *info = (MCDRV_PATH_INFO *)pvPrm;
+	int i;
+
+	struct path_table {
+		size_t offset;
+		char *name;
+	};
+
+	struct path_table table[] = {
+		DEF_PATH(asHpOut[0]), DEF_PATH(asHpOut[1]),
+		DEF_PATH(asSpOut[0]), DEF_PATH(asSpOut[1]),
+		DEF_PATH(asRcOut[0]),
+		DEF_PATH(asLout1[0]), DEF_PATH(asLout1[1]),
+		DEF_PATH(asLout2[0]), DEF_PATH(asLout2[1]),
+		DEF_PATH(asPeak[0]),
+		DEF_PATH(asDit0[0]),
+		DEF_PATH(asDit1[0]),
+		DEF_PATH(asDit2[0]),
+		DEF_PATH(asDac[0]), DEF_PATH(asDac[1]),
+		DEF_PATH(asAe[0]),
+		DEF_PATH(asCdsp[0]), DEF_PATH(asCdsp[1]),
+		DEF_PATH(asCdsp[2]), DEF_PATH(asCdsp[3]),
+		DEF_PATH(asAdc0[0]), DEF_PATH(asAdc0[1]),
+		DEF_PATH(asAdc1[0]),
+		DEF_PATH(asMix[0]),
+		DEF_PATH(asBias[0]),
+	};
+
+#define N_PATH_TABLE (sizeof(table) / sizeof(struct path_table))
+
+	for (i = 0; i < N_PATH_TABLE; i++) {
+		MCDRV_CHANNEL *ch = (MCDRV_CHANNEL *)((void *)info + table[i].offset);
+		int j;
+		for (j = 0; j < SOURCE_BLOCK_NUM; j++) {
+			if (ch->abSrcOnOff[j] != 0) {
+				dbg_info("%s.abSrcOnOff[%d] = 0x%02x\n",
+					 table[i].name, j, ch->abSrcOnOff[j]);
+			}
+		}
+	}
+}
+
+#define DEF_VOL(v) {offsetof(MCDRV_VOL_INFO, v), #v}
+
+static void mc1n2_dump_vol_info(const void *pvPrm, UINT32 dPrm)
+{
+	MCDRV_VOL_INFO *info = (MCDRV_VOL_INFO *)pvPrm;
+	int i;
+
+	struct vol_table {
+		size_t offset;
+		char *name;
+	};
+
+	struct vol_table table[] = {
+		DEF_VOL(aswD_Ad0[0]), DEF_VOL(aswD_Ad0[1]),
+		DEF_VOL(aswD_Ad1[0]),
+		DEF_VOL(aswD_Aeng6[0]), DEF_VOL(aswD_Aeng6[1]),
+		DEF_VOL(aswD_Pdm[0]), DEF_VOL(aswD_Pdm[1]),
+		DEF_VOL(aswD_Dtmfb[0]), DEF_VOL(aswD_Dtmfb[1]),
+		DEF_VOL(aswD_Dir0[0]), DEF_VOL(aswD_Dir0[1]),
+		DEF_VOL(aswD_Dir1[0]), DEF_VOL(aswD_Dir1[1]),
+		DEF_VOL(aswD_Dir2[0]), DEF_VOL(aswD_Dir2[1]),
+		DEF_VOL(aswD_Ad0Att[0]), DEF_VOL(aswD_Ad0Att[1]),
+		DEF_VOL(aswD_Ad1Att[0]),
+		DEF_VOL(aswD_Dir0Att[0]), DEF_VOL(aswD_Dir0Att[1]),
+		DEF_VOL(aswD_Dir1Att[0]), DEF_VOL(aswD_Dir1Att[1]),
+		DEF_VOL(aswD_Dir2Att[0]), DEF_VOL(aswD_Dir2Att[1]),
+		DEF_VOL(aswD_SideTone[0]), DEF_VOL(aswD_SideTone[1]),
+		DEF_VOL(aswD_DtmfAtt[0]), DEF_VOL(aswD_DtmfAtt[1]),
+		DEF_VOL(aswD_DacMaster[0]), DEF_VOL(aswD_DacMaster[1]),
+		DEF_VOL(aswD_DacVoice[0]), DEF_VOL(aswD_DacVoice[1]),
+		DEF_VOL(aswD_DacAtt[0]), DEF_VOL(aswD_DacAtt[1]),
+		DEF_VOL(aswD_Dit0[0]), DEF_VOL(aswD_Dit0[1]),
+		DEF_VOL(aswD_Dit1[0]), DEF_VOL(aswD_Dit1[1]),
+		DEF_VOL(aswD_Dit2[0]), DEF_VOL(aswD_Dit2[1]),
+		DEF_VOL(aswA_Ad0[0]), DEF_VOL(aswA_Ad0[1]),
+		DEF_VOL(aswA_Ad1[0]),
+		DEF_VOL(aswA_Lin1[0]), DEF_VOL(aswA_Lin1[1]),
+		DEF_VOL(aswA_Lin2[0]), DEF_VOL(aswA_Lin2[1]),
+		DEF_VOL(aswA_Mic1[0]),
+		DEF_VOL(aswA_Mic2[0]),
+		DEF_VOL(aswA_Mic3[0]),
+		DEF_VOL(aswA_Hp[0]), DEF_VOL(aswA_Hp[1]),
+		DEF_VOL(aswA_Sp[0]), DEF_VOL(aswA_Sp[1]),
+		DEF_VOL(aswA_Rc[0]),
+		DEF_VOL(aswA_Lout1[0]), DEF_VOL(aswA_Lout1[1]),
+		DEF_VOL(aswA_Lout2[0]), DEF_VOL(aswA_Lout2[1]),
+		DEF_VOL(aswA_Mic1Gain[0]),
+		DEF_VOL(aswA_Mic2Gain[0]),
+		DEF_VOL(aswA_Mic3Gain[0]),
+		DEF_VOL(aswA_HpGain[0]),
+	};
+
+#define N_VOL_TABLE (sizeof(table) / sizeof(struct vol_table))
+
+	for (i = 0; i < N_VOL_TABLE; i++) {
+		SINT16 vol = *(SINT16 *)((void *)info + table[i].offset);
+		if (vol & 0x0001) {
+			dbg_info("%s = 0x%04x\n", table[i].name, (vol & 0xfffe));
+		}
+	}
+}
+
+static void mc1n2_dump_dio_info(const void *pvPrm, UINT32 dPrm)
+{
+	MCDRV_DIO_INFO *info = (MCDRV_DIO_INFO *)pvPrm;
+	MCDRV_DIO_PORT *port;
+	UINT32 update;
+	int i;
+
+	for (i = 0; i < IOPORT_NUM; i++) {
+		dbg_info("asPortInfo[%d]:\n", i);
+		port = &info->asPortInfo[i];
+		update = dPrm >> (i*3);
+		if (update & MCDRV_DIO0_COM_UPDATE_FLAG) {
+			dbg_info("sDioCommon.bMasterSlave = 0x%02x\n",
+				 port->sDioCommon.bMasterSlave);
+			dbg_info("           bAutoFs = 0x%02x\n",
+				 port->sDioCommon.bAutoFs);
+			dbg_info("           bFs = 0x%02x\n",
+				 port->sDioCommon.bFs);
+			dbg_info("           bBckFs = 0x%02x\n",
+				 port->sDioCommon.bBckFs);
+			dbg_info("           bInterface = 0x%02x\n",
+				 port->sDioCommon.bInterface);
+			dbg_info("           bBckInvert = 0x%02x\n",
+				 port->sDioCommon.bBckInvert);
+			dbg_info("           bPcmHizTim = 0x%02x\n",
+				 port->sDioCommon.bPcmHizTim);
+			dbg_info("           bPcmClkDown = 0x%02x\n",
+				 port->sDioCommon.bPcmClkDown);
+			dbg_info("           bPcmFrame = 0x%02x\n",
+				 port->sDioCommon.bPcmFrame);
+			dbg_info("           bPcmHighPeriod = 0x%02x\n",
+				 port->sDioCommon.bPcmHighPeriod);
+		}
+		if (update & MCDRV_DIO0_DIR_UPDATE_FLAG) {
+			dbg_info("sDir.wSrcRate = 0x%04x\n",
+				 port->sDir.wSrcRate);
+			dbg_info("     sDaFormat.bBitSel = 0x%02x\n",
+				 port->sDir.sDaFormat.bBitSel);
+			dbg_info("               bMode = 0x%02x\n",
+				 port->sDir.sDaFormat.bMode);
+			dbg_info("     sPcmFormat.bMono = 0x%02x\n",
+				 port->sDir.sPcmFormat.bMono);
+			dbg_info("                bOrder = 0x%02x\n",
+				 port->sDir.sPcmFormat.bOrder);
+			dbg_info("                bLaw = 0x%02x\n",
+				 port->sDir.sPcmFormat.bLaw);
+			dbg_info("                bBitSel = 0x%02x\n",
+				 port->sDir.sPcmFormat.bBitSel);
+			dbg_info("     abSlot[] = {0x%02x, 0x%02x}\n",
+				 port->sDir.abSlot[0], port->sDir.abSlot[1]);
+		}
+		if (update & MCDRV_DIO0_DIT_UPDATE_FLAG) {
+			dbg_info("sDit.wSrcRate = 0x%04x\n",
+				 port->sDit.wSrcRate);
+			dbg_info("     sDaFormat.bBitSel = 0x%02x\n",
+				 port->sDit.sDaFormat.bBitSel);
+			dbg_info("               bMode = 0x%02x\n",
+				 port->sDit.sDaFormat.bMode);
+			dbg_info("     sPcmFormat.bMono = 0x%02x\n",
+				 port->sDit.sPcmFormat.bMono);
+			dbg_info("                bOrder = 0x%02x\n",
+				 port->sDit.sPcmFormat.bOrder);
+			dbg_info("                bLaw = 0x%02x\n",
+				 port->sDit.sPcmFormat.bLaw);
+			dbg_info("                bBitSel = 0x%02x\n",
+				 port->sDit.sPcmFormat.bBitSel);
+			dbg_info("     abSlot[] = {0x%02x, 0x%02x}\n",
+				 port->sDit.abSlot[0], port->sDit.abSlot[1]);
+		}
+	}
+}
+
+static void mc1n2_dump_dac_info(const void *pvPrm, UINT32 dPrm)
+{
+	MCDRV_DAC_INFO *info = (MCDRV_DAC_INFO *)pvPrm;
+
+	if (dPrm & MCDRV_DAC_MSWP_UPDATE_FLAG) {
+		dbg_info("bMasterSwap = 0x%02x\n", info->bMasterSwap);
+	}
+	if (dPrm & MCDRV_DAC_VSWP_UPDATE_FLAG) {
+		dbg_info("bVoiceSwap = 0x%02x\n", info->bVoiceSwap);
+	}
+	if (dPrm & MCDRV_DAC_HPF_UPDATE_FLAG) {
+		dbg_info("bDcCut = 0x%02x\n", info->bDcCut);
+	}
+}
+
+static void mc1n2_dump_adc_info(const void *pvPrm, UINT32 dPrm)
+{
+	MCDRV_ADC_INFO *info = (MCDRV_ADC_INFO *)pvPrm;
+
+	if (dPrm & MCDRV_ADCADJ_UPDATE_FLAG) {
+		dbg_info("bAgcAdjust = 0x%02x\n", info->bAgcAdjust);
+	}
+	if (dPrm & MCDRV_ADCAGC_UPDATE_FLAG) {
+		dbg_info("bAgcOn = 0x%02x\n", info->bAgcOn);
+	}
+	if (dPrm & MCDRV_ADCMONO_UPDATE_FLAG) {
+		dbg_info("bMono = 0x%02x\n", info->bMono);
+	}
+}
+
+static void mc1n2_dump_sp_info(const void *pvPrm, UINT32 dPrm)
+{
+	MCDRV_SP_INFO *info = (MCDRV_SP_INFO *)pvPrm;
+
+	dbg_info("bSwap = 0x%02x\n", info->bSwap);
+}
+
+static void mc1n2_dump_dng_info(const void *pvPrm, UINT32 dPrm)
+{
+	MCDRV_DNG_INFO *info = (MCDRV_DNG_INFO *)pvPrm;
+
+	if (dPrm & MCDRV_DNGSW_HP_UPDATE_FLAG) {
+		dbg_info("HP:abOnOff = 0x%02x\n", info->abOnOff[0]);
+	}
+	if (dPrm & MCDRV_DNGTHRES_HP_UPDATE_FLAG) {
+		dbg_info("HP:abThreshold = 0x%02x\n", info->abThreshold[0]);
+	}
+	if (dPrm & MCDRV_DNGHOLD_HP_UPDATE_FLAG) {
+		dbg_info("HP:abHold = 0x%02x\n", info->abHold[0]);
+	}
+	if (dPrm & MCDRV_DNGATK_HP_UPDATE_FLAG) {
+		dbg_info("HP:abAttack = 0x%02x\n", info->abAttack[0]);
+	}
+	if (dPrm & MCDRV_DNGREL_HP_UPDATE_FLAG) {
+		dbg_info("HP:abRelease = 0x%02x\n", info->abRelease[0]);
+	}
+	if (dPrm & MCDRV_DNGTARGET_HP_UPDATE_FLAG) {
+		dbg_info("HP:abTarget = 0x%02x\n", info->abTarget[0]);
+	}
+
+	if (dPrm & MCDRV_DNGSW_SP_UPDATE_FLAG) {
+		dbg_info("SP:abOnOff = 0x%02x\n", info->abOnOff[1]);
+	}
+	if (dPrm & MCDRV_DNGTHRES_SP_UPDATE_FLAG) {
+		dbg_info("SP:abThreshold = 0x%02x\n", info->abThreshold[1]);
+	}
+	if (dPrm & MCDRV_DNGHOLD_SP_UPDATE_FLAG) {
+		dbg_info("SP:abHold = 0x%02x\n", info->abHold[1]);
+	}
+	if (dPrm & MCDRV_DNGATK_SP_UPDATE_FLAG) {
+		dbg_info("SP:abAttack = 0x%02x\n", info->abAttack[1]);
+	}
+	if (dPrm & MCDRV_DNGREL_SP_UPDATE_FLAG) {
+		dbg_info("SP:abRelease = 0x%02x\n", info->abRelease[1]);
+	}
+	if (dPrm & MCDRV_DNGTARGET_SP_UPDATE_FLAG) {
+		dbg_info("SP:abTarget = 0x%02x\n", info->abTarget[1]);
+	}
+
+	if (dPrm & MCDRV_DNGSW_RC_UPDATE_FLAG) {
+		dbg_info("RC:abOnOff = 0x%02x\n", info->abOnOff[2]);
+	}
+	if (dPrm & MCDRV_DNGTHRES_RC_UPDATE_FLAG) {
+		dbg_info("RC:abThreshold = 0x%02x\n", info->abThreshold[2]);
+	}
+	if (dPrm & MCDRV_DNGHOLD_RC_UPDATE_FLAG) {
+		dbg_info("RC:abHold = 0x%02x\n", info->abHold[2]);
+	}
+	if (dPrm & MCDRV_DNGATK_RC_UPDATE_FLAG) {
+		dbg_info("RC:abAttack = 0x%02x\n", info->abAttack[2]);
+	}
+	if (dPrm & MCDRV_DNGREL_RC_UPDATE_FLAG) {
+		dbg_info("RC:abRelease = 0x%02x\n", info->abRelease[2]);
+	}
+	if (dPrm & MCDRV_DNGTARGET_RC_UPDATE_FLAG) {
+		dbg_info("RC:abTarget = 0x%02x\n", info->abTarget[2]);
+	}
+}
+
+static void mc1n2_dump_ae_info(const void *pvPrm, UINT32 dPrm)
+{
+	MCDRV_AE_INFO *info = (MCDRV_AE_INFO *)pvPrm;
+
+	dbg_info("bOnOff = 0x%02x\n", info->bOnOff);
+	if (dPrm & MCDRV_AEUPDATE_FLAG_BEX) {
+		mc1n2_dump_array("abBex", info->abBex, BEX_PARAM_SIZE);
+	}
+	if (dPrm & MCDRV_AEUPDATE_FLAG_WIDE) {
+		mc1n2_dump_array("abWide", info->abWide, WIDE_PARAM_SIZE);
+	}
+	if (dPrm & MCDRV_AEUPDATE_FLAG_DRC) {
+		mc1n2_dump_array("abDrc", info->abDrc, DRC_PARAM_SIZE);
+	}
+	if (dPrm & MCDRV_AEUPDATE_FLAG_EQ5) {
+		mc1n2_dump_array("abEq5", info->abEq5, EQ5_PARAM_SIZE);
+	}
+	if (dPrm & MCDRV_AEUPDATE_FLAG_EQ3) {
+		mc1n2_dump_array("abEq3", info->abEq3, EQ5_PARAM_SIZE);
+	}
+}
+
+static void mc1n2_dump_pdm_info(const void *pvPrm, UINT32 dPrm)
+{
+	MCDRV_PDM_INFO *info = (MCDRV_PDM_INFO *)pvPrm;
+
+	if (dPrm & MCDRV_PDMCLK_UPDATE_FLAG) {
+		dbg_info("bClk = 0x%02x\n", info->bClk);
+	}
+	if (dPrm & MCDRV_PDMADJ_UPDATE_FLAG) {
+		dbg_info("bAgcAdjust = 0x%02x\n", info->bAgcAdjust);
+	}
+	if (dPrm & MCDRV_PDMAGC_UPDATE_FLAG) {
+		dbg_info("bAgcOn = 0x%02x\n", info->bAgcOn);
+	}
+	if (dPrm & MCDRV_PDMEDGE_UPDATE_FLAG) {
+		dbg_info("bPdmEdge = 0x%02x\n", info->bPdmEdge);
+	}
+	if (dPrm & MCDRV_PDMWAIT_UPDATE_FLAG) {
+		dbg_info("bPdmWait = 0x%02x\n", info->bPdmWait);
+	}
+	if (dPrm & MCDRV_PDMSEL_UPDATE_FLAG) {
+		dbg_info("bPdmSel = 0x%02x\n", info->bPdmSel);
+	}
+	if (dPrm & MCDRV_PDMMONO_UPDATE_FLAG) {
+		dbg_info("bMono = 0x%02x\n", info->bMono);
+	}
+}
+
+static void mc1n2_dump_clksw_info(const void *pvPrm, UINT32 dPrm)
+{
+	MCDRV_CLKSW_INFO *info = (MCDRV_CLKSW_INFO *)pvPrm;
+
+	dbg_info("bClkSrc = 0x%02x\n", info->bClkSrc);
+}
+
+static void mc1n2_dump_syseq_info(const void *pvPrm, UINT32 dPrm)
+{
+	MCDRV_SYSEQ_INFO *info = (MCDRV_SYSEQ_INFO *)pvPrm;
+	int i;
+
+	if (dPrm & MCDRV_SYSEQ_ONOFF_UPDATE_FLAG) {
+		dbg_info("bOnOff = 0x%02x\n", info->bOnOff);
+	}
+	if (dPrm & MCDRV_SYSEQ_PARAM_UPDATE_FLAG) {
+		for (i = 0; i < 15; i++){
+			dbg_info("abParam[%d] = 0x%02x\n", i, info->abParam[i]);
+		}
+	}
+}
+
+struct mc1n2_dump_func {
+	char *name;
+	void (*func)(const void *, UINT32);
+};
+
+struct mc1n2_dump_func mc1n2_dump_func_map[] = {
+	{"MCDRV_INIT", NULL},
+	{"MCDRV_TERM", NULL},
+	{"MCDRV_READ_REG", mc1n2_dump_reg_info},
+	{"MCDRV_WRITE_REG", NULL},
+	{"MCDRV_GET_PATH", NULL},
+	{"MCDRV_SET_PATH", mc1n2_dump_path_info},
+	{"MCDRV_GET_VOLUME", NULL},
+	{"MCDRV_SET_VOLUME", mc1n2_dump_vol_info},
+	{"MCDRV_GET_DIGITALIO", NULL},
+	{"MCDRV_SET_DIGITALIO", mc1n2_dump_dio_info},
+	{"MCDRV_GET_DAC", NULL},
+	{"MCDRV_SET_DAC", mc1n2_dump_dac_info},
+	{"MCDRV_GET_ADC", NULL},
+	{"MCDRV_SET_ADC", mc1n2_dump_adc_info},
+	{"MCDRV_GET_SP", NULL},
+	{"MCDRV_SET_SP", mc1n2_dump_sp_info},
+	{"MCDRV_GET_DNG", NULL},
+	{"MCDRV_SET_DNG", mc1n2_dump_dng_info},
+	{"MCDRV_SET_AUDIOENGINE", mc1n2_dump_ae_info},
+	{"MCDRV_SET_AUDIOENGINE_EX", NULL},
+	{"MCDRV_SET_CDSP", NULL},
+	{"MCDRV_GET_CDSP_PARAM", NULL},
+	{"MCDRV_SET_CDSP_PARAM", NULL},
+	{"MCDRV_REGISTER_CDSP_CB", NULL},
+	{"MCDRV_GET_PDM", NULL},
+	{"MCDRV_SET_PDM", mc1n2_dump_pdm_info},
+	{"MCDRV_SET_DTMF", NULL},
+	{"MCDRV_CONFIG_GP", NULL},
+	{"MCDRV_MASK_GP", NULL},
+	{"MCDRV_GETSET_GP", NULL},
+	{"MCDRV_GET_PEAK", NULL},
+	{"MCDRV_IRQ", NULL},
+	{"MCDRV_UPDATE_CLOCK", NULL},
+	{"MCDRV_SWITCH_CLOCK", mc1n2_dump_clksw_info},
+	{"MCDRV_GET_SYSEQ", NULL},
+	{"MCDRV_SET_SYSEQ", mc1n2_dump_syseq_info},
+};
+
+SINT32 McDrv_Ctrl_dbg(UINT32 dCmd, void *pvPrm, UINT32 dPrm)
+{
+	SINT32 err;
+
+	dbg_info("calling %s:\n", mc1n2_dump_func_map[dCmd].name);
+
+	if (mc1n2_dump_func_map[dCmd].func) {
+		mc1n2_dump_func_map[dCmd].func(pvPrm, dPrm);
+	}
+
+	err = McDrv_Ctrl(dCmd, pvPrm, dPrm);
+	dbg_info("err = %ld\n", err);
+
+	return err;
+}
+
+#endif /* CONFIG_SND_SOC_MC1N2_DEBUG */
diff --git a/sound/soc/codecs/mc1n2/mc1n2_priv.h b/sound/soc/codecs/mc1n2/mc1n2_priv.h
new file mode 100644
index 0000000..47dee1a
--- /dev/null
+++ b/sound/soc/codecs/mc1n2/mc1n2_priv.h
@@ -0,0 +1,196 @@
+/*
+ * MC-1N2 ASoC codec driver - private header
+ *
+ * Copyright (c) 2010 Yamaha Corporation
+ *
+ * This software is provided 'as-is', without any express or implied
+ * warranty.  In no event will the authors be held liable for any damages
+ * arising from the use of this software.
+ *
+ * Permission is granted to anyone to use this software for any purpose,
+ * including commercial applications, and to alter it and redistribute it
+ * freely, subject to the following restrictions:
+ *
+ * 1. The origin of this software must not be misrepresented; you must not
+ *    claim that you wrote the original software. If you use this software
+ *    in a product, an acknowledgment in the product documentation would be
+ *    appreciated but is not required.
+ * 2. Altered source versions must be plainly marked as such, and must not be
+ *    misrepresented as being the original software.
+ * 3. This notice may not be removed or altered from any source distribution.
+ */
+
+#ifndef MC1N2_PRIV_H
+#define MC1N2_PRIV_H
+
+#include "mcdriver.h"
+
+/*
+ * Virtual registers
+ */
+enum {
+	MC1N2_DVOL_AD0,
+	MC1N2_DVOL_AENG6,
+	MC1N2_DVOL_PDM,
+	MC1N2_DVOL_DIR0,
+	MC1N2_DVOL_DIR1,
+	MC1N2_DVOL_DIR2,
+	MC1N2_DVOL_AD0_ATT,
+	MC1N2_DVOL_DIR0_ATT,
+	MC1N2_DVOL_DIR1_ATT,
+	MC1N2_DVOL_DIR2_ATT,
+	MC1N2_DVOL_SIDETONE,
+	MC1N2_DVOL_DAC_MASTER,
+	MC1N2_DVOL_DAC_VOICE,
+	MC1N2_DVOL_DAC_ATT,
+	MC1N2_DVOL_DIT0,
+	MC1N2_DVOL_DIT1,
+	MC1N2_DVOL_DIT2,
+	MC1N2_AVOL_AD0,
+	MC1N2_AVOL_LIN1,
+	MC1N2_AVOL_MIC1,
+	MC1N2_AVOL_MIC2,
+	MC1N2_AVOL_MIC3,
+	MC1N2_AVOL_HP,
+	MC1N2_AVOL_SP,
+	MC1N2_AVOL_RC,
+	MC1N2_AVOL_LOUT1,
+	MC1N2_AVOL_LOUT2,
+	MC1N2_AVOL_MIC1_GAIN,
+	MC1N2_AVOL_MIC2_GAIN,
+	MC1N2_AVOL_MIC3_GAIN,
+	MC1N2_AVOL_HP_GAIN,
+
+	MC1N2_ADCL_MIC1_SW,
+	MC1N2_ADCL_MIC2_SW,
+	MC1N2_ADCL_MIC3_SW,
+	MC1N2_ADCL_LINE_SW,
+	MC1N2_ADCR_MIC1_SW,
+	MC1N2_ADCR_MIC2_SW,
+	MC1N2_ADCR_MIC3_SW,
+	MC1N2_ADCR_LINE_SW,
+
+	MC1N2_HPL_MIC1_SW,
+	MC1N2_HPL_MIC2_SW,
+	MC1N2_HPL_MIC3_SW,
+	MC1N2_HPL_LINE_SW,
+	MC1N2_HPL_DAC_SW,
+
+	MC1N2_HPR_MIC1_SW,
+	MC1N2_HPR_MIC2_SW,
+	MC1N2_HPR_MIC3_SW,
+	MC1N2_HPR_LINER_SW,
+	MC1N2_HPR_DACR_SW,
+
+	MC1N2_SPL_LINE_SW,
+	MC1N2_SPL_DAC_SW,
+	MC1N2_SPR_LINE_SW,
+	MC1N2_SPR_DAC_SW,
+
+	MC1N2_RC_MIC1_SW,
+	MC1N2_RC_MIC2_SW,
+	MC1N2_RC_MIC3_SW,
+	MC1N2_RC_LINEMONO_SW,
+	MC1N2_RC_DACL_SW,
+	MC1N2_RC_DACR_SW,
+
+	MC1N2_LOUT1L_MIC1_SW,
+	MC1N2_LOUT1L_MIC2_SW,
+	MC1N2_LOUT1L_MIC3_SW,
+	MC1N2_LOUT1L_LINE_SW,
+	MC1N2_LOUT1L_DAC_SW,
+
+	MC1N2_LOUT1R_MIC1_SW,
+	MC1N2_LOUT1R_MIC2_SW,
+	MC1N2_LOUT1R_MIC3_SW,
+	MC1N2_LOUT1R_LINER_SW,
+	MC1N2_LOUT1R_DACR_SW,
+
+	MC1N2_LOUT2L_MIC1_SW,
+	MC1N2_LOUT2L_MIC2_SW,
+	MC1N2_LOUT2L_MIC3_SW,
+	MC1N2_LOUT2L_LINE_SW,
+	MC1N2_LOUT2L_DAC_SW,
+
+	MC1N2_LOUT2R_MIC1_SW,
+	MC1N2_LOUT2R_MIC2_SW,
+	MC1N2_LOUT2R_MIC3_SW,
+	MC1N2_LOUT2R_LINER_SW,
+	MC1N2_LOUT2R_DACR_SW,
+
+	MC1N2_DMIX_ADC_SW,
+	MC1N2_DMIX_DIR0_SW,
+	MC1N2_DMIX_DIR1_SW,
+	MC1N2_DMIX_DIR2_SW,
+
+	MC1N2_DACMAIN_SRC,
+	MC1N2_DACVOICE_SRC,
+	MC1N2_DIT0_SRC,
+	MC1N2_DIT1_SRC,
+	MC1N2_DIT2_SRC,
+	MC1N2_AE_SRC,
+
+	MC1N2_ADCL_LINE_SRC,
+	MC1N2_ADCR_LINE_SRC,
+	MC1N2_HPL_LINE_SRC,
+	MC1N2_HPL_DAC_SRC,
+	MC1N2_SPL_LINE_SRC,
+	MC1N2_SPL_DAC_SRC,
+	MC1N2_SPR_LINE_SRC,
+	MC1N2_SPR_DAC_SRC,
+	MC1N2_LOUT1L_LINE_SRC,
+	MC1N2_LOUT1L_DAC_SRC,
+	MC1N2_LOUT2L_LINE_SRC,
+	MC1N2_LOUT2L_DAC_SRC,
+
+	MC1N2_AE_PARAM_SEL,
+	MC1N2_ADC_PDM_SEL,
+
+	MC1N2_MICBIAS1,
+	MC1N2_MICBIAS2,
+	MC1N2_MICBIAS3,
+
+	MC1N2_N_REG
+};
+
+#define MC1N2_N_VOL_REG MC1N2_ADCL_MIC1_SW	 
+
+#define MC1N2_DSOURCE_OFF		0
+#define MC1N2_DSOURCE_ADC		1
+#define MC1N2_DSOURCE_DIR0		2
+#define MC1N2_DSOURCE_DIR1		3
+#define MC1N2_DSOURCE_DIR2		4
+#define MC1N2_DSOURCE_MIX		5
+
+#define MC1N2_AE_PARAM_1		0
+#define MC1N2_AE_PARAM_2		1
+#define MC1N2_AE_PARAM_3		2
+#define MC1N2_AE_PARAM_4		3
+#define MC1N2_AE_PARAM_5		4
+
+#define mc1n2_i2c_read_byte(c,r) i2c_smbus_read_byte_data((c), (r)<<1)
+
+extern struct i2c_client *mc1n2_get_i2c_client(void);
+
+/*
+ * For debugging
+ */
+#ifdef CONFIG_SND_SOC_MC1N2_DEBUG
+
+#define dbg_info(format, arg...) snd_printd(KERN_INFO format, ## arg)
+#define TRACE_FUNC() snd_printd(KERN_INFO "<trace> %s()\n", __FUNCTION__)
+
+
+#define _McDrv_Ctrl McDrv_Ctrl_dbg
+extern SINT32 McDrv_Ctrl_dbg(UINT32 dCmd, void *pvPrm, UINT32 dPrm);
+
+#else
+
+#define dbg_info(format, arg...)
+#define TRACE_FUNC()
+
+#define _McDrv_Ctrl McDrv_Ctrl
+
+#endif /* CONFIG_SND_SOC_MC1N2_DEBUG */
+
+#endif /* MC1N2_PRIV_H */
diff --git a/sound/soc/codecs/mc1n2/mcdebuglog.c b/sound/soc/codecs/mc1n2/mcdebuglog.c
new file mode 100644
index 0000000..5f1e61c0
--- /dev/null
+++ b/sound/soc/codecs/mc1n2/mcdebuglog.c
@@ -0,0 +1,1771 @@
+/****************************************************************************
+ *
+ *		Copyright(c) 2010 Yamaha Corporation. All rights reserved.
+ *
+ *		Module		: mcdebuglog.c
+ *
+ *		Description	: MC Driver debug log
+ *
+ *		Version		: 1.0.0		2010.09.10
+ *
+ ****************************************************************************/
+
+
+#include "mcdebuglog.h"
+#include "mcresctrl.h"
+
+#if MCDRV_DEBUG_LEVEL
+
+#include "mcdefs.h"
+#include "mcdevprof.h"
+#include "mcservice.h"
+#include "mcmachdep.h"
+
+
+
+typedef char	CHAR;
+
+static CHAR	gsbLogString[8192];
+static CHAR	gsbLFCode[]	= "\n";
+
+static const CHAR	gsbCmdName[][20]	=
+{
+	"init",
+	"term",
+	"read_reg",
+	"write_reg",
+	"get_path",
+	"set_path",
+	"get_volume",
+	"set_volume",
+	"get_digitalio",
+	"set_digitalio",
+	"get_dac",
+	"set_dac",
+	"get_adc",
+	"set_adc",
+	"get_sp",
+	"set_sp",
+	"get_dng",
+	"set_dng",
+	"set_ae",
+	"set_aeex",
+	"set_cdsp",
+	"get_cdspparam",
+	"set_cdspparam",
+	"reg_cdsp_cb",
+	"get_pdm",
+	"set_pdm",
+	"set_dtmf",
+	"config_gp",
+	"mask_gp",
+	"getset_gp",
+	"get_peak",
+	"irq",
+	"update_clock",
+	"switch_clock",
+	"get_syseq",
+	"set_syseq"
+};
+
+
+static void	OutputRegDump(void);
+static void	GetRegDump_B(CHAR* psbLogString, UINT8 bSlaveAddr, UINT8 bADRAddr, UINT8 bWINDOWAddr, UINT8 bRegType);
+
+static void	MakeInitInfoLog(const MCDRV_INIT_INFO* pParam);
+static void	MakeRegInfoLog(const MCDRV_REG_INFO* pParam);
+static void	MakeClockInfoLog(const MCDRV_CLOCK_INFO* pParam);
+static void	MakeClockSwInfoLog(const MCDRV_CLKSW_INFO* pParam);
+static void	MakePathInfoLog(const MCDRV_PATH_INFO* pParam);
+static void	MakeVolInfoLog(const MCDRV_VOL_INFO* pParam);
+static void	MakeDIOInfoLog(const MCDRV_DIO_INFO* pParam);
+static void	MakeDACInfoLog(const MCDRV_DAC_INFO* pParam);
+static void	MakeADCInfoLog(const MCDRV_ADC_INFO* pParam);
+static void	MakeSpInfoLog(const MCDRV_SP_INFO* pParam);
+static void	MakeDNGInfoLog(const MCDRV_DNG_INFO* pParam);
+static void	MakeAEInfoLog(const MCDRV_AE_INFO* pParam);
+static void	MakeAEExInfoLog(const UINT16* pParam);
+static void	MakeSetCDSPLog(const UINT16* pParam);
+static void	MakeCDSPParamLog(const MCDRV_CDSPPARAM* pParam);
+static void	MakeCDSPCBLog(const void* pParam);
+static void	MakePDMInfoLog(const MCDRV_PDM_INFO* pParam);
+static void	MakeDTMFInfoLog(const MCDRV_DTMF_INFO* pParam);
+static void	MakeGPModeLog(const MCDRV_GP_MODE* pParam);
+static void	MakeGPMaskLog(const UINT8* pParam);
+static void	MakeGetSetGPLog(const UINT8* pParam);
+static void	MakePeakLog(const MCDRV_PEAK* pParam);
+static void	MakeSysEQInfoLog(const MCDRV_SYSEQ_INFO* pParam);
+
+/****************************************************************************
+ *	McDebugLog_CmdIn
+ *
+ *	Description:
+ *			Output Function entrance log.
+ *	Arguments:
+ *			dCmd		Command ID
+ *			pvParam		pointer to parameter
+ *			dUpdateInfo	Update info
+ *	Return:
+ *			none
+ *
+ ****************************************************************************/
+void	McDebugLog_CmdIn
+(
+	UINT32		dCmd,
+	const void*	pvParam,
+	UINT32		dUpdateInfo
+)
+{
+	CHAR	sbStr[80];
+	UINT8	bLevel	= MCDRV_DEBUG_LEVEL;
+
+	if(dCmd >= sizeof(gsbCmdName)/sizeof(gsbCmdName[0]))
+	{
+		return;
+	}
+
+	strcpy(gsbLogString, gsbCmdName[dCmd]);
+	strcat(gsbLogString, " In");
+
+	if(bLevel < 2)
+	{
+		strcat(gsbLogString, gsbLFCode);
+		machdep_DebugPrint((UINT8*)(void*)gsbLogString);
+		return;
+	}
+
+	switch(dCmd)
+	{
+	case	MCDRV_INIT:
+		MakeInitInfoLog((MCDRV_INIT_INFO*)pvParam);
+		break;
+	case	MCDRV_READ_REG:
+	case	MCDRV_WRITE_REG:
+		MakeRegInfoLog((MCDRV_REG_INFO*)pvParam);
+		break;
+	case	MCDRV_UPDATE_CLOCK:
+		MakeClockInfoLog((MCDRV_CLOCK_INFO*)pvParam);
+		break;
+	case	MCDRV_SWITCH_CLOCK:
+		MakeClockSwInfoLog((MCDRV_CLKSW_INFO*)pvParam);
+		break;
+	case	MCDRV_SET_PATH:
+		MakePathInfoLog((MCDRV_PATH_INFO*)pvParam);
+		break;
+	case	MCDRV_SET_VOLUME:
+		MakeVolInfoLog((MCDRV_VOL_INFO*)pvParam);
+		break;
+	case	MCDRV_SET_DIGITALIO:
+		MakeDIOInfoLog((MCDRV_DIO_INFO*)pvParam);
+		sprintf(sbStr, " dPrm=%08lX", dUpdateInfo);
+		strcat(gsbLogString, sbStr);
+		break;
+	case	MCDRV_SET_DAC:
+		MakeDACInfoLog((MCDRV_DAC_INFO*)pvParam);
+		sprintf(sbStr, " dPrm=%08lX", dUpdateInfo);
+		strcat(gsbLogString, sbStr);
+		break;
+	case	MCDRV_SET_ADC:
+		MakeADCInfoLog((MCDRV_ADC_INFO*)pvParam);
+		sprintf(sbStr, " dPrm=%08lX", dUpdateInfo);
+		strcat(gsbLogString, sbStr);
+		break;
+	case	MCDRV_SET_SP:
+		MakeSpInfoLog((MCDRV_SP_INFO*)pvParam);
+		break;
+	case	MCDRV_SET_DNG:
+		MakeDNGInfoLog((MCDRV_DNG_INFO*)pvParam);
+		sprintf(sbStr, " dPrm=%08lX", dUpdateInfo);
+		strcat(gsbLogString, sbStr);
+		break;
+	case	MCDRV_SET_AUDIOENGINE:
+		MakeAEInfoLog((MCDRV_AE_INFO*)pvParam);
+		sprintf(sbStr, " dPrm=%08lX", dUpdateInfo);
+		strcat(gsbLogString, sbStr);
+		break;
+	case	MCDRV_SET_AUDIOENGINE_EX:
+		MakeAEExInfoLog((UINT16*)pvParam);
+		sprintf(sbStr, " dPrm=%08lX", dUpdateInfo);
+		strcat(gsbLogString, sbStr);
+		break;
+	case	MCDRV_SET_CDSP:
+		MakeSetCDSPLog((UINT16*)pvParam);
+		sprintf(sbStr, " dPrm=%08lX", dUpdateInfo);
+		strcat(gsbLogString, sbStr);
+		break;
+	case	MCDRV_SET_CDSP_PARAM:
+		MakeCDSPParamLog((MCDRV_CDSPPARAM*)pvParam);
+		break;
+	case	MCDRV_REGISTER_CDSP_CB:
+		MakeCDSPCBLog(pvParam);
+		break;
+	case	MCDRV_SET_PDM:
+		MakePDMInfoLog((MCDRV_PDM_INFO*)pvParam);
+		sprintf(sbStr, " dPrm=%08lX", dUpdateInfo);
+		strcat(gsbLogString, sbStr);
+		break;
+	case	MCDRV_SET_DTMF:
+		MakeDTMFInfoLog((MCDRV_DTMF_INFO*)pvParam);
+		break;
+	case	MCDRV_CONFIG_GP:
+		MakeGPModeLog((MCDRV_GP_MODE*)pvParam);
+		break;
+	case	MCDRV_MASK_GP:
+		MakeGPMaskLog((UINT8*)pvParam);
+		sprintf(sbStr, " dPrm=%08lX", dUpdateInfo);
+		strcat(gsbLogString, sbStr);
+		break;
+	case	MCDRV_GETSET_GP:
+		MakeGetSetGPLog((UINT8*)pvParam);
+		sprintf(sbStr, " dPrm=%08lX", dUpdateInfo);
+		strcat(gsbLogString, sbStr);
+		break;
+	case	MCDRV_SET_SYSEQ:
+		MakeSysEQInfoLog((MCDRV_SYSEQ_INFO*)pvParam);
+		sprintf(sbStr, " dPrm=%08lX", dUpdateInfo);
+		strcat(gsbLogString, sbStr);
+		break;
+
+	default:
+		break;
+	}
+
+	strcat(gsbLogString, gsbLFCode);
+	machdep_DebugPrint((UINT8*)(void*)gsbLogString);
+}
+
+/****************************************************************************
+ *	McDebugLog_CmdOut
+ *
+ *	Description:
+ *			Output Function exit log.
+ *	Arguments:
+ *			dCmd		Command ID
+ *			psdRet		retrun value
+ *			pvParam		pointer to parameter
+ *	Return:
+ *			none
+ *
+ ****************************************************************************/
+void	McDebugLog_CmdOut
+(
+	UINT32			dCmd,
+	const SINT32*	psdRet,
+	const void*		pvParam
+)
+{
+	CHAR	sbStr[80];
+	UINT8	bLevel	= MCDRV_DEBUG_LEVEL;
+
+	if(dCmd >= sizeof(gsbCmdName)/sizeof(gsbCmdName[0]))
+	{
+		return;
+	}
+
+	strcpy(gsbLogString, gsbCmdName[dCmd]);
+	strcat(gsbLogString, " Out");
+	if(psdRet != NULL)
+	{
+		sprintf(sbStr, " ret=%ld", *psdRet);
+		strcat(gsbLogString, sbStr);
+	}
+
+	if(bLevel < 2)
+	{
+		strcat(gsbLogString, gsbLFCode);
+		machdep_DebugPrint((UINT8*)(void*)gsbLogString);
+		return;
+	}
+
+	switch(dCmd)
+	{
+	case	MCDRV_READ_REG:
+		MakeRegInfoLog((MCDRV_REG_INFO*)pvParam);
+		break;
+	case	MCDRV_GET_PATH:
+		MakePathInfoLog((MCDRV_PATH_INFO*)pvParam);
+		break;
+	case	MCDRV_GET_VOLUME:
+		MakeVolInfoLog((MCDRV_VOL_INFO*)pvParam);
+		break;
+	case	MCDRV_GET_DIGITALIO:
+		MakeDIOInfoLog((MCDRV_DIO_INFO*)pvParam);
+		break;
+	case	MCDRV_GET_DAC:
+		MakeDACInfoLog((MCDRV_DAC_INFO*)pvParam);
+		break;
+	case	MCDRV_GET_ADC:
+		MakeADCInfoLog((MCDRV_ADC_INFO*)pvParam);
+		break;
+	case	MCDRV_GET_SP:
+		MakeSpInfoLog((MCDRV_SP_INFO*)pvParam);
+		break;
+	case	MCDRV_GET_DNG:
+		MakeDNGInfoLog((MCDRV_DNG_INFO*)pvParam);
+		break;
+	case	MCDRV_GET_CDSP_PARAM:
+		MakeCDSPParamLog((MCDRV_CDSPPARAM*)pvParam);
+		break;
+	case	MCDRV_GET_PDM:
+		MakePDMInfoLog((MCDRV_PDM_INFO*)pvParam);
+		break;
+	case	MCDRV_GETSET_GP:
+		MakeGetSetGPLog((UINT8*)pvParam);
+		break;
+	case	MCDRV_GET_PEAK:
+		MakePeakLog((MCDRV_PEAK*)pvParam);
+		break;
+	case	MCDRV_GET_SYSEQ:
+		MakeSysEQInfoLog((MCDRV_SYSEQ_INFO*)pvParam);
+		break;
+
+	default:
+		break;
+	}
+	strcat(gsbLogString, gsbLFCode);
+	machdep_DebugPrint((UINT8*)(void*)gsbLogString);
+
+	if(bLevel < 3)
+	{
+		return;
+	}
+
+	OutputRegDump();
+}
+
+/****************************************************************************
+ *	McDebugLog_FuncIn
+ *
+ *	Description:
+ *			Output Function entrance log.
+ *	Arguments:
+ *			pbFuncName	function name
+ *	Return:
+ *			none
+ *
+ ****************************************************************************/
+void	McDebugLog_FuncIn
+(
+	void*	pvFuncName
+)
+{
+	strcpy(gsbLogString, (CHAR*)pvFuncName);
+	strcat(gsbLogString, " In");
+
+	strcat(gsbLogString, gsbLFCode);
+	machdep_DebugPrint((UINT8*)(void*)gsbLogString);
+}
+
+/****************************************************************************
+ *	McDebugLog_FuncOut
+ *
+ *	Description:
+ *			Output Function exit log.
+ *	Arguments:
+ *			pbFuncName	function name
+ *			psdRet		retrun value
+ *	Return:
+ *			none
+ *
+ ****************************************************************************/
+void	McDebugLog_FuncOut
+(
+	void*			pvFuncName,
+	const SINT32*	psdRet
+)
+{
+	CHAR	sbStr[80];
+
+	strcpy(gsbLogString, (CHAR*)pvFuncName);
+	strcat(gsbLogString, " Out");
+	if(psdRet != NULL)
+	{
+		sprintf(sbStr, " ret=%ld", *psdRet);
+		strcat(gsbLogString, sbStr);
+	}
+
+	strcat(gsbLogString, gsbLFCode);
+	machdep_DebugPrint((UINT8*)(void*)gsbLogString);
+}
+
+
+/****************************************************************************
+ *	OutputRegDump
+ *
+ *	Description:
+ *			Output Register dump.
+ *	Arguments:
+ *			none
+ *	Return:
+ *			none
+ *
+ ****************************************************************************/
+static void	OutputRegDump
+(
+	void
+)
+{
+	UINT16	i;
+	CHAR	sbStr[10];
+	CHAR	sbLogString[2500]="";
+	UINT8	bSlaveAddr	= McDevProf_GetSlaveAddr(eMCDRV_SLAVE_ADDR_DIG);
+	MCDRV_REG_INFO	sRegInfo;
+
+	/*	A_ADR	*/
+	sRegInfo.bRegType	= MCDRV_REGTYPE_A;
+	strcpy(sbLogString, "A_ADR:");
+	for(i = 0; i < 256UL; i++)
+	{
+		sRegInfo.bAddress	= (UINT8)i;
+		if((McResCtrl_GetRegAccess(&sRegInfo) & eMCDRV_READ_ONLY) != 0)
+		{
+			sprintf(sbStr, "[%d]=%02X", i, McSrv_ReadI2C(bSlaveAddr, i));
+			strcat(sbLogString, sbStr);
+			if(i < 255UL)
+			{
+				strcat(sbLogString, " ");
+			}
+		}
+	}
+	strcat(sbLogString, gsbLFCode);
+	machdep_DebugPrint((UINT8*)(void*)sbLogString);
+
+	/*	BASE_ADR	*/
+	strcpy(sbLogString, "BASE_ADR:");
+	GetRegDump_B(sbLogString, bSlaveAddr, MCI_BASE_ADR, MCI_BASE_WINDOW, MCDRV_REGTYPE_B_BASE);
+	strcat(sbLogString, gsbLFCode);
+	machdep_DebugPrint((UINT8*)(void*)sbLogString);
+
+	/*	ANA_ADR	*/
+	strcpy(sbLogString, "ANA_ADR:");
+	GetRegDump_B(sbLogString, McDevProf_GetSlaveAddr(eMCDRV_SLAVE_ADDR_ANA), MCI_ANA_ADR, MCI_ANA_WINDOW, MCDRV_REGTYPE_B_ANALOG);
+	strcat(sbLogString, gsbLFCode);
+	machdep_DebugPrint((UINT8*)(void*)sbLogString);
+
+	/*	CD_ADR	*/
+	strcpy(sbLogString, "CD_ADR:");
+	GetRegDump_B(sbLogString, bSlaveAddr, MCI_CD_ADR, MCI_CD_WINDOW, MCDRV_REGTYPE_B_CODEC);
+	strcat(sbLogString, gsbLFCode);
+	machdep_DebugPrint((UINT8*)(void*)sbLogString);
+
+	/*	MIX_ADR	*/
+	strcpy(sbLogString, "MIX_ADR:");
+	GetRegDump_B(sbLogString, bSlaveAddr, MCI_MIX_ADR, MCI_MIX_WINDOW, MCDRV_REGTYPE_B_MIXER);
+	strcat(sbLogString, gsbLFCode);
+	machdep_DebugPrint((UINT8*)(void*)sbLogString);
+
+#if 0
+	/*	AE_ADR	*/
+	strcpy(sbLogString, "AE_ADR:");
+	GetRegDump_B(sbLogString, bSlaveAddr, MCI_AE_ADR, MCI_AE_WINDOW, MCDRV_REGTYPE_B_AE);
+	strcat(sbLogString, gsbLFCode);
+	machdep_DebugPrint((UINT8*)(void*)sbLogString);
+#endif
+}
+
+/****************************************************************************
+ *	GetRegDump_B
+ *
+ *	Description:
+ *			Get B-ADR Register dump string.
+ *	Arguments:
+ *			psbLogString	string buffer
+ *			bSlaveAddr		Slave address
+ *			bADRAddr		ADR address
+ *			bWINDOWAddr		WINDOW address
+ *			bRegType		register type
+ *	Return:
+ *			none
+ *
+ ****************************************************************************/
+static void	GetRegDump_B
+(
+	CHAR*	psbLogString,
+	UINT8	bSlaveAddr,
+	UINT8	bADRAddr,
+	UINT8	bWINDOWAddr,
+	UINT8	bRegType
+)
+{
+	UINT16	i;
+	CHAR	sbStr[10];
+	UINT8	abData[2];
+	MCDRV_REG_INFO	sRegInfo;
+
+	abData[0]	= bADRAddr<<1;
+	sRegInfo.bRegType	= bRegType;
+
+	for(i = 0; i < 256UL; i++)
+	{
+		sRegInfo.bAddress	= (UINT8)i;
+		if((McResCtrl_GetRegAccess(&sRegInfo) & eMCDRV_READ_ONLY) != 0)
+		{
+			abData[1]	= (UINT8)i;
+			McSrv_WriteI2C(bSlaveAddr, abData, 2);
+			sprintf(sbStr, "[%d]=%02X", i, McSrv_ReadI2C(bSlaveAddr, bWINDOWAddr));
+			strcat(psbLogString, sbStr);
+			if(i < 255UL)
+			{
+				strcat(psbLogString, " ");
+			}
+		}
+	}
+}
+
+/****************************************************************************
+ *	MakeInitInfoLog
+ *
+ *	Description:
+ *			Make Init Parameter log.
+ *	Arguments:
+ *			pParam	pointer to parameter
+ *	Return:
+ *			none
+ *
+ ****************************************************************************/
+static void	MakeInitInfoLog
+(
+	const MCDRV_INIT_INFO*	pParam
+)
+{
+	CHAR	sbStr[80];
+
+	if(pParam == NULL)
+	{
+		strcat(gsbLogString, " param=NULL");
+		return;
+	}
+
+	sprintf(sbStr, " bCkSel=%02X", pParam->bCkSel);
+	strcat(gsbLogString, sbStr);
+	sprintf(sbStr, " bDivR0=%02X", pParam->bDivR0);
+	strcat(gsbLogString, sbStr);
+	sprintf(sbStr, " bDivF0=%02X", pParam->bDivF0);
+	strcat(gsbLogString, sbStr);
+	sprintf(sbStr, " bDivR1=%02X", pParam->bDivR1);
+	strcat(gsbLogString, sbStr);
+	sprintf(sbStr, " bDivF1=%02X", pParam->bDivF1);
+	strcat(gsbLogString, sbStr);
+	sprintf(sbStr, " bRange0=%02X", pParam->bRange0);
+	strcat(gsbLogString, sbStr);
+	sprintf(sbStr, " bRange1=%02X", pParam->bRange1);
+	strcat(gsbLogString, sbStr);
+	sprintf(sbStr, " bBypass=%02X", pParam->bBypass);
+	strcat(gsbLogString, sbStr);
+	sprintf(sbStr, " bDioSdo0Hiz=%02X", pParam->bDioSdo0Hiz);
+	strcat(gsbLogString, sbStr);
+	sprintf(sbStr, " bDioSdo1Hiz=%02X", pParam->bDioSdo1Hiz);
+	strcat(gsbLogString, sbStr);
+	sprintf(sbStr, " bDioSdo2Hiz=%02X", pParam->bDioSdo2Hiz);
+	strcat(gsbLogString, sbStr);
+	sprintf(sbStr, " bDioClk0Hiz=%02X", pParam->bDioClk0Hiz);
+	strcat(gsbLogString, sbStr);
+	sprintf(sbStr, " bDioClk1Hiz=%02X", pParam->bDioClk1Hiz);
+	strcat(gsbLogString, sbStr);
+	sprintf(sbStr, " bDioClk2Hiz=%02X", pParam->bDioClk2Hiz);
+	strcat(gsbLogString, sbStr);
+	sprintf(sbStr, " bPcmHiz=%02X", pParam->bPcmHiz);
+	strcat(gsbLogString, sbStr);
+	sprintf(sbStr, " bLineIn1Dif=%02X", pParam->bLineIn1Dif);
+	strcat(gsbLogString, sbStr);
+	sprintf(sbStr, " bLineIn2Dif=%02X", pParam->bLineIn2Dif);
+	strcat(gsbLogString, sbStr);
+	sprintf(sbStr, " bLineOut1Dif=%02X", pParam->bLineOut1Dif);
+	strcat(gsbLogString, sbStr);
+	sprintf(sbStr, " bLineOut2Dif=%02X", pParam->bLineOut2Dif);
+	strcat(gsbLogString, sbStr);
+	sprintf(sbStr, " bSpmn=%02X", pParam->bSpmn);
+	strcat(gsbLogString, sbStr);
+	sprintf(sbStr, " bMic1Sng=%02X", pParam->bMic1Sng);
+	strcat(gsbLogString, sbStr);
+	sprintf(sbStr, " bMic2Sng=%02X", pParam->bMic2Sng);
+	strcat(gsbLogString, sbStr);
+	sprintf(sbStr, " bMic3Sng=%02X", pParam->bMic3Sng);
+	strcat(gsbLogString, sbStr);
+	sprintf(sbStr, " bPowerMode=%02X", pParam->bPowerMode);
+	strcat(gsbLogString, sbStr);
+	sprintf(sbStr, " bSpHiz=%02X", pParam->bSpHiz);
+	strcat(gsbLogString, sbStr);
+	sprintf(sbStr, " bLdo=%02X", pParam->bLdo);
+	strcat(gsbLogString, sbStr);
+	sprintf(sbStr, " bPad0Func=%02X", pParam->bPad0Func);
+	strcat(gsbLogString, sbStr);
+	sprintf(sbStr, " bPad1Func=%02X", pParam->bPad1Func);
+	strcat(gsbLogString, sbStr);
+	sprintf(sbStr, " bPad2Func=%02X", pParam->bPad2Func);
+	strcat(gsbLogString, sbStr);
+	sprintf(sbStr, " bAvddLev=%02X", pParam->bAvddLev);
+	strcat(gsbLogString, sbStr);
+	sprintf(sbStr, " bVrefLev=%02X", pParam->bVrefLev);
+	strcat(gsbLogString, sbStr);
+	sprintf(sbStr, " bDclGain=%02X", pParam->bDclGain);
+	strcat(gsbLogString, sbStr);
+	sprintf(sbStr, " bDclLimit=%02X", pParam->bDclLimit);
+	strcat(gsbLogString, sbStr);
+	sprintf(sbStr, " bCpMod=%02X", pParam->bCpMod);
+	strcat(gsbLogString, sbStr);
+	sprintf(sbStr, " bReserved1=%02X", pParam->bReserved1);
+	strcat(gsbLogString, sbStr);
+	sprintf(sbStr, " bReserved2=%02X", pParam->bReserved2);
+	strcat(gsbLogString, sbStr);
+	sprintf(sbStr, " bReserved3=%02X", pParam->bReserved3);
+	strcat(gsbLogString, sbStr);
+	sprintf(sbStr, " bReserved4=%02X", pParam->bReserved4);
+	strcat(gsbLogString, sbStr);
+	sprintf(sbStr, " bReserved5=%02X", pParam->bReserved5);
+	strcat(gsbLogString, sbStr);
+	sprintf(sbStr, " sWaitTime.dAdHpf=%08lX", pParam->sWaitTime.dAdHpf);
+	strcat(gsbLogString, sbStr);
+	sprintf(sbStr, " sWaitTime.dMic1Cin=%08lX", pParam->sWaitTime.dMic1Cin);
+	strcat(gsbLogString, sbStr);
+	sprintf(sbStr, " sWaitTime.dMic2Cin=%08lX", pParam->sWaitTime.dMic2Cin);
+	strcat(gsbLogString, sbStr);
+	sprintf(sbStr, " sWaitTime.dMic3Cin=%08lX", pParam->sWaitTime.dMic3Cin);
+	strcat(gsbLogString, sbStr);
+	sprintf(sbStr, " sWaitTime.dLine1Cin=%08lX", pParam->sWaitTime.dLine1Cin);
+	strcat(gsbLogString, sbStr);
+	sprintf(sbStr, " sWaitTime.dLine2Cin=%08lX", pParam->sWaitTime.dLine2Cin);
+	strcat(gsbLogString, sbStr);
+	sprintf(sbStr, " sWaitTime.dVrefRdy1=%08lX", pParam->sWaitTime.dVrefRdy1);
+	strcat(gsbLogString, sbStr);
+	sprintf(sbStr, " sWaitTime.dVrefRdy2=%08lX", pParam->sWaitTime.dVrefRdy2);
+	strcat(gsbLogString, sbStr);
+	sprintf(sbStr, " sWaitTime.dHpRdy=%08lX", pParam->sWaitTime.dHpRdy);
+	strcat(gsbLogString, sbStr);
+	sprintf(sbStr, " sWaitTime.dSpRdy=%08lX", pParam->sWaitTime.dSpRdy);
+	strcat(gsbLogString, sbStr);
+	sprintf(sbStr, " sWaitTime.dPdm=%08lX", pParam->sWaitTime.dPdm);
+	strcat(gsbLogString, sbStr);
+	sprintf(sbStr, " sWaitTime.dAnaRdyInterval=%08lX", pParam->sWaitTime.dAnaRdyInterval);
+	strcat(gsbLogString, sbStr);
+	sprintf(sbStr, " sWaitTime.dSvolInterval=%08lX", pParam->sWaitTime.dSvolInterval);
+	strcat(gsbLogString, sbStr);
+	sprintf(sbStr, " sWaitTime.dAnaRdyTimeOut=%08lX", pParam->sWaitTime.dAnaRdyTimeOut);
+	strcat(gsbLogString, sbStr);
+	sprintf(sbStr, " sWaitTime.dSvolTimeOut=%08lX", pParam->sWaitTime.dSvolTimeOut);
+	strcat(gsbLogString, sbStr);
+}
+
+/****************************************************************************
+ *	MakeRegInfoLog
+ *
+ *	Description:
+ *			Make Reg Info Parameter log.
+ *	Arguments:
+ *			pParam	pointer to parameter
+ *	Return:
+ *			none
+ *
+ ****************************************************************************/
+static void	MakeRegInfoLog
+(
+	const MCDRV_REG_INFO* pParam
+)
+{
+	CHAR	sbStr[80];
+
+	if(pParam == NULL)
+	{
+		strcat(gsbLogString, " param=NULL");
+		return;
+	}
+
+	sprintf(sbStr, " bRegType=%02X", pParam->bRegType);
+	strcat(gsbLogString, sbStr);
+	sprintf(sbStr, " bAddress=%02X", pParam->bAddress);
+	strcat(gsbLogString, sbStr);
+	sprintf(sbStr, " bData=%02X", pParam->bData);
+	strcat(gsbLogString, sbStr);
+}
+
+/****************************************************************************
+ *	MakeClockInfoLog
+ *
+ *	Description:
+ *			Make Clock Info Parameter log.
+ *	Arguments:
+ *			pParam	pointer to parameter
+ *	Return:
+ *			none
+ *
+ ****************************************************************************/
+static void	MakeClockInfoLog
+(
+	const MCDRV_CLOCK_INFO* pParam
+)
+{
+	CHAR	sbStr[80];
+
+	if(pParam == NULL)
+	{
+		strcat(gsbLogString, " param=NULL");
+		return;
+	}
+
+	sprintf(sbStr, " bCkSel=%02X", pParam->bCkSel);
+	strcat(gsbLogString, sbStr);
+	sprintf(sbStr, " bDivR0=%02X", pParam->bDivR0);
+	strcat(gsbLogString, sbStr);
+	sprintf(sbStr, " bDivF0=%02X", pParam->bDivF0);
+	strcat(gsbLogString, sbStr);
+	sprintf(sbStr, " bDivR1=%02X", pParam->bDivR1);
+	strcat(gsbLogString, sbStr);
+	sprintf(sbStr, " bDivF1=%02X", pParam->bDivF1);
+	strcat(gsbLogString, sbStr);
+	sprintf(sbStr, " bRange0=%02X", pParam->bRange0);
+	strcat(gsbLogString, sbStr);
+	sprintf(sbStr, " bRange1=%02X", pParam->bRange1);
+	strcat(gsbLogString, sbStr);
+	sprintf(sbStr, " bBypass=%02X", pParam->bBypass);
+	strcat(gsbLogString, sbStr);
+}
+
+/****************************************************************************
+ *	MakeClockSwInfoLog
+ *
+ *	Description:
+ *			Make Clock Switch Info Parameter log.
+ *	Arguments:
+ *			pParam	pointer to parameter
+ *	Return:
+ *			none
+ *
+ ****************************************************************************/
+static void	MakeClockSwInfoLog
+(
+	const MCDRV_CLKSW_INFO* pParam
+)
+{
+	CHAR	sbStr[80];
+
+	if(pParam == NULL)
+	{
+		strcat(gsbLogString, " param=NULL");
+		return;
+	}
+
+	sprintf(sbStr, " bClkSrc=%02X", pParam->bClkSrc);
+	strcat(gsbLogString, sbStr);
+}
+
+/****************************************************************************
+ *	MakePathInfoLog
+ *
+ *	Description:
+ *			Make Path Info Parameter log.
+ *	Arguments:
+ *			pParam	pointer to parameter
+ *	Return:
+ *			none
+ *
+ ****************************************************************************/
+static void	MakePathInfoLog
+(
+	const MCDRV_PATH_INFO* pParam
+)
+{
+	UINT8	bBlock, bCh;
+	CHAR	sbStr[80];
+
+	if(pParam == NULL)
+	{
+		strcat(gsbLogString, " param=NULL");
+		return;
+	}
+
+	for(bCh = 0; bCh < HP_PATH_CHANNELS; bCh++)
+	{
+		for(bBlock = 0; bBlock < SOURCE_BLOCK_NUM; bBlock++)
+		{
+			sprintf(sbStr, " asHpOut[%d].abSrcOnOff[%d]=%02X", bCh, bBlock, pParam->asHpOut[bCh].abSrcOnOff[bBlock]);
+			strcat(gsbLogString, sbStr);
+		}
+	}
+	for(bCh = 0; bCh < SP_PATH_CHANNELS; bCh++)
+	{
+		for(bBlock = 0; bBlock < SOURCE_BLOCK_NUM; bBlock++)
+		{
+			sprintf(sbStr, " asSpOut[%d].abSrcOnOff[%d]=%02X", bCh, bBlock, pParam->asSpOut[bCh].abSrcOnOff[bBlock]);
+			strcat(gsbLogString, sbStr);
+		}
+	}
+	for(bCh = 0; bCh < RC_PATH_CHANNELS; bCh++)
+	{
+		for(bBlock = 0; bBlock < SOURCE_BLOCK_NUM; bBlock++)
+		{
+			sprintf(sbStr, " asRcOut[%d].abSrcOnOff[%d]=%02X", bCh, bBlock, pParam->asRcOut[bCh].abSrcOnOff[bBlock]);
+			strcat(gsbLogString, sbStr);
+		}
+	}
+	for(bCh = 0; bCh < LOUT1_PATH_CHANNELS; bCh++)
+	{
+		for(bBlock = 0; bBlock < SOURCE_BLOCK_NUM; bBlock++)
+		{
+			sprintf(sbStr, " asLout1[%d].abSrcOnOff[%d]=%02X", bCh, bBlock, pParam->asLout1[bCh].abSrcOnOff[bBlock]);
+			strcat(gsbLogString, sbStr);
+		}
+	}
+	for(bCh = 0; bCh < LOUT2_PATH_CHANNELS; bCh++)
+	{
+		for(bBlock = 0; bBlock < SOURCE_BLOCK_NUM; bBlock++)
+		{
+			sprintf(sbStr, " asLout2[%d].abSrcOnOff[%d]=%02X", bCh, bBlock, pParam->asLout2[bCh].abSrcOnOff[bBlock]);
+			strcat(gsbLogString, sbStr);
+		}
+	}
+	for(bCh = 0; bCh < PEAK_PATH_CHANNELS; bCh++)
+	{
+		for(bBlock = 0; bBlock < SOURCE_BLOCK_NUM; bBlock++)
+		{
+			sprintf(sbStr, " asPeak[%d].abSrcOnOff[%d]=%02X", bCh, bBlock, pParam->asPeak[bCh].abSrcOnOff[bBlock]);
+			strcat(gsbLogString, sbStr);
+		}
+	}
+	for(bCh = 0; bCh < DIT0_PATH_CHANNELS; bCh++)
+	{
+		for(bBlock = 0; bBlock < SOURCE_BLOCK_NUM; bBlock++)
+		{
+			sprintf(sbStr, " asDit0[%d].abSrcOnOff[%d]=%02X", bCh, bBlock, pParam->asDit0[bCh].abSrcOnOff[bBlock]);
+			strcat(gsbLogString, sbStr);
+		}
+	}
+	for(bCh = 0; bCh < DIT1_PATH_CHANNELS; bCh++)
+	{
+		for(bBlock = 0; bBlock < SOURCE_BLOCK_NUM; bBlock++)
+		{
+			sprintf(sbStr, " asDit1[%d].abSrcOnOff[%d]=%02X", bCh, bBlock, pParam->asDit1[bCh].abSrcOnOff[bBlock]);
+			strcat(gsbLogString, sbStr);
+		}
+	}
+	for(bCh = 0; bCh < DIT2_PATH_CHANNELS; bCh++)
+	{
+		for(bBlock = 0; bBlock < SOURCE_BLOCK_NUM; bBlock++)
+		{
+			sprintf(sbStr, " asDit2[%d].abSrcOnOff[%d]=%02X", bCh, bBlock, pParam->asDit2[bCh].abSrcOnOff[bBlock]);
+			strcat(gsbLogString, sbStr);
+		}
+	}
+	for(bCh = 0; bCh < DAC_PATH_CHANNELS; bCh++)
+	{
+		for(bBlock = 0; bBlock < SOURCE_BLOCK_NUM; bBlock++)
+		{
+			sprintf(sbStr, " asDac[%d].abSrcOnOff[%d]=%02X", bCh, bBlock, pParam->asDac[bCh].abSrcOnOff[bBlock]);
+			strcat(gsbLogString, sbStr);
+		}
+	}
+	for(bCh = 0; bCh < AE_PATH_CHANNELS; bCh++)
+	{
+		for(bBlock = 0; bBlock < SOURCE_BLOCK_NUM; bBlock++)
+		{
+			sprintf(sbStr, " asAe[%d].abSrcOnOff[%d]=%02X", bCh, bBlock, pParam->asAe[bCh].abSrcOnOff[bBlock]);
+			strcat(gsbLogString, sbStr);
+		}
+	}
+	for(bCh = 0; bCh < CDSP_PATH_CHANNELS; bCh++)
+	{
+		for(bBlock = 0; bBlock < SOURCE_BLOCK_NUM; bBlock++)
+		{
+			sprintf(sbStr, " asCdsp[%d].abSrcOnOff[%d]=%02X", bCh, bBlock, pParam->asCdsp[bCh].abSrcOnOff[bBlock]);
+			strcat(gsbLogString, sbStr);
+		}
+	}
+	for(bCh = 0; bCh < ADC0_PATH_CHANNELS; bCh++)
+	{
+		for(bBlock = 0; bBlock < SOURCE_BLOCK_NUM; bBlock++)
+		{
+			sprintf(sbStr, " asAdc0[%d].abSrcOnOff[%d]=%02X", bCh, bBlock, pParam->asAdc0[bCh].abSrcOnOff[bBlock]);
+			strcat(gsbLogString, sbStr);
+		}
+	}
+	for(bCh = 0; bCh < ADC1_PATH_CHANNELS; bCh++)
+	{
+		for(bBlock = 0; bBlock < SOURCE_BLOCK_NUM; bBlock++)
+		{
+			sprintf(sbStr, " asAdc1[%d].abSrcOnOff[%d]=%02X", bCh, bBlock, pParam->asAdc1[bCh].abSrcOnOff[bBlock]);
+			strcat(gsbLogString, sbStr);
+		}
+	}
+	for(bCh = 0; bCh < MIX_PATH_CHANNELS; bCh++)
+	{
+		for(bBlock = 0; bBlock < SOURCE_BLOCK_NUM; bBlock++)
+		{
+			sprintf(sbStr, " asMix[%d].abSrcOnOff[%d]=%02X", bCh, bBlock, pParam->asMix[bCh].abSrcOnOff[bBlock]);
+			strcat(gsbLogString, sbStr);
+		}
+	}
+	for(bCh = 0; bCh < BIAS_PATH_CHANNELS; bCh++)
+	{
+		for(bBlock = 0; bBlock < SOURCE_BLOCK_NUM; bBlock++)
+		{
+			sprintf(sbStr, " asBias[%d].abSrcOnOff[%d]=%02X", bCh, bBlock, pParam->asBias[bCh].abSrcOnOff[bBlock]);
+			strcat(gsbLogString, sbStr);
+		}
+	}
+}
+
+/****************************************************************************
+ *	MakeVolInfoLog
+ *
+ *	Description:
+ *			Make Volume Info Parameter log.
+ *	Arguments:
+ *			pParam	pointer to parameter
+ *	Return:
+ *			none
+ *
+ ****************************************************************************/
+static void	MakeVolInfoLog
+(
+	const MCDRV_VOL_INFO* pParam
+)
+{
+	UINT8	bCh;
+	CHAR	sbStr[80];
+
+	if(pParam == NULL)
+	{
+		strcat(gsbLogString, " param=NULL");
+		return;
+	}
+
+	for(bCh = 0; bCh < AD0_VOL_CHANNELS; bCh++)
+	{
+		sprintf(sbStr, " aswD_Ad0[%d]=%04X", bCh, (UINT16)pParam->aswD_Ad0[bCh]);
+		strcat(gsbLogString, sbStr);
+	}
+	for(bCh = 0; bCh < AD1_VOL_CHANNELS; bCh++)
+	{
+		sprintf(sbStr, " aswD_Ad1[%d]=%04X", bCh, (UINT16)pParam->aswD_Ad1[bCh]);
+		strcat(gsbLogString, sbStr);
+	}
+	for(bCh = 0; bCh < AENG6_VOL_CHANNELS; bCh++)
+	{
+		sprintf(sbStr, " aswD_Aeng6[%d]=%04X", bCh, (UINT16)pParam->aswD_Aeng6[bCh]);
+		strcat(gsbLogString, sbStr);
+	}
+	for(bCh = 0; bCh < PDM_VOL_CHANNELS; bCh++)
+	{
+		sprintf(sbStr, " aswD_Pdm[%d]=%04X", bCh, (UINT16)pParam->aswD_Pdm[bCh]);
+		strcat(gsbLogString, sbStr);
+	}
+	for(bCh = 0; bCh < DTMF_VOL_CHANNELS; bCh++)
+	{
+		sprintf(sbStr, " aswD_Dtmfb[%d]=%04X", bCh, (UINT16)pParam->aswD_Dtmfb[bCh]);
+		strcat(gsbLogString, sbStr);
+	}
+	for(bCh = 0; bCh < DIO0_VOL_CHANNELS; bCh++)
+	{
+		sprintf(sbStr, " aswD_Dir0[%d]=%04X", bCh, (UINT16)pParam->aswD_Dir0[bCh]);
+		strcat(gsbLogString, sbStr);
+	}
+	for(bCh = 0; bCh < DIO1_VOL_CHANNELS; bCh++)
+	{
+		sprintf(sbStr, " aswD_Dir1[%d]=%04X", bCh, (UINT16)pParam->aswD_Dir1[bCh]);
+		strcat(gsbLogString, sbStr);
+	}
+	for(bCh = 0; bCh < DIO2_VOL_CHANNELS; bCh++)
+	{
+		sprintf(sbStr, " aswD_Dir2[%d]=%04X", bCh, (UINT16)pParam->aswD_Dir2[bCh]);
+		strcat(gsbLogString, sbStr);
+	}
+	for(bCh = 0; bCh < AD0_VOL_CHANNELS; bCh++)
+	{
+		sprintf(sbStr, " aswD_Ad0Att[%d]=%04X", bCh, (UINT16)pParam->aswD_Ad0Att[bCh]);
+		strcat(gsbLogString, sbStr);
+	}
+	for(bCh = 0; bCh < AD1_VOL_CHANNELS; bCh++)
+	{
+		sprintf(sbStr, " aswD_Ad1Att[%d]=%04X", bCh, (UINT16)pParam->aswD_Ad1Att[bCh]);
+		strcat(gsbLogString, sbStr);
+	}
+	for(bCh = 0; bCh < DIO0_VOL_CHANNELS; bCh++)
+	{
+		sprintf(sbStr, " aswD_Dir0Att[%d]=%04X", bCh, (UINT16)pParam->aswD_Dir0Att[bCh]);
+		strcat(gsbLogString, sbStr);
+	}
+	for(bCh = 0; bCh < DIO1_VOL_CHANNELS; bCh++)
+	{
+		sprintf(sbStr, " aswD_Dir1Att[%d]=%04X", bCh, (UINT16)pParam->aswD_Dir1Att[bCh]);
+		strcat(gsbLogString, sbStr);
+	}
+	for(bCh = 0; bCh < DIO2_VOL_CHANNELS; bCh++)
+	{
+		sprintf(sbStr, " aswD_Dir2Att[%d]=%04X", bCh, (UINT16)pParam->aswD_Dir2Att[bCh]);
+		strcat(gsbLogString, sbStr);
+	}
+	for(bCh = 0; bCh < PDM_VOL_CHANNELS; bCh++)
+	{
+		sprintf(sbStr, " aswD_SideTone[%d]=%04X", bCh, (UINT16)pParam->aswD_SideTone[bCh]);
+		strcat(gsbLogString, sbStr);
+	}
+	for(bCh = 0; bCh < DTFM_VOL_CHANNELS; bCh++)
+	{
+		sprintf(sbStr, " aswD_DtmfAtt[%d]=%04X", bCh, (UINT16)pParam->aswD_DtmfAtt[bCh]);
+		strcat(gsbLogString, sbStr);
+	}
+	for(bCh = 0; bCh < DAC_VOL_CHANNELS; bCh++)
+	{
+		sprintf(sbStr, " aswD_DacMaster[%d]=%04X", bCh, (UINT16)pParam->aswD_DacMaster[bCh]);
+		strcat(gsbLogString, sbStr);
+	}
+	for(bCh = 0; bCh < DAC_VOL_CHANNELS; bCh++)
+	{
+		sprintf(sbStr, " aswD_DacVoice[%d]=%04X", bCh, (UINT16)pParam->aswD_DacVoice[bCh]);
+		strcat(gsbLogString, sbStr);
+	}
+	for(bCh = 0; bCh < DAC_VOL_CHANNELS; bCh++)
+	{
+		sprintf(sbStr, " aswD_DacAtt[%d]=%04X", bCh, (UINT16)pParam->aswD_DacAtt[bCh]);
+		strcat(gsbLogString, sbStr);
+	}
+	for(bCh = 0; bCh < DIO0_VOL_CHANNELS; bCh++)
+	{
+		sprintf(sbStr, " aswD_Dit0[%d]=%04X",bCh, (UINT16)pParam->aswD_Dit0[bCh]);
+		strcat(gsbLogString, sbStr);
+	}
+	for(bCh = 0; bCh < DIO1_VOL_CHANNELS; bCh++)
+	{
+		sprintf(sbStr, " aswD_Dit1[%d]=%04X", bCh, (UINT16)pParam->aswD_Dit1[bCh]);
+		strcat(gsbLogString, sbStr);
+	}
+	for(bCh = 0; bCh < DIO2_VOL_CHANNELS; bCh++)
+	{
+		sprintf(sbStr, " aswD_Dit2[%d]=%04X", bCh, (UINT16)pParam->aswD_Dit2[bCh]);
+		strcat(gsbLogString, sbStr);
+	}
+	for(bCh = 0; bCh < AD0_VOL_CHANNELS; bCh++)
+	{
+		sprintf(sbStr, " aswA_Ad0[%d]=%04X", bCh, (UINT16)pParam->aswA_Ad0[bCh]);
+		strcat(gsbLogString, sbStr);
+	}
+	for(bCh = 0; bCh < AD1_VOL_CHANNELS; bCh++)
+	{
+		sprintf(sbStr, " aswA_Ad1[%d]=%04X", bCh, (UINT16)pParam->aswA_Ad1[bCh]);
+		strcat(gsbLogString, sbStr);
+	}
+	for(bCh = 0; bCh <LIN1_VOL_CHANNELS ; bCh++)
+	{
+		sprintf(sbStr, " aswA_Lin1[%d]=%04X", bCh, (UINT16)pParam->aswA_Lin1[bCh]);
+		strcat(gsbLogString, sbStr);
+	}
+	for(bCh = 0; bCh < LIN2_VOL_CHANNELS; bCh++)
+	{
+		sprintf(sbStr, " aswA_Lin2[%d]=%04X", bCh, (UINT16)pParam->aswA_Lin2[bCh]);
+		strcat(gsbLogString, sbStr);
+	}
+	for(bCh = 0; bCh < MIC1_VOL_CHANNELS; bCh++)
+	{
+		sprintf(sbStr, " aswA_Mic1[%d]=%04X", bCh, (UINT16)pParam->aswA_Mic1[bCh]);
+		strcat(gsbLogString, sbStr);
+	}
+	for(bCh = 0; bCh < MIC2_VOL_CHANNELS; bCh++)
+	{
+		sprintf(sbStr, " aswA_Mic2[%d]=%04X", bCh, (UINT16)pParam->aswA_Mic2[bCh]);
+		strcat(gsbLogString, sbStr);
+	}
+	for(bCh = 0; bCh < MIC3_VOL_CHANNELS; bCh++)
+	{
+		sprintf(sbStr, " aswA_Mic3[%d]=%04X", bCh, (UINT16)pParam->aswA_Mic3[bCh]);
+		strcat(gsbLogString, sbStr);
+	}
+	for(bCh = 0; bCh < HP_VOL_CHANNELS; bCh++)
+	{
+		sprintf(sbStr, " aswA_Hp[%d]=%04X", bCh, (UINT16)pParam->aswA_Hp[bCh]);
+		strcat(gsbLogString, sbStr);
+	}
+	for(bCh = 0; bCh < SP_VOL_CHANNELS; bCh++)
+	{
+		sprintf(sbStr, " aswA_Sp[%d]=%04X", bCh, (UINT16)pParam->aswA_Sp[bCh]);
+		strcat(gsbLogString, sbStr);
+	}
+	for(bCh = 0; bCh < RC_VOL_CHANNELS; bCh++)
+	{
+		sprintf(sbStr, " aswA_Rc[%d]=%04X", bCh, (UINT16)pParam->aswA_Rc[bCh]);
+		strcat(gsbLogString, sbStr);
+	}
+	for(bCh = 0; bCh < LOUT1_VOL_CHANNELS; bCh++)
+	{
+		sprintf(sbStr, " aswA_Lout1[%d]=%04X", bCh, (UINT16)pParam->aswA_Lout1[bCh]);
+		strcat(gsbLogString, sbStr);
+	}
+	for(bCh = 0; bCh < LOUT2_VOL_CHANNELS; bCh++)
+	{
+		sprintf(sbStr, " aswA_Lout2[%d]=%04X", bCh, (UINT16)pParam->aswA_Lout2[bCh]);
+		strcat(gsbLogString, sbStr);
+	}
+	for(bCh = 0; bCh < MIC1_VOL_CHANNELS; bCh++)
+	{
+		sprintf(sbStr, " aswA_Mic1Gain[%d]=%04X", bCh, (UINT16)pParam->aswA_Mic1Gain[bCh]);
+		strcat(gsbLogString, sbStr);
+	}
+	for(bCh = 0; bCh < MIC2_VOL_CHANNELS; bCh++)
+	{
+		sprintf(sbStr, " aswA_Mic2Gain[%d]=%04X", bCh, (UINT16)pParam->aswA_Mic2Gain[bCh]);
+		strcat(gsbLogString, sbStr);
+	}
+	for(bCh = 0; bCh < MIC3_VOL_CHANNELS; bCh++)
+	{
+		sprintf(sbStr, " aswA_Mic3Gain[%d]=%04X", bCh, (UINT16)pParam->aswA_Mic3Gain[bCh]);
+		strcat(gsbLogString, sbStr);
+	}
+	for(bCh = 0; bCh < HPGAIN_VOL_CHANNELS; bCh++)
+	{
+		sprintf(sbStr, " aswA_HpGain[%d]=%04X", bCh, (UINT16)pParam->aswA_HpGain[bCh]);
+		strcat(gsbLogString, sbStr);
+	}
+}
+
+/****************************************************************************
+ *	MakeDIOInfoLog
+ *
+ *	Description:
+ *			Make Digital I/O Info Parameter log.
+ *	Arguments:
+ *			pParam	pointer to parameter
+ *	Return:
+ *			none
+ *
+ ****************************************************************************/
+static void	MakeDIOInfoLog
+(
+	const MCDRV_DIO_INFO* pParam
+)
+{
+	CHAR	sbStr[80];
+	UINT8	bPort, bCh;
+
+	if(pParam == NULL)
+	{
+		strcat(gsbLogString, " param=NULL");
+		return;
+	}
+
+	for(bPort = 0; bPort < IOPORT_NUM; bPort++)
+	{
+		sprintf(sbStr, " asPortInfo[%d].sDioCommon.bMasterSlave=%02X", bPort, pParam->asPortInfo[bPort].sDioCommon.bMasterSlave);
+		strcat(gsbLogString, sbStr);
+		sprintf(sbStr, " asPortInfo[%d].sDioCommon.bAutoFs=%02X", bPort, pParam->asPortInfo[bPort].sDioCommon.bAutoFs);
+		strcat(gsbLogString, sbStr);
+		sprintf(sbStr, " asPortInfo[%d].sDioCommon.bFs=%02X", bPort, pParam->asPortInfo[bPort].sDioCommon.bFs);
+		strcat(gsbLogString, sbStr);
+		sprintf(sbStr, " asPortInfo[%d].sDioCommon.bBckFs=%02X", bPort, pParam->asPortInfo[bPort].sDioCommon.bBckFs);
+		strcat(gsbLogString, sbStr);
+		sprintf(sbStr, " asPortInfo[%d].sDioCommon.bInterface=%02X", bPort, pParam->asPortInfo[bPort].sDioCommon.bInterface);
+		strcat(gsbLogString, sbStr);
+		sprintf(sbStr, " asPortInfo[%d].sDioCommon.bBckInvert=%02X", bPort, pParam->asPortInfo[bPort].sDioCommon.bBckInvert);
+		strcat(gsbLogString, sbStr);
+		sprintf(sbStr, " asPortInfo[%d].sDioCommon.bPcmHizTim=%02X", bPort, pParam->asPortInfo[bPort].sDioCommon.bPcmHizTim);
+		strcat(gsbLogString, sbStr);
+		sprintf(sbStr, " asPortInfo[%d].sDioCommon.bPcmClkDown=%02X", bPort, pParam->asPortInfo[bPort].sDioCommon.bPcmClkDown);
+		strcat(gsbLogString, sbStr);
+		sprintf(sbStr, " asPortInfo[%d].sDioCommon.bPcmFrame=%02X", bPort, pParam->asPortInfo[bPort].sDioCommon.bPcmFrame);
+		strcat(gsbLogString, sbStr);
+		sprintf(sbStr, " asPortInfo[%d].sDioCommon.bPcmHighPeriod=%02X", bPort, pParam->asPortInfo[bPort].sDioCommon.bPcmHighPeriod);
+		strcat(gsbLogString, sbStr);
+
+		sprintf(sbStr, " asPortInfo[%d].sDir.wSrcRate=%04X", bPort, pParam->asPortInfo[bPort].sDir.wSrcRate);
+		strcat(gsbLogString, sbStr);
+		sprintf(sbStr, " asPortInfo[%d].sDir.sDaFormat.bBitSel=%02X", bPort, pParam->asPortInfo[bPort].sDir.sDaFormat.bBitSel);
+		strcat(gsbLogString, sbStr);
+		sprintf(sbStr, " asPortInfo[%d].sDir.sDaFormat.bMode=%02X", bPort, pParam->asPortInfo[bPort].sDir.sDaFormat.bMode);
+		strcat(gsbLogString, sbStr);
+		sprintf(sbStr, " asPortInfo[%d].sDir.sPcmFormat.bMono=%02X", bPort, pParam->asPortInfo[bPort].sDir.sPcmFormat.bMono);
+		strcat(gsbLogString, sbStr);
+		sprintf(sbStr, " asPortInfo[%d].sDir.sPcmFormat.bOrder=%02X", bPort, pParam->asPortInfo[bPort].sDir.sPcmFormat.bOrder);
+		strcat(gsbLogString, sbStr);
+		sprintf(sbStr, " asPortInfo[%d].sDir.sPcmFormat.bLaw=%02X", bPort, pParam->asPortInfo[bPort].sDir.sPcmFormat.bLaw);
+		strcat(gsbLogString, sbStr);
+		sprintf(sbStr, " asPortInfo[%d].sDir.sPcmFormat.bBitSel=%02X", bPort, pParam->asPortInfo[bPort].sDir.sPcmFormat.bBitSel);
+		strcat(gsbLogString, sbStr);
+		for(bCh = 0; bCh < DIO_CHANNELS; bCh++)
+		{
+			sprintf(sbStr, " asPortInfo[%d].sDir.abSlot[%d]=%02X", bPort, bCh, pParam->asPortInfo[bPort].sDir.abSlot[bCh]);
+			strcat(gsbLogString, sbStr);
+		}
+
+		sprintf(sbStr, " asPortInfo[%d].sDit.wSrcRate=%04X", bPort, pParam->asPortInfo[bPort].sDit.wSrcRate);
+		strcat(gsbLogString, sbStr);
+		sprintf(sbStr, " asPortInfo[%d].sDit.sDaFormat.bBitSel=%02X", bPort, pParam->asPortInfo[bPort].sDit.sDaFormat.bBitSel);
+		strcat(gsbLogString, sbStr);
+		sprintf(sbStr, " asPortInfo[%d].sDit.sDaFormat.bMode=%02X", bPort, pParam->asPortInfo[bPort].sDit.sDaFormat.bMode);
+		strcat(gsbLogString, sbStr);
+		sprintf(sbStr, " asPortInfo[%d].sDit.sPcmFormat.bMono=%02X", bPort, pParam->asPortInfo[bPort].sDit.sPcmFormat.bMono);
+		strcat(gsbLogString, sbStr);
+		sprintf(sbStr, " asPortInfo[%d].sDit.sPcmFormat.bOrder=%02X", bPort, pParam->asPortInfo[bPort].sDit.sPcmFormat.bOrder);
+		strcat(gsbLogString, sbStr);
+		sprintf(sbStr, " asPortInfo[%d].sDit.sPcmFormat.bLaw=%02X", bPort, pParam->asPortInfo[bPort].sDit.sPcmFormat.bLaw);
+		strcat(gsbLogString, sbStr);
+		sprintf(sbStr, " asPortInfo[%d].sDit.sPcmFormat.bBitSel=%02X", bPort, pParam->asPortInfo[bPort].sDit.sPcmFormat.bBitSel);
+		strcat(gsbLogString, sbStr);
+		for(bCh = 0; bCh < DIO_CHANNELS; bCh++)
+		{
+			sprintf(sbStr, " asPortInfo[%d].sDit.abSlot[%d]=%02X", bPort, bCh, pParam->asPortInfo[bPort].sDit.abSlot[bCh]);
+			strcat(gsbLogString, sbStr);
+		}
+	}
+}
+
+/****************************************************************************
+ *	MakeDACInfoLog
+ *
+ *	Description:
+ *			Make DAC Info Parameter log.
+ *	Arguments:
+ *			pParam	pointer to parameter
+ *	Return:
+ *			none
+ *
+ ****************************************************************************/
+static void	MakeDACInfoLog
+(
+	const MCDRV_DAC_INFO* pParam
+)
+{
+	CHAR	sbStr[80];
+
+	if(pParam == NULL)
+	{
+		strcat(gsbLogString, " param=NULL");
+		return;
+	}
+
+	sprintf(sbStr, " bMasterSwap=%02X", pParam->bMasterSwap);
+	strcat(gsbLogString, sbStr);
+	sprintf(sbStr, " bVoiceSwap=%02X", pParam->bVoiceSwap);
+	strcat(gsbLogString, sbStr);
+	sprintf(sbStr, " bDcCut=%02X", pParam->bDcCut);
+	strcat(gsbLogString, sbStr);
+}
+
+/****************************************************************************
+ *	MakeADCInfoLog
+ *
+ *	Description:
+ *			Make ADC Info Parameter log.
+ *	Arguments:
+ *			pParam	pointer to parameter
+ *	Return:
+ *			none
+ *
+ ****************************************************************************/
+static void	MakeADCInfoLog
+(
+	const MCDRV_ADC_INFO* pParam
+)
+{
+	CHAR	sbStr[80];
+
+	if(pParam == NULL)
+	{
+		strcat(gsbLogString, " param=NULL");
+		return;
+	}
+
+	sprintf(sbStr, " bAgcAdjust=%02X", pParam->bAgcAdjust);
+	strcat(gsbLogString, sbStr);
+	sprintf(sbStr, " bAgcOn=%02X", pParam->bAgcOn);
+	strcat(gsbLogString, sbStr);
+	sprintf(sbStr, " bMono=%02X", pParam->bMono);
+	strcat(gsbLogString, sbStr);
+}
+
+/****************************************************************************
+ *	MakeSpInfoLog
+ *
+ *	Description:
+ *			Make Sp Info Parameter log.
+ *	Arguments:
+ *			pParam	pointer to parameter
+ *	Return:
+ *			none
+ *
+ ****************************************************************************/
+static void	MakeSpInfoLog
+(
+	const MCDRV_SP_INFO* pParam
+)
+{
+	CHAR	sbStr[80];
+
+	if(pParam == NULL)
+	{
+		strcat(gsbLogString, " param=NULL");
+		return;
+	}
+
+	sprintf(sbStr, " bSwap=%02X", pParam->bSwap);
+	strcat(gsbLogString, sbStr);
+}
+
+/****************************************************************************
+ *	MakeDNGInfoLog
+ *
+ *	Description:
+ *			Make DNG Info Parameter log.
+ *	Arguments:
+ *			pParam	pointer to parameter
+ *	Return:
+ *			none
+ *
+ ****************************************************************************/
+static void	MakeDNGInfoLog
+(
+	const MCDRV_DNG_INFO* pParam
+)
+{
+	CHAR	sbStr[80];
+	UINT8	bItem;
+
+	if(pParam == NULL)
+	{
+		strcat(gsbLogString, " param=NULL");
+		return;
+	}
+
+	for(bItem = 0; bItem < DNG_ITEM_NUM; bItem++)
+	{
+		sprintf(sbStr, " abOnOff[%d]=%02X", bItem, pParam->abOnOff[bItem]);
+		strcat(gsbLogString, sbStr);
+		sprintf(sbStr, " abThreshold[%d]=%02X", bItem, pParam->abThreshold[bItem]);
+		strcat(gsbLogString, sbStr);
+		sprintf(sbStr, " abHold[%d]=%02X", bItem, pParam->abHold[bItem]);
+		strcat(gsbLogString, sbStr);
+		sprintf(sbStr, " abAttack[%d]=%02X", bItem, pParam->abAttack[bItem]);
+		strcat(gsbLogString, sbStr);
+		sprintf(sbStr, " abRelease[%d]=%02X", bItem, pParam->abRelease[bItem]);
+		strcat(gsbLogString, sbStr);
+		sprintf(sbStr, " abTarget[%d]=%02X", bItem, pParam->abTarget[bItem]);
+		strcat(gsbLogString, sbStr);
+	}
+}
+
+/****************************************************************************
+ *	MakeAEInfoLog
+ *
+ *	Description:
+ *			Make AudioEngine Info Parameter log.
+ *	Arguments:
+ *			pParam	pointer to parameter
+ *	Return:
+ *			none
+ *
+ ****************************************************************************/
+static void	MakeAEInfoLog
+(
+	const MCDRV_AE_INFO* pParam
+)
+{
+	CHAR	sbStr[80];
+	UINT16	wIdx;
+
+	if(pParam == NULL)
+	{
+		strcat(gsbLogString, " param=NULL");
+		return;
+	}
+
+	sprintf(sbStr, " bOnOff=%02X", pParam->bOnOff);
+	strcat(gsbLogString, sbStr);
+
+	for(wIdx = 0; wIdx < BEX_PARAM_SIZE; wIdx++)
+	{
+		sprintf(sbStr, " abBex[%d]=%02X", wIdx, pParam->abBex[wIdx]);
+		strcat(gsbLogString, sbStr);
+	}
+	for(wIdx = 0; wIdx < WIDE_PARAM_SIZE; wIdx++)
+	{
+		sprintf(sbStr, " abWide[%d]=%02X", wIdx, pParam->abWide[wIdx]);
+		strcat(gsbLogString, sbStr);
+	}
+	for(wIdx = 0; wIdx < DRC_PARAM_SIZE; wIdx++)
+	{
+		sprintf(sbStr, " abDrc[%d]=%02X", wIdx, pParam->abDrc[wIdx]);
+		strcat(gsbLogString, sbStr);
+	}
+	for(wIdx = 0; wIdx < EQ5_PARAM_SIZE; wIdx++)
+	{
+		sprintf(sbStr, " abEq5[%d]=%02X", wIdx, pParam->abEq5[wIdx]);
+		strcat(gsbLogString, sbStr);
+	}
+	for(wIdx = 0; wIdx < EQ3_PARAM_SIZE; wIdx++)
+	{
+		sprintf(sbStr, " abEq3[%d]=%02X", wIdx, pParam->abEq3[wIdx]);
+		strcat(gsbLogString, sbStr);
+	}
+}
+
+/****************************************************************************
+ *	MakeAEExInfoLog
+ *
+ *	Description:
+ *			Make AudioEngineEx Info Parameter log.
+ *	Arguments:
+ *			pParam	pointer to parameter
+ *	Return:
+ *			none
+ *
+ ****************************************************************************/
+static void	MakeAEExInfoLog
+(
+	const UINT16* pParam
+)
+{
+	CHAR	sbStr[80];
+
+	if(pParam == NULL)
+	{
+		strcat(gsbLogString, " param=NULL");
+		return;
+	}
+
+	sprintf(sbStr, " param=%04X", *pParam);
+	strcat(gsbLogString, sbStr);
+}
+
+/****************************************************************************
+ *	MakeSetCDSPLog
+ *
+ *	Description:
+ *			Make CDSP Parameter log.
+ *	Arguments:
+ *			pParam	pointer to parameter
+ *	Return:
+ *			none
+ *
+ ****************************************************************************/
+static void	MakeSetCDSPLog
+(
+	const UINT16* pParam
+)
+{
+	CHAR	sbStr[80];
+
+	if(pParam == NULL)
+	{
+		strcat(gsbLogString, " param=NULL");
+		return;
+	}
+
+	sprintf(sbStr, " param=%04X", *pParam);
+	strcat(gsbLogString, sbStr);
+}
+
+/****************************************************************************
+ *	MakeCDSPParamLog
+ *
+ *	Description:
+ *			Make CDSP Parameter log.
+ *	Arguments:
+ *			pParam	pointer to parameter
+ *	Return:
+ *			none
+ *
+ ****************************************************************************/
+static void	MakeCDSPParamLog
+(
+	const MCDRV_CDSPPARAM* pParam
+)
+{
+	CHAR	sbStr[80];
+	UINT8	bIdx;
+
+	if(pParam == NULL)
+	{
+		strcat(gsbLogString, " param=NULL");
+		return;
+	}
+
+	sprintf(sbStr, " bId=%02X", pParam->bId);
+	strcat(gsbLogString, sbStr);
+	for(bIdx = 0; bIdx < 16; bIdx++)
+	{
+		sprintf(sbStr, " abParam[%d]=%02X", bIdx, pParam->abParam[bIdx]);
+		strcat(gsbLogString, sbStr);
+	}
+}
+
+/****************************************************************************
+ *	MakeCDSPCBLog
+ *
+ *	Description:
+ *			Make CDSP Callback Parameter log.
+ *	Arguments:
+ *			pParam	pointer to parameter
+ *	Return:
+ *			none
+ *
+ ****************************************************************************/
+static void	MakeCDSPCBLog
+(
+	const void* pParam
+)
+{
+	CHAR	sbStr[80];
+
+	if(pParam == NULL)
+	{
+		strcat(gsbLogString, " param=NULL");
+		return;
+	}
+
+	sprintf(sbStr, " param=%08lX", *(UINT32*)pParam);
+	strcat(gsbLogString, sbStr);
+}
+
+/****************************************************************************
+ *	MakePDMInfoLog
+ *
+ *	Description:
+ *			Make PDM Info Parameter log.
+ *	Arguments:
+ *			pParam	pointer to parameter
+ *	Return:
+ *			none
+ *
+ ****************************************************************************/
+static void	MakePDMInfoLog
+(
+	const MCDRV_PDM_INFO* pParam
+)
+{
+	CHAR	sbStr[80];
+
+	if(pParam == NULL)
+	{
+		strcat(gsbLogString, " param=NULL");
+		return;
+	}
+
+	sprintf(sbStr, " bClk=%02X", pParam->bClk);
+	strcat(gsbLogString, sbStr);
+	sprintf(sbStr, " bAgcAdjust=%02X", pParam->bAgcAdjust);
+	strcat(gsbLogString, sbStr);
+	sprintf(sbStr, " bAgcOn=%02X", pParam->bAgcOn);
+	strcat(gsbLogString, sbStr);
+	sprintf(sbStr, " bPdmEdge=%02X", pParam->bPdmEdge);
+	strcat(gsbLogString, sbStr);
+	sprintf(sbStr, " bPdmWait=%02X", pParam->bPdmWait);
+	strcat(gsbLogString, sbStr);
+	sprintf(sbStr, " bPdmSel=%02X", pParam->bPdmSel);
+	strcat(gsbLogString, sbStr);
+	sprintf(sbStr, " bMono=%02X", pParam->bMono);
+	strcat(gsbLogString, sbStr);
+}
+
+/****************************************************************************
+ *	MakeDTMFInfoLog
+ *
+ *	Description:
+ *			Make DTMF Info Parameter log.
+ *	Arguments:
+ *			pParam	pointer to parameter
+ *	Return:
+ *			none
+ *
+ ****************************************************************************/
+static void	MakeDTMFInfoLog
+(
+	const MCDRV_DTMF_INFO* pParam
+)
+{
+	CHAR	sbStr[80];
+
+	if(pParam == NULL)
+	{
+		strcat(gsbLogString, " param=NULL");
+		return;
+	}
+
+	sprintf(sbStr, " bOnOff=%02X", pParam->bOnOff);
+	strcat(gsbLogString, sbStr);
+
+	sprintf(sbStr, " sParam.bSinGen0Vol=%02X", pParam->sParam.bSinGen0Vol);
+	strcat(gsbLogString, sbStr);
+	sprintf(sbStr, " sParam.bSinGen1Vol=%02X", pParam->sParam.bSinGen1Vol);
+	strcat(gsbLogString, sbStr);
+	sprintf(sbStr, " sParam.wSinGen0Freq=%04X", pParam->sParam.wSinGen0Freq);
+	strcat(gsbLogString, sbStr);
+	sprintf(sbStr, " sParam.wSinGen1Freq=%04X", pParam->sParam.wSinGen1Freq);
+	strcat(gsbLogString, sbStr);
+	sprintf(sbStr, " sParam.bSinGenGate=%02X", pParam->sParam.bSinGenGate);
+	strcat(gsbLogString, sbStr);
+	sprintf(sbStr, " sParam.=bSinGenMode%02X", pParam->sParam.bSinGenMode);
+	strcat(gsbLogString, sbStr);
+	sprintf(sbStr, " sParam.bSinGenLoop=%02X", pParam->sParam.bSinGenLoop);
+	strcat(gsbLogString, sbStr);
+}
+
+/****************************************************************************
+ *	MakeGPModeLog
+ *
+ *	Description:
+ *			Make GPIO mode Info Parameter log.
+ *	Arguments:
+ *			pParam	pointer to parameter
+ *	Return:
+ *			none
+ *
+ ****************************************************************************/
+static void	MakeGPModeLog
+(
+	const MCDRV_GP_MODE* pParam
+)
+{
+	CHAR	sbStr[80];
+	UINT8	bPadNo;
+
+	if(pParam == NULL)
+	{
+		strcat(gsbLogString, " param=NULL");
+		return;
+	}
+
+	for(bPadNo = 0; bPadNo < GPIO_PAD_NUM; bPadNo++)
+	{
+		sprintf(sbStr, " abGpDdr[%d]=%02X", bPadNo, pParam->abGpDdr[bPadNo]);
+		strcat(gsbLogString, sbStr);
+	}
+	for(bPadNo = 0; bPadNo < GPIO_PAD_NUM; bPadNo++)
+	{
+		sprintf(sbStr, " abGpMode[%d]=%02X", bPadNo, pParam->abGpMode[bPadNo]);
+		strcat(gsbLogString, sbStr);
+	}
+	for(bPadNo = 0; bPadNo < GPIO_PAD_NUM; bPadNo++)
+	{
+		sprintf(sbStr, " abGpHost[%d]=%02X", bPadNo, pParam->abGpHost[bPadNo]);
+		strcat(gsbLogString, sbStr);
+	}
+	for(bPadNo = 0; bPadNo < GPIO_PAD_NUM; bPadNo++)
+	{
+		sprintf(sbStr, " abGpInvert[%d]=%02X", bPadNo, pParam->abGpInvert[bPadNo]);
+		strcat(gsbLogString, sbStr);
+	}
+}
+
+/****************************************************************************
+ *	MakeGPMaskLog
+ *
+ *	Description:
+ *			Make GPIO Mask Info Parameter log.
+ *	Arguments:
+ *			pParam	pointer to parameter
+ *	Return:
+ *			none
+ *
+ ****************************************************************************/
+static void	MakeGPMaskLog
+(
+	const UINT8* pParam
+)
+{
+	CHAR	sbStr[80];
+
+	if(pParam == NULL)
+	{
+		strcat(gsbLogString, " param=NULL");
+		return;
+	}
+
+	sprintf(sbStr, " mask=%02X", *pParam);
+	strcat(gsbLogString, sbStr);
+}
+
+/****************************************************************************
+ *	MakeGetSetGPLog
+ *
+ *	Description:
+ *			Make Get/Set GPIO Info Parameter log.
+ *	Arguments:
+ *			pParam	pointer to parameter
+ *	Return:
+ *			none
+ *
+ ****************************************************************************/
+static void	MakeGetSetGPLog
+(
+	const UINT8* pParam
+)
+{
+	CHAR	sbStr[80];
+
+	if(pParam == NULL)
+	{
+		strcat(gsbLogString, " param=NULL");
+		return;
+	}
+
+	sprintf(sbStr, " HiLow=%02X", *pParam);
+	strcat(gsbLogString, sbStr);
+}
+
+/****************************************************************************
+ *	MakePeakLog
+ *
+ *	Description:
+ *			Make Peak Parameter log.
+ *	Arguments:
+ *			pParam	pointer to parameter
+ *	Return:
+ *			none
+ *
+ ****************************************************************************/
+static void	MakePeakLog
+(
+	const MCDRV_PEAK* pParam
+)
+{
+	CHAR	sbStr[80];
+	UINT8	bIdx;
+
+	if(pParam == NULL)
+	{
+		strcat(gsbLogString, " param=NULL");
+		return;
+	}
+
+	for(bIdx = 0; bIdx < PEAK_CHANNELS; bIdx++)
+	{
+		sprintf(sbStr, " aswPeak[%d]=%02X", bIdx, pParam->aswPeak[bIdx]);
+		strcat(gsbLogString, sbStr);
+	}
+}
+
+/****************************************************************************
+ *	MakeSysEQInfoLog
+ *
+ *	Description:
+ *			Make System EQ Info Parameter log.
+ *	Arguments:
+ *			pParam	pointer to parameter
+ *	Return:
+ *			none
+ *
+ ****************************************************************************/
+static void	MakeSysEQInfoLog
+(
+	const MCDRV_SYSEQ_INFO* pParam
+)
+{
+	CHAR	sbStr[80];
+	UINT8	bIdx;
+
+	if(pParam == NULL)
+	{
+		strcat(gsbLogString, " param=NULL");
+		return;
+	}
+
+	sprintf(sbStr, " bOnOff=%02X", pParam->bOnOff);
+	strcat(gsbLogString, sbStr);
+
+	for(bIdx = 0; bIdx < 15; bIdx++)
+	{
+		sprintf(sbStr, " abParam[%d]=%02X", bIdx, pParam->abParam[bIdx]);
+		strcat(gsbLogString, sbStr);
+	}
+}
+
+
+
+
+#endif	/*	MCDRV_DEBUG_LEVEL	*/
diff --git a/sound/soc/codecs/mc1n2/mcdebuglog.h b/sound/soc/codecs/mc1n2/mcdebuglog.h
new file mode 100644
index 0000000..f7b9e86
--- /dev/null
+++ b/sound/soc/codecs/mc1n2/mcdebuglog.h
@@ -0,0 +1,31 @@
+/****************************************************************************
+ *
+ *		Copyright(c) 2010 Yamaha Corporation. All rights reserved.
+ *
+ *		Module		: mcdebuglog.h
+ *
+ *		Description	: MC Driver debug log header
+ *
+ *		Version		: 1.0.0 	2010.08.16
+ *
+ ****************************************************************************/
+
+#ifndef _MCDEBUGLOB_H_
+#define _MCDEBUGLOG_H_
+
+#include "mcdriver.h"
+#include "mcmachdep.h"
+
+#if MCDRV_DEBUG_LEVEL
+
+
+void		McDebugLog_CmdIn	(UINT32 dCmd, const void* pvParam, UINT32 dUpdateInfo);
+void		McDebugLog_CmdOut	(UINT32 dCmd, const SINT32* psdRet, const void* pvParam);
+
+void		McDebugLog_FuncIn	(void* pvFuncName);
+void		McDebugLog_FuncOut	(void* pvFuncName, const SINT32* psdRet);
+
+
+#endif	/*	MCDRV_DEBUG_LEVEL	*/
+
+#endif /* _MCDEBUGLOG_H_ */
diff --git a/sound/soc/codecs/mc1n2/mcdefs.h b/sound/soc/codecs/mc1n2/mcdefs.h
new file mode 100644
index 0000000..fd05382
--- /dev/null
+++ b/sound/soc/codecs/mc1n2/mcdefs.h
@@ -0,0 +1,1160 @@
+/****************************************************************************
+ *
+ *		Copyright(c) 2010 Yamaha Corporation. All rights reserved.
+ *
+ *		Module		: mcdefs.h
+ *
+ *		Description	: MC Device Definitions
+ *
+ *		Version		: 1.0.0 	2010.07.05
+ *
+ ****************************************************************************/
+
+#ifndef _MCDEFS_H_
+#define	_MCDEFS_H_
+
+/*	Register Definition
+
+	[Naming Rules]
+
+	  MCI_xxx		: Registers
+	  MCI_xxx_DEF	: Default setting of registers
+	  MCB_xxx		: Miscelleneous bit definition
+*/
+
+/*	Registers	*/
+/*	A_ADR	*/
+#define	MCI_RST						(0)
+#define	MCB_RST						(0x01)
+#define	MCI_RST_DEF					(MCB_RST)
+
+#define	MCI_BASE_ADR				(1)
+#define	MCI_BASE_WINDOW				(2)
+
+#define	MCI_HW_ID					(8)
+#define	MCI_HW_ID_DEF				(0x79)
+
+#define	MCI_ANA_ADR					(12)
+#define	MCI_ANA_WINDOW				(13)
+
+#define	MCI_CD_ADR					(14)
+#define	MCI_CD_WINDOW				(15)
+
+#define	MCI_MIX_ADR					(16)
+#define	MCI_MIX_WINDOW				(17)
+
+#define	MCI_AE_ADR					(18)
+#define	MCI_AE_WINDOW				(19)
+
+#define	MCI_BDSP_ST					(20)
+#define	MCB_EQ5ON					(0x80)
+#define	MCB_DRCON					(0x40)
+#define	MCB_EQ3ON					(0x20)
+#define	MCB_DBEXON					(0x08)
+#define	MCB_BDSP_ST					(0x01)
+
+#define	MCI_BDSP_RST				(21)
+#define	MCB_TRAM_RST				(0x02)
+#define	MCB_BDSP_RST				(0x01)
+
+#define	MCI_BDSP_ADR				(22)
+#define	MCI_BDSP_WINDOW				(23)
+
+#define	MCI_CDSP_ADR				(24)
+#define	MCI_CDSP_WINDOW				(25)
+
+/*	B_ADR(BASE)	*/
+#define	MCI_RSTB					(0)
+#define	MCB_RSTB					(0x10)
+#define	MCI_RSTB_DEF				(MCB_RSTB)
+
+#define	MCI_PWM_DIGITAL				(1)
+#define	MCB_PWM_DP2					(0x04)
+#define	MCB_PWM_DP1					(0x02)
+#define	MCI_PWM_DIGITAL_DEF			(MCB_PWM_DP2 | MCB_PWM_DP1)
+
+#define	MCI_PWM_DIGITAL_1			(3)
+#define	MCB_PWM_DPPDM				(0x10)
+#define	MCB_PWM_DPDI2				(0x08)
+#define	MCB_PWM_DPDI1				(0x04)
+#define	MCB_PWM_DPDI0				(0x02)
+#define	MCB_PWM_DPB					(0x01)
+#define	MCI_PWM_DIGITAL_1_DEF		(MCB_PWM_DPPDM | MCB_PWM_DPDI2 | MCB_PWM_DPDI1 | MCB_PWM_DPDI0 | MCB_PWM_DPB)
+
+#define	MCI_PWM_DIGITAL_CDSP		(4)
+#define	MCB_PWM_DPCDSP				(0x00)
+#define	MCI_PWM_DIGITAL_CDSP_DEF	(MCB_PWM_DPCDSP)
+
+#define	MCI_PWM_DIGITAL_BDSP		(6)
+#define	MCI_PWM_DIGITAL_BDSP_DEF	(MCB_PWM_DPBDSP)
+#define	MCB_PWM_DPBDSP				(0x01)
+
+#define	MCI_SD_MSK					(9)
+#define	MCB_SDIN_MSK2				(0x80)
+#define	MCB_SDO_DDR2				(0x10)
+#define	MCB_SDIN_MSK1				(0x08)
+#define	MCB_SDO_DDR1				(0x01)
+#define	MCI_SD_MSK_DEF				(MCB_SDIN_MSK2 | MCB_SDIN_MSK1)
+
+#define	MCI_SD_MSK_1				(10)
+#define	MCB_SDIN_MSK0				(0x80)
+#define	MCB_SDO_DDR0				(0x10)
+#define	MCI_SD_MSK_1_DEF			(MCB_SDIN_MSK0)
+
+#define	MCI_BCLK_MSK				(11)
+#define	MCB_BCLK_MSK2				(0x80)
+#define	MCB_BCLK_DDR2				(0x40)
+#define	MCB_LRCK_MSK2				(0x20)
+#define	MCB_LRCK_DDR2				(0x10)
+#define	MCB_BCLK_MSK1				(0x08)
+#define	MCB_BCLK_DDR1				(0x04)
+#define	MCB_LRCK_MSK1				(0x02)
+#define	MCB_LRCK_DDR1				(0x01)
+#define	MCI_BCLK_MSK_DEF			(MCB_BCLK_MSK2 | MCB_LRCK_MSK2 | MCB_BCLK_MSK1 | MCB_LRCK_MSK1)
+
+#define	MCI_BCLK_MSK_1				(12)
+#define	MCB_BCLK_MSK0				(0x80)
+#define	MCB_BCLK_DDR0				(0x40)
+#define	MCB_LRCK_MSK0				(0x20)
+#define	MCB_LRCK_DDR0				(0x10)
+#define	MCB_PCMOUT_HIZ2				(0x08)
+#define	MCB_PCMOUT_HIZ1				(0x04)
+#define	MCB_PCMOUT_HIZ0				(0x02)
+#define	MCB_ROUTER_MS				(0x01)
+#define	MCI_BCLK_MSK_1_DEF			(MCB_BCLK_MSK0 | MCB_LRCK_MSK0)
+
+#define	MCI_BCKP					(13)
+#define	MCB_DI2_BCKP				(0x04)
+#define	MCB_DI1_BCKP				(0x02)
+#define	MCB_DI0_BCKP				(0x01)
+#define	MCI_BCKP_DEF				(0)
+
+#define	MCI_BYPASS					(21)
+#define	MCB_LOCK1					(0x80)
+#define	MCB_LOCK0					(0x40)
+#define	MCB_BYPASS1					(0x02)
+#define	MCB_BYPASS0					(0x01)
+
+#define	MCI_EPA_IRQ					(22)
+#define	MCB_EPA2_IRQ				(0x04)
+#define	MCB_EPA1_IRQ				(0x02)
+#define	MCB_EPA0_IRQ				(0x01)
+
+#define	MCI_PA_FLG					(23)
+#define	MCB_PA2_FLAG				(0x04)
+#define	MCB_PA1_FLAG				(0x02)
+#define	MCB_PA0_FLAG				(0x01)
+
+#define	MCI_PA_MSK					(26)
+#define	MCB_PA1_MSK					(0x80)
+#define	MCB_PA1_DDR					(0x40)
+#define	MCB_PA0_MSK					(0x08)
+#define	MCB_PA0_DDR					(0x04)
+#define	MCI_PA_MSK_DEF				(MCB_PA1_MSK | MCB_PA0_MSK)
+
+#define	MCI_PA_HOST					(28)
+#define	MCI_PA_HOST_1				(29)
+
+#define	MCI_PA_OUT					(30)
+#define	MCB_PA_OUT					(0x01)
+
+#define	MCI_PA_SCU_PA				(31)
+#define	MCB_PA_SCU_PA0				(0x01)
+#define	MCB_PA_SCU_PA1				(0x02)
+
+/*	B_ADR(MIX)	*/
+#define	MCI_DIT_INVFLAGL			(0)
+#define	MCB_DIT0_INVFLAGL			(0x20)
+#define	MCB_DIT1_INVFLAGL			(0x10)
+#define	MCB_DIT2_INVFLAGL			(0x08)
+
+#define	MCI_DIT_INVFLAGR			(1)
+#define	MCB_DIT0_INVFLAGR			(0x20)
+#define	MCB_DIT1_INVFLAGR			(0x10)
+#define	MCB_DIT2_INVFLAGR			(0x08)
+
+#define	MCI_DIR_VFLAGL				(2)
+#define	MCB_PDM0_VFLAGL				(0x80)
+#define	MCB_DIR0_VFLAGL				(0x20)
+#define	MCB_DIR1_VFLAGL				(0x10)
+#define	MCB_DIR2_VFLAGL				(0x08)
+
+#define	MCI_DIR_VFLAGR				(3)
+#define	MCB_PDM0_VFLAGR				(0x80)
+#define	MCB_DIR0_VFLAGR				(0x20)
+#define	MCB_DIR1_VFLAGR				(0x10)
+#define	MCB_DIR2_VFLAGR				(0x08)
+
+#define	MCI_AD_VFLAGL				(4)
+#define	MCB_ADC_VFLAGL				(0x80)
+#define	MCB_AENG6_VFLAGL			(0x20)
+
+#define	MCI_AD_VFLAGR				(5)
+#define	MCB_ADC_VFLAGR				(0x80)
+#define	MCB_AENG6_VFLAGR			(0x20)
+
+#define	MCI_AFLAGL					(6)
+#define	MCB_ADC_AFLAGL				(0x40)
+#define	MCB_DIR0_AFLAGL				(0x20)
+#define	MCB_DIR1_AFLAGL				(0x10)
+#define	MCB_DIR2_AFLAGL				(0x04)
+
+#define	MCI_AFLAGR					(7)
+#define	MCB_ADC_AFLAGR				(0x40)
+#define	MCB_DIR0_AFLAGR				(0x20)
+#define	MCB_DIR1_AFLAGR				(0x10)
+#define	MCB_DIR2_AFLAGR				(0x04)
+
+#define	MCI_DAC_INS_FLAG			(8)
+#define	MCB_DAC_INS_FLAG			(0x80)
+
+#define	MCI_INS_FLAG				(9)
+#define	MCB_ADC_INS_FLAG			(0x40)
+#define	MCB_DIR0_INS_FLAG			(0x20)
+#define	MCB_DIR1_INS_FLAG			(0x10)
+#define	MCB_DIR2_INS_FLAG			(0x04)
+
+#define	MCI_DAC_FLAGL				(10)
+#define	MCB_ST_FLAGL				(0x80)
+#define	MCB_MASTER_OFLAGL			(0x40)
+#define	MCB_VOICE_FLAGL				(0x10)
+#define	MCB_DAC_FLAGL				(0x02)
+
+#define	MCI_DAC_FLAGR				(11)
+#define	MCB_ST_FLAGR				(0x80)
+#define	MCB_MASTER_OFLAGR			(0x40)
+#define	MCB_VOICE_FLAGR				(0x10)
+#define	MCB_DAC_FLAGR				(0x02)
+
+#define	MCI_DIT0_INVOLL				(12)
+#define	MCB_DIT0_INLAT				(0x80)
+#define	MCB_DIT0_INVOLL				(0x7F)
+
+#define	MCI_DIT0_INVOLR				(13)
+#define	MCB_DIT0_INVOLR				(0x7F)
+
+#define	MCI_DIT1_INVOLL				(14)
+#define	MCB_DIT1_INLAT				(0x80)
+#define	MCB_DIT1_INVOLL				(0x7F)
+
+#define	MCI_DIT1_INVOLR				(15)
+#define	MCB_DIT1_INVOLR				(0x7F)
+
+#define	MCI_DIT2_INVOLL				(16)
+#define	MCB_DIT2_INLAT				(0x80)
+#define	MCB_DIT2_INVOLL				(0x7F)
+
+#define	MCI_DIT2_INVOLR				(17)
+#define	MCB_DIT2_INVOLR				(0x7F)
+
+#define	MCI_ESRC0_INVOLL			(16)
+#define	MCI_ESRC0_INVOLR			(17)
+
+#define	MCI_PDM0_VOLL				(24)
+#define	MCB_PDM0_LAT				(0x80)
+#define	MCB_PDM0_VOLL				(0x7F)
+
+#define	MCI_PDM0_VOLR				(25)
+#define	MCB_PDM0_VOLR				(0x7F)
+
+#define	MCI_DIR0_VOLL				(28)
+#define	MCB_DIR0_LAT				(0x80)
+#define	MCB_DIR0_VOLL				(0x7F)
+
+#define	MCI_DIR0_VOLR				(29)
+#define	MCB_DIR0_VOLR				(0x7F)
+
+#define	MCI_DIR1_VOLL				(30)
+#define	MCB_DIR1_LAT				(0x80)
+#define	MCB_DIR1_VOLL				(0x7F)
+
+#define	MCI_DIR1_VOLR				(31)
+#define	MCB_DIR1_VOLR				(0x7F)
+
+#define	MCI_DIR2_VOLL				(32)
+#define	MCB_DIR2_LAT				(0x80)
+#define	MCB_DIR2_VOLL				(0x7F)
+
+#define	MCI_DIR2_VOLR				(33)
+#define	MCB_DIR2_VOLR				(0x7F)
+/*
+#define	MCI_ADC1_VOLL				(38?)
+#define	MCB_ADC1_LAT				(0x80)
+#define	MCB_ADC1_VOLL				(0x7F)
+
+#define	MCI_ADC1_VOLR				(39?)
+#define	MCB_ADC1_VOLR				(0x7F)
+*/
+#define	MCI_ADC_VOLL				(40)
+#define	MCB_ADC_LAT					(0x80)
+#define	MCB_ADC_VOLL				(0x7F)
+
+#define	MCI_ADC_VOLR				(41)
+#define	MCB_ADC_VOLR				(0x7F)
+/*
+#define	MCI_DTMFB_VOLL				(42)
+#define	MCI_DTMFB_VOLR				(43)
+*/
+#define	MCI_AENG6_VOLL				(44)
+#define	MCB_AENG6_LAT				(0x80)
+#define	MCB_AENG6_VOLL				(0x7F)
+
+#define	MCI_AENG6_VOLR				(45)
+#define	MCB_AENG6_VOLR				(0x7F)
+
+#define	MCI_DIT_ININTP				(50)
+#define	MCB_DIT0_ININTP				(0x20)
+#define	MCB_DIT1_ININTP				(0x10)
+#define	MCB_DIT2_ININTP				(0x08)
+#define	MCI_DIT_ININTP_DEF			(MCB_DIT0_ININTP | MCB_DIT1_ININTP | MCB_DIT2_ININTP)
+
+#define	MCI_DIR_INTP				(51)
+#define	MCB_PDM0_INTP				(0x80)
+#define	MCB_DIR0_INTP				(0x20)
+#define	MCB_DIR1_INTP				(0x10)
+#define	MCB_DIR2_INTP				(0x08)
+#define	MCB_ADC2_INTP				(0x01)
+#define	MCI_DIR_INTP_DEF			(MCB_PDM0_INTP | MCB_DIR0_INTP | MCB_DIR1_INTP | MCB_DIR2_INTP)
+
+#define	MCI_ADC_INTP				(52)
+#define	MCB_ADC_INTP				(0x80)
+#define	MCB_AENG6_INTP				(0x20)
+#define	MCI_ADC_INTP_DEF			(MCB_ADC_INTP | MCB_AENG6_INTP)
+
+#define	MCI_ADC_ATTL				(54)
+#define	MCB_ADC_ALAT				(0x80)
+#define	MCB_ADC_ATTL				(0x7F)
+
+#define	MCI_ADC_ATTR				(55)
+#define	MCB_ADC_ATTR				(0x7F)
+
+#define	MCI_DIR0_ATTL				(56)
+#define	MCB_DIR0_ALAT				(0x80)
+#define	MCB_DIR0_ATTL				(0x7F)
+
+#define	MCI_DIR0_ATTR				(57)
+#define	MCB_DIR0_ATTR				(0x7F)
+
+#define	MCI_DIR1_ATTL				(58)
+#define	MCB_DIR1_ALAT				(0x80)
+#define	MCB_DIR1_ATTL				(0x7F)
+
+#define	MCI_DIR1_ATTR				(59)
+#define	MCB_DIR1_ATTR				(0x7F)
+/*
+#define	MCI_ADC2_ATTL				(60)
+#define	MCI_ADC2_ATTR				(61)
+*/
+#define	MCI_DIR2_ATTL				(62)
+#define	MCB_DIR2_ALAT				(0x80)
+#define	MCB_DIR2_ATTL				(0x7F)
+
+#define	MCI_DIR2_ATTR				(63)
+#define	MCB_DIR2_ATTR				(0x7F)
+
+#define	MCI_AINTP					(72)
+#define	MCB_ADC_AINTP				(0x40)
+#define	MCB_DIR0_AINTP				(0x20)
+#define	MCB_DIR1_AINTP				(0x10)
+#define	MCB_DIR2_AINTP				(0x04)
+#define	MCI_AINTP_DEF				(MCB_ADC_AINTP | MCB_DIR0_AINTP | MCB_DIR1_AINTP | MCB_DIR2_AINTP)
+
+#define	MCI_DAC_INS					(74)
+#define	MCB_DAC_INS					(0x80)
+
+#define	MCI_INS						(75)
+#define	MCB_ADC_INS					(0x40)
+#define	MCB_DIR0_INS				(0x20)
+#define	MCB_DIR1_INS				(0x10)
+#define	MCB_DIR2_INS				(0x04)
+
+#define	MCI_IINTP					(76)
+#define	MCB_DAC_IINTP				(0x80)
+#define	MCB_ADC_IINTP				(0x40)
+#define	MCB_DIR0_IINTP				(0x20)
+#define	MCB_DIR1_IINTP				(0x10)
+#define	MCB_DIR2_IINTP				(0x04)
+#define	MCI_IINTP_DEF				(MCB_DAC_IINTP | MCB_ADC_IINTP | MCB_DIR0_IINTP | MCB_DIR1_IINTP | MCB_DIR2_IINTP)
+
+#define	MCI_ST_VOLL					(77)
+#define	MCB_ST_LAT					(0x80)
+#define	MCB_ST_VOLL					(0x7F)
+
+#define	MCI_ST_VOLR					(78)
+#define	MCB_ST_VOLR					(0x7F)
+
+#define	MCI_MASTER_OUTL				(79)
+#define	MCB_MASTER_OLAT				(0x80)
+#define	MCB_MASTER_OUTL				(0x7F)
+
+#define	MCI_MASTER_OUTR				(80)
+#define	MCB_MASTER_OUTR				(0x7F)
+
+#define	MCI_VOICE_ATTL				(83)
+#define	MCB_VOICE_LAT				(0x80)
+#define	MCB_VOICE_ATTL				(0x7F)
+
+#define	MCI_VOICE_ATTR				(84)
+#define	MCB_VOICE_ATTR				(0x7F)
+/*
+#define	MCI_DTMF_ATTL				(85)
+#define	MCI_DTMF_ATTR				(86)
+*/
+#define	MCI_DAC_ATTL				(89)
+#define	MCB_DAC_LAT					(0x80)
+#define	MCB_DAC_ATTL				(0x7F)
+
+#define	MCI_DAC_ATTR				(90)
+#define	MCB_DAC_ATTR				(0x7F)
+
+#define	MCI_DAC_INTP				(93)
+#define	MCB_ST_INTP					(0x80)
+#define	MCB_MASTER_OINTP			(0x40)
+#define	MCB_VOICE_INTP				(0x10)
+/*#define	MCB_DTMF_INTP				(0x08)*/
+#define	MCB_DAC_INTP				(0x02)
+#define	MCI_DAC_INTP_DEF			(MCB_ST_INTP | MCB_MASTER_OINTP | MCB_VOICE_INTP | MCB_DAC_INTP)
+
+#define	MCI_SOURCE					(110)
+#define	MCB_DAC_SOURCE_AD			(0x10)
+#define	MCB_DAC_SOURCE_DIR2			(0x20)
+#define	MCB_DAC_SOURCE_DIR0			(0x30)
+#define	MCB_DAC_SOURCE_DIR1			(0x40)
+#define	MCB_DAC_SOURCE_MIX			(0x70)
+#define	MCB_VOICE_SOURCE_AD			(0x01)
+#define	MCB_VOICE_SOURCE_DIR2		(0x02)
+#define	MCB_VOICE_SOURCE_DIR0		(0x03)
+#define	MCB_VOICE_SOURCE_DIR1		(0x04)
+#define	MCB_VOICE_SOURCE_MIX		(0x07)
+
+#define	MCI_SWP						(111)
+
+#define	MCI_SRC_SOURCE				(112)
+#define	MCB_DIT0_SOURCE_AD			(0x10)
+#define	MCB_DIT0_SOURCE_DIR2		(0x20)
+#define	MCB_DIT0_SOURCE_DIR0		(0x30)
+#define	MCB_DIT0_SOURCE_DIR1		(0x40)
+#define	MCB_DIT0_SOURCE_MIX			(0x70)
+#define	MCB_DIT1_SOURCE_AD			(0x01)
+#define	MCB_DIT1_SOURCE_DIR2		(0x02)
+#define	MCB_DIT1_SOURCE_DIR0		(0x03)
+#define	MCB_DIT1_SOURCE_DIR1		(0x04)
+#define	MCB_DIT1_SOURCE_MIX			(0x07)
+
+#define	MCI_SRC_SOURCE_1			(113)
+#define	MCB_AE_SOURCE_AD			(0x10)
+#define	MCB_AE_SOURCE_DIR2			(0x20)
+#define	MCB_AE_SOURCE_DIR0			(0x30)
+#define	MCB_AE_SOURCE_DIR1			(0x40)
+#define	MCB_AE_SOURCE_MIX			(0x70)
+#define	MCB_DIT2_SOURCE_AD			(0x01)
+#define	MCB_DIT2_SOURCE_DIR2		(0x02)
+#define	MCB_DIT2_SOURCE_DIR0		(0x03)
+#define	MCB_DIT2_SOURCE_DIR1		(0x04)
+#define	MCB_DIT2_SOURCE_MIX			(0x07)
+
+#define	MCI_ESRC_SOURCE				(114)
+
+#define	MCI_AENG6_SOURCE			(115)
+#define	MCB_AENG6_ADC0				(0x00)
+#define	MCB_AENG6_PDM				(0x01)
+
+#define	MCI_EFIFO_SOURCE			(116)
+
+#define	MCI_SRC_SOURCE_2			(117)
+
+#define	MCI_PEAK_METER				(121)
+
+#define	MCI_OVFL					(122)
+#define	MCI_OVFR					(123)
+
+#define	MCI_DIMODE0					(130)
+
+#define	MCI_DIRSRC_RATE0_MSB		(131)
+
+#define	MCI_DIRSRC_RATE0_LSB		(132)
+
+#define	MCI_DITSRC_RATE0_MSB		(133)
+
+#define	MCI_DITSRC_RATE0_LSB		(134)
+
+#define	MCI_DI_FS0					(135)
+
+/*	DI Common Parameter	*/
+#define	MCB_DICOMMON_SRC_RATE_SET	(0x01)
+
+#define	MCI_DI0_SRC					(136)
+
+#define	MCI_DIX0_START				(137)
+#define	MCB_DITIM0_START			(0x40)
+#define	MCB_DIR0_SRC_START			(0x08)
+#define	MCB_DIR0_START				(0x04)
+#define	MCB_DIT0_SRC_START			(0x02)
+#define	MCB_DIT0_START				(0x01)
+
+#define	MCI_DIX0_FMT				(142)
+
+#define	MCI_DIR0_CH					(143)
+#define	MCI_DIR0_CH_DEF				(0x10)
+
+#define	MCI_DIT0_SLOT				(144)
+#define	MCI_DIT0_SLOT_DEF			(0x10)
+
+#define	MCI_HIZ_REDGE0				(145)
+
+#define	MCI_PCM_RX0					(146)
+#define	MCB_PCM_MONO_RX0			(0x80)
+#define	MCI_PCM_RX0_DEF				(MCB_PCM_MONO_RX0)
+
+#define	MCI_PCM_SLOT_RX0			(147)
+
+#define	MCI_PCM_TX0					(148)
+#define	MCB_PCM_MONO_TX0			(0x80)
+#define	MCI_PCM_TX0_DEF				(MCB_PCM_MONO_TX0)
+
+#define	MCI_PCM_SLOT_TX0			(149)
+#define	MCI_PCM_SLOT_TX0_DEF		(0x10)
+
+#define	MCI_DIMODE1					(150)
+
+#define	MCI_DIRSRC_RATE1_MSB		(151)
+#define	MCI_DIRSRC_RATE1_LSB		(152)
+
+#define	MCI_DITSRC_RATE1_MSB		(153)
+#define	MCI_DITSRC_RATE1_LSB		(154)
+
+#define	MCI_DI_FS1					(155)
+
+#define	MCI_DI1_SRC					(156)
+
+#define	MCI_DIX1_START				(157)
+#define	MCB_DITIM1_START			(0x40)
+#define	MCB_DIR1_SRC_START			(0x08)
+#define	MCB_DIR1_START				(0x04)
+#define	MCB_DIT1_SRC_START			(0x02)
+#define	MCB_DIT1_START				(0x01)
+
+#define	MCI_DIX1_FMT				(162)
+
+#define	MCI_DIR1_CH					(163)
+#define	MCB_DIR1_CH1				(0x10)
+#define	MCI_DIR1_CH_DEF				(MCB_DIR1_CH1)
+
+#define	MCI_DIT1_SLOT				(164)
+#define	MCB_DIT1_SLOT1				(0x10)
+#define	MCI_DIT1_SLOT_DEF			(MCB_DIT1_SLOT1)
+
+#define	MCI_HIZ_REDGE1				(165)
+
+#define	MCI_PCM_RX1					(166)
+#define	MCB_PCM_MONO_RX1			(0x80)
+#define	MCI_PCM_RX1_DEF				(MCB_PCM_MONO_RX1)
+
+#define	MCI_PCM_SLOT_RX1			(167)
+
+#define	MCI_PCM_TX1					(168)
+#define	MCB_PCM_MONO_TX1			(0x80)
+#define	MCI_PCM_TX1_DEF				(MCB_PCM_MONO_TX1)
+
+#define	MCI_PCM_SLOT_TX1			(169)
+#define	MCI_PCM_SLOT_TX1_DEF		(0x10)
+
+#define	MCI_DIMODE2					(170)
+
+#define	MCI_DIRSRC_RATE2_MSB		(171)
+#define	MCI_DIRSRC_RATE2_LSB		(172)
+
+#define	MCI_DITSRC_RATE2_MSB		(173)
+#define	MCI_DITSRC_RATE2_LSB		(174)
+
+#define	MCI_DI_FS2					(175)
+
+#define	MCI_DI2_SRC					(176)
+
+#define	MCI_DIX2_START				(177)
+#define	MCB_DITIM2_START			(0x40)
+#define	MCB_DIR2_SRC_START			(0x08)
+#define	MCB_DIR2_START				(0x04)
+#define	MCB_DIT2_SRC_START			(0x02)
+#define	MCB_DIT2_START				(0x01)
+
+#define	MCI_DIX2_FMT				(182)
+
+#define	MCI_DIR2_CH					(183)
+#define	MCB_DIR2_CH1				(0x10)
+#define	MCB_DIR2_CH0				(0x01)
+#define	MCI_DIR2_CH_DEF				(MCB_DIR2_CH1)
+
+#define	MCI_DIT2_SLOT				(184)
+#define	MCB_DIT2_SLOT1				(0x10)
+#define	MCB_DIT2_SLOT0				(0x01)
+#define	MCI_DIT2_SLOT_DEF			(MCB_DIT2_SLOT1)
+
+#define	MCI_HIZ_REDGE2				(185)
+
+#define	MCI_PCM_RX2					(186)
+#define	MCB_PCM_MONO_RX2			(0x80)
+#define	MCI_PCM_RX2_DEF				(MCB_PCM_MONO_RX2)
+
+#define	MCI_PCM_SLOT_RX2			(187)
+
+#define	MCI_PCM_TX2					(188)
+#define	MCB_PCM_MONO_TX2			(0x80)
+#define	MCI_PCM_TX2_DEF				(MCB_PCM_MONO_TX2)
+
+#define	MCI_PCM_SLOT_TX2			(189)
+#define	MCI_PCM_SLOT_TX2_DEF		(0x10)
+
+#define	MCI_CD_START				(192)
+
+#define	MCI_CDI_CH					(193)
+#define	MCI_CDI_CH_DEF				(0xE4)
+
+#define	MCI_CDO_SLOT				(194)
+#define	MCI_CDO_SLOT_DEF			(0xE4)
+
+#define	MCI_PDM_AGC					(200)
+#define	MCI_PDM_AGC_DEF				(0x03)
+
+#define	MCI_PDM_START				(202)
+#define	MCB_PDM_MN					(0x02)
+#define	MCB_PDM_START				(0x01)
+
+#define	MCI_PDM_STWAIT				(205)
+#define	MCI_PDM_STWAIT_DEF			(0x40)
+
+#define	MCI_HP_ID					(206)
+
+#define	MCI_CHP_H					(207)
+#define	MCI_CHP_H_DEF				(0x3F)
+
+#define	MCI_CHP_M					(208)
+#define	MCI_CHP_M_DEF				(0xEA)
+
+#define	MCI_CHP_L					(209)
+#define	MCI_CHP_L_DEF				(0x94)
+
+#define	MCI_SINGEN0_VOL				(210)
+#define	MCI_SINGEN1_VOL				(211)
+
+#define	MCI_SINGEN_FREQ0_MSB		(212)
+#define	MCI_SINGEN_FREQ0_LSB		(213)
+
+#define	MCI_SINGEN_FREQ1_MSB		(214)
+#define	MCI_SINGEN_FREQ1_LSB		(215)
+
+#define	MCI_SINGEN_GATETIME			(216)
+
+#define	MCI_SINGEN_FLAG				(217)
+
+/*	BADR(AE)	*/
+#define	MCI_BAND0_CEQ0				(0)
+#define	MCI_BAND0_CEQ0_H_DEF		(0x10)
+
+#define	MCI_BAND1_CEQ0				(15)
+#define	MCI_BAND1_CEQ0_H_DEF		(0x10)
+
+#define	MCI_BAND2_CEQ0				(30)
+#define	MCI_BAND2_CEQ0_H_DEF		(0x10)
+
+#define	MCI_BAND3H_CEQ0				(45)
+#define	MCI_BAND3H_CEQ0_H_DEF		(0x10)
+
+#define	MCI_BAND4H_CEQ0				(75)
+#define	MCI_BAND4H_CEQ0_H_DEF		(0x10)
+
+#define	MCI_BAND5_CEQ0				(105)
+#define	MCI_BAND5_CEQ0_H_DEF		(0x10)
+
+#define	MCI_BAND6H_CEQ0				(120)
+#define	MCI_BAND6H_CEQ0_H_DEF		(0x10)
+
+#define	MCI_BAND7H_CEQ0				(150)
+#define	MCI_BAND7H_CEQ0_H_DEF		(0x10)
+
+#define	MCI_PDM_CHP0_H				(240)
+#define	MCI_PDM_CHP0_H_DEF			(0x3F)
+#define	MCI_PDM_CHP0_M				(241)
+#define	MCI_PDM_CHP0_M_DEF			(0xEA)
+#define	MCI_PDM_CHP0_L				(242)
+#define	MCI_PDM_CHP0_L_DEF			(0x94)
+
+#define	MCI_PDM_CHP1_H				(243)
+#define	MCI_PDM_CHP1_H_DEF			(0xC0)
+#define	MCI_PDM_CHP1_M				(244)
+#define	MCI_PDM_CHP1_M_DEF			(0x15)
+#define	MCI_PDM_CHP1_L				(245)
+#define	MCI_PDM_CHP1_L_DEF			(0x6C)
+
+#define	MCI_PDM_CHP2_H				(246)
+#define	MCI_PDM_CHP2_H_DEF			(0x00)
+#define	MCI_PDM_CHP2_M				(247)
+#define	MCI_PDM_CHP2_M_DEF			(0x00)
+#define	MCI_PDM_CHP2_L				(248)
+#define	MCI_PDM_CHP2_L_DEF			(0x00)
+
+#define	MCI_PDM_CHP3_H				(249)
+#define	MCI_PDM_CHP3_H_DEF			(0x3F)
+#define	MCI_PDM_CHP3_M				(250)
+#define	MCI_PDM_CHP3_M_DEF			(0xD5)
+#define	MCI_PDM_CHP3_L				(251)
+#define	MCI_PDM_CHP3_L_DEF			(0x29)
+
+#define	MCI_PDM_CHP4_H				(252)
+#define	MCI_PDM_CHP4_H_DEF			(0x00)
+#define	MCI_PDM_CHP4_M				(253)
+#define	MCI_PDM_CHP4_M_DEF			(0x00)
+#define	MCI_PDM_CHP4_L				(254)
+#define	MCI_PDM_CHP4_L_DEF			(0x00)
+
+/*	B_ADR(CDSP)	*/
+#define	MCI_CDSP_SAVEOFF			(0)
+
+#define	MCI_OFIFO_LVL				(1)
+
+#define	MCI_EFIFO_LVL				(2)
+
+#define	MCI_DEC_POS_24				(4)
+#define	MCI_DEC_POS_16				(5)
+#define	MCI_DEC_POS_8				(6)
+#define	MCI_DEC_POS_0				(7)
+
+#define	MCI_ENC_POS_24				(8)
+#define	MCI_ENC_POS_16				(9)
+#define	MCI_ENC_POS_8				(10)
+#define	MCI_ENC_POS_0				(11)
+
+#define	MCI_DEC_ERR					(12)
+#define	MCI_ENC_ERR					(13)
+
+#define	MCI_FIFO_RST				(14)
+
+#define	MCI_DEC_ENC_START			(15)
+
+#define	MCI_FIFO4CH					(16)
+
+#define	MCI_DEC_CTL15				(19)
+
+#define	MCI_DEC_GPR15				(35)
+
+#define	MCI_DEC_SFR1				(51)
+#define	MCI_DEC_SFR0				(52)
+
+#define	MCI_ENC_CTL15				(53)
+
+#define	MCI_ENC_GPR15				(69)
+
+#define	MCI_ENC_SFR1				(85)
+#define	MCI_ENC_SFR0				(86)
+
+#define	MCI_JOEMP					(92)
+#define	MCB_JOEMP					(0x80)
+#define	MCB_JOPNT					(0x40)
+#define	MCB_OOVF_FLG				(0x08)
+#define	MCB_OUDF_FLG				(0x04)
+#define	MCB_OEMP_FLG				(0x02)
+#define	MCB_OPNT_FLG				(0x01)
+#define	MCI_JOEMP_DEF				(MCB_JOEMP | MCB_OEMP_FLG)
+
+#define	MCI_JEEMP					(93)
+#define	MCB_JEEMP					(0x80)
+#define	MCB_JEPNT					(0x40)
+#define	MCB_EOVF_FLG				(0x08)
+#define	MCB_EUDF_FLG				(0x04)
+#define	MCB_EEMP_FLG				(0x02)
+#define	MCB_EPNT_FLG				(0x01)
+#define	MCI_JEEMP_DEF				(MCB_JEEMP | MCB_EEMP_FLG)
+
+#define	MCI_DEC_FLG					(96)
+#define	MCI_ENC_FLG					(97)
+
+#define	MCI_DEC_GPR_FLG				(98)
+#define	MCI_ENC_GPR_FLG				(99)
+
+#define	MCI_EOPNT					(101)
+
+#define	MCI_EDEC					(105)
+#define	MCI_EENC					(106)
+
+#define	MCI_EDEC_GPR				(107)
+#define	MCI_EENC_GPR				(108)
+
+#define	MCI_CDSP_SRST				(110)
+#define	MCB_CDSP_FMODE				(0x10)
+#define	MCB_CDSP_MSAVE				(0x08)
+#define	MCB_CDSP_SRST				(0x01)
+#define	MCI_CDSP_SRST_DEF			(MCB_CDSP_SRST)
+
+#define	MCI_CDSP_SLEEP				(112)
+
+#define	MCI_CDSP_ERR				(113)
+
+#define	MCI_CDSP_MAR_MSB			(114)
+#define	MCI_CDSP_MAR_LSB			(115)
+
+#define	MCI_OFIFO_IRQ_PNT			(116)
+
+#define	MCI_EFIFO_IRQ_PNT			(122)
+
+#define	MCI_CDSP_FLG				(128)
+
+#define	MCI_ECDSP_ERR				(129)
+
+/*	B_ADR(CD)	*/
+#define	MCI_DPADIF					(1)
+#define	MCB_CLKSRC					(0x80)
+#define	MCB_CLKBUSY					(0x40)
+#define	MCB_CLKINPUT				(0x20)
+#define	MCB_DPADIF					(0x10)
+#define	MCB_DP0_CLKI1				(0x08)
+#define	MCB_DP0_CLKI0				(0x01)
+#define	MCI_DPADIF_DEF				(MCB_DPADIF|MCB_DP0_CLKI1|MCB_DP0_CLKI0)
+
+#define	MCI_CKSEL					(4)
+#define	MCB_CK1SEL					(0x80)
+#define	MCB_CK0SEL					(0x40)
+
+#define	MCI_CD_HW_ID				(8)
+#define	MCI_CD_HW_ID_DEF			(0x79)
+
+#define	MCI_PLL_RST					(15)
+#define	MCB_PLLRST0					(0x01)
+#define	MCI_PLL_RST_DEF				(MCB_PLLRST0)
+
+#define	MCI_DIVR0					(16)
+#define	MCI_DIVR0_DEF				(0x0D)
+
+#define	MCI_DIVF0					(17)
+#define	MCI_DIVF0_DEF				(0x55)
+
+#define	MCI_DIVR1					(18)
+#define	MCI_DIVR1_DEF				(0x02)
+
+#define	MCI_DIVF1					(19)
+#define	MCI_DIVF1_DEF				(0x48)
+
+#define	MCI_AD_AGC					(70)
+#define	MCI_AD_AGC_DEF				(0x03)
+
+#define	MCI_AD_START				(72)
+#define	MCI_AD_START_DEF			(0x00)
+#define	MCB_AD_START				(0x01)
+
+#define	MCI_DCCUTOFF				(77)
+#define	MCI_DCCUTOFF_DEF			(0x00)
+
+#define	MCI_DAC_CONFIG				(78)
+#define	MCI_DAC_CONFIG_DEF			(0x02)
+#define	MCB_NSMUTE					(0x02)
+#define	MCB_DACON					(0x01)
+
+#define	MCI_DCL						(79)
+#define	MCI_DCL_DEF					(0x00)
+
+#define	MCI_SYS_CEQ0_19_12			(80)
+#define	MCI_SYS_CEQ0_19_12_DEF		(0x10)
+
+#define	MCI_SYS_CEQ0_11_4			(81)
+#define	MCI_SYS_CEQ0_11_4_DEF		(0xC4)
+
+#define	MCI_SYS_CEQ0_3_0			(82)
+#define	MCI_SYS_CEQ0_3_0_DEF		(0x50)
+
+#define	MCI_SYS_CEQ1_19_12			(83)
+#define	MCI_SYS_CEQ1_19_12_DEF		(0x12)
+
+#define	MCI_SYS_CEQ1_11_4			(84)
+#define	MCI_SYS_CEQ1_11_4_DEF		(0xC4)
+
+#define	MCI_SYS_CEQ1_3_0			(85)
+#define	MCI_SYS_CEQ1_3_0_DEF		(0x40)
+
+#define	MCI_SYS_CEQ2_19_12			(86)
+#define	MCI_SYS_CEQ2_19_12_DEF		(0x02)
+
+#define	MCI_SYS_CEQ2_11_4			(87)
+#define	MCI_SYS_CEQ2_11_4_DEF		(0xA9)
+
+#define	MCI_SYS_CEQ2_3_0			(88)
+#define	MCI_SYS_CEQ2_3_0_DEF		(0x60)
+
+#define	MCI_SYS_CEQ3_19_12			(89)
+#define	MCI_SYS_CEQ3_19_12_DEF		(0xED)
+
+#define	MCI_SYS_CEQ3_11_4			(90)
+#define	MCI_SYS_CEQ3_11_4_DEF		(0x3B)
+
+#define	MCI_SYS_CEQ3_3_0			(91)
+#define	MCI_SYS_CEQ3_3_0_DEF		(0xC0)
+
+#define	MCI_SYS_CEQ4_19_12			(92)
+#define	MCI_SYS_CEQ4_19_12_DEF		(0xFC)
+
+#define	MCI_SYS_CEQ4_11_4			(93)
+#define	MCI_SYS_CEQ4_11_4_DEF		(0x92)
+
+#define	MCI_SYS_CEQ4_3_0			(94)
+#define	MCI_SYS_CEQ4_3_0_DEF		(0x40)
+
+#define	MCI_SYSTEM_EQON				(95)
+#define	MCB_SYSEQ_INTP				(0x20)
+#define	MCB_SYSEQ_FLAG				(0x10)
+#define	MCB_SYSTEM_EQON				(0x01)
+#define	MCI_SYSTEM_EQON_DEF			(MCB_SYSEQ_INTP|MCB_SYSTEM_EQON)
+
+/*	B_ADR(ANA)	*/
+#define	MCI_ANA_RST					(0)
+#define	MCI_ANA_RST_DEF				(0x01)
+
+#define	MCI_PWM_ANALOG_0			(2)
+#define	MCB_PWM_VR					(0x01)
+#define	MCB_PWM_CP					(0x02)
+#define	MCB_PWM_REFA				(0x04)
+#define	MCB_PWM_LDOA				(0x08)
+#define	MCI_PWM_ANALOG_0_DEF		(MCB_PWM_VR|MCB_PWM_CP|MCB_PWM_REFA|MCB_PWM_LDOA)
+
+#define	MCI_PWM_ANALOG_1			(3)
+#define	MCB_PWM_SPL1				(0x01)
+#define	MCB_PWM_SPL2				(0x02)
+#define	MCB_PWM_SPR1				(0x04)
+#define	MCB_PWM_SPR2				(0x08)
+#define	MCB_PWM_HPL					(0x10)
+#define	MCB_PWM_HPR					(0x20)
+#define	MCB_PWM_ADL					(0x40)
+#define	MCB_PWM_ADR					(0x80)
+#define	MCI_PWM_ANALOG_1_DEF		(MCB_PWM_SPL1|MCB_PWM_SPL2|MCB_PWM_SPR1|MCB_PWM_SPR2|MCB_PWM_HPL|MCB_PWM_HPR|MCB_PWM_ADL|MCB_PWM_ADR)
+
+#define	MCI_PWM_ANALOG_2			(4)
+#define	MCB_PWM_LO1L				(0x01)
+#define	MCB_PWM_LO1R				(0x02)
+#define	MCB_PWM_LO2L				(0x04)
+#define	MCB_PWM_LO2R				(0x08)
+#define	MCB_PWM_RC1					(0x10)
+#define	MCB_PWM_RC2					(0x20)
+#define	MCI_PWM_ANALOG_2_DEF		(MCB_PWM_LO1L|MCB_PWM_LO1R|MCB_PWM_LO2L|MCB_PWM_LO2R|MCB_PWM_RC1|MCB_PWM_RC2)
+
+#define	MCI_PWM_ANALOG_3			(5)
+#define	MCB_PWM_MB1					(0x01)
+#define	MCB_PWM_MB2					(0x02)
+#define	MCB_PWM_MB3					(0x04)
+#define	MCB_PWM_DAL					(0x08)
+#define	MCB_PWM_DAR					(0x10)
+#define	MCI_PWM_ANALOG_3_DEF		(MCB_PWM_MB1|MCB_PWM_MB2|MCB_PWM_MB3|MCB_PWM_DAL|MCB_PWM_DAR)
+
+#define	MCI_PWM_ANALOG_4			(6)
+#define	MCB_PWM_MC1					(0x10)
+#define	MCB_PWM_MC2					(0x20)
+#define	MCB_PWM_MC3					(0x40)
+#define	MCB_PWM_LI					(0x80)
+#define	MCI_PWM_ANALOG_4_DEF		(MCB_PWM_MC1|MCB_PWM_MC2|MCB_PWM_MC3|MCB_PWM_LI)
+
+#define	MCI_BUSY1					(12)
+#define	MCB_RC_BUSY					(0x20)
+#define	MCB_HPL_BUSY				(0x10)
+#define	MCB_SPL_BUSY				(0x08)
+
+#define	MCI_BUSY2					(13)
+#define	MCB_HPR_BUSY				(0x10)
+#define	MCB_SPR_BUSY				(0x08)
+
+#define	MCI_APMOFF					(16)
+#define	MCB_APMOFF_SP				(0x01)
+#define	MCB_APMOFF_HP				(0x02)
+#define	MCB_APMOFF_RC				(0x04)
+
+#define	MCI_DIF_LINE				(24)
+#define	MCI_DIF_LINE_DEF			(0x00)
+
+#define	MCI_LI1VOL_L				(25)
+#define	MCI_LI1VOL_L_DEF			(0x00)
+#define	MCB_ALAT_LI1				(0x40)
+#define	MCB_LI1VOL_L				(0x1F)
+
+#define	MCI_LI1VOL_R				(26)
+#define	MCI_LI1VOL_R_DEF			(0x00)
+#define	MCB_LI1VOL_R				(0x1F)
+
+#define	MCI_LI2VOL_L				(27)
+#define	MCI_LI2VOL_L_DEF			(0x00)
+#define	MCB_ALAT_LI2				(0x40)
+#define	MCB_LI2VOL_L				(0x1F)
+
+#define	MCI_LI2VOL_R				(28)
+#define	MCI_LI2VOL_R_DEF			(0x00)
+#define	MCB_LI2VOL_R				(0x1F)
+
+#define	MCI_MC1VOL					(29)
+#define	MCI_MC1VOL_DEF				(0x00)
+#define	MCB_MC1VOL					(0x1F)
+
+#define	MCI_MC2VOL					(30)
+#define	MCI_MC2VOL_DEF				(0x00)
+#define	MCB_MC2VOL					(0x1F)
+
+#define	MCI_MC3VOL					(31)
+#define	MCI_MC3VOL_DEF				(0x00)
+#define	MCB_MC3VOL					(0x1F)
+
+#define	MCI_ADVOL_L					(32)
+#define	MCI_ADVOL_L_DEF				(0x00)
+#define	MCB_ALAT_AD					(0x40)
+#define	MCB_ADVOL_L					(0x1F)
+
+#define	MCI_ADVOL_R					(33)
+#define	MCB_ADVOL_R					(0x1F)
+
+#define	MCI_HPVOL_L					(35)
+#define	MCB_ALAT_HP					(0x40)
+#define	MCB_SVOL_HP					(0x20)
+#define	MCB_HPVOL_L					(0x1F)
+#define	MCI_HPVOL_L_DEF				(MCB_SVOL_HP)
+
+#define	MCI_HPVOL_R					(36)
+#define	MCI_HPVOL_R_DEF				(0x00)
+#define	MCB_HPVOL_R					(0x1F)
+
+#define	MCI_SPVOL_L					(37)
+#define	MCB_ALAT_SP					(0x40)
+#define	MCB_SVOL_SP					(0x20)
+#define	MCB_SPVOL_L					(0x1F)
+#define	MCI_SPVOL_L_DEF				(MCB_SVOL_SP)
+
+#define	MCI_SPVOL_R					(38)
+#define	MCI_SPVOL_R_DEF				(0x00)
+#define	MCB_SPVOL_R					(0x1F)
+
+#define	MCI_RCVOL					(39)
+#define	MCB_SVOL_RC					(0x20)
+#define	MCB_RCVOL					(0x1F)
+#define	MCI_RCVOL_DEF				(MCB_SVOL_RC)
+
+#define	MCI_LO1VOL_L				(40)
+#define	MCI_LO1VOL_L_DEF			(0x20)
+#define	MCB_ALAT_LO1				(0x40)
+#define	MCB_LO1VOL_L				(0x1F)
+
+#define	MCI_LO1VOL_R				(41)
+#define	MCI_LO1VOL_R_DEF			(0x00)
+#define	MCB_LO1VOL_R				(0x1F)
+
+#define	MCI_LO2VOL_L				(42)
+#define	MCI_LO2VOL_L_DEF			(0x20)
+#define	MCB_ALAT_LO2				(0x40)
+#define	MCB_LO2VOL_L				(0x1F)
+
+#define	MCI_LO2VOL_R				(43)
+#define	MCI_LO2VOL_R_DEF			(0x00)
+#define	MCB_LO2VOL_R				(0x1F)
+
+#define	MCI_SP_MODE					(44)
+#define	MCB_SPR_HIZ					(0x20)
+#define	MCB_SPL_HIZ					(0x10)
+#define	MCB_SPMN					(0x02)
+#define	MCB_SP_SWAP					(0x01)
+
+#define	MCI_MC_GAIN					(45)
+#define	MCI_MC_GAIN_DEF				(0x00)
+#define	MCB_MC2SNG					(0x40)
+#define	MCB_MC2GAIN					(0x30)
+#define	MCB_MC1SNG					(0x04)
+#define	MCB_MC1GAIN					(0x03)
+
+#define	MCI_MC3_GAIN				(46)
+#define	MCI_MC3_GAIN_DEF			(0x00)
+#define	MCB_MC3SNG					(0x04)
+#define	MCB_MC3GAIN					(0x03)
+
+#define	MCI_RDY_FLAG				(47)
+#define	MCB_LDO_RDY					(0x80)
+#define	MCB_VREF_RDY				(0x40)
+#define	MCB_SPRDY_R					(0x20)
+#define	MCB_SPRDY_L					(0x10)
+#define	MCB_HPRDY_R					(0x08)
+#define	MCB_HPRDY_L					(0x04)
+#define	MCB_CPPDRDY					(0x02)
+
+/*	analog mixer common */
+#define	MCB_LI1MIX					(0x01)
+#define	MCB_M1MIX					(0x08)
+#define	MCB_M2MIX					(0x10)
+#define	MCB_M3MIX					(0x20)
+#define	MCB_DAMIX					(0x40)
+#define	MCB_DARMIX					(0x40)
+#define	MCB_DALMIX					(0x80)
+
+#define	MCB_MONO_DA					(0x40)
+#define	MCB_MONO_LI1				(0x01)
+
+#define	MCI_ADL_MIX					(50)
+#define	MCI_ADL_MONO				(51)
+#define	MCI_ADR_MIX					(52)
+#define	MCI_ADR_MONO				(53)
+
+#define	MCI_LO1L_MIX				(55)
+#define	MCI_LO1L_MONO				(56)
+#define	MCI_LO1R_MIX				(57)
+
+#define	MCI_LO2L_MIX				(58)
+#define	MCI_LO2L_MONO				(59)
+#define	MCI_LO2R_MIX				(60)
+
+#define	MCI_HPL_MIX					(61)
+#define	MCI_HPL_MONO				(62)
+#define	MCI_HPR_MIX					(63)
+
+#define	MCI_SPL_MIX					(64)
+#define	MCI_SPL_MONO				(65)
+#define	MCI_SPR_MIX					(66)
+#define	MCI_SPR_MONO				(67)
+
+#define	MCI_RC_MIX					(69)
+
+#define	MCI_CPMOD					(72)
+
+#define	MCI_HP_GAIN					(77)
+
+#define	MCI_LEV						(79)
+#define	MCB_AVDDLEV					(0x07)
+#define	MCI_LEV_DEF					(0x24)
+
+#define	MCI_DNGATRT_HP				(82)
+#define	MCI_DNGATRT_HP_DEF			(0x23)
+
+#define	MCI_DNGTARGET_HP			(83)
+#define	MCI_DNGTARGET_HP_DEF		(0x50)
+
+#define	MCI_DNGON_HP				(84)
+#define	MCI_DNGON_HP_DEF			(0x54)
+
+#define	MCI_DNGATRT_SP				(85)
+#define	MCI_DNGATRT_SP_DEF			(0x23)
+
+#define	MCI_DNGTARGET_SP			(86)
+#define	MCI_DNGTARGET_SP_DEF		(0x50)
+
+#define	MCI_DNGON_SP				(87)
+#define	MCI_DNGON_SP_DEF			(0x54)
+
+#define	MCI_DNGATRT_RC				(88)
+#define	MCI_DNGATRT_RC_DEF			(0x23)
+
+#define	MCI_DNGTARGET_RC			(89)
+#define	MCI_DNGTARGET_RC_DEF		(0x50)
+
+#define	MCI_DNGON_RC				(90)
+#define	MCI_DNGON_RC_DEF			(0x54)
+
+#define	MCI_AP_A1					(123)
+#define	MCB_AP_CP_A					(0x10)
+#define	MCB_AP_HPL_A				(0x02)
+#define	MCB_AP_HPR_A				(0x01)
+
+#define	MCI_AP_A2					(124)
+#define	MCB_AP_RC1_A				(0x20)
+#define	MCB_AP_RC2_A				(0x10)
+#define	MCB_AP_SPL1_A				(0x08)
+#define	MCB_AP_SPR1_A				(0x04)
+#define	MCB_AP_SPL2_A				(0x02)
+#define	MCB_AP_SPR2_A				(0x01)
+
+#endif /* __MCDEFS_H__ */
diff --git a/sound/soc/codecs/mc1n2/mcdevif.c b/sound/soc/codecs/mc1n2/mcdevif.c
new file mode 100644
index 0000000..00a2224
--- /dev/null
+++ b/sound/soc/codecs/mc1n2/mcdevif.c
@@ -0,0 +1,317 @@
+/****************************************************************************
+ *
+ *		Copyright(c) 2010 Yamaha Corporation. All rights reserved.
+ *
+ *		Module		: mcdevif.c
+ *
+ *		Description	: MC Driver device interface
+ *
+ *		Version		: 1.0.0 	2010.09.10
+ *
+ ****************************************************************************/
+
+
+#include "mcdevif.h"
+#include "mcservice.h"
+#include "mcresctrl.h"
+#include "mcmachdep.h"
+#if MCDRV_DEBUG_LEVEL
+#include "mcdebuglog.h"
+#endif
+
+
+
+static MCDRV_PACKET*	gpsPacket	= NULL;
+
+/****************************************************************************
+ *	McDevIf_AllocPacketBuf
+ *
+ *	Description:
+ *			allocate the buffer for register setting packets.
+ *	Arguments:
+ *			none
+ *	Return:
+ *			MCDRV_SUCCESS
+ *			MCDRV_ERROR
+ *
+ ****************************************************************************/
+SINT32	McDevIf_AllocPacketBuf
+(
+	void
+)
+{
+	SINT32	sdRet	= MCDRV_SUCCESS;
+
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncIn("McDevIf_AllocPacketBuf");
+#endif
+
+	gpsPacket	= McResCtrl_AllocPacketBuf();
+	if(gpsPacket == NULL)
+	{
+		sdRet	= MCDRV_ERROR;
+	}
+	else
+	{
+		McDevIf_ClearPacket();
+	}
+
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncOut("McDevIf_AllocPacketBuf", &sdRet);
+#endif
+
+	return sdRet;
+}
+
+/****************************************************************************
+ *	McDevIf_ReleasePacketBuf
+ *
+ *	Description:
+ *			Release the buffer for register setting packets.
+ *	Arguments:
+ *			none
+ *	Return:
+ *			none
+ *
+ ****************************************************************************/
+void	McDevIf_ReleasePacketBuf
+(
+	void
+)
+{
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncIn("McDevIf_ReleasePacketBuf");
+#endif
+
+	McResCtrl_ReleasePacketBuf();
+
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncOut("McDevIf_ReleasePacketBuf", 0);
+#endif
+}
+
+/****************************************************************************
+ *	McDevIf_ClearPacket
+ *
+ *	Description:
+ *			Clear packets.
+ *	Arguments:
+ *			none
+ *	Return:
+ *			none
+ *
+ ****************************************************************************/
+void	McDevIf_ClearPacket
+(
+	void
+)
+{
+#if (MCDRV_DEBUG_LEVEL>=4)
+	SINT32	sdRet;
+	McDebugLog_FuncIn("McDevIf_ClearPacket");
+#endif
+
+	if(gpsPacket == NULL)
+	{
+		#if (MCDRV_DEBUG_LEVEL>=4)
+			sdRet	= MCDRV_ERROR;
+			McDebugLog_FuncOut("McDevIf_ClearPacket", &sdRet);
+		#endif
+		return;
+	}
+
+	gpsPacket[0].dDesc = MCDRV_PACKET_TYPE_TERMINATE;
+
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncOut("McDevIf_ClearPacket", 0);
+#endif
+}
+
+/****************************************************************************
+ *	McDevIf_AddPacket
+ *
+ *	Description:
+ *			Add a packet.
+ *	Arguments:
+ *			dDesc		packet info
+ *			bData		packet data
+ *	Return:
+ *			none
+ *
+ ****************************************************************************/
+void	McDevIf_AddPacket
+(
+	UINT32			dDesc,
+	UINT8			bData
+)
+{
+	UINT32	i;
+
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncIn("McDevIf_AddPacket");
+#endif
+
+	if(gpsPacket == NULL)
+	{
+	}
+	else
+	{
+		for(i = 0; i < MCDRV_MAX_PACKETS; i++)
+		{
+			if(gpsPacket[i].dDesc == MCDRV_PACKET_TYPE_TERMINATE)
+			{
+				break;
+			}
+		}
+		if(i >= MCDRV_MAX_PACKETS)
+		{
+			McDevIf_ExecutePacket();
+			i	= 0;
+		}
+
+		gpsPacket[i].dDesc		= dDesc;
+		gpsPacket[i].bData		= bData;
+		gpsPacket[i+1UL].dDesc	= MCDRV_PACKET_TYPE_TERMINATE;
+	}
+
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncOut("McDevIf_AddPacket", 0);
+#endif
+}
+
+/****************************************************************************
+ *	McDevIf_AddPacketRepeat
+ *
+ *	Description:
+ *			Add packets to set data at same register over agian.
+ *	Arguments:
+ *			dDesc			packet info
+ *			pbData			poointer to packet data
+ *			wDataCount		packet data count
+ *	Return:
+ *			none
+ *
+ ****************************************************************************/
+void	McDevIf_AddPacketRepeat
+(
+	UINT32			dDesc,
+	const UINT8*	pbData,
+	UINT16			wDataCount
+)
+{
+	UINT16	wCount;
+
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncIn("McDevIf_AddPacketRepeat");
+#endif
+
+	for(wCount = 0; wCount < wDataCount; wCount++)
+	{
+		McDevIf_AddPacket(dDesc, pbData[wCount]);
+	}
+
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncOut("McDevIf_AddPacketRepeat", 0);
+#endif
+}
+
+/****************************************************************************
+ *	McDevIf_ExecutePacket
+ *
+ *	Description:
+ *			Execute sequence for register setting.
+ *	Arguments:
+ *			none
+ *	Return:
+ *			MCDRV_SUCCESS
+ *			MCDRV_ERROR_ARGUMENT
+ *
+ ****************************************************************************/
+SINT32	McDevIf_ExecutePacket
+(
+	void
+)
+{
+	SINT32	sdRet;
+	SINT16	swPacketIndex;
+	UINT32	dPacketType;
+	UINT32	dParam1;
+	UINT32	dParam2;
+	UINT16	wAddress;
+	UINT16	wRegType;
+	MCDRV_UPDATE_MODE	eUpdateMode;
+
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncIn("McDevIf_ExecutePacket");
+#endif
+
+	if(gpsPacket == NULL)
+	{
+		sdRet	= MCDRV_ERROR_RESOURCEOVER;
+	}
+	else
+	{
+		sdRet	= MCDRV_SUCCESS;
+
+		McResCtrl_InitRegUpdate();
+		swPacketIndex = 0;
+		while ((MCDRV_PACKET_TYPE_TERMINATE != (gpsPacket[swPacketIndex].dDesc & MCDRV_PACKET_TYPE_MASK)) && (sdRet == MCDRV_SUCCESS))
+		{
+			dPacketType = gpsPacket[swPacketIndex].dDesc & MCDRV_PACKET_TYPE_MASK;
+			switch (dPacketType)
+			{
+			case MCDRV_PACKET_TYPE_WRITE:
+			case MCDRV_PACKET_TYPE_FORCE_WRITE:
+				wRegType = (UINT16)(gpsPacket[swPacketIndex].dDesc & MCDRV_PACKET_REGTYPE_MASK);
+				wAddress = (UINT16)(gpsPacket[swPacketIndex].dDesc & MCDRV_PACKET_ADR_MASK);
+				if (MCDRV_PACKET_TYPE_WRITE == dPacketType)
+				{
+					eUpdateMode = eMCDRV_UPDATE_NORMAL;
+				}
+				else if (MCDRV_PACKET_TYPE_FORCE_WRITE == dPacketType)
+				{
+					eUpdateMode = eMCDRV_UPDATE_FORCE;
+				}
+				else
+				{
+					eUpdateMode = eMCDRV_UPDATE_DUMMY;
+				}
+				McResCtrl_AddRegUpdate(wRegType, wAddress, gpsPacket[swPacketIndex].bData, eUpdateMode);
+				break;
+
+			case MCDRV_PACKET_TYPE_TIMWAIT:
+				McResCtrl_ExecuteRegUpdate();
+				McResCtrl_InitRegUpdate();
+				dParam1 = gpsPacket[swPacketIndex].dDesc & MCDRV_PACKET_TIME_MASK;
+				McSrv_Sleep(dParam1);
+				break;
+
+			case MCDRV_PACKET_TYPE_EVTWAIT:
+				McResCtrl_ExecuteRegUpdate();
+				McResCtrl_InitRegUpdate();
+				dParam1 = gpsPacket[swPacketIndex].dDesc & MCDRV_PACKET_EVT_MASK;
+				dParam2 = gpsPacket[swPacketIndex].dDesc & MCDRV_PACKET_EVTPRM_MASK;
+				sdRet = McResCtrl_WaitEvent(dParam1, dParam2);
+				break;
+
+			default:
+				sdRet	= MCDRV_ERROR;
+				break;
+			}
+
+			swPacketIndex++;
+		}
+		if(sdRet == MCDRV_SUCCESS)
+		{
+			McResCtrl_ExecuteRegUpdate();
+		}
+		McDevIf_ClearPacket();
+	}
+
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncOut("McDevIf_ExecutePacket", &sdRet);
+#endif
+
+	return sdRet;
+}
+
diff --git a/sound/soc/codecs/mc1n2/mcdevif.h b/sound/soc/codecs/mc1n2/mcdevif.h
new file mode 100644
index 0000000..b51383a
--- /dev/null
+++ b/sound/soc/codecs/mc1n2/mcdevif.h
@@ -0,0 +1,81 @@
+/****************************************************************************
+ *
+ *		Copyright(c) 2010 Yamaha Corporation. All rights reserved.
+ *
+ *		Module		: mcdevif.h
+ *
+ *		Description	: MC Driver device interface header
+ *
+ *		Version		: 1.0.0 	2010.07.05
+ *
+ ****************************************************************************/
+
+#ifndef _MCDEVIF_H_
+#define _MCDEVIF_H_
+
+#include "mctypedef.h"
+#include "mcdriver.h"
+
+/* packet */
+typedef struct
+{
+	UINT32	dDesc;
+	UINT8	bData;
+} MCDRV_PACKET;
+
+#define	MCDRV_MAX_PACKETS					(256UL)
+
+/*	packet dDesc	*/
+/*	packet type	*/
+#define	MCDRV_PACKET_TYPE_WRITE				(0x10000000UL)
+#define	MCDRV_PACKET_TYPE_FORCE_WRITE		(0x20000000UL)
+#define	MCDRV_PACKET_TYPE_TIMWAIT			(0x30000000UL)
+#define	MCDRV_PACKET_TYPE_EVTWAIT			(0x40000000UL)
+#define	MCDRV_PACKET_TYPE_TERMINATE			(0xF0000000UL)
+
+#define	MCDRV_PACKET_TYPE_MASK				(0xF0000000UL)
+
+/*	reg type	*/
+#define	MCDRV_PACKET_REGTYPE_A				(0x00000000UL)
+#define	MCDRV_PACKET_REGTYPE_B_BASE			(0x00001000UL)
+#define	MCDRV_PACKET_REGTYPE_B_MIXER		(0x00002000UL)
+#define	MCDRV_PACKET_REGTYPE_B_AE			(0x00003000UL)
+#define	MCDRV_PACKET_REGTYPE_B_CDSP			(0x00004000UL)
+#define	MCDRV_PACKET_REGTYPE_B_CODEC		(0x00005000UL)
+#define	MCDRV_PACKET_REGTYPE_B_ANA			(0x00006000UL)
+
+#define	MCDRV_PACKET_REGTYPE_MASK			(0x0000F000UL)
+#define	MCDRV_PACKET_ADR_MASK				(0x00000FFFUL)
+
+/*	event	*/
+#define	MCDRV_EVT_INSFLG					(0x00010000UL)
+#define	MCDRV_EVT_ALLMUTE					(0x00020000UL)
+#define	MCDRV_EVT_DACMUTE					(0x00030000UL)
+#define	MCDRV_EVT_DITMUTE					(0x00040000UL)
+#define	MCDRV_EVT_SVOL_DONE					(0x00050000UL)
+#define	MCDRV_EVT_APM_DONE					(0x00060000UL)
+#define	MCDRV_EVT_ANA_RDY					(0x00070000UL)
+#define	MCDRV_EVT_SYSEQ_FLAG_RESET			(0x00080000UL)
+#define	MCDRV_EVT_CLKBUSY_RESET				(0x00090000UL)
+#define	MCDRV_EVT_CLKSRC_SET				(0x000A0000UL)
+#define	MCDRV_EVT_CLKSRC_RESET				(0x000B0000UL)
+#define MCDRV_EVT_ADCMUTE					(0x000C0000UL)
+
+
+#define	MCDRV_PACKET_EVT_MASK				(0x0FFF0000UL)
+#define	MCDRV_PACKET_EVTPRM_MASK			(0x0000FFFFUL)
+
+/*	timer	*/
+#define	MCDRV_PACKET_TIME_MASK				(0x0FFFFFFFUL)
+
+
+
+SINT32		McDevIf_AllocPacketBuf		(void);
+void		McDevIf_ReleasePacketBuf	(void);
+void		McDevIf_ClearPacket			(void);
+void		McDevIf_AddPacket			(UINT32 dDesc, UINT8 bData);
+void		McDevIf_AddPacketRepeat		(UINT32 dDesc, const UINT8* pbData, UINT16 wDataCount);
+SINT32		McDevIf_ExecutePacket		(void);
+
+
+#endif /* _MCDEVIF_H_ */
diff --git a/sound/soc/codecs/mc1n2/mcdevprof.c b/sound/soc/codecs/mc1n2/mcdevprof.c
new file mode 100644
index 0000000..ece8349
--- /dev/null
+++ b/sound/soc/codecs/mc1n2/mcdevprof.c
@@ -0,0 +1,131 @@
+/****************************************************************************
+ *
+ *		Copyright(c) 2010 Yamaha Corporation. All rights reserved.
+ *
+ *		Module		: mcdevprof.c
+ *
+ *		Description	: MC Driver device profile
+ *
+ *		Version		: 1.0.0 	2010.09.10
+ *
+ ****************************************************************************/
+
+
+#include "mcdevprof.h"
+#include "mcmachdep.h"
+#if MCDRV_DEBUG_LEVEL
+#include "mcdebuglog.h"
+#endif
+
+
+static	MCDRV_DEV_ID	geDevID	= eMCDRV_DEV_ID_1N2;
+
+static	UINT8	gabValid[][3]	=
+{
+/*	MC-1N2	MC-2N	MC-3N	*/
+	{0,		0,		1},		/*	DI2		*/
+	{0,		0,		1},		/*	RANGE	*/
+	{0,		0,		1},		/*	BYPASS	*/
+	{0,		0,		1},		/*	ADC1	*/
+	{0,		0,		0},		/*	PAD2	*/
+	{0,		1,		1},		/*	DBEX	*/
+	{0,		0,		1},		/*	GPMODE	*/
+	{0,		0,		1},		/*	DTMF	*/
+	{0,		0,		1},		/*	IRQ		*/
+};
+
+static UINT8	gabSlaveAddr[3][2]	=
+{
+/*	Digital Analog	*/
+	{0x3A,	0x3A},	/*	MC1N2	*/
+	{0x00,	0x00},	/*	MC2N	*/
+	{0x00,	0x00}	/*	MC3N	*/
+};
+
+/****************************************************************************
+ *	McDevProf_SetDevId
+ *
+ *	Description:
+ *			Set device ID.
+ *	Arguments:
+ *			eDevId	device ID
+ *	Return:
+ *			none
+ *
+ ****************************************************************************/
+void	McDevProf_SetDevId(MCDRV_DEV_ID eDevId)
+{
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncIn("McDevProf_SetDevId");
+#endif
+
+	geDevID	= eDevId;
+
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncOut("McDevProf_SetDevId", 0);
+#endif
+}
+
+/****************************************************************************
+ *	McDevProf_IsValid
+ *
+ *	Description:
+ *			Validity function.
+ *	Arguments:
+ *			function kind
+ *	Return:
+ *			0:Invalid/1:Valid
+ *
+ ****************************************************************************/
+UINT8	McDevProf_IsValid
+(
+	MCDRV_FUNC_KIND eFuncKind
+)
+{
+	UINT8	bData;
+
+#if (MCDRV_DEBUG_LEVEL>=4)
+	SINT32	sdRet;
+	McDebugLog_FuncIn("McDevProf_IsValid");
+#endif
+
+	bData	= gabValid[eFuncKind][geDevID];
+
+#if (MCDRV_DEBUG_LEVEL>=4)
+	sdRet	= (SINT32)bData;
+	McDebugLog_FuncOut("McDevProf_IsValid", &sdRet);
+#endif
+	return bData;
+}
+
+/****************************************************************************
+ *	McDevProf_GetSlaveAddr
+ *
+ *	Description:
+ *			get slave address.
+ *	Arguments:
+ *			eSlaveAddrKind	slave address kind
+ *	Return:
+ *			slave address
+ *
+ ****************************************************************************/
+UINT8	McDevProf_GetSlaveAddr
+(
+	MCDRV_SLAVE_ADDR_KIND eSlaveAddrKind
+)
+{
+	UINT8	bData	= gabSlaveAddr[geDevID][eSlaveAddrKind];
+
+#if (MCDRV_DEBUG_LEVEL>=4)
+	SINT32	sdRet;
+	McDebugLog_FuncIn("McDevProf_GetSlaveAddr");
+#endif
+
+#if (MCDRV_DEBUG_LEVEL>=4)
+	sdRet	= (SINT32)bData;
+	McDebugLog_FuncOut("McDevProf_GetSlaveAddr", &sdRet);
+#endif
+
+	return bData;
+}
+
diff --git a/sound/soc/codecs/mc1n2/mcdevprof.h b/sound/soc/codecs/mc1n2/mcdevprof.h
new file mode 100644
index 0000000..6c1c166
--- /dev/null
+++ b/sound/soc/codecs/mc1n2/mcdevprof.h
@@ -0,0 +1,53 @@
+/****************************************************************************
+ *
+ *		Copyright(c) 2010 Yamaha Corporation. All rights reserved.
+ *
+ *		Module		: mcdevprof.h
+ *
+ *		Description	: MC Driver device profile header
+ *
+ *		Version		: 1.0.0 	2010.07.05
+ *
+ ****************************************************************************/
+
+#ifndef _MCDEVPROF_H_
+#define _MCDEVPROF_H_
+
+#include "mctypedef.h"
+
+typedef enum
+{
+	eMCDRV_DEV_ID_1N2	= 0,
+	eMCDRV_DEV_ID_2N,
+	eMCDRV_DEV_ID_3N
+} MCDRV_DEV_ID;
+
+typedef enum
+{
+	eMCDRV_FUNC_LI2	= 0,
+	eMCDRV_FUNC_RANGE,
+	eMCDRV_FUNC_BYPASS,
+	eMCDRV_FUNC_ADC1,
+	eMCDRV_FUNC_PAD2,
+	eMCDRV_FUNC_DBEX,
+	eMCDRV_FUNC_GPMODE,
+	eMCDRV_FUNC_DTMF,
+	eMCDRV_FUNC_IRQ
+} MCDRV_FUNC_KIND;
+
+typedef enum
+{
+	eMCDRV_SLAVE_ADDR_DIG	= 0,
+	eMCDRV_SLAVE_ADDR_ANA
+} MCDRV_SLAVE_ADDR_KIND;
+
+
+
+void	McDevProf_SetDevId(MCDRV_DEV_ID eDevId);
+
+UINT8	McDevProf_IsValid(MCDRV_FUNC_KIND eFuncKind);
+UINT8	McDevProf_GetSlaveAddr(MCDRV_SLAVE_ADDR_KIND eSlaveAddrKind);
+
+
+
+#endif	/*	_MCDEVPROF_H_	*/
diff --git a/sound/soc/codecs/mc1n2/mcdriver.c b/sound/soc/codecs/mc1n2/mcdriver.c
new file mode 100644
index 0000000..af3cdc3
--- /dev/null
+++ b/sound/soc/codecs/mc1n2/mcdriver.c
@@ -0,0 +1,4047 @@
+/****************************************************************************
+ *
+ *		Copyright(c) 2010-2011 Yamaha Corporation. All rights reserved.
+ *
+ *		Module		: mcdriver.c
+ *
+ *		Description	: MC Driver
+ *
+ *		Version		: 1.0.2		2011.04.18
+ *
+ ****************************************************************************/
+
+
+#include "mcdriver_AA.h"
+#include "mcdriver.h"
+#include "mcservice.h"
+#include "mcdevif.h"
+#include "mcresctrl.h"
+#include "mcdefs.h"
+#include "mcdevprof.h"
+#include "mcmachdep.h"
+#if MCDRV_DEBUG_LEVEL
+#include "mcdebuglog.h"
+#endif
+
+
+
+#define	MCDRV_MAX_WAIT_TIME	((UINT32)0x0FFFFFFF)
+
+static SINT32	init					(const MCDRV_INIT_INFO* psInitInfo);
+static SINT32	term					(void);
+
+static SINT32	read_reg				(MCDRV_REG_INFO* psRegInfo);
+static SINT32	write_reg				(const MCDRV_REG_INFO* psRegInfo);
+
+static SINT32	update_clock			(const MCDRV_CLOCK_INFO* psClockInfo);
+static SINT32	switch_clock			(const MCDRV_CLKSW_INFO* psClockInfo);
+
+static SINT32	get_path				(MCDRV_PATH_INFO* psPathInfo);
+static SINT32	set_path				(const MCDRV_PATH_INFO* psPathInfo);
+
+static SINT32	get_volume				(MCDRV_VOL_INFO* psVolInfo);
+static SINT32	set_volume				(const MCDRV_VOL_INFO *psVolInfo);
+
+static SINT32	get_digitalio			(MCDRV_DIO_INFO* psDioInfo);
+static SINT32	set_digitalio			(const MCDRV_DIO_INFO* psDioInfo, UINT32 dUpdateInfo);
+
+static SINT32	get_dac					(MCDRV_DAC_INFO* psDacInfo);
+static SINT32	set_dac					(const MCDRV_DAC_INFO* psDacInfo, UINT32 dUpdateInfo);
+
+static SINT32	get_adc					(MCDRV_ADC_INFO* psAdcInfo);
+static SINT32	set_adc					(const MCDRV_ADC_INFO* psAdcInfo, UINT32 dUpdateInfo);
+
+static SINT32	get_sp					(MCDRV_SP_INFO* psSpInfo);
+static SINT32	set_sp					(const MCDRV_SP_INFO* psSpInfo);
+
+static SINT32	get_dng					(MCDRV_DNG_INFO* psDngInfo);
+static SINT32	set_dng					(const MCDRV_DNG_INFO* psDngInfo, UINT32 dUpdateInfo);
+
+static SINT32	set_ae					(const MCDRV_AE_INFO* psAeInfo, UINT32 dUpdateInfo);
+
+static SINT32	get_pdm					(MCDRV_PDM_INFO* psPdmInfo);
+static SINT32	set_pdm					(const MCDRV_PDM_INFO* psPdmInfo, UINT32 dUpdateInfo);
+
+static SINT32	config_gp				(const MCDRV_GP_MODE* psGpMode);
+static SINT32	mask_gp					(UINT8* pbMask, UINT32 dPadNo);
+static SINT32	getset_gp				(UINT8* pbGpio, UINT32 dPadNo);
+
+static SINT32	get_syseq				(MCDRV_SYSEQ_INFO* psSysEq);
+static SINT32	set_syseq				(const MCDRV_SYSEQ_INFO* psSysEq, UINT32 dUpdateInfo);
+
+static SINT32	ValidateInitParam		(const MCDRV_INIT_INFO* psInitInfo);
+static SINT32	ValidateClockParam		(const MCDRV_CLOCK_INFO* psClockInfo);
+static SINT32	ValidateReadRegParam	(const MCDRV_REG_INFO* psRegInfo);
+static SINT32	ValidateWriteRegParam	(const MCDRV_REG_INFO* psRegInfo);
+static SINT32	ValidatePathParam		(const MCDRV_PATH_INFO* psPathInfo);
+static SINT32	ValidateDioParam		(const MCDRV_DIO_INFO* psDioInfo, UINT32 dUpdateInfo);
+static SINT32	CheckDIOCommon			(const MCDRV_DIO_INFO*	psDioInfo, UINT8 bPort);
+static SINT32	CheckDIODIR				(const MCDRV_DIO_INFO*	psDioInfo, UINT8 bPort, UINT8 bInterface);
+static SINT32	CheckDIODIT				(const MCDRV_DIO_INFO*	psDioInfo, UINT8 bPort, UINT8 bInterface);
+
+static SINT32	SetVol					(UINT32 dUpdate, MCDRV_VOLUPDATE_MODE eMode, UINT32* pdSVolDoneParam);
+static	SINT32	PreUpdatePath			(UINT16* pwDACMuteParam, UINT16* pwDITMuteParam);
+
+
+/****************************************************************************
+ *	init
+ *
+ *	Description:
+ *			Initialize.
+ *	Arguments:
+ *			psInitInfo	initialize information
+ *	Return:
+ *			MCDRV_SUCCESS
+ *			MCDRV_ERROR_ARGUMENT
+ *			MCDRV_ERROR_STATE
+ *
+ ****************************************************************************/
+static	SINT32	init
+(
+	const MCDRV_INIT_INFO	*psInitInfo
+)
+{
+	SINT32	sdRet;
+	UINT8	bHWID;
+
+	if(NULL == psInitInfo)
+	{
+		return MCDRV_ERROR_ARGUMENT;
+	}
+
+	if(eMCDRV_STATE_NOTINIT != McResCtrl_GetState())
+	{
+		return MCDRV_ERROR_STATE;
+	}
+
+	McSrv_SystemInit();
+	McSrv_Lock();
+
+	bHWID	= McSrv_ReadI2C(McDevProf_GetSlaveAddr(eMCDRV_SLAVE_ADDR_DIG), (UINT32)MCI_HW_ID);
+	sdRet	= McResCtrl_SetHwId(bHWID);
+	if(sdRet != MCDRV_SUCCESS)
+	{
+		McSrv_Unlock();
+		McSrv_SystemTerm();
+		return sdRet;
+	}
+
+	if(bHWID == MCDRV_HWID_AA)
+	{
+		McSrv_Unlock();
+		McSrv_SystemTerm();
+		return McDrv_Ctrl_AA(MCDRV_INIT, (MCDRV_INIT_INFO*)psInitInfo, 0);
+	}
+	else
+	{
+		sdRet	= ValidateInitParam(psInitInfo);
+
+		if(sdRet == MCDRV_SUCCESS)
+		{
+			McResCtrl_Init(psInitInfo);
+			sdRet	= McDevIf_AllocPacketBuf();
+		}
+
+		if(sdRet == MCDRV_SUCCESS)
+		{
+			sdRet	= McPacket_AddInit(psInitInfo);
+		}
+
+		if(sdRet == MCDRV_SUCCESS)
+		{
+			sdRet	= McDevIf_ExecutePacket();
+		}
+
+		if(sdRet == MCDRV_SUCCESS)
+		{
+			McResCtrl_UpdateState(eMCDRV_STATE_READY);
+		}
+		else
+		{
+			McDevIf_ReleasePacketBuf();
+		}
+
+		McSrv_Unlock();
+
+		if(sdRet != MCDRV_SUCCESS)
+		{
+			McSrv_SystemTerm();
+		}
+	}
+
+	return sdRet;
+}
+
+/****************************************************************************
+ *	term
+ *
+ *	Description:
+ *			Terminate.
+ *	Arguments:
+ *			none
+ *	Return:
+ *			MCDRV_SUCCESS
+ *			MCDRV_ERROR_STATE
+ *
+ ****************************************************************************/
+static	SINT32	term
+(
+	void
+)
+{
+	SINT32	sdRet	= MCDRV_SUCCESS;
+	UINT8	bCh, bSrcIdx;
+	UINT8	abOnOff[SOURCE_BLOCK_NUM];
+	MCDRV_PATH_INFO		sPathInfo;
+	MCDRV_POWER_INFO	sPowerInfo;
+	MCDRV_POWER_UPDATE	sPowerUpdate;
+
+	if(eMCDRV_STATE_READY != McResCtrl_GetState())
+	{
+		return MCDRV_ERROR_STATE;
+	}
+
+	McSrv_Lock();
+
+	abOnOff[0]	= (MCDRV_SRC0_MIC1_OFF|MCDRV_SRC0_MIC2_OFF|MCDRV_SRC0_MIC3_OFF);
+	abOnOff[1]	= (MCDRV_SRC1_LINE1_L_OFF|MCDRV_SRC1_LINE1_R_OFF|MCDRV_SRC1_LINE1_M_OFF);
+	abOnOff[2]	= (MCDRV_SRC2_LINE2_L_OFF|MCDRV_SRC2_LINE2_R_OFF|MCDRV_SRC2_LINE2_M_OFF);
+	abOnOff[3]	= (MCDRV_SRC3_DIR0_OFF|MCDRV_SRC3_DIR1_OFF|MCDRV_SRC3_DIR2_OFF|MCDRV_SRC3_DIR2_DIRECT_OFF);
+	abOnOff[4]	= (MCDRV_SRC4_DTMF_OFF|MCDRV_SRC4_PDM_OFF|MCDRV_SRC4_ADC0_OFF|MCDRV_SRC4_ADC1_OFF);
+	abOnOff[5]	= (MCDRV_SRC5_DAC_L_OFF|MCDRV_SRC5_DAC_R_OFF|MCDRV_SRC5_DAC_M_OFF);
+	abOnOff[6]	= (MCDRV_SRC6_MIX_OFF|MCDRV_SRC6_AE_OFF|MCDRV_SRC6_CDSP_OFF|MCDRV_SRC6_CDSP_DIRECT_OFF);
+
+	for(bSrcIdx = 0; bSrcIdx < SOURCE_BLOCK_NUM; bSrcIdx++)
+	{
+		for(bCh = 0; bCh < HP_PATH_CHANNELS; bCh++)
+		{
+			sPathInfo.asHpOut[bCh].abSrcOnOff[bSrcIdx]	= abOnOff[bSrcIdx];
+		}
+		for(bCh = 0; bCh < SP_PATH_CHANNELS; bCh++)
+		{
+			sPathInfo.asSpOut[bCh].abSrcOnOff[bSrcIdx]	= abOnOff[bSrcIdx];
+		}
+		for(bCh = 0; bCh < RC_PATH_CHANNELS; bCh++)
+		{
+			sPathInfo.asRcOut[bCh].abSrcOnOff[bSrcIdx]	= abOnOff[bSrcIdx];
+		}
+		for(bCh = 0; bCh < LOUT1_PATH_CHANNELS; bCh++)
+		{
+			sPathInfo.asLout1[bCh].abSrcOnOff[bSrcIdx]	= abOnOff[bSrcIdx];
+		}
+		for(bCh = 0; bCh < LOUT2_PATH_CHANNELS; bCh++)
+		{
+			sPathInfo.asLout2[bCh].abSrcOnOff[bSrcIdx]	= abOnOff[bSrcIdx];
+		}
+		for(bCh = 0; bCh < PEAK_PATH_CHANNELS; bCh++)
+		{
+			sPathInfo.asPeak[bCh].abSrcOnOff[bSrcIdx]	= abOnOff[bSrcIdx];
+		}
+		for(bCh = 0; bCh < DIT0_PATH_CHANNELS; bCh++)
+		{
+			sPathInfo.asDit0[bCh].abSrcOnOff[bSrcIdx]	= abOnOff[bSrcIdx];
+		}
+		for(bCh = 0; bCh < DIT1_PATH_CHANNELS; bCh++)
+		{
+			sPathInfo.asDit1[bCh].abSrcOnOff[bSrcIdx]	= abOnOff[bSrcIdx];
+		}
+		for(bCh = 0; bCh < DIT2_PATH_CHANNELS; bCh++)
+		{
+			sPathInfo.asDit2[bCh].abSrcOnOff[bSrcIdx]	= abOnOff[bSrcIdx];
+		}
+		for(bCh = 0; bCh < DAC_PATH_CHANNELS; bCh++)
+		{
+			sPathInfo.asDac[bCh].abSrcOnOff[bSrcIdx]	= abOnOff[bSrcIdx];
+		}
+		for(bCh = 0; bCh < AE_PATH_CHANNELS; bCh++)
+		{
+			sPathInfo.asAe[bCh].abSrcOnOff[bSrcIdx]		= abOnOff[bSrcIdx];
+		}
+		for(bCh = 0; bCh < CDSP_PATH_CHANNELS; bCh++)
+		{
+			sPathInfo.asCdsp[bCh].abSrcOnOff[bSrcIdx]	= abOnOff[bSrcIdx];
+		}
+		for(bCh = 0; bCh < ADC0_PATH_CHANNELS; bCh++)
+		{
+			sPathInfo.asAdc0[bCh].abSrcOnOff[bSrcIdx]	= abOnOff[bSrcIdx];
+		}
+		for(bCh = 0; bCh < ADC1_PATH_CHANNELS; bCh++)
+		{
+			sPathInfo.asAdc1[bCh].abSrcOnOff[bSrcIdx]	= abOnOff[bSrcIdx];
+		}
+		for(bCh = 0; bCh < MIX_PATH_CHANNELS; bCh++)
+		{
+			sPathInfo.asMix[bCh].abSrcOnOff[bSrcIdx]	= abOnOff[bSrcIdx];
+		}
+		for(bCh = 0; bCh < BIAS_PATH_CHANNELS; bCh++)
+		{
+			sPathInfo.asBias[bCh].abSrcOnOff[bSrcIdx]	= abOnOff[bSrcIdx];
+		}
+	}
+	sdRet	= set_path(&sPathInfo);
+	if(sdRet == MCDRV_SUCCESS)
+	{
+		sPowerInfo.dDigital			= (MCDRV_POWINFO_DIGITAL_DP0
+									  |MCDRV_POWINFO_DIGITAL_DP1
+									  |MCDRV_POWINFO_DIGITAL_DP2
+									  |MCDRV_POWINFO_DIGITAL_DPB
+									  |MCDRV_POWINFO_DIGITAL_DPDI0
+									  |MCDRV_POWINFO_DIGITAL_DPDI1
+									  |MCDRV_POWINFO_DIGITAL_DPDI2
+									  |MCDRV_POWINFO_DIGITAL_DPPDM
+									  |MCDRV_POWINFO_DIGITAL_DPBDSP
+									  |MCDRV_POWINFO_DIGITAL_DPADIF
+									  |MCDRV_POWINFO_DIGITAL_PLLRST0);
+		sPowerInfo.abAnalog[0]		=
+		sPowerInfo.abAnalog[1]		=
+		sPowerInfo.abAnalog[2]		=
+		sPowerInfo.abAnalog[3]		=
+		sPowerInfo.abAnalog[4]		= (UINT8)0xFF;
+		sPowerUpdate.dDigital		= MCDRV_POWUPDATE_DIGITAL_ALL;
+		sPowerUpdate.abAnalog[0]	= (UINT8)MCDRV_POWUPDATE_ANALOG0_ALL;
+		sPowerUpdate.abAnalog[1]	= (UINT8)MCDRV_POWUPDATE_ANALOG1_ALL;
+		sPowerUpdate.abAnalog[2]	= (UINT8)MCDRV_POWUPDATE_ANALOG2_ALL;
+		sPowerUpdate.abAnalog[3]	= (UINT8)MCDRV_POWUPDATE_ANALOG3_ALL;
+		sPowerUpdate.abAnalog[4]	= (UINT8)MCDRV_POWUPDATE_ANALOG4_ALL;
+		sdRet	= McPacket_AddPowerDown(&sPowerInfo, &sPowerUpdate);
+	}
+	if(sdRet == MCDRV_SUCCESS)
+	{
+		sdRet	= McDevIf_ExecutePacket();
+	}
+
+	McDevIf_ReleasePacketBuf();
+
+	McResCtrl_UpdateState(eMCDRV_STATE_NOTINIT);
+
+	McSrv_Unlock();
+
+	McSrv_SystemTerm();
+
+	return sdRet;
+}
+
+/****************************************************************************
+ *	read_reg
+ *
+ *	Description:
+ *			read register.
+ *	Arguments:
+ *			psRegInfo	register information
+ *	Return:
+ *			MCDRV_SUCCESS
+ *			MCDRV_ERROR_STATE
+ *			MCDRV_ERROR_ARGUMENT
+ *
+ ****************************************************************************/
+static	SINT32	read_reg
+(
+	MCDRV_REG_INFO*	psRegInfo
+)
+{
+	SINT32	sdRet	= MCDRV_SUCCESS;
+	UINT8	bSlaveAddr;
+	UINT8	bAddr;
+	UINT8	abData[2];
+	MCDRV_POWER_INFO	sPowerInfo;
+	MCDRV_POWER_INFO	sCurPowerInfo;
+	MCDRV_POWER_UPDATE	sPowerUpdate;
+
+	if(NULL == psRegInfo)
+	{
+		return MCDRV_ERROR_ARGUMENT;
+	}
+
+	if(eMCDRV_STATE_NOTINIT == McResCtrl_GetState())
+	{
+		return MCDRV_ERROR_STATE;
+	}
+
+	sdRet	= ValidateReadRegParam(psRegInfo);
+	if(sdRet != MCDRV_SUCCESS)
+	{
+		return sdRet;
+	}
+
+	/*	get current power info	*/
+	McResCtrl_GetCurPowerInfo(&sCurPowerInfo);
+
+	/*	power up	*/
+	McResCtrl_GetPowerInfoRegAccess(psRegInfo, &sPowerInfo);
+	sPowerUpdate.dDigital		= MCDRV_POWUPDATE_DIGITAL_ALL;
+	sPowerUpdate.abAnalog[0]	= (UINT8)MCDRV_POWUPDATE_ANALOG0_ALL;
+	sPowerUpdate.abAnalog[1]	= (UINT8)MCDRV_POWUPDATE_ANALOG1_ALL;
+	sPowerUpdate.abAnalog[2]	= (UINT8)MCDRV_POWUPDATE_ANALOG2_ALL;
+	sPowerUpdate.abAnalog[3]	= (UINT8)MCDRV_POWUPDATE_ANALOG3_ALL;
+	sPowerUpdate.abAnalog[4]	= (UINT8)MCDRV_POWUPDATE_ANALOG4_ALL;
+	sdRet	= McPacket_AddPowerUp(&sPowerInfo, &sPowerUpdate);
+	if(MCDRV_SUCCESS != sdRet)
+	{
+		return sdRet;
+	}
+	sdRet	= McDevIf_ExecutePacket();
+	if(MCDRV_SUCCESS != sdRet)
+	{
+		return sdRet;
+	}
+
+	bAddr	= psRegInfo->bAddress;
+
+	if(psRegInfo->bRegType == MCDRV_REGTYPE_A)
+	{
+		bSlaveAddr	= McDevProf_GetSlaveAddr(eMCDRV_SLAVE_ADDR_DIG);
+	}
+	else
+	{
+		switch(psRegInfo->bRegType)
+		{
+		case	MCDRV_REGTYPE_B_BASE:
+			bSlaveAddr	= McDevProf_GetSlaveAddr(eMCDRV_SLAVE_ADDR_DIG);
+			abData[0]	= MCI_BASE_ADR<<1;
+			abData[1]	= bAddr;
+			McSrv_WriteI2C(bSlaveAddr, abData, 2);
+			bAddr	= MCI_BASE_WINDOW;
+			break;
+
+		case	MCDRV_REGTYPE_B_MIXER:
+			bSlaveAddr	= McDevProf_GetSlaveAddr(eMCDRV_SLAVE_ADDR_DIG);
+			abData[0]	= MCI_MIX_ADR<<1;
+			abData[1]	= bAddr;
+			McSrv_WriteI2C(bSlaveAddr, abData, 2);
+			bAddr	= MCI_MIX_WINDOW;
+			break;
+
+		case	MCDRV_REGTYPE_B_AE:
+			bSlaveAddr	= McDevProf_GetSlaveAddr(eMCDRV_SLAVE_ADDR_DIG);
+			abData[0]	= MCI_AE_ADR<<1;
+			abData[1]	= bAddr;
+			McSrv_WriteI2C(bSlaveAddr, abData, 2);
+			bAddr	= MCI_AE_WINDOW;
+			break;
+
+		case	MCDRV_REGTYPE_B_CDSP:
+			bSlaveAddr	= McDevProf_GetSlaveAddr(eMCDRV_SLAVE_ADDR_DIG);
+			abData[0]	= MCI_CDSP_ADR<<1;
+			abData[1]	= bAddr;
+			McSrv_WriteI2C(bSlaveAddr, abData, 2);
+			bAddr	= MCI_CDSP_WINDOW;
+			break;
+
+		case	MCDRV_REGTYPE_B_CODEC:
+			bSlaveAddr	= McDevProf_GetSlaveAddr(eMCDRV_SLAVE_ADDR_DIG);
+			abData[0]	= MCI_CD_ADR<<1;
+			abData[1]	= bAddr;
+			McSrv_WriteI2C(bSlaveAddr, abData, 2);
+			bAddr	= MCI_CD_WINDOW;
+			break;
+
+		case	MCDRV_REGTYPE_B_ANALOG:
+			bSlaveAddr	= McDevProf_GetSlaveAddr(eMCDRV_SLAVE_ADDR_ANA);
+			abData[0]	= MCI_ANA_ADR<<1;
+			abData[1]	= bAddr;
+			McSrv_WriteI2C(bSlaveAddr, abData, 2);
+			bAddr	= MCI_ANA_WINDOW;
+			break;
+
+		default:
+			return MCDRV_ERROR_ARGUMENT;
+		}
+	}
+
+	/*	read register	*/
+	psRegInfo->bData	= McSrv_ReadI2C(bSlaveAddr, bAddr);
+
+	/*	restore power	*/
+	sdRet	= McPacket_AddPowerDown(&sCurPowerInfo, &sPowerUpdate);
+	if(MCDRV_SUCCESS != sdRet)
+	{
+		return sdRet;
+	}
+	return McDevIf_ExecutePacket();
+}
+
+/****************************************************************************
+ *	write_reg
+ *
+ *	Description:
+ *			Write register.
+ *	Arguments:
+ *			psWR	register information
+ *	Return:
+ *			MCDRV_SUCCESS
+ *			MCDRV_ERROR_STATE
+ *			MCDRV_ERROR_ARGUMENT
+ *			MCDRV_ERROR_RESOURCEOVER
+ *
+ ****************************************************************************/
+static	SINT32	write_reg
+(
+	const MCDRV_REG_INFO*	psRegInfo
+)
+{
+	SINT32	sdRet	= MCDRV_SUCCESS;
+	MCDRV_POWER_INFO	sPowerInfo;
+	MCDRV_POWER_INFO	sCurPowerInfo;
+	MCDRV_POWER_UPDATE	sPowerUpdate;
+
+	if(NULL == psRegInfo)
+	{
+		return MCDRV_ERROR_ARGUMENT;
+	}
+
+	if(eMCDRV_STATE_NOTINIT == McResCtrl_GetState())
+	{
+		return MCDRV_ERROR_STATE;
+	}
+
+	sdRet	= ValidateWriteRegParam(psRegInfo);
+	if(sdRet != MCDRV_SUCCESS)
+	{
+		return sdRet;
+	}
+
+	/*	get current power info	*/
+	McResCtrl_GetCurPowerInfo(&sCurPowerInfo);
+
+	/*	power up	*/
+	McResCtrl_GetPowerInfoRegAccess(psRegInfo, &sPowerInfo);
+	sPowerUpdate.dDigital		= MCDRV_POWUPDATE_DIGITAL_ALL;
+	sPowerUpdate.abAnalog[0]	= (UINT8)MCDRV_POWUPDATE_ANALOG0_ALL;
+	sPowerUpdate.abAnalog[1]	= (UINT8)MCDRV_POWUPDATE_ANALOG1_ALL;
+	sPowerUpdate.abAnalog[2]	= (UINT8)MCDRV_POWUPDATE_ANALOG2_ALL;
+	sPowerUpdate.abAnalog[3]	= (UINT8)MCDRV_POWUPDATE_ANALOG3_ALL;
+	sPowerUpdate.abAnalog[4]	= (UINT8)MCDRV_POWUPDATE_ANALOG4_ALL;
+	sdRet	= McPacket_AddPowerUp(&sPowerInfo, &sPowerUpdate);
+	if(MCDRV_SUCCESS != sdRet)
+	{
+		return sdRet;
+	}
+
+	switch(psRegInfo->bRegType)
+	{
+	case	MCDRV_REGTYPE_A:
+		McDevIf_AddPacket((MCDRV_PACKET_TYPE_FORCE_WRITE | MCDRV_PACKET_REGTYPE_A | psRegInfo->bAddress), psRegInfo->bData);
+		break;
+
+	case	MCDRV_REGTYPE_B_BASE:
+		McDevIf_AddPacket((MCDRV_PACKET_TYPE_FORCE_WRITE | MCDRV_PACKET_REGTYPE_B_BASE | psRegInfo->bAddress), psRegInfo->bData);
+		break;
+
+	case	MCDRV_REGTYPE_B_MIXER:
+		McDevIf_AddPacket((MCDRV_PACKET_TYPE_FORCE_WRITE | MCDRV_PACKET_REGTYPE_B_MIXER | psRegInfo->bAddress), psRegInfo->bData);
+		break;
+
+	case	MCDRV_REGTYPE_B_AE:
+		McDevIf_AddPacket((MCDRV_PACKET_TYPE_FORCE_WRITE | MCDRV_PACKET_REGTYPE_B_AE | psRegInfo->bAddress), psRegInfo->bData);
+		break;
+
+	case	MCDRV_REGTYPE_B_CDSP:
+		McDevIf_AddPacket((MCDRV_PACKET_TYPE_FORCE_WRITE | MCDRV_PACKET_REGTYPE_B_CDSP | psRegInfo->bAddress), psRegInfo->bData);
+		break;
+
+	case	MCDRV_REGTYPE_B_CODEC:
+		McDevIf_AddPacket((MCDRV_PACKET_TYPE_FORCE_WRITE | MCDRV_PACKET_REGTYPE_B_CODEC | psRegInfo->bAddress), psRegInfo->bData);
+		break;
+
+	case	MCDRV_REGTYPE_B_ANALOG:
+		McDevIf_AddPacket((MCDRV_PACKET_TYPE_FORCE_WRITE | MCDRV_PACKET_REGTYPE_B_ANA | psRegInfo->bAddress), psRegInfo->bData);
+		break;
+
+	default:
+		return MCDRV_ERROR_ARGUMENT;
+	}
+
+	sdRet	= McDevIf_ExecutePacket();
+	if(MCDRV_SUCCESS != sdRet)
+	{
+		return sdRet;
+	}
+
+	/*	restore power	*/
+	if(psRegInfo->bRegType == MCDRV_REGTYPE_B_BASE)
+	{
+		if(psRegInfo->bAddress == MCI_PWM_DIGITAL)
+		{
+			if((psRegInfo->bData & MCB_PWM_DP1) == 0)
+			{
+				sCurPowerInfo.dDigital &= ~MCDRV_POWINFO_DIGITAL_DP1;
+			}
+			if((psRegInfo->bData & MCB_PWM_DP2) == 0)
+			{
+				sCurPowerInfo.dDigital &= ~MCDRV_POWINFO_DIGITAL_DP2;
+			}
+		}
+		else if(psRegInfo->bAddress == MCI_PWM_DIGITAL_1)
+		{
+			if((psRegInfo->bData & MCB_PWM_DPB) == 0)
+			{
+				sCurPowerInfo.dDigital &= ~MCDRV_POWINFO_DIGITAL_DPB;
+			}
+			if((psRegInfo->bData & MCB_PWM_DPDI0) == 0)
+			{
+				sCurPowerInfo.dDigital &= ~MCDRV_POWINFO_DIGITAL_DPDI0;
+			}
+			if((psRegInfo->bData & MCB_PWM_DPDI1) == 0)
+			{
+				sCurPowerInfo.dDigital &= ~MCDRV_POWINFO_DIGITAL_DPDI1;
+			}
+			if((psRegInfo->bData & MCB_PWM_DPDI2) == 0)
+			{
+				sCurPowerInfo.dDigital &= ~MCDRV_POWINFO_DIGITAL_DPDI2;
+			}
+			if((psRegInfo->bData & MCB_PWM_DPPDM) == 0)
+			{
+				sCurPowerInfo.dDigital &= ~MCDRV_POWINFO_DIGITAL_DPPDM;
+			}
+		}
+		else if(psRegInfo->bAddress == MCI_PWM_DIGITAL_BDSP)
+		{
+			if((psRegInfo->bData & MCB_PWM_DPBDSP) == 0)
+			{
+				sCurPowerInfo.dDigital &= ~MCDRV_POWINFO_DIGITAL_DPBDSP;
+			}
+		}
+		else
+		{
+		}
+	}
+	else if(psRegInfo->bRegType == MCDRV_REGTYPE_B_CODEC)
+	{
+		if(psRegInfo->bAddress == MCI_DPADIF)
+		{
+			if((psRegInfo->bData & MCB_DPADIF) == 0)
+			{
+				sCurPowerInfo.dDigital &= ~MCDRV_POWINFO_DIGITAL_DPADIF;
+			}
+			if((psRegInfo->bData & MCB_DP0_CLKI0) == 0)
+			{
+				sCurPowerInfo.dDigital &= ~MCDRV_POWINFO_DIGITAL_DP0;
+			}
+			if((psRegInfo->bData & MCB_DP0_CLKI1) == 0)
+			{
+				sCurPowerInfo.dDigital &= ~MCDRV_POWINFO_DIGITAL_DP0;
+			}
+		}
+		if(psRegInfo->bAddress == MCI_PLL_RST)
+		{
+			if((psRegInfo->bData & MCB_PLLRST0) == 0)
+			{
+				sCurPowerInfo.dDigital &= ~MCDRV_POWINFO_DIGITAL_PLLRST0;
+			}
+		}
+	}
+	else if(psRegInfo->bRegType == MCDRV_REGTYPE_B_ANALOG)
+	{
+		if(psRegInfo->bAddress == MCI_PWM_ANALOG_0)
+		{
+			sCurPowerInfo.abAnalog[0]	= psRegInfo->bData;
+		}
+		else if(psRegInfo->bAddress == MCI_PWM_ANALOG_1)
+		{
+			sCurPowerInfo.abAnalog[1]	= psRegInfo->bData;
+		}
+		else if(psRegInfo->bAddress == MCI_PWM_ANALOG_2)
+		{
+			sCurPowerInfo.abAnalog[2]	= psRegInfo->bData;
+		}
+		else if(psRegInfo->bAddress == MCI_PWM_ANALOG_3)
+		{
+			sCurPowerInfo.abAnalog[3]	= psRegInfo->bData;
+		}
+		else if(psRegInfo->bAddress == MCI_PWM_ANALOG_4)
+		{
+			sCurPowerInfo.abAnalog[4]	= psRegInfo->bData;
+		}
+		else
+		{
+		}
+	}
+	else
+	{
+	}
+
+	sdRet	= McPacket_AddPowerDown(&sCurPowerInfo, &sPowerUpdate);
+	if(MCDRV_SUCCESS != sdRet)
+	{
+		return sdRet;
+	}
+	return McDevIf_ExecutePacket();
+}
+
+/****************************************************************************
+ *	update_clock
+ *
+ *	Description:
+ *			Update clock info.
+ *	Arguments:
+ *			psClockInfo	clock info
+ *	Return:
+ *			MCDRV_SUCCESS
+ *			MCDRV_ERROR_ARGUMENT
+ *			MCDRV_ERROR_STATE
+ *
+ ****************************************************************************/
+static	SINT32	update_clock
+(
+	const MCDRV_CLOCK_INFO*	psClockInfo
+)
+{
+	SINT32			sdRet	= MCDRV_SUCCESS;
+	MCDRV_STATE		eState	= McResCtrl_GetState();
+	MCDRV_INIT_INFO	sInitInfo;
+
+	if(NULL == psClockInfo)
+	{
+		return MCDRV_ERROR_ARGUMENT;
+	}
+
+	if(eMCDRV_STATE_NOTINIT == eState)
+	{
+		return MCDRV_ERROR_STATE;
+	}
+
+	McResCtrl_GetInitInfo(&sInitInfo);
+	if((sInitInfo.bPowerMode & MCDRV_POWMODE_CLKON) != 0)
+	{
+		return MCDRV_ERROR_ARGUMENT;
+	}
+
+	sdRet	= ValidateClockParam(psClockInfo);
+	if(MCDRV_SUCCESS != sdRet)
+	{
+		return sdRet;
+	}
+
+	McResCtrl_SetClockInfo(psClockInfo);
+	return sdRet;
+}
+
+/****************************************************************************
+ *	switch_clock
+ *
+ *	Description:
+ *			Switch clock.
+ *	Arguments:
+ *			psClockInfo	clock info
+ *	Return:
+ *			MCDRV_SUCCESS
+ *			MCDRV_ERROR_ARGUMENT
+ *			MCDRV_ERROR_STATE
+ *
+ ****************************************************************************/
+static	SINT32	switch_clock
+(
+	const MCDRV_CLKSW_INFO*	psClockInfo
+)
+{
+	SINT32		sdRet	= MCDRV_SUCCESS;
+	MCDRV_STATE	eState	= McResCtrl_GetState();
+
+	if(eMCDRV_STATE_NOTINIT == eState)
+	{
+		return MCDRV_ERROR_STATE;
+	}
+
+	if(NULL == psClockInfo)
+	{
+		return MCDRV_ERROR_ARGUMENT;
+	}
+
+	if((psClockInfo->bClkSrc != MCDRV_CLKSW_CLKI0) && (psClockInfo->bClkSrc != MCDRV_CLKSW_CLKI1))
+	{
+		return MCDRV_ERROR_ARGUMENT;
+	}
+
+	McResCtrl_SetClockSwitch(psClockInfo);
+
+	sdRet	= McPacket_AddClockSwitch();
+	if(MCDRV_SUCCESS != sdRet)
+	{
+		return sdRet;
+	}
+	return McDevIf_ExecutePacket();
+}
+
+/****************************************************************************
+ *	get_path
+ *
+ *	Description:
+ *			Get current path setting.
+ *	Arguments:
+ *			psPathInfo	path information
+ *	Return:
+ *			MCDRV_SUCCESS
+ *			MCDRV_ERROR_STATE
+ *
+ ****************************************************************************/
+static	SINT32	get_path
+(
+	MCDRV_PATH_INFO*	psPathInfo
+)
+{
+	if(NULL == psPathInfo)
+	{
+		return MCDRV_ERROR_ARGUMENT;
+	}
+
+	if(eMCDRV_STATE_NOTINIT == McResCtrl_GetState())
+	{
+		return MCDRV_ERROR_STATE;
+	}
+
+	McResCtrl_GetPathInfoVirtual(psPathInfo);
+
+	return MCDRV_SUCCESS;
+}
+
+/****************************************************************************
+ *	set_path
+ *
+ *	Description:
+ *			Set path.
+ *	Arguments:
+ *			psPathInfo	path information
+ *	Return:
+ *			MCDRV_SUCCESS
+ *			MCDRV_ERROR_ARGUMENT
+ *			MCDRV_ERROR_STATE
+ *
+ ****************************************************************************/
+static	SINT32	set_path
+(
+	const MCDRV_PATH_INFO*	psPathInfo
+)
+{
+	SINT32			sdRet	= MCDRV_SUCCESS;
+	UINT32			dSVolDoneParam	= 0;
+	UINT16			wDACMuteParam	= 0;
+	UINT16			wDITMuteParam	= 0;
+	MCDRV_STATE		eState	= McResCtrl_GetState();
+	MCDRV_POWER_INFO	sPowerInfo;
+	MCDRV_POWER_UPDATE	sPowerUpdate;
+
+	if(NULL == psPathInfo)
+	{
+		return MCDRV_ERROR_ARGUMENT;
+	}
+
+	if(eMCDRV_STATE_NOTINIT == eState)
+	{
+		return MCDRV_ERROR_STATE;
+	}
+
+	sdRet	= ValidatePathParam(psPathInfo);
+	if(MCDRV_SUCCESS != sdRet)
+	{
+		return sdRet;
+	}
+
+	McResCtrl_SetPathInfo(psPathInfo);
+
+	/*	unused analog out volume mute	*/
+	sdRet	= SetVol(MCDRV_VOLUPDATE_ANAOUT_ALL, eMCDRV_VOLUPDATE_MUTE, &dSVolDoneParam);
+	if(MCDRV_SUCCESS != sdRet)
+	{
+		return sdRet;
+	}
+
+	/*	DAC/DIT* mute	*/
+	sdRet	= PreUpdatePath(&wDACMuteParam, &wDITMuteParam);
+	if(MCDRV_SUCCESS != sdRet)
+	{
+		return sdRet;
+	}
+
+	/*	unused volume mute	*/
+	sdRet	= SetVol(MCDRV_VOLUPDATE_ALL&~MCDRV_VOLUPDATE_ANAOUT_ALL, eMCDRV_VOLUPDATE_MUTE, NULL);
+	if(MCDRV_SUCCESS != sdRet)
+	{
+		return sdRet;
+	}
+
+	/*	wait XX_BUSY	*/
+	if(dSVolDoneParam != (UINT32)0)
+	{
+		McDevIf_AddPacket(MCDRV_PACKET_TYPE_EVTWAIT | MCDRV_EVT_SVOL_DONE | dSVolDoneParam, 0);
+	}
+	if(wDACMuteParam != 0)
+	{
+		McDevIf_AddPacket(MCDRV_PACKET_TYPE_EVTWAIT | MCDRV_EVT_DACMUTE | wDACMuteParam, 0);
+	}
+	if(wDITMuteParam != 0)
+	{
+		McDevIf_AddPacket(MCDRV_PACKET_TYPE_EVTWAIT | MCDRV_EVT_DITMUTE | wDITMuteParam, 0);
+	}
+
+	/*	stop unused path	*/
+	sdRet	= McPacket_AddStop();
+	if(MCDRV_SUCCESS != sdRet)
+	{
+		return sdRet;
+	}
+	sdRet	= McDevIf_ExecutePacket();
+	if(MCDRV_SUCCESS != sdRet)
+	{
+		return sdRet;
+	}
+
+	McResCtrl_GetPowerInfo(&sPowerInfo);
+
+	/*	used path power up	*/
+	sPowerUpdate.dDigital		= MCDRV_POWUPDATE_DIGITAL_ALL;
+	sPowerUpdate.abAnalog[0]	= (UINT8)MCDRV_POWUPDATE_ANALOG0_ALL;
+	sPowerUpdate.abAnalog[1]	= (UINT8)MCDRV_POWUPDATE_ANALOG1_ALL;
+	sPowerUpdate.abAnalog[2]	= (UINT8)MCDRV_POWUPDATE_ANALOG2_ALL;
+	sPowerUpdate.abAnalog[3]	= (UINT8)MCDRV_POWUPDATE_ANALOG3_ALL;
+	sPowerUpdate.abAnalog[4]	= (UINT8)MCDRV_POWUPDATE_ANALOG4_ALL;
+	sdRet	= McPacket_AddPowerUp(&sPowerInfo, &sPowerUpdate);
+	if(MCDRV_SUCCESS != sdRet)
+	{
+		return sdRet;
+	}
+	sdRet	= McDevIf_ExecutePacket();
+	if(MCDRV_SUCCESS != sdRet)
+	{
+		return sdRet;
+	}
+
+	/*	set digital mixer	*/
+	sdRet	= McPacket_AddPathSet();
+	if(MCDRV_SUCCESS != sdRet)
+	{
+		return sdRet;
+	}
+	sdRet	= McDevIf_ExecutePacket();
+	if(MCDRV_SUCCESS != sdRet)
+	{
+		return sdRet;
+	}
+
+	/*	set analog mixer	*/
+	sdRet	= McPacket_AddMixSet();
+	if(MCDRV_SUCCESS != sdRet)
+	{
+		return sdRet;
+	}
+	sdRet	= McDevIf_ExecutePacket();
+	if(MCDRV_SUCCESS != sdRet)
+	{
+		return sdRet;
+	}
+
+	/*	unused path power down	*/
+	sPowerUpdate.dDigital		= MCDRV_POWUPDATE_DIGITAL_ALL;
+	sPowerUpdate.abAnalog[0]	= (UINT8)MCDRV_POWUPDATE_ANALOG0_ALL;
+	sPowerUpdate.abAnalog[1]	= (UINT8)MCDRV_POWUPDATE_ANALOG1_ALL;
+	sPowerUpdate.abAnalog[2]	= (UINT8)MCDRV_POWUPDATE_ANALOG2_ALL;
+	sPowerUpdate.abAnalog[3]	= (UINT8)MCDRV_POWUPDATE_ANALOG3_ALL;
+	sPowerUpdate.abAnalog[4]	= (UINT8)MCDRV_POWUPDATE_ANALOG4_ALL;
+	sdRet	= McPacket_AddPowerDown(&sPowerInfo, &sPowerUpdate);
+	if(MCDRV_SUCCESS != sdRet)
+	{
+		return sdRet;
+	}
+	sdRet	= McDevIf_ExecutePacket();
+	if(MCDRV_SUCCESS != sdRet)
+	{
+		return sdRet;
+	}
+
+	/*	start	*/
+	sdRet	= McPacket_AddStart();
+	if(MCDRV_SUCCESS != sdRet)
+	{
+		return sdRet;
+	}
+	sdRet	= McDevIf_ExecutePacket();
+	if(MCDRV_SUCCESS != sdRet)
+	{
+		return sdRet;
+	}
+
+	/*	set volume	*/
+	sdRet	= SetVol(MCDRV_VOLUPDATE_ALL&~MCDRV_VOLUPDATE_ANAOUT_ALL, eMCDRV_VOLUPDATE_ALL, NULL);
+	if(MCDRV_SUCCESS != sdRet)
+	{
+		return sdRet;
+	}
+	return SetVol(MCDRV_VOLUPDATE_ANAOUT_ALL, eMCDRV_VOLUPDATE_ALL, &dSVolDoneParam);
+}
+
+/****************************************************************************
+ *	get_volume
+ *
+ *	Description:
+ *			Get current volume setting.
+ *	Arguments:
+ *			psVolInfo	volume information
+ *	Return:
+ *			MCDRV_SUCCESS
+ *			MCDRV_ERROR_ARGUMENT
+ *
+ ****************************************************************************/
+static	SINT32	get_volume
+(
+	MCDRV_VOL_INFO*	psVolInfo
+)
+{
+	if(NULL == psVolInfo)
+	{
+		return MCDRV_ERROR_ARGUMENT;
+	}
+
+	if(eMCDRV_STATE_NOTINIT == McResCtrl_GetState())
+	{
+		return MCDRV_ERROR_STATE;
+	}
+
+	McResCtrl_GetVolInfo(psVolInfo);
+
+	return MCDRV_SUCCESS;
+}
+
+/****************************************************************************
+ *	set_volume
+ *
+ *	Description:
+ *			Set volume.
+ *	Arguments:
+ *			psVolInfo	volume update information
+ *	Return:
+ *			MCDRV_SUCCESS
+ *			MCDRV_ERROR_ARGUMENT
+ *
+ ****************************************************************************/
+static	SINT32	set_volume
+(
+	const MCDRV_VOL_INFO*	psVolInfo
+)
+{
+	MCDRV_STATE	eState	= McResCtrl_GetState();
+	MCDRV_PATH_INFO	sPathInfo;
+
+	if(NULL == psVolInfo)
+	{
+		return MCDRV_ERROR_ARGUMENT;
+	}
+
+	if(eMCDRV_STATE_NOTINIT == eState)
+	{
+		return MCDRV_ERROR_STATE;
+	}
+
+	McResCtrl_SetVolInfo(psVolInfo);
+
+	McResCtrl_GetPathInfoVirtual(&sPathInfo);
+	return	set_path(&sPathInfo);
+}
+
+/****************************************************************************
+ *	get_digitalio
+ *
+ *	Description:
+ *			Get current digital IO setting.
+ *	Arguments:
+ *			psDioInfo	digital IO information
+ *	Return:
+ *			MCDRV_SUCCESS
+ *			MCDRV_ERROR_STATE
+ *
+ ****************************************************************************/
+static	SINT32	get_digitalio
+(
+	MCDRV_DIO_INFO*	psDioInfo
+)
+{
+	if(NULL == psDioInfo)
+	{
+		return MCDRV_ERROR_ARGUMENT;
+	}
+
+	if(eMCDRV_STATE_NOTINIT == McResCtrl_GetState())
+	{
+		return MCDRV_ERROR_STATE;
+	}
+
+	McResCtrl_GetDioInfo(psDioInfo);
+
+	return MCDRV_SUCCESS;
+}
+
+/****************************************************************************
+ *	set_digitalio
+ *
+ *	Description:
+ *			Update digital IO configuration.
+ *	Arguments:
+ *			psDioInfo	digital IO configuration
+ *			dUpdateInfo	update information
+ *	Return:
+ *			MCDRV_SUCCESS
+ *			MCDRV_ERROR_ARGUMENT
+ *			MCDRV_ERROR_STATE
+ *
+ ****************************************************************************/
+static	SINT32	set_digitalio
+(
+	const MCDRV_DIO_INFO*	psDioInfo,
+	UINT32					dUpdateInfo
+)
+{
+	SINT32		sdRet	= MCDRV_SUCCESS;
+	MCDRV_STATE	eState	= McResCtrl_GetState();
+
+	if(NULL == psDioInfo)
+	{
+		return MCDRV_ERROR_ARGUMENT;
+	}
+
+	if(eMCDRV_STATE_NOTINIT == eState)
+	{
+		return MCDRV_ERROR_STATE;
+	}
+
+	sdRet	= ValidateDioParam(psDioInfo, dUpdateInfo);
+	if(MCDRV_SUCCESS != sdRet)
+	{
+		return sdRet;
+	}
+
+	McResCtrl_SetDioInfo(psDioInfo, dUpdateInfo);
+
+	sdRet	= McPacket_AddDigitalIO(dUpdateInfo);
+	if(MCDRV_SUCCESS != sdRet)
+	{
+		return sdRet;
+	}
+	return McDevIf_ExecutePacket();
+}
+
+/****************************************************************************
+ *	get_dac
+ *
+ *	Description:
+ *			Get current DAC setting.
+ *	Arguments:
+ *			psDacInfo	DAC information
+ *	Return:
+ *			MCDRV_SUCCESS
+ *			MCDRV_ERROR_STATE
+ *
+ ****************************************************************************/
+static	SINT32	get_dac
+(
+	MCDRV_DAC_INFO*	psDacInfo
+)
+{
+	if(NULL == psDacInfo)
+	{
+		return MCDRV_ERROR_ARGUMENT;
+	}
+
+	if(eMCDRV_STATE_NOTINIT == McResCtrl_GetState())
+	{
+		return MCDRV_ERROR_STATE;
+	}
+
+	McResCtrl_GetDacInfo(psDacInfo);
+
+	return MCDRV_SUCCESS;
+}
+
+/****************************************************************************
+ *	set_dac
+ *
+ *	Description:
+ *			Update DAC configuration.
+ *	Arguments:
+ *			psDacInfo	DAC configuration
+ *			dUpdateInfo	update information
+ *	Return:
+ *			MCDRV_SUCCESS
+ *			MCDRV_ERROR_ARGUMENT
+ *			MCDRV_ERROR_STATE
+ *
+ ****************************************************************************/
+static	SINT32	set_dac
+(
+	const MCDRV_DAC_INFO*	psDacInfo,
+	UINT32					dUpdateInfo
+)
+{
+	SINT32		sdRet	= MCDRV_SUCCESS;
+	MCDRV_STATE	eState	= McResCtrl_GetState();
+
+	if(NULL == psDacInfo)
+	{
+		return MCDRV_ERROR_ARGUMENT;
+	}
+
+	if(eMCDRV_STATE_NOTINIT == eState)
+	{
+		return MCDRV_ERROR_STATE;
+	}
+
+	McResCtrl_SetDacInfo(psDacInfo, dUpdateInfo);
+
+	sdRet	= McPacket_AddDAC(dUpdateInfo);
+	if(MCDRV_SUCCESS != sdRet)
+	{
+		return sdRet;
+	}
+	return McDevIf_ExecutePacket();
+}
+
+/****************************************************************************
+ *	get_adc
+ *
+ *	Description:
+ *			Get current ADC setting.
+ *	Arguments:
+ *			psAdcInfo	ADC information
+ *	Return:
+ *			MCDRV_SUCCESS
+ *			MCDRV_ERROR_STATE
+ *
+ ****************************************************************************/
+static	SINT32	get_adc
+(
+	MCDRV_ADC_INFO*	psAdcInfo
+)
+{
+	if(NULL == psAdcInfo)
+	{
+		return MCDRV_ERROR_ARGUMENT;
+	}
+
+	if(eMCDRV_STATE_NOTINIT == McResCtrl_GetState())
+	{
+		return MCDRV_ERROR_STATE;
+	}
+
+	McResCtrl_GetAdcInfo(psAdcInfo);
+
+	return MCDRV_SUCCESS;
+}
+
+/****************************************************************************
+ *	set_adc
+ *
+ *	Description:
+ *			Update ADC configuration.
+ *	Arguments:
+ *			psAdcInfo	ADC configuration
+ *			dUpdateInfo	update information
+ *	Return:
+ *			MCDRV_SUCCESS
+ *			MCDRV_ERROR_ARGUMENT
+ *			MCDRV_ERROR_STATE
+ *
+ ****************************************************************************/
+static	SINT32	set_adc
+(
+	const MCDRV_ADC_INFO*	psAdcInfo,
+	UINT32					dUpdateInfo
+)
+{
+	SINT32		sdRet	= MCDRV_SUCCESS;
+	MCDRV_STATE	eState	= McResCtrl_GetState();
+
+	if(NULL == psAdcInfo)
+	{
+		return MCDRV_ERROR_ARGUMENT;
+	}
+
+	if(eMCDRV_STATE_NOTINIT == eState)
+	{
+		return MCDRV_ERROR_STATE;
+	}
+
+	McResCtrl_SetAdcInfo(psAdcInfo, dUpdateInfo);
+
+	sdRet	= McPacket_AddADC(dUpdateInfo);
+	if(MCDRV_SUCCESS != sdRet)
+	{
+		return sdRet;
+	}
+	return McDevIf_ExecutePacket();
+}
+
+/****************************************************************************
+ *	get_sp
+ *
+ *	Description:
+ *			Get current SP setting.
+ *	Arguments:
+ *			psSpInfo	SP information
+ *	Return:
+ *			MCDRV_SUCCESS
+ *			MCDRV_ERROR_STATE
+ *
+ ****************************************************************************/
+static	SINT32	get_sp
+(
+	MCDRV_SP_INFO*	psSpInfo
+)
+{
+	if(NULL == psSpInfo)
+	{
+		return MCDRV_ERROR_ARGUMENT;
+	}
+
+	if(eMCDRV_STATE_NOTINIT == McResCtrl_GetState())
+	{
+		return MCDRV_ERROR_STATE;
+	}
+
+	McResCtrl_GetSpInfo(psSpInfo);
+
+	return MCDRV_SUCCESS;
+}
+
+/****************************************************************************
+ *	set_sp
+ *
+ *	Description:
+ *			Update SP configuration.
+ *	Arguments:
+ *			psSpInfo	SP configuration
+ *	Return:
+ *			MCDRV_SUCCESS
+ *			MCDRV_ERROR_ARGUMENT
+ *			MCDRV_ERROR_STATE
+ *
+ ****************************************************************************/
+static	SINT32	set_sp
+(
+	const MCDRV_SP_INFO*	psSpInfo
+)
+{
+	SINT32		sdRet	= MCDRV_SUCCESS;
+	MCDRV_STATE	eState	= McResCtrl_GetState();
+
+	if(NULL == psSpInfo)
+	{
+		return MCDRV_ERROR_ARGUMENT;
+	}
+
+	if(eMCDRV_STATE_NOTINIT == eState)
+	{
+		return MCDRV_ERROR_STATE;
+	}
+
+	McResCtrl_SetSpInfo(psSpInfo);
+
+	sdRet	= McPacket_AddSP();
+	if(MCDRV_SUCCESS != sdRet)
+	{
+		return sdRet;
+	}
+	return McDevIf_ExecutePacket();
+}
+
+/****************************************************************************
+ *	get_dng
+ *
+ *	Description:
+ *			Get current Digital Noise Gate setting.
+ *	Arguments:
+ *			psDngInfo	DNG information
+ *	Return:
+ *			MCDRV_SUCCESS
+ *			MCDRV_ERROR_STATE
+ *
+ ****************************************************************************/
+static	SINT32	get_dng
+(
+	MCDRV_DNG_INFO*	psDngInfo
+)
+{
+	if(NULL == psDngInfo)
+	{
+		return MCDRV_ERROR_ARGUMENT;
+	}
+
+	if(eMCDRV_STATE_NOTINIT == McResCtrl_GetState())
+	{
+		return MCDRV_ERROR_STATE;
+	}
+
+	McResCtrl_GetDngInfo(psDngInfo);
+
+	return MCDRV_SUCCESS;
+}
+
+/****************************************************************************
+ *	set_dng
+ *
+ *	Description:
+ *			Update Digital Noise Gate configuration.
+ *	Arguments:
+ *			psDngInfo	DNG configuration
+ *			dUpdateInfo	update information
+ *	Return:
+ *			MCDRV_SUCCESS
+ *			MCDRV_ERROR_ARGUMENT
+ *			MCDRV_ERROR_STATE
+ *
+ ****************************************************************************/
+static	SINT32	set_dng
+(
+	const MCDRV_DNG_INFO*	psDngInfo,
+	UINT32					dUpdateInfo
+)
+{
+	SINT32		sdRet	= MCDRV_SUCCESS;
+	MCDRV_STATE	eState	= McResCtrl_GetState();
+
+	if(NULL == psDngInfo)
+	{
+		return MCDRV_ERROR_ARGUMENT;
+	}
+
+	if(eMCDRV_STATE_NOTINIT == eState)
+	{
+		return MCDRV_ERROR_STATE;
+	}
+
+	McResCtrl_SetDngInfo(psDngInfo, dUpdateInfo);
+
+	sdRet	= McPacket_AddDNG(dUpdateInfo);
+	if(MCDRV_SUCCESS != sdRet)
+	{
+		return sdRet;
+	}
+	return McDevIf_ExecutePacket();
+}
+
+/****************************************************************************
+ *	set_ae
+ *
+ *	Description:
+ *			Update Audio Engine configuration.
+ *	Arguments:
+ *			psAeInfo	AE configuration
+ *			dUpdateInfo	update information
+ *	Return:
+ *			MCDRV_SUCCESS
+ *			MCDRV_ERROR_ARGUMENT
+ *			MCDRV_ERROR_STATE
+ *
+ ****************************************************************************/
+static	SINT32	set_ae
+(
+	const MCDRV_AE_INFO*	psAeInfo,
+	UINT32					dUpdateInfo
+)
+{
+	SINT32		sdRet	= MCDRV_SUCCESS;
+	MCDRV_STATE	eState	= McResCtrl_GetState();
+	MCDRV_PATH_INFO	sPathInfo;
+
+	if(NULL == psAeInfo)
+	{
+		return MCDRV_ERROR_ARGUMENT;
+	}
+
+	if(eMCDRV_STATE_NOTINIT == eState)
+	{
+		return MCDRV_ERROR_STATE;
+	}
+
+	McResCtrl_SetAeInfo(psAeInfo, dUpdateInfo);
+
+	sdRet	= McPacket_AddAE(dUpdateInfo);
+	if(MCDRV_SUCCESS != sdRet)
+	{
+		return sdRet;
+	}
+	sdRet	= McDevIf_ExecutePacket();
+	if(MCDRV_SUCCESS != sdRet)
+	{
+		return sdRet;
+	}
+
+	McResCtrl_GetPathInfoVirtual(&sPathInfo);
+	return	set_path(&sPathInfo);
+}
+
+/****************************************************************************
+ *	get_pdm
+ *
+ *	Description:
+ *			Get current PDM setting.
+ *	Arguments:
+ *			psPdmInfo	PDM information
+ *	Return:
+ *			MCDRV_SUCCESS
+ *			MCDRV_ERROR_STATE
+ *
+ ****************************************************************************/
+static	SINT32	get_pdm
+(
+	MCDRV_PDM_INFO*	psPdmInfo
+)
+{
+	if(NULL == psPdmInfo)
+	{
+		return MCDRV_ERROR_ARGUMENT;
+	}
+
+	if(eMCDRV_STATE_NOTINIT == McResCtrl_GetState())
+	{
+		return MCDRV_ERROR_STATE;
+	}
+
+	McResCtrl_GetPdmInfo(psPdmInfo);
+
+	return MCDRV_SUCCESS;
+}
+
+/****************************************************************************
+ *	set_pdm
+ *
+ *	Description:
+ *			Update PDM configuration.
+ *	Arguments:
+ *			psPdmInfo	PDM configuration
+ *			dUpdateInfo	update information
+ *	Return:
+ *			MCDRV_SUCCESS
+ *			MCDRV_ERROR_ARGUMENT
+ *			MCDRV_ERROR_STATE
+ *
+ ****************************************************************************/
+static	SINT32	set_pdm
+(
+	const MCDRV_PDM_INFO*	psPdmInfo,
+	UINT32					dUpdateInfo
+)
+{
+	SINT32		sdRet	= MCDRV_SUCCESS;
+	MCDRV_STATE	eState	= McResCtrl_GetState();
+
+	if(NULL == psPdmInfo)
+	{
+		return MCDRV_ERROR_ARGUMENT;
+	}
+
+	if(eMCDRV_STATE_NOTINIT == eState)
+	{
+		return MCDRV_ERROR_STATE;
+	}
+
+	McResCtrl_SetPdmInfo(psPdmInfo, dUpdateInfo);
+
+	sdRet	= McPacket_AddPDM(dUpdateInfo);
+	if(MCDRV_SUCCESS != sdRet)
+	{
+		return sdRet;
+	}
+	return McDevIf_ExecutePacket();
+}
+
+/****************************************************************************
+ *	config_gp
+ *
+ *	Description:
+ *			Set GPIO mode.
+ *	Arguments:
+ *			psGpMode	GPIO mode information
+ *	Return:
+ *			MCDRV_SUCCESS
+ *			MCDRV_ERROR_ARGUMENT
+ *			MCDRV_ERROR_STATE
+*
+ ****************************************************************************/
+static	SINT32	config_gp
+(
+	const MCDRV_GP_MODE*	psGpMode
+)
+{
+	SINT32		sdRet	= MCDRV_SUCCESS;
+	MCDRV_STATE	eState	= McResCtrl_GetState();
+
+	if(NULL == psGpMode)
+	{
+		return MCDRV_ERROR_ARGUMENT;
+	}
+
+	if(eMCDRV_STATE_NOTINIT == eState)
+	{
+		return MCDRV_ERROR_STATE;
+	}
+
+	McResCtrl_SetGPMode(psGpMode);
+
+	sdRet	= McPacket_AddGPMode();
+	if(MCDRV_SUCCESS != sdRet)
+	{
+		return sdRet;
+	}
+	return McDevIf_ExecutePacket();
+}
+
+/****************************************************************************
+ *	mask_gp
+ *
+ *	Description:
+ *			Set GPIO input mask.
+ *	Arguments:
+ *			pbMask	mask setting
+ *			dPadNo	PAD number
+ *	Return:
+ *			MCDRV_SUCCESS
+ *			MCDRV_ERROR_ARGUMENT
+ *			MCDRV_ERROR_STATE
+ *			MCDRV_ERROR
+*
+ ****************************************************************************/
+static	SINT32	mask_gp
+(
+	UINT8*	pbMask,
+	UINT32	dPadNo
+)
+{
+	SINT32		sdRet	= MCDRV_SUCCESS;
+	MCDRV_STATE	eState	= McResCtrl_GetState();
+	MCDRV_INIT_INFO	sInitInfo;
+	MCDRV_GP_MODE	sGPMode;
+
+	if(NULL == pbMask)
+	{
+		return MCDRV_ERROR_ARGUMENT;
+	}
+
+	if(eMCDRV_STATE_NOTINIT == eState)
+	{
+		return MCDRV_ERROR_STATE;
+	}
+
+	McResCtrl_GetInitInfo(&sInitInfo);
+	McResCtrl_GetGPMode(&sGPMode);
+
+	if(dPadNo == MCDRV_GP_PAD0)
+	{
+		if((sInitInfo.bPad0Func == MCDRV_PAD_GPIO) && (sGPMode.abGpDdr[dPadNo] == MCDRV_GPDDR_OUT))
+		{
+			return MCDRV_ERROR;
+		}
+	}
+	else if(dPadNo == MCDRV_GP_PAD1)
+	{
+		if((sInitInfo.bPad1Func == MCDRV_PAD_GPIO) && (sGPMode.abGpDdr[dPadNo] == MCDRV_GPDDR_OUT))
+		{
+			return MCDRV_ERROR;
+		}
+	}
+	else
+	{
+		return MCDRV_ERROR;
+	}
+
+	McResCtrl_SetGPMask(*pbMask, dPadNo);
+
+	sdRet	= McPacket_AddGPMask(dPadNo);
+	if(sdRet != MCDRV_SUCCESS)
+	{
+		return sdRet;
+	}
+	return McDevIf_ExecutePacket();
+}
+
+/****************************************************************************
+ *	getset_gp
+ *
+ *	Description:
+ *			Set or get state of GPIO pin.
+ *	Arguments:
+ *			pbGpio	pin state
+ *			dPadNo	PAD number
+ *	Return:
+ *			MCDRV_SUCCESS
+ *			MCDRV_ERROR_ARGUMENT
+*
+ ****************************************************************************/
+static	SINT32	getset_gp
+(
+	UINT8*	pbGpio,
+	UINT32	dPadNo
+)
+{
+	SINT32			sdRet	= MCDRV_SUCCESS;
+	UINT8			bSlaveAddr;
+	UINT8			abData[2];
+	UINT8			bRegData;
+	MCDRV_STATE		eState	= McResCtrl_GetState();
+	MCDRV_INIT_INFO	sInitInfo;
+	MCDRV_GP_MODE	sGPMode;
+
+	if(NULL == pbGpio)
+	{
+		return MCDRV_ERROR_ARGUMENT;
+	}
+
+	if(eMCDRV_STATE_NOTINIT == eState)
+	{
+		return MCDRV_ERROR_STATE;
+	}
+
+	McResCtrl_GetInitInfo(&sInitInfo);
+	McResCtrl_GetGPMode(&sGPMode);
+
+	if(((dPadNo == MCDRV_GP_PAD0) && (sInitInfo.bPad0Func != MCDRV_PAD_GPIO))
+	|| ((dPadNo == MCDRV_GP_PAD1) && (sInitInfo.bPad1Func != MCDRV_PAD_GPIO)))
+	{
+		return MCDRV_ERROR;
+	}
+
+	if(sGPMode.abGpDdr[dPadNo] == MCDRV_GPDDR_IN)
+	{
+		bSlaveAddr	= McDevProf_GetSlaveAddr(eMCDRV_SLAVE_ADDR_DIG);
+		abData[0]	= MCI_BASE_ADR<<1;
+		abData[1]	= MCI_PA_SCU_PA;
+		McSrv_WriteI2C(bSlaveAddr, abData, 2);
+		bRegData	= McSrv_ReadI2C(bSlaveAddr, MCI_BASE_WINDOW);
+		if(dPadNo == MCDRV_GP_PAD0)
+		{
+			*pbGpio	= bRegData & MCB_PA_SCU_PA0;
+		}
+		else if(dPadNo == MCDRV_GP_PAD1)
+		{
+			*pbGpio	= (bRegData & MCB_PA_SCU_PA1) >> 1;
+		}
+		else
+		{
+			return MCDRV_ERROR_ARGUMENT;
+		}
+	}
+	else
+	{
+		sdRet	= McPacket_AddGPSet(*pbGpio, dPadNo);
+		if(sdRet != MCDRV_SUCCESS)
+		{
+			return sdRet;
+		}
+		return McDevIf_ExecutePacket();
+	}
+
+	return MCDRV_SUCCESS;
+}
+
+/****************************************************************************
+ *	get_syseq
+ *
+ *	Description:
+ *			Get System Eq.
+ *	Arguments:
+ *			psSysEq	pointer to MCDRV_SYSEQ_INFO struct
+ *	Return:
+ *			MCDRV_SUCCESS
+ *			MCDRV_ERROR_STATE
+ *			MCDRV_ERROR_ARGUMENT
+*
+ ****************************************************************************/
+static	SINT32	get_syseq
+(
+	MCDRV_SYSEQ_INFO*	psSysEq
+)
+{
+	MCDRV_STATE	eState	= McResCtrl_GetState();
+
+	if(eMCDRV_STATE_NOTINIT == eState)
+	{
+		return MCDRV_ERROR_STATE;
+	}
+
+	if(NULL == psSysEq)
+	{
+		return MCDRV_ERROR_ARGUMENT;
+	}
+
+	McResCtrl_GetSysEq(psSysEq);
+
+	return MCDRV_SUCCESS;
+}
+
+/****************************************************************************
+ *	set_syseq
+ *
+ *	Description:
+ *			Set System Eq.
+ *	Arguments:
+ *			psSysEq		pointer to MCDRV_SYSEQ_INFO struct
+ *			dUpdateInfo	update information
+ *	Return:
+ *			MCDRV_SUCCESS
+ *			MCDRV_ERROR_STATE
+ *			MCDRV_ERROR_ARGUMENT
+*
+ ****************************************************************************/
+static	SINT32	set_syseq
+(
+	const MCDRV_SYSEQ_INFO*	psSysEq,
+	UINT32					dUpdateInfo
+)
+{
+	SINT32		sdRet	= MCDRV_SUCCESS;
+	MCDRV_STATE	eState	= McResCtrl_GetState();
+
+	if(eMCDRV_STATE_NOTINIT == eState)
+	{
+		return MCDRV_ERROR_STATE;
+	}
+
+	if(NULL == psSysEq)
+	{
+		return MCDRV_ERROR_ARGUMENT;
+	}
+
+	McResCtrl_SetSysEq(psSysEq, dUpdateInfo);
+	sdRet	= McPacket_AddSysEq(dUpdateInfo);
+	if(sdRet != MCDRV_SUCCESS)
+	{
+		return sdRet;
+	}
+	return McDevIf_ExecutePacket();
+}
+
+
+/****************************************************************************
+ *	ValidateInitParam
+ *
+ *	Description:
+ *			validate init parameters.
+ *	Arguments:
+ *			psInitInfo	initialize information
+ *	Return:
+ *			MCDRV_SUCCESS
+ *			MCDRV_ERROR_ARGUMENT
+ *
+ ****************************************************************************/
+static	SINT32	ValidateInitParam
+(
+	const MCDRV_INIT_INFO*	psInitInfo
+)
+{
+	SINT32	sdRet	= MCDRV_SUCCESS;
+
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncIn("ValidateInitParam");
+#endif
+
+
+	if((MCDRV_CKSEL_CMOS != psInitInfo->bCkSel)
+	&& (MCDRV_CKSEL_TCXO != psInitInfo->bCkSel)
+	&& (MCDRV_CKSEL_CMOS_TCXO != psInitInfo->bCkSel)
+	&& (MCDRV_CKSEL_TCXO_CMOS != psInitInfo->bCkSel))
+	{
+		sdRet	= MCDRV_ERROR_ARGUMENT;
+	}
+	if(((psInitInfo->bDivR0 == 0x00) || (psInitInfo->bDivR0 > 0x3F))
+	|| ((psInitInfo->bDivR1 == 0x00) || (psInitInfo->bDivR1 > 0x3F))
+	|| ((psInitInfo->bDivF0 == 0x00) || (psInitInfo->bDivF0 > 0x7F))
+	|| ((psInitInfo->bDivF1 == 0x00) || (psInitInfo->bDivF1 > 0x7F)))
+	{
+		sdRet	= MCDRV_ERROR_ARGUMENT;
+	}
+	if((McDevProf_IsValid(eMCDRV_FUNC_RANGE) == 1) && (((psInitInfo->bRange0 > 0x07) || (psInitInfo->bRange1 > 0x07))))
+	{
+		sdRet	= MCDRV_ERROR_ARGUMENT;
+	}
+	if((McDevProf_IsValid(eMCDRV_FUNC_BYPASS) == 1) && (psInitInfo->bBypass > 0x03))
+	{
+		sdRet	= MCDRV_ERROR_ARGUMENT;
+	}
+	if(((MCDRV_DAHIZ_LOW != psInitInfo->bDioSdo0Hiz) && (MCDRV_DAHIZ_HIZ != psInitInfo->bDioSdo0Hiz))
+	|| ((MCDRV_DAHIZ_LOW != psInitInfo->bDioSdo1Hiz) && (MCDRV_DAHIZ_HIZ != psInitInfo->bDioSdo1Hiz))
+	|| ((MCDRV_DAHIZ_LOW != psInitInfo->bDioSdo2Hiz) && (MCDRV_DAHIZ_HIZ != psInitInfo->bDioSdo2Hiz)))
+	{
+		sdRet	= MCDRV_ERROR_ARGUMENT;
+	}
+	if((MCDRV_PCMHIZ_HIZ != psInitInfo->bPcmHiz) && (MCDRV_PCMHIZ_LOW != psInitInfo->bPcmHiz))
+	{
+		sdRet	= MCDRV_ERROR_ARGUMENT;
+	}
+	if(((MCDRV_DAHIZ_LOW != psInitInfo->bDioClk0Hiz) && (MCDRV_DAHIZ_HIZ != psInitInfo->bDioClk0Hiz))
+	|| ((MCDRV_DAHIZ_LOW != psInitInfo->bDioClk1Hiz) && (MCDRV_DAHIZ_HIZ != psInitInfo->bDioClk1Hiz))
+	|| ((MCDRV_DAHIZ_LOW != psInitInfo->bDioClk2Hiz) && (MCDRV_DAHIZ_HIZ != psInitInfo->bDioClk2Hiz)))
+	{
+		sdRet	= MCDRV_ERROR_ARGUMENT;
+	}
+	if((MCDRV_PCMHIZ_HIZ != psInitInfo->bPcmHiz) && (MCDRV_PCMHIZ_LOW != psInitInfo->bPcmHiz))
+	{
+		sdRet	= MCDRV_ERROR_ARGUMENT;
+	}
+	if((MCDRV_LINE_STEREO != psInitInfo->bLineIn1Dif) && (MCDRV_LINE_DIF != psInitInfo->bLineIn1Dif))
+	{
+		sdRet	= MCDRV_ERROR_ARGUMENT;
+	}
+	if((McDevProf_IsValid(eMCDRV_FUNC_LI2) == 1) && (MCDRV_LINE_STEREO != psInitInfo->bLineIn2Dif) && (MCDRV_LINE_DIF != psInitInfo->bLineIn2Dif))
+	{
+		sdRet	= MCDRV_ERROR_ARGUMENT;
+	}
+	if(((MCDRV_LINE_STEREO != psInitInfo->bLineOut1Dif) && (MCDRV_LINE_DIF != psInitInfo->bLineOut1Dif))
+	|| ((MCDRV_LINE_STEREO != psInitInfo->bLineOut2Dif) && (MCDRV_LINE_DIF != psInitInfo->bLineOut2Dif)))
+	{
+		sdRet	= MCDRV_ERROR_ARGUMENT;
+	}
+	if((MCDRV_SPMN_ON != psInitInfo->bSpmn) && (MCDRV_SPMN_OFF != psInitInfo->bSpmn))
+	{
+		sdRet	= MCDRV_ERROR_ARGUMENT;
+	}
+	if(((MCDRV_MIC_DIF != psInitInfo->bMic1Sng) && (MCDRV_MIC_SINGLE != psInitInfo->bMic1Sng))
+	|| ((MCDRV_MIC_DIF != psInitInfo->bMic2Sng) && (MCDRV_MIC_SINGLE != psInitInfo->bMic2Sng))
+	|| ((MCDRV_MIC_DIF != psInitInfo->bMic3Sng) && (MCDRV_MIC_SINGLE != psInitInfo->bMic3Sng)))
+	{
+		sdRet	= MCDRV_ERROR_ARGUMENT;
+	}
+	if((MCDRV_POWMODE_NORMAL != psInitInfo->bPowerMode)
+	&& (MCDRV_POWMODE_CLKON != psInitInfo->bPowerMode)
+	&& (MCDRV_POWMODE_VREFON != psInitInfo->bPowerMode)
+	&& (MCDRV_POWMODE_CLKVREFON != psInitInfo->bPowerMode)
+	&& (MCDRV_POWMODE_FULL != psInitInfo->bPowerMode))
+	{
+		sdRet	= MCDRV_ERROR_ARGUMENT;
+	}
+	if((MCDRV_SPHIZ_PULLDOWN != psInitInfo->bSpHiz) && (MCDRV_SPHIZ_HIZ != psInitInfo->bSpHiz))
+	{
+		sdRet	= MCDRV_ERROR_ARGUMENT;
+	}
+	if((MCDRV_LDO_OFF != psInitInfo->bLdo) && (MCDRV_LDO_ON != psInitInfo->bLdo))
+	{
+		sdRet	= MCDRV_ERROR_ARGUMENT;
+	}
+	if((MCDRV_PAD_GPIO != psInitInfo->bPad0Func) && (MCDRV_PAD_PDMCK != psInitInfo->bPad0Func) && (MCDRV_PAD_IRQ != psInitInfo->bPad0Func))
+	{
+		sdRet	= MCDRV_ERROR_ARGUMENT;
+	}
+	if((McDevProf_IsValid(eMCDRV_FUNC_IRQ) != 1) && (MCDRV_PAD_IRQ == psInitInfo->bPad0Func))
+	{
+		sdRet	= MCDRV_ERROR_ARGUMENT;
+	}
+	if((MCDRV_PAD_GPIO != psInitInfo->bPad1Func) && (MCDRV_PAD_PDMDI != psInitInfo->bPad1Func) && (MCDRV_PAD_IRQ != psInitInfo->bPad1Func))
+	{
+		sdRet	= MCDRV_ERROR_ARGUMENT;
+	}
+	if((McDevProf_IsValid(eMCDRV_FUNC_IRQ) != 1) && (MCDRV_PAD_IRQ == psInitInfo->bPad1Func))
+	{
+		sdRet	= MCDRV_ERROR_ARGUMENT;
+	}
+	if((McDevProf_IsValid(eMCDRV_FUNC_PAD2) == 1)
+	&& (MCDRV_PAD_GPIO != psInitInfo->bPad2Func)
+	&& (MCDRV_PAD_PDMDI != psInitInfo->bPad2Func)
+	&& (MCDRV_PAD_IRQ != psInitInfo->bPad2Func))
+	{
+		sdRet	= MCDRV_ERROR_ARGUMENT;
+	}
+	if((MCDRV_OUTLEV_0 != psInitInfo->bAvddLev) && (MCDRV_OUTLEV_1 != psInitInfo->bAvddLev)
+	&& (MCDRV_OUTLEV_2 != psInitInfo->bAvddLev) && (MCDRV_OUTLEV_3 != psInitInfo->bAvddLev)
+	&& (MCDRV_OUTLEV_4 != psInitInfo->bAvddLev) && (MCDRV_OUTLEV_5 != psInitInfo->bAvddLev)
+	&& (MCDRV_OUTLEV_6 != psInitInfo->bAvddLev) && (MCDRV_OUTLEV_7 != psInitInfo->bAvddLev))
+	{
+		sdRet	= MCDRV_ERROR_ARGUMENT;
+	}
+	if((MCDRV_OUTLEV_0 != psInitInfo->bVrefLev) && (MCDRV_OUTLEV_1 != psInitInfo->bVrefLev)
+	&& (MCDRV_OUTLEV_2 != psInitInfo->bVrefLev) && (MCDRV_OUTLEV_3 != psInitInfo->bVrefLev)
+	&& (MCDRV_OUTLEV_4 != psInitInfo->bVrefLev) && (MCDRV_OUTLEV_5 != psInitInfo->bVrefLev)
+	&& (MCDRV_OUTLEV_6 != psInitInfo->bVrefLev) && (MCDRV_OUTLEV_7 != psInitInfo->bVrefLev))
+	{
+		sdRet	= MCDRV_ERROR_ARGUMENT;
+	}
+	if((MCDRV_DCLGAIN_0 != psInitInfo->bDclGain) && (MCDRV_DCLGAIN_6 != psInitInfo->bDclGain)
+	&& (MCDRV_DCLGAIN_12!= psInitInfo->bDclGain) && (MCDRV_DCLGAIN_18!= psInitInfo->bDclGain))
+	{
+		sdRet	= MCDRV_ERROR_ARGUMENT;
+	}
+	if((MCDRV_DCLLIMIT_0 != psInitInfo->bDclLimit) && (MCDRV_DCLLIMIT_116 != psInitInfo->bDclLimit)
+	&& (MCDRV_DCLLIMIT_250 != psInitInfo->bDclLimit) && (MCDRV_DCLLIMIT_602 != psInitInfo->bDclLimit))
+	{
+		sdRet	= MCDRV_ERROR_ARGUMENT;
+	}
+	if((MCDRV_CPMOD_ON != psInitInfo->bCpMod) && (MCDRV_CPMOD_OFF != psInitInfo->bCpMod))
+	{
+		sdRet	= MCDRV_ERROR_ARGUMENT;
+	}
+	if((MCDRV_MAX_WAIT_TIME < psInitInfo->sWaitTime.dAdHpf)
+	|| (MCDRV_MAX_WAIT_TIME < psInitInfo->sWaitTime.dMic1Cin)
+	|| (MCDRV_MAX_WAIT_TIME < psInitInfo->sWaitTime.dMic2Cin)
+	|| (MCDRV_MAX_WAIT_TIME < psInitInfo->sWaitTime.dMic3Cin)
+	|| (MCDRV_MAX_WAIT_TIME < psInitInfo->sWaitTime.dLine1Cin)
+	|| (MCDRV_MAX_WAIT_TIME < psInitInfo->sWaitTime.dLine2Cin)
+	|| (MCDRV_MAX_WAIT_TIME < psInitInfo->sWaitTime.dVrefRdy1)
+	|| (MCDRV_MAX_WAIT_TIME < psInitInfo->sWaitTime.dVrefRdy2)
+	|| (MCDRV_MAX_WAIT_TIME < psInitInfo->sWaitTime.dHpRdy)
+	|| (MCDRV_MAX_WAIT_TIME < psInitInfo->sWaitTime.dSpRdy)
+	|| (MCDRV_MAX_WAIT_TIME < psInitInfo->sWaitTime.dPdm))
+	{
+		sdRet	= MCDRV_ERROR_ARGUMENT;
+	}
+
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncOut("ValidateInitParam", &sdRet);
+#endif
+
+	return sdRet;
+}
+
+/****************************************************************************
+ *	ValidateClockParam
+ *
+ *	Description:
+ *			validate clock parameters.
+ *	Arguments:
+ *			psClockInfo	clock information
+ *	Return:
+ *			MCDRV_SUCCESS
+ *			MCDRV_ERROR_ARGUMENT
+ *
+ ****************************************************************************/
+static	SINT32	ValidateClockParam
+(
+	const MCDRV_CLOCK_INFO*	psClockInfo
+)
+{
+	SINT32	sdRet	= MCDRV_SUCCESS;
+
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncIn("ValidateClockParam");
+#endif
+
+
+	if((MCDRV_CKSEL_CMOS != psClockInfo->bCkSel)
+	&& (MCDRV_CKSEL_TCXO != psClockInfo->bCkSel)
+	&& (MCDRV_CKSEL_CMOS_TCXO != psClockInfo->bCkSel)
+	&& (MCDRV_CKSEL_TCXO_CMOS != psClockInfo->bCkSel))
+	{
+		sdRet	= MCDRV_ERROR_ARGUMENT;
+	}
+	else if((psClockInfo->bDivR0 == 0x00) || (psClockInfo->bDivR0 > 0x3F))
+	{
+		sdRet	= MCDRV_ERROR_ARGUMENT;
+	}
+	else if((psClockInfo->bDivR1 == 0x00) || (psClockInfo->bDivR1 > 0x3F))
+	{
+		sdRet	= MCDRV_ERROR_ARGUMENT;
+	}
+	else if((psClockInfo->bDivF0 == 0x00) || (psClockInfo->bDivF0 > 0x7F))
+	{
+		sdRet	= MCDRV_ERROR_ARGUMENT;
+	}
+	else if((psClockInfo->bDivF1 == 0x00) || (psClockInfo->bDivF1 > 0x7F))
+	{
+		sdRet	= MCDRV_ERROR_ARGUMENT;
+	}
+	else if((McDevProf_IsValid(eMCDRV_FUNC_RANGE) == 1)
+	&& ((psClockInfo->bRange0 > 0x07) || (psClockInfo->bRange1 > 0x07)))
+	{
+		sdRet	= MCDRV_ERROR_ARGUMENT;
+	}
+	else if((McDevProf_IsValid(eMCDRV_FUNC_BYPASS) == 1) && (psClockInfo->bBypass > 0x03))
+	{
+		sdRet	= MCDRV_ERROR_ARGUMENT;
+	}
+	else
+	{
+	}
+
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncOut("ValidateClockParam", &sdRet);
+#endif
+
+	return sdRet;
+}
+
+/****************************************************************************
+ *	ValidateReadRegParam
+ *
+ *	Description:
+ *			validate read reg parameter.
+ *	Arguments:
+ *			psRegInfo	register information
+ *	Return:
+ *			MCDRV_SUCCESS
+ *			MCDRV_ERROR_ARGUMENT
+ *
+ ****************************************************************************/
+static	SINT32	ValidateReadRegParam
+(
+	const MCDRV_REG_INFO*	psRegInfo
+)
+{
+	SINT32	sdRet	= MCDRV_SUCCESS;
+
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncIn("ValidateReadRegParam");
+#endif
+
+
+	if((McResCtrl_GetRegAccess(psRegInfo) & eMCDRV_READ_ONLY) == 0)
+	{
+		sdRet	= MCDRV_ERROR_ARGUMENT;
+	}
+
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncOut("ValidateReadRegParam", &sdRet);
+#endif
+
+	return sdRet;
+}
+
+/****************************************************************************
+ *	ValidateWriteRegParam
+ *
+ *	Description:
+ *			validate write reg parameter.
+ *	Arguments:
+ *			psRegInfo	register information
+ *	Return:
+ *			MCDRV_SUCCESS
+ *			MCDRV_ERROR_ARGUMENT
+ *
+ ****************************************************************************/
+static	SINT32	ValidateWriteRegParam
+(
+	const MCDRV_REG_INFO*	psRegInfo
+)
+{
+	SINT32	sdRet	= MCDRV_SUCCESS;
+
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncIn("ValidateWriteRegParam");
+#endif
+
+
+	if((McResCtrl_GetRegAccess(psRegInfo) & eMCDRV_WRITE_ONLY) == 0)
+	{
+		sdRet	= MCDRV_ERROR_ARGUMENT;
+	}
+
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncOut("ValidateWriteRegParam", &sdRet);
+#endif
+
+	return sdRet;
+}
+
+/****************************************************************************
+ *	ValidatePathParam
+ *
+ *	Description:
+ *			validate path parameters.
+ *	Arguments:
+ *			psPathInfo	path information
+ *	Return:
+ *			MCDRV_SUCCESS
+ *			MCDRV_ERROR_ARGUMENT
+ *
+ ****************************************************************************/
+SINT32	ValidatePathParam
+(
+	const MCDRV_PATH_INFO*	psPathInfo
+)
+{
+	SINT32	sdRet	= MCDRV_SUCCESS;
+	UINT8	bBlock;
+	UINT8	bCh;
+	UINT8	bPDMIsSrc	= 0;
+	UINT8	bADC0IsSrc	= 0;
+	MCDRV_PATH_INFO		sCurPathInfo;
+
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncIn("ValidatePathParam");
+#endif
+
+
+	McResCtrl_GetPathInfoVirtual(&sCurPathInfo);
+	/*	set off to current path info	*/
+	for(bBlock = 0; bBlock < SOURCE_BLOCK_NUM; bBlock++)
+	{
+		for(bCh = 0; bCh < HP_PATH_CHANNELS; bCh++)
+		{
+			if((psPathInfo->asHpOut[bCh].abSrcOnOff[bBlock] & (0x03)) == 0x02)
+			{
+				sCurPathInfo.asHpOut[bCh].abSrcOnOff[bBlock]	&= (UINT8)~0x01;
+				sCurPathInfo.asHpOut[bCh].abSrcOnOff[bBlock]	|= 0x02;
+			}
+			if((psPathInfo->asHpOut[bCh].abSrcOnOff[bBlock] & (0x0C)) == 0x08)
+			{
+				sCurPathInfo.asHpOut[bCh].abSrcOnOff[bBlock]	&= (UINT8)~0x04;
+				sCurPathInfo.asHpOut[bCh].abSrcOnOff[bBlock]	|= 0x08;
+			}
+			if((psPathInfo->asHpOut[bCh].abSrcOnOff[bBlock] & (0x30)) == 0x20)
+			{
+				sCurPathInfo.asHpOut[bCh].abSrcOnOff[bBlock]	&= (UINT8)~0x10;
+				sCurPathInfo.asHpOut[bCh].abSrcOnOff[bBlock]	|= 0x20;
+			}
+			if((psPathInfo->asHpOut[bCh].abSrcOnOff[bBlock] & (0xC0)) == 0x80)
+			{
+				sCurPathInfo.asHpOut[bCh].abSrcOnOff[bBlock]	&= (UINT8)~0x40;
+				sCurPathInfo.asHpOut[bCh].abSrcOnOff[bBlock]	|= 0x80;
+			}
+		}
+		for(bCh = 0; bCh < SP_PATH_CHANNELS; bCh++)
+		{
+			if((psPathInfo->asSpOut[bCh].abSrcOnOff[bBlock] & (0x03)) == 0x02)
+			{
+				sCurPathInfo.asSpOut[bCh].abSrcOnOff[bBlock]	&= (UINT8)~0x01;
+				sCurPathInfo.asSpOut[bCh].abSrcOnOff[bBlock]	|= (UINT8)0x02;
+			}
+			if((psPathInfo->asSpOut[bCh].abSrcOnOff[bBlock] & (0x0C)) == 0x08)
+			{
+				sCurPathInfo.asSpOut[bCh].abSrcOnOff[bBlock]	&= (UINT8)~0x04;
+				sCurPathInfo.asSpOut[bCh].abSrcOnOff[bBlock]	|= (UINT8)0x08;
+			}
+			if((psPathInfo->asSpOut[bCh].abSrcOnOff[bBlock] & (0x30)) == 0x20)
+			{
+				sCurPathInfo.asSpOut[bCh].abSrcOnOff[bBlock]	&= (UINT8)~0x10;
+				sCurPathInfo.asSpOut[bCh].abSrcOnOff[bBlock]	|= (UINT8)0x20;
+			}
+			if((psPathInfo->asSpOut[bCh].abSrcOnOff[bBlock] & (0xC0)) == 0x80)
+			{
+				sCurPathInfo.asSpOut[bCh].abSrcOnOff[bBlock]	&= (UINT8)~0x40;
+				sCurPathInfo.asSpOut[bCh].abSrcOnOff[bBlock]	|= (UINT8)0x80;
+			}
+		}
+		for(bCh = 0; bCh < RC_PATH_CHANNELS; bCh++)
+		{
+			if((psPathInfo->asRcOut[bCh].abSrcOnOff[bBlock] & (0x03)) == 0x02)
+			{
+				sCurPathInfo.asRcOut[bCh].abSrcOnOff[bBlock]	&= (UINT8)~0x01;
+				sCurPathInfo.asRcOut[bCh].abSrcOnOff[bBlock]	|= (UINT8)0x02;
+			}
+			if((psPathInfo->asRcOut[bCh].abSrcOnOff[bBlock] & (0x0C)) == 0x08)
+			{
+				sCurPathInfo.asRcOut[bCh].abSrcOnOff[bBlock]	&= (UINT8)~0x04;
+				sCurPathInfo.asRcOut[bCh].abSrcOnOff[bBlock]	|= (UINT8)0x08;
+			}
+			if((psPathInfo->asRcOut[bCh].abSrcOnOff[bBlock] & (0x30)) == 0x20)
+			{
+				sCurPathInfo.asRcOut[bCh].abSrcOnOff[bBlock]	&= (UINT8)~0x10;
+				sCurPathInfo.asRcOut[bCh].abSrcOnOff[bBlock]	|= (UINT8)0x20;
+			}
+			if((psPathInfo->asRcOut[bCh].abSrcOnOff[bBlock] & (0xC0)) == 0x80)
+			{
+				sCurPathInfo.asRcOut[bCh].abSrcOnOff[bBlock]	&= (UINT8)~0x40;
+				sCurPathInfo.asRcOut[bCh].abSrcOnOff[bBlock]	|= (UINT8)0x80;
+			}
+		}
+		for(bCh = 0; bCh < LOUT1_PATH_CHANNELS; bCh++)
+		{
+			if((psPathInfo->asLout1[bCh].abSrcOnOff[bBlock] & (0x03)) == 0x02)
+			{
+				sCurPathInfo.asLout1[bCh].abSrcOnOff[bBlock]	&= (UINT8)~0x01;
+				sCurPathInfo.asLout1[bCh].abSrcOnOff[bBlock]	|= (UINT8)0x02;
+			}
+			if((psPathInfo->asLout1[bCh].abSrcOnOff[bBlock] & (0x0C)) == 0x08)
+			{
+				sCurPathInfo.asLout1[bCh].abSrcOnOff[bBlock]	&= (UINT8)~0x04;
+				sCurPathInfo.asLout1[bCh].abSrcOnOff[bBlock]	|= (UINT8)0x08;
+			}
+			if((psPathInfo->asLout1[bCh].abSrcOnOff[bBlock] & (0x30)) == 0x20)
+			{
+				sCurPathInfo.asLout1[bCh].abSrcOnOff[bBlock]	&= (UINT8)~0x10;
+				sCurPathInfo.asLout1[bCh].abSrcOnOff[bBlock]	|= (UINT8)0x20;
+			}
+			if((psPathInfo->asLout1[bCh].abSrcOnOff[bBlock] & (0xC0)) == 0x80)
+			{
+				sCurPathInfo.asLout1[bCh].abSrcOnOff[bBlock]	&= (UINT8)~0x40;
+				sCurPathInfo.asLout1[bCh].abSrcOnOff[bBlock]	|= (UINT8)0x80;
+			}
+		}
+		for(bCh = 0; bCh < LOUT2_PATH_CHANNELS; bCh++)
+		{
+			if((psPathInfo->asLout2[bCh].abSrcOnOff[bBlock] & (0x03)) == 0x02)
+			{
+				sCurPathInfo.asLout2[bCh].abSrcOnOff[bBlock]	&= (UINT8)~0x01;
+				sCurPathInfo.asLout2[bCh].abSrcOnOff[bBlock]	|= 0x02;
+			}
+			if((psPathInfo->asLout2[bCh].abSrcOnOff[bBlock] & (0x0C)) == 0x08)
+			{
+				sCurPathInfo.asLout2[bCh].abSrcOnOff[bBlock]	&= (UINT8)~0x04;
+				sCurPathInfo.asLout2[bCh].abSrcOnOff[bBlock]	|= 0x08;
+			}
+			if((psPathInfo->asLout2[bCh].abSrcOnOff[bBlock] & (0x30)) == 0x20)
+			{
+				sCurPathInfo.asLout2[bCh].abSrcOnOff[bBlock]	&= (UINT8)~0x10;
+				sCurPathInfo.asLout2[bCh].abSrcOnOff[bBlock]	|= 0x20;
+			}
+			if((psPathInfo->asLout2[bCh].abSrcOnOff[bBlock] & (0xC0)) == 0x80)
+			{
+				sCurPathInfo.asLout2[bCh].abSrcOnOff[bBlock]	&= (UINT8)~0x40;
+				sCurPathInfo.asLout2[bCh].abSrcOnOff[bBlock]	|= 0x80;
+			}
+		}
+		for(bCh = 0; bCh < DIT0_PATH_CHANNELS; bCh++)
+		{
+			if((psPathInfo->asDit0[bCh].abSrcOnOff[bBlock] & (0x03)) == 0x02)
+			{
+				sCurPathInfo.asDit0[bCh].abSrcOnOff[bBlock]	&= (UINT8)~0x01;
+				sCurPathInfo.asDit0[bCh].abSrcOnOff[bBlock]	|= 0x02;
+			}
+			if((psPathInfo->asDit0[bCh].abSrcOnOff[bBlock] & (0x0C)) == 0x08)
+			{
+				sCurPathInfo.asDit0[bCh].abSrcOnOff[bBlock]	&= (UINT8)~0x04;
+				sCurPathInfo.asDit0[bCh].abSrcOnOff[bBlock]	|= 0x08;
+			}
+			if((psPathInfo->asDit0[bCh].abSrcOnOff[bBlock] & (0x30)) == 0x20)
+			{
+				sCurPathInfo.asDit0[bCh].abSrcOnOff[bBlock]	&= (UINT8)~0x10;
+				sCurPathInfo.asDit0[bCh].abSrcOnOff[bBlock]	|= 0x20;
+			}
+			if((psPathInfo->asDit0[bCh].abSrcOnOff[bBlock] & (0xC0)) == 0x80)
+			{
+				sCurPathInfo.asDit0[bCh].abSrcOnOff[bBlock]	&= (UINT8)~0x40;
+				sCurPathInfo.asDit0[bCh].abSrcOnOff[bBlock]	|= 0x80;
+			}
+		}
+		for(bCh = 0; bCh < DIT1_PATH_CHANNELS; bCh++)
+		{
+			if((psPathInfo->asDit1[bCh].abSrcOnOff[bBlock] & (0x03)) == 0x02)
+			{
+				sCurPathInfo.asDit1[bCh].abSrcOnOff[bBlock]	&= (UINT8)~0x01;
+				sCurPathInfo.asDit1[bCh].abSrcOnOff[bBlock]	|= 0x02;
+			}
+			if((psPathInfo->asDit1[bCh].abSrcOnOff[bBlock] & (0x0C)) == 0x08)
+			{
+				sCurPathInfo.asDit1[bCh].abSrcOnOff[bBlock]	&= (UINT8)~0x04;
+				sCurPathInfo.asDit1[bCh].abSrcOnOff[bBlock]	|= 0x08;
+			}
+			if((psPathInfo->asDit1[bCh].abSrcOnOff[bBlock] & (0x30)) == 0x20)
+			{
+				sCurPathInfo.asDit1[bCh].abSrcOnOff[bBlock]	&= (UINT8)~0x10;
+				sCurPathInfo.asDit1[bCh].abSrcOnOff[bBlock]	|= 0x20;
+			}
+			if((psPathInfo->asDit1[bCh].abSrcOnOff[bBlock] & (0xC0)) == 0x80)
+			{
+				sCurPathInfo.asDit1[bCh].abSrcOnOff[bBlock]	&= (UINT8)~0x40;
+				sCurPathInfo.asDit1[bCh].abSrcOnOff[bBlock]	|= 0x80;
+			}
+		}
+		for(bCh = 0; bCh < DIT2_PATH_CHANNELS; bCh++)
+		{
+			if((psPathInfo->asDit2[bCh].abSrcOnOff[bBlock] & (0x03)) == 0x02)
+			{
+				sCurPathInfo.asDit2[bCh].abSrcOnOff[bBlock]	&= (UINT8)~0x01;
+				sCurPathInfo.asDit2[bCh].abSrcOnOff[bBlock]	|= 0x02;
+			}
+			if((psPathInfo->asDit2[bCh].abSrcOnOff[bBlock] & (0x0C)) == 0x08)
+			{
+				sCurPathInfo.asDit2[bCh].abSrcOnOff[bBlock]	&= (UINT8)~0x04;
+				sCurPathInfo.asDit2[bCh].abSrcOnOff[bBlock]	|= 0x08;
+			}
+			if((psPathInfo->asDit2[bCh].abSrcOnOff[bBlock] & (0x30)) == 0x20)
+			{
+				sCurPathInfo.asDit2[bCh].abSrcOnOff[bBlock]	&= (UINT8)~0x10;
+				sCurPathInfo.asDit2[bCh].abSrcOnOff[bBlock]	|= 0x20;
+			}
+			if((psPathInfo->asDit2[bCh].abSrcOnOff[bBlock] & (0xC0)) == 0x80)
+			{
+				sCurPathInfo.asDit2[bCh].abSrcOnOff[bBlock]	&= (UINT8)~0x40;
+				sCurPathInfo.asDit2[bCh].abSrcOnOff[bBlock]	|= 0x80;
+			}
+		}
+		for(bCh = 0; bCh < DAC_PATH_CHANNELS; bCh++)
+		{
+			if((psPathInfo->asDac[bCh].abSrcOnOff[bBlock] & (0x03)) == 0x02)
+			{
+				sCurPathInfo.asDac[bCh].abSrcOnOff[bBlock]	&= (UINT8)~0x01;
+				sCurPathInfo.asDac[bCh].abSrcOnOff[bBlock]	|= 0x02;
+			}
+			if((psPathInfo->asDac[bCh].abSrcOnOff[bBlock] & (0x0C)) == 0x08)
+			{
+				sCurPathInfo.asDac[bCh].abSrcOnOff[bBlock]	&= (UINT8)~0x04;
+				sCurPathInfo.asDac[bCh].abSrcOnOff[bBlock]	|= 0x08;
+			}
+			if((psPathInfo->asDac[bCh].abSrcOnOff[bBlock] & (0x30)) == 0x20)
+			{
+				sCurPathInfo.asDac[bCh].abSrcOnOff[bBlock]	&= (UINT8)~0x10;
+				sCurPathInfo.asDac[bCh].abSrcOnOff[bBlock]	|= 0x20;
+			}
+			if((psPathInfo->asDac[bCh].abSrcOnOff[bBlock] & (0xC0)) == 0x80)
+			{
+				sCurPathInfo.asDac[bCh].abSrcOnOff[bBlock]	&= (UINT8)~0x40;
+				sCurPathInfo.asDac[bCh].abSrcOnOff[bBlock]	|= 0x80;
+			}
+		}
+		for(bCh = 0; bCh < AE_PATH_CHANNELS; bCh++)
+		{
+			if((psPathInfo->asAe[bCh].abSrcOnOff[bBlock] & (0x03)) == 0x02)
+			{
+				sCurPathInfo.asAe[bCh].abSrcOnOff[bBlock]	&= (UINT8)~0x01;
+				sCurPathInfo.asAe[bCh].abSrcOnOff[bBlock]	|= 0x02;
+			}
+			if((psPathInfo->asAe[bCh].abSrcOnOff[bBlock] & (0x0C)) == 0x08)
+			{
+				sCurPathInfo.asAe[bCh].abSrcOnOff[bBlock]	&= (UINT8)~0x04;
+				sCurPathInfo.asAe[bCh].abSrcOnOff[bBlock]	|= 0x08;
+			}
+			if((psPathInfo->asAe[bCh].abSrcOnOff[bBlock] & (0x30)) == 0x20)
+			{
+				sCurPathInfo.asAe[bCh].abSrcOnOff[bBlock]	&= (UINT8)~0x10;
+				sCurPathInfo.asAe[bCh].abSrcOnOff[bBlock]	|= 0x20;
+			}
+			if((psPathInfo->asAe[bCh].abSrcOnOff[bBlock] & (0xC0)) == 0x80)
+			{
+				sCurPathInfo.asAe[bCh].abSrcOnOff[bBlock]	&= (UINT8)~0x40;
+				sCurPathInfo.asAe[bCh].abSrcOnOff[bBlock]	|= 0x80;
+			}
+		}
+		for(bCh = 0; bCh < ADC0_PATH_CHANNELS; bCh++)
+		{
+			if((psPathInfo->asAdc0[bCh].abSrcOnOff[bBlock] & (0x03)) == 0x02)
+			{
+				sCurPathInfo.asAdc0[bCh].abSrcOnOff[bBlock]	&= (UINT8)~0x01;
+				sCurPathInfo.asAdc0[bCh].abSrcOnOff[bBlock]	|= (UINT8)0x02;
+			}
+			if((psPathInfo->asAdc0[bCh].abSrcOnOff[bBlock] & (0x0C)) == 0x08)
+			{
+				sCurPathInfo.asAdc0[bCh].abSrcOnOff[bBlock]	&= (UINT8)~0x04;
+				sCurPathInfo.asAdc0[bCh].abSrcOnOff[bBlock]	|= (UINT8)0x08;
+			}
+			if((psPathInfo->asAdc0[bCh].abSrcOnOff[bBlock] & (0x30)) == 0x20)
+			{
+				sCurPathInfo.asAdc0[bCh].abSrcOnOff[bBlock]	&= (UINT8)~0x10;
+				sCurPathInfo.asAdc0[bCh].abSrcOnOff[bBlock]	|= (UINT8)0x20;
+			}
+			if((psPathInfo->asAdc0[bCh].abSrcOnOff[bBlock] & (0xC0)) == 0x80)
+			{
+				sCurPathInfo.asAdc0[bCh].abSrcOnOff[bBlock]	&= (UINT8)~0x40;
+				sCurPathInfo.asAdc0[bCh].abSrcOnOff[bBlock]	|= (UINT8)0x80;
+			}
+		}
+		for(bCh = 0; bCh < MIX_PATH_CHANNELS; bCh++)
+		{
+			if((psPathInfo->asMix[bCh].abSrcOnOff[bBlock] & (0x03)) == 0x02)
+			{
+				sCurPathInfo.asMix[bCh].abSrcOnOff[bBlock]	&= (UINT8)~0x01;
+				sCurPathInfo.asMix[bCh].abSrcOnOff[bBlock]	|= 0x02;
+			}
+			if((psPathInfo->asMix[bCh].abSrcOnOff[bBlock] & (0x0C)) == 0x08)
+			{
+				sCurPathInfo.asMix[bCh].abSrcOnOff[bBlock]	&= (UINT8)~0x04;
+				sCurPathInfo.asMix[bCh].abSrcOnOff[bBlock]	|= 0x08;
+			}
+			if((psPathInfo->asMix[bCh].abSrcOnOff[bBlock] & (0x30)) == 0x20)
+			{
+				sCurPathInfo.asMix[bCh].abSrcOnOff[bBlock]	&= (UINT8)~0x10;
+				sCurPathInfo.asMix[bCh].abSrcOnOff[bBlock]	|= 0x20;
+			}
+			if((psPathInfo->asMix[bCh].abSrcOnOff[bBlock] & (0xC0)) == 0x80)
+			{
+				sCurPathInfo.asMix[bCh].abSrcOnOff[bBlock]	&= (UINT8)~0x40;
+				sCurPathInfo.asMix[bCh].abSrcOnOff[bBlock]	|= 0x80;
+			}
+		}
+	}
+
+	if(((sCurPathInfo.asDit0[0].abSrcOnOff[MCDRV_SRC_PDM_BLOCK] & MCDRV_SRC4_PDM_ON) == MCDRV_SRC4_PDM_ON)
+	|| ((sCurPathInfo.asDit1[0].abSrcOnOff[MCDRV_SRC_PDM_BLOCK] & MCDRV_SRC4_PDM_ON) == MCDRV_SRC4_PDM_ON)
+	|| ((sCurPathInfo.asDit2[0].abSrcOnOff[MCDRV_SRC_PDM_BLOCK] & MCDRV_SRC4_PDM_ON) == MCDRV_SRC4_PDM_ON)
+	|| ((sCurPathInfo.asDac[0].abSrcOnOff[MCDRV_SRC_PDM_BLOCK] & MCDRV_SRC4_PDM_ON) == MCDRV_SRC4_PDM_ON)
+	|| ((sCurPathInfo.asDac[1].abSrcOnOff[MCDRV_SRC_PDM_BLOCK] & MCDRV_SRC4_PDM_ON) == MCDRV_SRC4_PDM_ON)
+	|| ((sCurPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_PDM_BLOCK] & MCDRV_SRC4_PDM_ON) == MCDRV_SRC4_PDM_ON)
+	|| ((sCurPathInfo.asMix[0].abSrcOnOff[MCDRV_SRC_PDM_BLOCK] & MCDRV_SRC4_PDM_ON) == MCDRV_SRC4_PDM_ON))
+	{
+		bPDMIsSrc	= 1;
+	}
+	if(((sCurPathInfo.asDit0[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK] & MCDRV_SRC4_ADC0_ON) == MCDRV_SRC4_ADC0_ON)
+	|| ((sCurPathInfo.asDit1[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK] & MCDRV_SRC4_ADC0_ON) == MCDRV_SRC4_ADC0_ON)
+	|| ((sCurPathInfo.asDit2[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK] & MCDRV_SRC4_ADC0_ON) == MCDRV_SRC4_ADC0_ON)
+	|| ((sCurPathInfo.asDac[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK] & MCDRV_SRC4_ADC0_ON) == MCDRV_SRC4_ADC0_ON)
+	|| ((sCurPathInfo.asDac[1].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK] & MCDRV_SRC4_ADC0_ON) == MCDRV_SRC4_ADC0_ON)
+	|| ((sCurPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK] & MCDRV_SRC4_ADC0_ON) == MCDRV_SRC4_ADC0_ON)
+	|| ((sCurPathInfo.asMix[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK] & MCDRV_SRC4_ADC0_ON) == MCDRV_SRC4_ADC0_ON))
+	{
+		bADC0IsSrc	= 1;
+	}
+
+	/*	HP	*/
+	if((psPathInfo->asHpOut[0].abSrcOnOff[MCDRV_SRC_LINE1_L_BLOCK] & (MCDRV_SRC1_LINE1_L_ON|MCDRV_SRC1_LINE1_L_OFF)) == MCDRV_SRC1_LINE1_L_ON)
+	{
+		if(((psPathInfo->asHpOut[0].abSrcOnOff[MCDRV_SRC_LINE1_M_BLOCK] & (MCDRV_SRC1_LINE1_M_ON|MCDRV_SRC1_LINE1_M_OFF)) == MCDRV_SRC1_LINE1_M_ON)
+		|| ((sCurPathInfo.asHpOut[0].abSrcOnOff[MCDRV_SRC_LINE1_M_BLOCK] & (MCDRV_SRC1_LINE1_M_ON|MCDRV_SRC1_LINE1_M_OFF)) == MCDRV_SRC1_LINE1_M_ON))
+		{
+			sdRet	= MCDRV_ERROR_ARGUMENT;
+		}
+	}
+	if((psPathInfo->asHpOut[0].abSrcOnOff[MCDRV_SRC_LINE1_M_BLOCK] & (MCDRV_SRC1_LINE1_M_ON|MCDRV_SRC1_LINE1_M_OFF)) == MCDRV_SRC1_LINE1_M_ON)
+	{
+		if((sCurPathInfo.asHpOut[0].abSrcOnOff[MCDRV_SRC_LINE1_L_BLOCK] & (MCDRV_SRC1_LINE1_L_ON|MCDRV_SRC1_LINE1_L_OFF)) == MCDRV_SRC1_LINE1_L_ON)
+		{
+			sdRet	= MCDRV_ERROR_ARGUMENT;
+		}
+	}
+	if((psPathInfo->asHpOut[0].abSrcOnOff[MCDRV_SRC_DAC_L_BLOCK] & (MCDRV_SRC5_DAC_L_ON|MCDRV_SRC5_DAC_L_OFF)) == MCDRV_SRC5_DAC_L_ON)
+	{
+		if(((psPathInfo->asHpOut[0].abSrcOnOff[MCDRV_SRC_DAC_M_BLOCK] & (MCDRV_SRC5_DAC_M_ON|MCDRV_SRC5_DAC_M_OFF)) == MCDRV_SRC5_DAC_M_ON)
+		|| ((sCurPathInfo.asHpOut[0].abSrcOnOff[MCDRV_SRC_DAC_M_BLOCK] & (MCDRV_SRC5_DAC_M_ON|MCDRV_SRC5_DAC_M_OFF)) == MCDRV_SRC5_DAC_M_ON))
+		{
+			sdRet	= MCDRV_ERROR_ARGUMENT;
+		}
+	}
+	if((psPathInfo->asHpOut[0].abSrcOnOff[MCDRV_SRC_DAC_M_BLOCK] & (MCDRV_SRC5_DAC_M_ON|MCDRV_SRC5_DAC_M_OFF)) == MCDRV_SRC5_DAC_M_ON)
+	{
+		if((sCurPathInfo.asHpOut[0].abSrcOnOff[MCDRV_SRC_DAC_L_BLOCK] & (MCDRV_SRC5_DAC_L_ON|MCDRV_SRC5_DAC_L_OFF)) == MCDRV_SRC5_DAC_L_ON)
+		{
+			sdRet	= MCDRV_ERROR_ARGUMENT;
+		}
+	}
+
+	/*	SP	*/
+	if((psPathInfo->asSpOut[0].abSrcOnOff[MCDRV_SRC_LINE1_L_BLOCK] & (MCDRV_SRC1_LINE1_L_ON|MCDRV_SRC1_LINE1_L_OFF)) == MCDRV_SRC1_LINE1_L_ON)
+	{
+		if(((psPathInfo->asSpOut[0].abSrcOnOff[MCDRV_SRC_LINE1_M_BLOCK] & (MCDRV_SRC1_LINE1_M_ON|MCDRV_SRC1_LINE1_M_OFF)) == MCDRV_SRC1_LINE1_M_ON)
+		|| ((sCurPathInfo.asSpOut[0].abSrcOnOff[MCDRV_SRC_LINE1_M_BLOCK] & (MCDRV_SRC1_LINE1_M_ON|MCDRV_SRC1_LINE1_M_OFF)) == MCDRV_SRC1_LINE1_M_ON))
+		{
+			sdRet	= MCDRV_ERROR_ARGUMENT;
+		}
+	}
+	if((psPathInfo->asSpOut[0].abSrcOnOff[MCDRV_SRC_LINE1_M_BLOCK] & (MCDRV_SRC1_LINE1_M_ON|MCDRV_SRC1_LINE1_M_OFF)) == MCDRV_SRC1_LINE1_M_ON)
+	{
+		if((sCurPathInfo.asSpOut[0].abSrcOnOff[MCDRV_SRC_LINE1_L_BLOCK] & (MCDRV_SRC1_LINE1_L_ON|MCDRV_SRC1_LINE1_L_OFF)) == MCDRV_SRC1_LINE1_L_ON)
+		{
+			sdRet	= MCDRV_ERROR_ARGUMENT;
+		}
+	}
+	if((psPathInfo->asSpOut[0].abSrcOnOff[MCDRV_SRC_DAC_L_BLOCK] & (MCDRV_SRC5_DAC_L_ON|MCDRV_SRC5_DAC_L_OFF)) == MCDRV_SRC5_DAC_L_ON)
+	{
+		if(((psPathInfo->asSpOut[0].abSrcOnOff[MCDRV_SRC_DAC_M_BLOCK] & (MCDRV_SRC5_DAC_M_ON|MCDRV_SRC5_DAC_M_OFF)) == MCDRV_SRC5_DAC_M_ON)
+		|| ((sCurPathInfo.asSpOut[0].abSrcOnOff[MCDRV_SRC_DAC_M_BLOCK] & (MCDRV_SRC5_DAC_M_ON|MCDRV_SRC5_DAC_M_OFF)) == MCDRV_SRC5_DAC_M_ON))
+		{
+			sdRet	= MCDRV_ERROR_ARGUMENT;
+		}
+	}
+	if((psPathInfo->asSpOut[0].abSrcOnOff[MCDRV_SRC_DAC_M_BLOCK] & (MCDRV_SRC5_DAC_M_ON|MCDRV_SRC5_DAC_M_OFF)) == MCDRV_SRC5_DAC_M_ON)
+	{
+		if((sCurPathInfo.asSpOut[0].abSrcOnOff[MCDRV_SRC_DAC_L_BLOCK] & (MCDRV_SRC5_DAC_L_ON|MCDRV_SRC5_DAC_L_OFF)) == MCDRV_SRC5_DAC_L_ON)
+		{
+			sdRet	= MCDRV_ERROR_ARGUMENT;
+		}
+	}
+	if((psPathInfo->asSpOut[1].abSrcOnOff[MCDRV_SRC_LINE1_R_BLOCK] & (MCDRV_SRC1_LINE1_R_ON|MCDRV_SRC1_LINE1_R_OFF)) == MCDRV_SRC1_LINE1_R_ON)
+	{
+		if(((psPathInfo->asSpOut[1].abSrcOnOff[MCDRV_SRC_LINE1_M_BLOCK] & (MCDRV_SRC1_LINE1_M_ON|MCDRV_SRC1_LINE1_M_OFF)) == MCDRV_SRC1_LINE1_M_ON)
+		|| ((sCurPathInfo.asSpOut[1].abSrcOnOff[MCDRV_SRC_LINE1_M_BLOCK] & (MCDRV_SRC1_LINE1_M_ON|MCDRV_SRC1_LINE1_M_OFF)) == MCDRV_SRC1_LINE1_M_ON))
+		{
+			sdRet	= MCDRV_ERROR_ARGUMENT;
+		}
+	}
+	if((psPathInfo->asSpOut[1].abSrcOnOff[MCDRV_SRC_LINE1_M_BLOCK] & (MCDRV_SRC1_LINE1_M_ON|MCDRV_SRC1_LINE1_M_OFF)) == MCDRV_SRC1_LINE1_M_ON)
+	{
+		if((sCurPathInfo.asSpOut[1].abSrcOnOff[MCDRV_SRC_LINE1_R_BLOCK] & (MCDRV_SRC1_LINE1_R_ON|MCDRV_SRC1_LINE1_R_OFF)) == MCDRV_SRC1_LINE1_R_ON)
+		{
+			sdRet	= MCDRV_ERROR_ARGUMENT;
+		}
+	}
+	if((psPathInfo->asSpOut[1].abSrcOnOff[MCDRV_SRC_DAC_R_BLOCK] & (MCDRV_SRC5_DAC_R_ON|MCDRV_SRC5_DAC_R_OFF)) == MCDRV_SRC5_DAC_R_ON)
+	{
+		if(((psPathInfo->asSpOut[1].abSrcOnOff[MCDRV_SRC_DAC_M_BLOCK] & (MCDRV_SRC5_DAC_M_ON|MCDRV_SRC5_DAC_M_OFF)) == MCDRV_SRC5_DAC_M_ON)
+		|| ((sCurPathInfo.asSpOut[1].abSrcOnOff[MCDRV_SRC_DAC_M_BLOCK] & (MCDRV_SRC5_DAC_M_ON|MCDRV_SRC5_DAC_M_OFF)) == MCDRV_SRC5_DAC_M_ON))
+		{
+			sdRet	= MCDRV_ERROR_ARGUMENT;
+		}
+	}
+	if((psPathInfo->asSpOut[1].abSrcOnOff[MCDRV_SRC_DAC_M_BLOCK] & (MCDRV_SRC5_DAC_M_ON|MCDRV_SRC5_DAC_M_OFF)) == MCDRV_SRC5_DAC_M_ON)
+	{
+		if((sCurPathInfo.asSpOut[1].abSrcOnOff[MCDRV_SRC_DAC_R_BLOCK] & (MCDRV_SRC5_DAC_R_ON|MCDRV_SRC5_DAC_R_OFF)) == MCDRV_SRC5_DAC_R_ON)
+		{
+			sdRet	= MCDRV_ERROR_ARGUMENT;
+		}
+	}
+
+	/*	RCV	*/
+
+	/*	LOUT1	*/
+	if((psPathInfo->asLout1[0].abSrcOnOff[MCDRV_SRC_LINE1_L_BLOCK] & (MCDRV_SRC1_LINE1_L_ON|MCDRV_SRC1_LINE1_L_OFF)) == MCDRV_SRC1_LINE1_L_ON)
+	{
+		if(((psPathInfo->asLout1[0].abSrcOnOff[MCDRV_SRC_LINE1_M_BLOCK] & (MCDRV_SRC1_LINE1_M_ON|MCDRV_SRC1_LINE1_M_OFF)) == MCDRV_SRC1_LINE1_M_ON)
+		|| ((sCurPathInfo.asLout1[0].abSrcOnOff[MCDRV_SRC_LINE1_M_BLOCK] & (MCDRV_SRC1_LINE1_M_ON|MCDRV_SRC1_LINE1_M_OFF)) == MCDRV_SRC1_LINE1_M_ON))
+		{
+			sdRet	= MCDRV_ERROR_ARGUMENT;
+		}
+	}
+	if((psPathInfo->asLout1[0].abSrcOnOff[MCDRV_SRC_LINE1_M_BLOCK] & (MCDRV_SRC1_LINE1_M_ON|MCDRV_SRC1_LINE1_M_OFF)) == MCDRV_SRC1_LINE1_M_ON)
+	{
+		if((sCurPathInfo.asLout1[0].abSrcOnOff[MCDRV_SRC_LINE1_L_BLOCK] & (MCDRV_SRC1_LINE1_L_ON|MCDRV_SRC1_LINE1_L_OFF)) == MCDRV_SRC1_LINE1_L_ON)
+		{
+			sdRet	= MCDRV_ERROR_ARGUMENT;
+		}
+	}
+	if((psPathInfo->asLout1[0].abSrcOnOff[MCDRV_SRC_DAC_L_BLOCK] & (MCDRV_SRC5_DAC_L_ON|MCDRV_SRC5_DAC_L_OFF)) == MCDRV_SRC5_DAC_L_ON)
+	{
+		if(((psPathInfo->asLout1[0].abSrcOnOff[MCDRV_SRC_DAC_M_BLOCK] & (MCDRV_SRC5_DAC_M_ON|MCDRV_SRC5_DAC_M_OFF)) == MCDRV_SRC5_DAC_M_ON)
+		|| ((sCurPathInfo.asLout1[0].abSrcOnOff[MCDRV_SRC_DAC_M_BLOCK] & (MCDRV_SRC5_DAC_M_ON|MCDRV_SRC5_DAC_M_OFF)) == MCDRV_SRC5_DAC_M_ON))
+		{
+			sdRet	= MCDRV_ERROR_ARGUMENT;
+		}
+	}
+	if((psPathInfo->asLout1[0].abSrcOnOff[MCDRV_SRC_DAC_M_BLOCK] & (MCDRV_SRC5_DAC_M_ON|MCDRV_SRC5_DAC_M_OFF)) == MCDRV_SRC5_DAC_M_ON)
+	{
+		if((sCurPathInfo.asLout1[0].abSrcOnOff[MCDRV_SRC_DAC_L_BLOCK] & (MCDRV_SRC5_DAC_L_ON|MCDRV_SRC5_DAC_L_OFF)) == MCDRV_SRC5_DAC_L_ON)
+		{
+			sdRet	= MCDRV_ERROR_ARGUMENT;
+		}
+	}
+
+	/*	LOUT2	*/
+	if((psPathInfo->asLout2[0].abSrcOnOff[MCDRV_SRC_LINE1_L_BLOCK] & (MCDRV_SRC1_LINE1_L_ON|MCDRV_SRC1_LINE1_L_OFF)) == MCDRV_SRC1_LINE1_L_ON)
+	{
+		if(((psPathInfo->asLout2[0].abSrcOnOff[MCDRV_SRC_LINE1_M_BLOCK] & (MCDRV_SRC1_LINE1_M_ON|MCDRV_SRC1_LINE1_M_OFF)) == MCDRV_SRC1_LINE1_M_ON)
+		|| ((sCurPathInfo.asLout2[0].abSrcOnOff[MCDRV_SRC_LINE1_M_BLOCK] & (MCDRV_SRC1_LINE1_M_ON|MCDRV_SRC1_LINE1_M_OFF)) == MCDRV_SRC1_LINE1_M_ON))
+		{
+			sdRet	= MCDRV_ERROR_ARGUMENT;
+		}
+	}
+	if((psPathInfo->asLout2[0].abSrcOnOff[MCDRV_SRC_LINE1_M_BLOCK] & (MCDRV_SRC1_LINE1_M_ON|MCDRV_SRC1_LINE1_M_OFF)) == MCDRV_SRC1_LINE1_M_ON)
+	{
+		if((sCurPathInfo.asLout2[0].abSrcOnOff[MCDRV_SRC_LINE1_L_BLOCK] & (MCDRV_SRC1_LINE1_L_ON|MCDRV_SRC1_LINE1_L_OFF)) == MCDRV_SRC1_LINE1_L_ON)
+		{
+			sdRet	= MCDRV_ERROR_ARGUMENT;
+		}
+	}
+	if((psPathInfo->asLout2[0].abSrcOnOff[MCDRV_SRC_DAC_L_BLOCK] & (MCDRV_SRC5_DAC_L_ON|MCDRV_SRC5_DAC_L_OFF)) == MCDRV_SRC5_DAC_L_ON)
+	{
+		if(((psPathInfo->asLout2[0].abSrcOnOff[MCDRV_SRC_DAC_M_BLOCK] & (MCDRV_SRC5_DAC_M_ON|MCDRV_SRC5_DAC_M_OFF)) == MCDRV_SRC5_DAC_M_ON)
+		|| ((sCurPathInfo.asLout2[0].abSrcOnOff[MCDRV_SRC_DAC_M_BLOCK] & (MCDRV_SRC5_DAC_M_ON|MCDRV_SRC5_DAC_M_OFF)) == MCDRV_SRC5_DAC_M_ON))
+		{
+			sdRet	= MCDRV_ERROR_ARGUMENT;
+		}
+	}
+	if((psPathInfo->asLout2[0].abSrcOnOff[MCDRV_SRC_DAC_M_BLOCK] & (MCDRV_SRC5_DAC_M_ON|MCDRV_SRC5_DAC_M_OFF)) == MCDRV_SRC5_DAC_M_ON)
+	{
+		if((sCurPathInfo.asLout2[0].abSrcOnOff[MCDRV_SRC_DAC_L_BLOCK] & (MCDRV_SRC5_DAC_L_ON|MCDRV_SRC5_DAC_L_OFF)) == MCDRV_SRC5_DAC_L_ON)
+		{
+			sdRet	= MCDRV_ERROR_ARGUMENT;
+		}
+	}
+
+	/*	PeakMeter	*/
+
+	/*	DIT0	*/
+	if((psPathInfo->asDit0[0].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK] & (MCDRV_SRC3_DIR0_ON|MCDRV_SRC3_DIR0_OFF)) == MCDRV_SRC3_DIR0_ON)
+	{
+		if(((psPathInfo->asDit0[0].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK] & (MCDRV_SRC3_DIR1_ON|MCDRV_SRC3_DIR1_OFF)) == MCDRV_SRC3_DIR1_ON)
+		|| ((psPathInfo->asDit0[0].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK] & (MCDRV_SRC3_DIR2_ON|MCDRV_SRC3_DIR2_OFF)) == MCDRV_SRC3_DIR2_ON)
+		|| ((psPathInfo->asDit0[0].abSrcOnOff[MCDRV_SRC_PDM_BLOCK] & (MCDRV_SRC4_PDM_ON|MCDRV_SRC4_PDM_OFF)) == MCDRV_SRC4_PDM_ON)
+		|| ((psPathInfo->asDit0[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK] & (MCDRV_SRC4_ADC0_ON|MCDRV_SRC4_ADC0_OFF)) == MCDRV_SRC4_ADC0_ON)
+		|| ((psPathInfo->asDit0[0].abSrcOnOff[MCDRV_SRC_AE_BLOCK] & (MCDRV_SRC6_AE_ON|MCDRV_SRC6_AE_OFF)) == MCDRV_SRC6_AE_ON)
+		|| ((psPathInfo->asDit0[0].abSrcOnOff[MCDRV_SRC_MIX_BLOCK] & (MCDRV_SRC6_MIX_ON|MCDRV_SRC6_MIX_OFF)) == MCDRV_SRC6_MIX_ON)
+		|| ((sCurPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK] & (MCDRV_SRC3_DIR0_ON|MCDRV_SRC3_DIR0_OFF)) == MCDRV_SRC3_DIR0_ON))
+		{
+			sdRet	= MCDRV_ERROR_ARGUMENT;
+		}
+	}
+	if((psPathInfo->asDit0[0].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK] & (MCDRV_SRC3_DIR1_ON|MCDRV_SRC3_DIR1_OFF)) == MCDRV_SRC3_DIR1_ON)
+	{
+		if(((psPathInfo->asDit0[0].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK] & (MCDRV_SRC3_DIR2_ON|MCDRV_SRC3_DIR2_OFF)) == MCDRV_SRC3_DIR2_ON)
+		|| ((psPathInfo->asDit0[0].abSrcOnOff[MCDRV_SRC_PDM_BLOCK] & (MCDRV_SRC4_PDM_ON|MCDRV_SRC4_PDM_OFF)) == MCDRV_SRC4_PDM_ON)
+		|| ((psPathInfo->asDit0[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK] & (MCDRV_SRC4_ADC0_ON|MCDRV_SRC4_ADC0_OFF)) == MCDRV_SRC4_ADC0_ON)
+		|| ((psPathInfo->asDit0[0].abSrcOnOff[MCDRV_SRC_AE_BLOCK] & (MCDRV_SRC6_AE_ON|MCDRV_SRC6_AE_OFF)) == MCDRV_SRC6_AE_ON)
+		|| ((psPathInfo->asDit0[0].abSrcOnOff[MCDRV_SRC_MIX_BLOCK] & (MCDRV_SRC6_MIX_ON|MCDRV_SRC6_MIX_OFF)) == MCDRV_SRC6_MIX_ON)
+		|| ((sCurPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK] & (MCDRV_SRC3_DIR1_ON|MCDRV_SRC3_DIR1_OFF)) == MCDRV_SRC3_DIR1_ON))
+		{
+			sdRet	= MCDRV_ERROR_ARGUMENT;
+		}
+	}
+	if((psPathInfo->asDit0[0].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK] & (MCDRV_SRC3_DIR2_ON|MCDRV_SRC3_DIR2_OFF)) == MCDRV_SRC3_DIR2_ON)
+	{
+		if(((psPathInfo->asDit0[0].abSrcOnOff[MCDRV_SRC_PDM_BLOCK] & (MCDRV_SRC4_PDM_ON|MCDRV_SRC4_PDM_OFF)) == MCDRV_SRC4_PDM_ON)
+		|| ((psPathInfo->asDit0[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK] & (MCDRV_SRC4_ADC0_ON|MCDRV_SRC4_ADC0_OFF)) == MCDRV_SRC4_ADC0_ON)
+		|| ((psPathInfo->asDit0[0].abSrcOnOff[MCDRV_SRC_AE_BLOCK] & (MCDRV_SRC6_AE_ON|MCDRV_SRC6_AE_OFF)) == MCDRV_SRC6_AE_ON)
+		|| ((psPathInfo->asDit0[0].abSrcOnOff[MCDRV_SRC_MIX_BLOCK] & (MCDRV_SRC6_MIX_ON|MCDRV_SRC6_MIX_OFF)) == MCDRV_SRC6_MIX_ON)
+		|| ((sCurPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK] & (MCDRV_SRC3_DIR2_ON|MCDRV_SRC3_DIR2_OFF)) == MCDRV_SRC3_DIR2_ON))
+		{
+			sdRet	= MCDRV_ERROR_ARGUMENT;
+		}
+	}
+	if((psPathInfo->asDit0[0].abSrcOnOff[MCDRV_SRC_PDM_BLOCK] & (MCDRV_SRC4_PDM_ON|MCDRV_SRC4_PDM_OFF)) == MCDRV_SRC4_PDM_ON)
+	{
+		if(((psPathInfo->asDit0[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK] & (MCDRV_SRC4_ADC0_ON|MCDRV_SRC4_ADC0_OFF)) == MCDRV_SRC4_ADC0_ON)
+		|| ((psPathInfo->asDit0[0].abSrcOnOff[MCDRV_SRC_AE_BLOCK] & (MCDRV_SRC6_AE_ON|MCDRV_SRC6_AE_OFF)) == MCDRV_SRC6_AE_ON)
+		|| ((psPathInfo->asDit0[0].abSrcOnOff[MCDRV_SRC_MIX_BLOCK] & (MCDRV_SRC6_MIX_ON|MCDRV_SRC6_MIX_OFF)) == MCDRV_SRC6_MIX_ON)
+		|| ((sCurPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_PDM_BLOCK] & (MCDRV_SRC4_PDM_ON|MCDRV_SRC4_PDM_OFF)) == MCDRV_SRC4_PDM_ON))
+		{
+			sdRet	= MCDRV_ERROR_ARGUMENT;
+		}
+	}
+	if((psPathInfo->asDit0[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK] & (MCDRV_SRC4_ADC0_ON|MCDRV_SRC4_ADC0_OFF)) == MCDRV_SRC4_ADC0_ON)
+	{
+		if(((psPathInfo->asDit0[0].abSrcOnOff[MCDRV_SRC_AE_BLOCK] & (MCDRV_SRC6_AE_ON|MCDRV_SRC6_AE_OFF)) == MCDRV_SRC6_AE_ON)
+		|| ((psPathInfo->asDit0[0].abSrcOnOff[MCDRV_SRC_MIX_BLOCK] & (MCDRV_SRC6_MIX_ON|MCDRV_SRC6_MIX_OFF)) == MCDRV_SRC6_MIX_ON)
+		|| ((sCurPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK] & (MCDRV_SRC4_ADC0_ON|MCDRV_SRC4_ADC0_OFF)) == MCDRV_SRC4_ADC0_ON))
+		{
+			sdRet	= MCDRV_ERROR_ARGUMENT;
+		}
+	}
+	if((psPathInfo->asDit0[0].abSrcOnOff[MCDRV_SRC_AE_BLOCK] & (MCDRV_SRC6_AE_ON|MCDRV_SRC6_AE_OFF)) == MCDRV_SRC6_AE_ON)
+	{
+		if((psPathInfo->asDit0[0].abSrcOnOff[MCDRV_SRC_MIX_BLOCK] & (MCDRV_SRC6_MIX_ON|MCDRV_SRC6_MIX_OFF)) == MCDRV_SRC6_MIX_ON)
+		{
+			sdRet	= MCDRV_ERROR_ARGUMENT;
+		}
+	}
+	if((psPathInfo->asDit0[0].abSrcOnOff[MCDRV_SRC_MIX_BLOCK] & (MCDRV_SRC6_MIX_ON|MCDRV_SRC6_MIX_OFF)) == MCDRV_SRC6_MIX_ON)
+	{
+		if((sCurPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_MIX_BLOCK] & (MCDRV_SRC6_MIX_ON|MCDRV_SRC6_MIX_OFF)) == MCDRV_SRC6_MIX_ON)
+		{
+			sdRet	= MCDRV_ERROR_ARGUMENT;
+		}
+	}
+
+	if((psPathInfo->asDit0[0].abSrcOnOff[MCDRV_SRC_PDM_BLOCK] & (MCDRV_SRC4_PDM_ON|MCDRV_SRC4_PDM_OFF)) == MCDRV_SRC4_PDM_ON)
+	{
+		if(bADC0IsSrc == 1)
+		{
+			sdRet	= MCDRV_ERROR_ARGUMENT;
+		}
+		else
+		{
+			bPDMIsSrc	= 1;
+		}
+	}
+	if((psPathInfo->asDit0[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK] & (MCDRV_SRC4_ADC0_ON|MCDRV_SRC4_ADC0_OFF)) == MCDRV_SRC4_ADC0_ON)
+	{
+		if(bPDMIsSrc == 1)
+		{
+			sdRet	= MCDRV_ERROR_ARGUMENT;
+		}
+		else
+		{
+			bADC0IsSrc	= 1;
+		}
+	}
+
+	/*	DIT1	*/
+	if((psPathInfo->asDit1[0].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK] & (MCDRV_SRC3_DIR0_ON|MCDRV_SRC3_DIR0_OFF)) == MCDRV_SRC3_DIR0_ON)
+	{
+		if(((psPathInfo->asDit1[0].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK] & (MCDRV_SRC3_DIR1_ON|MCDRV_SRC3_DIR1_OFF)) == MCDRV_SRC3_DIR1_ON)
+		|| ((psPathInfo->asDit1[0].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK] & (MCDRV_SRC3_DIR2_ON|MCDRV_SRC3_DIR2_OFF)) == MCDRV_SRC3_DIR2_ON)
+		|| ((psPathInfo->asDit1[0].abSrcOnOff[MCDRV_SRC_PDM_BLOCK] & (MCDRV_SRC4_PDM_ON|MCDRV_SRC4_PDM_OFF)) == MCDRV_SRC4_PDM_ON)
+		|| ((psPathInfo->asDit1[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK] & (MCDRV_SRC4_ADC0_ON|MCDRV_SRC4_ADC0_OFF)) == MCDRV_SRC4_ADC0_ON)
+		|| ((psPathInfo->asDit1[0].abSrcOnOff[MCDRV_SRC_AE_BLOCK] & (MCDRV_SRC6_AE_ON|MCDRV_SRC6_AE_OFF)) == MCDRV_SRC6_AE_ON)
+		|| ((psPathInfo->asDit1[0].abSrcOnOff[MCDRV_SRC_MIX_BLOCK] & (MCDRV_SRC6_MIX_ON|MCDRV_SRC6_MIX_OFF)) == MCDRV_SRC6_MIX_ON)
+		|| ((sCurPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK] & (MCDRV_SRC3_DIR0_ON|MCDRV_SRC3_DIR0_OFF)) == MCDRV_SRC3_DIR0_ON))
+		{
+			sdRet	= MCDRV_ERROR_ARGUMENT;
+		}
+	}
+	if((psPathInfo->asDit1[0].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK] & (MCDRV_SRC3_DIR1_ON|MCDRV_SRC3_DIR1_OFF)) == MCDRV_SRC3_DIR1_ON)
+	{
+		if(((psPathInfo->asDit1[0].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK] & (MCDRV_SRC3_DIR2_ON|MCDRV_SRC3_DIR2_OFF)) == MCDRV_SRC3_DIR2_ON)
+		|| ((psPathInfo->asDit1[0].abSrcOnOff[MCDRV_SRC_PDM_BLOCK] & (MCDRV_SRC4_PDM_ON|MCDRV_SRC4_PDM_OFF)) == MCDRV_SRC4_PDM_ON)
+		|| ((psPathInfo->asDit1[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK] & (MCDRV_SRC4_ADC0_ON|MCDRV_SRC4_ADC0_OFF)) == MCDRV_SRC4_ADC0_ON)
+		|| ((psPathInfo->asDit1[0].abSrcOnOff[MCDRV_SRC_AE_BLOCK] & (MCDRV_SRC6_AE_ON|MCDRV_SRC6_AE_OFF)) == MCDRV_SRC6_AE_ON)
+		|| ((psPathInfo->asDit1[0].abSrcOnOff[MCDRV_SRC_MIX_BLOCK] & (MCDRV_SRC6_MIX_ON|MCDRV_SRC6_MIX_OFF)) == MCDRV_SRC6_MIX_ON)
+		|| ((sCurPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK] & (MCDRV_SRC3_DIR1_ON|MCDRV_SRC3_DIR1_OFF)) == MCDRV_SRC3_DIR1_ON))
+		{
+			sdRet	= MCDRV_ERROR_ARGUMENT;
+		}
+	}
+	if((psPathInfo->asDit1[0].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK] & (MCDRV_SRC3_DIR2_ON|MCDRV_SRC3_DIR2_OFF)) == MCDRV_SRC3_DIR2_ON)
+	{
+		if(((psPathInfo->asDit1[0].abSrcOnOff[MCDRV_SRC_PDM_BLOCK] & (MCDRV_SRC4_PDM_ON|MCDRV_SRC4_PDM_OFF)) == MCDRV_SRC4_PDM_ON)
+		|| ((psPathInfo->asDit1[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK] & (MCDRV_SRC4_ADC0_ON|MCDRV_SRC4_ADC0_OFF)) == MCDRV_SRC4_ADC0_ON)
+		|| ((psPathInfo->asDit1[0].abSrcOnOff[MCDRV_SRC_AE_BLOCK] & (MCDRV_SRC6_AE_ON|MCDRV_SRC6_AE_OFF)) == MCDRV_SRC6_AE_ON)
+		|| ((psPathInfo->asDit1[0].abSrcOnOff[MCDRV_SRC_MIX_BLOCK] & (MCDRV_SRC6_MIX_ON|MCDRV_SRC6_MIX_OFF)) == MCDRV_SRC6_MIX_ON)
+		|| ((sCurPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK] & (MCDRV_SRC3_DIR2_ON|MCDRV_SRC3_DIR2_OFF)) == MCDRV_SRC3_DIR2_ON))
+		{
+			sdRet	= MCDRV_ERROR_ARGUMENT;
+		}
+	}
+	if((psPathInfo->asDit1[0].abSrcOnOff[MCDRV_SRC_PDM_BLOCK] & (MCDRV_SRC4_PDM_ON|MCDRV_SRC4_PDM_OFF)) == MCDRV_SRC4_PDM_ON)
+	{
+		if(((psPathInfo->asDit1[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK] & (MCDRV_SRC4_ADC0_ON|MCDRV_SRC4_ADC0_OFF)) == MCDRV_SRC4_ADC0_ON)
+		|| ((psPathInfo->asDit1[0].abSrcOnOff[MCDRV_SRC_AE_BLOCK] & (MCDRV_SRC6_AE_ON|MCDRV_SRC6_AE_OFF)) == MCDRV_SRC6_AE_ON)
+		|| ((psPathInfo->asDit1[0].abSrcOnOff[MCDRV_SRC_MIX_BLOCK] & (MCDRV_SRC6_MIX_ON|MCDRV_SRC6_MIX_OFF)) == MCDRV_SRC6_MIX_ON)
+		|| ((sCurPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_PDM_BLOCK] & (MCDRV_SRC4_PDM_ON|MCDRV_SRC4_PDM_OFF)) == MCDRV_SRC4_PDM_ON))
+		{
+			sdRet	= MCDRV_ERROR_ARGUMENT;
+		}
+	}
+	if((psPathInfo->asDit1[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK] & (MCDRV_SRC4_ADC0_ON|MCDRV_SRC4_ADC0_OFF)) == MCDRV_SRC4_ADC0_ON)
+	{
+		if(((psPathInfo->asDit1[0].abSrcOnOff[MCDRV_SRC_AE_BLOCK] & (MCDRV_SRC6_AE_ON|MCDRV_SRC6_AE_OFF)) == MCDRV_SRC6_AE_ON)
+		|| ((psPathInfo->asDit1[0].abSrcOnOff[MCDRV_SRC_MIX_BLOCK] & (MCDRV_SRC6_MIX_ON|MCDRV_SRC6_MIX_OFF)) == MCDRV_SRC6_MIX_ON)
+		|| ((sCurPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK] & (MCDRV_SRC4_ADC0_ON|MCDRV_SRC4_ADC0_OFF)) == MCDRV_SRC4_ADC0_ON))
+		{
+			sdRet	= MCDRV_ERROR_ARGUMENT;
+		}
+	}
+	if((psPathInfo->asDit1[0].abSrcOnOff[MCDRV_SRC_AE_BLOCK] & (MCDRV_SRC6_AE_ON|MCDRV_SRC6_AE_OFF)) == MCDRV_SRC6_AE_ON)
+	{
+		if((psPathInfo->asDit1[0].abSrcOnOff[MCDRV_SRC_MIX_BLOCK] & (MCDRV_SRC6_MIX_ON|MCDRV_SRC6_MIX_OFF)) == MCDRV_SRC6_MIX_ON)
+		{
+			sdRet	= MCDRV_ERROR_ARGUMENT;
+		}
+	}
+	if((psPathInfo->asDit1[0].abSrcOnOff[MCDRV_SRC_MIX_BLOCK] & (MCDRV_SRC6_MIX_ON|MCDRV_SRC6_MIX_OFF)) == MCDRV_SRC6_MIX_ON)
+	{
+		if((sCurPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_MIX_BLOCK] & (MCDRV_SRC6_MIX_ON|MCDRV_SRC6_MIX_OFF)) == MCDRV_SRC6_MIX_ON)
+		{
+			sdRet	= MCDRV_ERROR_ARGUMENT;
+		}
+	}
+
+	if((psPathInfo->asDit1[0].abSrcOnOff[MCDRV_SRC_PDM_BLOCK] & (MCDRV_SRC4_PDM_ON|MCDRV_SRC4_PDM_OFF)) == MCDRV_SRC4_PDM_ON)
+	{
+		if(bADC0IsSrc == 1)
+		{
+			sdRet	= MCDRV_ERROR_ARGUMENT;
+		}
+		else
+		{
+			bPDMIsSrc	= 1;
+		}
+	}
+	if((psPathInfo->asDit1[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK] & (MCDRV_SRC4_ADC0_ON|MCDRV_SRC4_ADC0_OFF)) == MCDRV_SRC4_ADC0_ON)
+	{
+		if(bPDMIsSrc == 1)
+		{
+			sdRet	= MCDRV_ERROR_ARGUMENT;
+		}
+		else
+		{
+			bADC0IsSrc	= 1;
+		}
+	}
+
+	/*	DIT2	*/
+	if((psPathInfo->asDit2[0].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK] & (MCDRV_SRC3_DIR0_ON|MCDRV_SRC3_DIR0_OFF)) == MCDRV_SRC3_DIR0_ON)
+	{
+		if(((psPathInfo->asDit2[0].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK] & (MCDRV_SRC3_DIR1_ON|MCDRV_SRC3_DIR1_OFF)) == MCDRV_SRC3_DIR1_ON)
+		|| ((psPathInfo->asDit2[0].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK] & (MCDRV_SRC3_DIR2_ON|MCDRV_SRC3_DIR2_OFF)) == MCDRV_SRC3_DIR2_ON)
+		|| ((psPathInfo->asDit2[0].abSrcOnOff[MCDRV_SRC_PDM_BLOCK] & (MCDRV_SRC4_PDM_ON|MCDRV_SRC4_PDM_OFF)) == MCDRV_SRC4_PDM_ON)
+		|| ((psPathInfo->asDit2[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK] & (MCDRV_SRC4_ADC0_ON|MCDRV_SRC4_ADC0_OFF)) == MCDRV_SRC4_ADC0_ON)
+		|| ((psPathInfo->asDit2[0].abSrcOnOff[MCDRV_SRC_AE_BLOCK] & (MCDRV_SRC6_AE_ON|MCDRV_SRC6_AE_OFF)) == MCDRV_SRC6_AE_ON)
+		|| ((psPathInfo->asDit2[0].abSrcOnOff[MCDRV_SRC_MIX_BLOCK] & (MCDRV_SRC6_MIX_ON|MCDRV_SRC6_MIX_OFF)) == MCDRV_SRC6_MIX_ON)
+		|| ((sCurPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK] & (MCDRV_SRC3_DIR0_ON|MCDRV_SRC3_DIR0_OFF)) == MCDRV_SRC3_DIR0_ON))
+		{
+			sdRet	= MCDRV_ERROR_ARGUMENT;
+		}
+	}
+	if((psPathInfo->asDit2[0].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK] & (MCDRV_SRC3_DIR1_ON|MCDRV_SRC3_DIR1_OFF)) == MCDRV_SRC3_DIR1_ON)
+	{
+		if(((psPathInfo->asDit2[0].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK] & (MCDRV_SRC3_DIR2_ON|MCDRV_SRC3_DIR2_OFF)) == MCDRV_SRC3_DIR2_ON)
+		|| ((psPathInfo->asDit2[0].abSrcOnOff[MCDRV_SRC_PDM_BLOCK] & (MCDRV_SRC4_PDM_ON|MCDRV_SRC4_PDM_OFF)) == MCDRV_SRC4_PDM_ON)
+		|| ((psPathInfo->asDit2[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK] & (MCDRV_SRC4_ADC0_ON|MCDRV_SRC4_ADC0_OFF)) == MCDRV_SRC4_ADC0_ON)
+		|| ((psPathInfo->asDit2[0].abSrcOnOff[MCDRV_SRC_AE_BLOCK] & (MCDRV_SRC6_AE_ON|MCDRV_SRC6_AE_OFF)) == MCDRV_SRC6_AE_ON)
+		|| ((psPathInfo->asDit2[0].abSrcOnOff[MCDRV_SRC_MIX_BLOCK] & (MCDRV_SRC6_MIX_ON|MCDRV_SRC6_MIX_OFF)) == MCDRV_SRC6_MIX_ON)
+		|| ((sCurPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK] & (MCDRV_SRC3_DIR1_ON|MCDRV_SRC3_DIR1_OFF)) == MCDRV_SRC3_DIR1_ON))
+		{
+			sdRet	= MCDRV_ERROR_ARGUMENT;
+		}
+	}
+	if((psPathInfo->asDit2[0].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK] & (MCDRV_SRC3_DIR2_ON|MCDRV_SRC3_DIR2_OFF)) == MCDRV_SRC3_DIR2_ON)
+	{
+		if(((psPathInfo->asDit2[0].abSrcOnOff[MCDRV_SRC_PDM_BLOCK] & (MCDRV_SRC4_PDM_ON|MCDRV_SRC4_PDM_OFF)) == MCDRV_SRC4_PDM_ON)
+		|| ((psPathInfo->asDit2[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK] & (MCDRV_SRC4_ADC0_ON|MCDRV_SRC4_ADC0_OFF)) == MCDRV_SRC4_ADC0_ON)
+		|| ((psPathInfo->asDit2[0].abSrcOnOff[MCDRV_SRC_AE_BLOCK] & (MCDRV_SRC6_AE_ON|MCDRV_SRC6_AE_OFF)) == MCDRV_SRC6_AE_ON)
+		|| ((psPathInfo->asDit2[0].abSrcOnOff[MCDRV_SRC_MIX_BLOCK] & (MCDRV_SRC6_MIX_ON|MCDRV_SRC6_MIX_OFF)) == MCDRV_SRC6_MIX_ON)
+		|| ((sCurPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK] & (MCDRV_SRC3_DIR2_ON|MCDRV_SRC3_DIR2_OFF)) == MCDRV_SRC3_DIR2_ON))
+		{
+			sdRet	= MCDRV_ERROR_ARGUMENT;
+		}
+	}
+	if((psPathInfo->asDit2[0].abSrcOnOff[MCDRV_SRC_PDM_BLOCK] & (MCDRV_SRC4_PDM_ON|MCDRV_SRC4_PDM_OFF)) == MCDRV_SRC4_PDM_ON)
+	{
+		if(((psPathInfo->asDit2[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK] & (MCDRV_SRC4_ADC0_ON|MCDRV_SRC4_ADC0_OFF)) == MCDRV_SRC4_ADC0_ON)
+		|| ((psPathInfo->asDit2[0].abSrcOnOff[MCDRV_SRC_AE_BLOCK] & (MCDRV_SRC6_AE_ON|MCDRV_SRC6_AE_OFF)) == MCDRV_SRC6_AE_ON)
+		|| ((psPathInfo->asDit2[0].abSrcOnOff[MCDRV_SRC_MIX_BLOCK] & (MCDRV_SRC6_MIX_ON|MCDRV_SRC6_MIX_OFF)) == MCDRV_SRC6_MIX_ON)
+		|| ((sCurPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_PDM_BLOCK] & (MCDRV_SRC4_PDM_ON|MCDRV_SRC4_PDM_OFF)) == MCDRV_SRC4_PDM_ON))
+		{
+			sdRet	= MCDRV_ERROR_ARGUMENT;
+		}
+	}
+	if((psPathInfo->asDit2[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK] & (MCDRV_SRC4_ADC0_ON|MCDRV_SRC4_ADC0_OFF)) == MCDRV_SRC4_ADC0_ON)
+	{
+		if(((psPathInfo->asDit2[0].abSrcOnOff[MCDRV_SRC_AE_BLOCK] & (MCDRV_SRC6_AE_ON|MCDRV_SRC6_AE_OFF)) == MCDRV_SRC6_AE_ON)
+		|| ((psPathInfo->asDit2[0].abSrcOnOff[MCDRV_SRC_MIX_BLOCK] & (MCDRV_SRC6_MIX_ON|MCDRV_SRC6_MIX_OFF)) == MCDRV_SRC6_MIX_ON)
+		|| ((sCurPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK] & (MCDRV_SRC4_ADC0_ON|MCDRV_SRC4_ADC0_OFF)) == MCDRV_SRC4_ADC0_ON))
+		{
+			sdRet	= MCDRV_ERROR_ARGUMENT;
+		}
+	}
+	if((psPathInfo->asDit2[0].abSrcOnOff[MCDRV_SRC_AE_BLOCK] & (MCDRV_SRC6_AE_ON|MCDRV_SRC6_AE_OFF)) == MCDRV_SRC6_AE_ON)
+	{
+		if((psPathInfo->asDit2[0].abSrcOnOff[MCDRV_SRC_MIX_BLOCK] & (MCDRV_SRC6_MIX_ON|MCDRV_SRC6_MIX_OFF)) == MCDRV_SRC6_MIX_ON)
+		{
+			sdRet	= MCDRV_ERROR_ARGUMENT;
+		}
+	}
+	if((psPathInfo->asDit2[0].abSrcOnOff[MCDRV_SRC_MIX_BLOCK] & (MCDRV_SRC6_MIX_ON|MCDRV_SRC6_MIX_OFF)) == MCDRV_SRC6_MIX_ON)
+	{
+		if((sCurPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_MIX_BLOCK] & (MCDRV_SRC6_MIX_ON|MCDRV_SRC6_MIX_OFF)) == MCDRV_SRC6_MIX_ON)
+		{
+			sdRet	= MCDRV_ERROR_ARGUMENT;
+		}
+	}
+
+	if((psPathInfo->asDit2[0].abSrcOnOff[MCDRV_SRC_PDM_BLOCK] & (MCDRV_SRC4_PDM_ON|MCDRV_SRC4_PDM_OFF)) == MCDRV_SRC4_PDM_ON)
+	{
+		if(bADC0IsSrc == 1)
+		{
+			sdRet	= MCDRV_ERROR_ARGUMENT;
+		}
+		else
+		{
+			bPDMIsSrc	= 1;
+		}
+	}
+	if((psPathInfo->asDit2[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK] & (MCDRV_SRC4_ADC0_ON|MCDRV_SRC4_ADC0_OFF)) == MCDRV_SRC4_ADC0_ON)
+	{
+		if(bPDMIsSrc == 1)
+		{
+			sdRet	= MCDRV_ERROR_ARGUMENT;
+		}
+		else
+		{
+			bADC0IsSrc	= 1;
+		}
+	}
+
+	/*	DAC	*/
+	for(bCh = 0; bCh < DAC_PATH_CHANNELS; bCh++)
+	{
+		if((psPathInfo->asDac[bCh].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK] & (MCDRV_SRC3_DIR0_ON|MCDRV_SRC3_DIR0_OFF)) == MCDRV_SRC3_DIR0_ON)
+		{
+			if(((psPathInfo->asDac[bCh].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK] & (MCDRV_SRC3_DIR1_ON|MCDRV_SRC3_DIR1_OFF)) == MCDRV_SRC3_DIR1_ON)
+			|| ((psPathInfo->asDac[bCh].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK] & (MCDRV_SRC3_DIR2_ON|MCDRV_SRC3_DIR2_OFF)) == MCDRV_SRC3_DIR2_ON)
+			|| ((psPathInfo->asDac[bCh].abSrcOnOff[MCDRV_SRC_PDM_BLOCK] & (MCDRV_SRC4_PDM_ON|MCDRV_SRC4_PDM_OFF)) == MCDRV_SRC4_PDM_ON)
+			|| ((psPathInfo->asDac[bCh].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK] & (MCDRV_SRC4_ADC0_ON|MCDRV_SRC4_ADC0_OFF)) == MCDRV_SRC4_ADC0_ON)
+			|| ((psPathInfo->asDac[bCh].abSrcOnOff[MCDRV_SRC_AE_BLOCK] & (MCDRV_SRC6_AE_ON|MCDRV_SRC6_AE_OFF)) == MCDRV_SRC6_AE_ON)
+			|| ((psPathInfo->asDac[bCh].abSrcOnOff[MCDRV_SRC_MIX_BLOCK] & (MCDRV_SRC6_MIX_ON|MCDRV_SRC6_MIX_OFF)) == MCDRV_SRC6_MIX_ON)
+			|| ((sCurPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK] & (MCDRV_SRC3_DIR0_ON|MCDRV_SRC3_DIR0_OFF)) == MCDRV_SRC3_DIR0_ON))
+			{
+				sdRet	= MCDRV_ERROR_ARGUMENT;
+			}
+		}
+		if((psPathInfo->asDac[bCh].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK] & (MCDRV_SRC3_DIR1_ON|MCDRV_SRC3_DIR1_OFF)) == MCDRV_SRC3_DIR1_ON)
+		{
+			if(((psPathInfo->asDac[bCh].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK] & (MCDRV_SRC3_DIR2_ON|MCDRV_SRC3_DIR2_OFF)) == MCDRV_SRC3_DIR2_ON)
+			|| ((psPathInfo->asDac[bCh].abSrcOnOff[MCDRV_SRC_PDM_BLOCK] & (MCDRV_SRC4_PDM_ON|MCDRV_SRC4_PDM_OFF)) == MCDRV_SRC4_PDM_ON)
+			|| ((psPathInfo->asDac[bCh].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK] & (MCDRV_SRC4_ADC0_ON|MCDRV_SRC4_ADC0_OFF)) == MCDRV_SRC4_ADC0_ON)
+			|| ((psPathInfo->asDac[bCh].abSrcOnOff[MCDRV_SRC_AE_BLOCK] & (MCDRV_SRC6_AE_ON|MCDRV_SRC6_AE_OFF)) == MCDRV_SRC6_AE_ON)
+			|| ((psPathInfo->asDac[bCh].abSrcOnOff[MCDRV_SRC_MIX_BLOCK] & (MCDRV_SRC6_MIX_ON|MCDRV_SRC6_MIX_OFF)) == MCDRV_SRC6_MIX_ON)
+			|| ((sCurPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK] & (MCDRV_SRC3_DIR1_ON|MCDRV_SRC3_DIR1_OFF)) == MCDRV_SRC3_DIR1_ON))
+			{
+				sdRet	= MCDRV_ERROR_ARGUMENT;
+			}
+		}
+		if((psPathInfo->asDac[bCh].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK] & (MCDRV_SRC3_DIR2_ON|MCDRV_SRC3_DIR2_OFF)) == MCDRV_SRC3_DIR2_ON)
+		{
+			if(((psPathInfo->asDac[bCh].abSrcOnOff[MCDRV_SRC_PDM_BLOCK] & (MCDRV_SRC4_PDM_ON|MCDRV_SRC4_PDM_OFF)) == MCDRV_SRC4_PDM_ON)
+			|| ((psPathInfo->asDac[bCh].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK] & (MCDRV_SRC4_ADC0_ON|MCDRV_SRC4_ADC0_OFF)) == MCDRV_SRC4_ADC0_ON)
+			|| ((psPathInfo->asDac[bCh].abSrcOnOff[MCDRV_SRC_AE_BLOCK] & (MCDRV_SRC6_AE_ON|MCDRV_SRC6_AE_OFF)) == MCDRV_SRC6_AE_ON)
+			|| ((psPathInfo->asDac[bCh].abSrcOnOff[MCDRV_SRC_MIX_BLOCK] & (MCDRV_SRC6_MIX_ON|MCDRV_SRC6_MIX_OFF)) == MCDRV_SRC6_MIX_ON)
+			|| ((sCurPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK] & (MCDRV_SRC3_DIR2_ON|MCDRV_SRC3_DIR2_OFF)) == MCDRV_SRC3_DIR2_ON))
+			{
+				sdRet	= MCDRV_ERROR_ARGUMENT;
+			}
+		}
+		if((psPathInfo->asDac[bCh].abSrcOnOff[MCDRV_SRC_PDM_BLOCK] & (MCDRV_SRC4_PDM_ON|MCDRV_SRC4_PDM_OFF)) == MCDRV_SRC4_PDM_ON)
+		{
+			if(((psPathInfo->asDac[bCh].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK] & (MCDRV_SRC4_ADC0_ON|MCDRV_SRC4_ADC0_OFF)) == MCDRV_SRC4_ADC0_ON)
+			|| ((psPathInfo->asDac[bCh].abSrcOnOff[MCDRV_SRC_AE_BLOCK] & (MCDRV_SRC6_AE_ON|MCDRV_SRC6_AE_OFF)) == MCDRV_SRC6_AE_ON)
+			|| ((psPathInfo->asDac[bCh].abSrcOnOff[MCDRV_SRC_MIX_BLOCK] & (MCDRV_SRC6_MIX_ON|MCDRV_SRC6_MIX_OFF)) == MCDRV_SRC6_MIX_ON)
+			|| ((sCurPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_PDM_BLOCK] & (MCDRV_SRC4_PDM_ON|MCDRV_SRC4_PDM_OFF)) == MCDRV_SRC4_PDM_ON))
+			{
+				sdRet	= MCDRV_ERROR_ARGUMENT;
+			}
+		}
+		if((psPathInfo->asDac[bCh].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK] & (MCDRV_SRC4_ADC0_ON|MCDRV_SRC4_ADC0_OFF)) == MCDRV_SRC4_ADC0_ON)
+		{
+			if(((psPathInfo->asDac[bCh].abSrcOnOff[MCDRV_SRC_AE_BLOCK] & (MCDRV_SRC6_AE_ON|MCDRV_SRC6_AE_OFF)) == MCDRV_SRC6_AE_ON)
+			|| ((psPathInfo->asDac[bCh].abSrcOnOff[MCDRV_SRC_MIX_BLOCK] & (MCDRV_SRC6_MIX_ON|MCDRV_SRC6_MIX_OFF)) == MCDRV_SRC6_MIX_ON)
+			|| ((sCurPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK] & (MCDRV_SRC4_ADC0_ON|MCDRV_SRC4_ADC0_OFF)) == MCDRV_SRC4_ADC0_ON))
+			{
+				sdRet	= MCDRV_ERROR_ARGUMENT;
+			}
+		}
+		if((psPathInfo->asDac[bCh].abSrcOnOff[MCDRV_SRC_AE_BLOCK] & (MCDRV_SRC6_AE_ON|MCDRV_SRC6_AE_OFF)) == MCDRV_SRC6_AE_ON)
+		{
+			if((psPathInfo->asDac[bCh].abSrcOnOff[MCDRV_SRC_MIX_BLOCK] & (MCDRV_SRC6_MIX_ON|MCDRV_SRC6_MIX_OFF)) == MCDRV_SRC6_MIX_ON)
+			{
+				sdRet	= MCDRV_ERROR_ARGUMENT;
+			}
+		}
+		if((psPathInfo->asDac[bCh].abSrcOnOff[MCDRV_SRC_MIX_BLOCK] & (MCDRV_SRC6_MIX_ON|MCDRV_SRC6_MIX_OFF)) == MCDRV_SRC6_MIX_ON)
+		{
+			if((sCurPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_MIX_BLOCK] & (MCDRV_SRC6_MIX_ON|MCDRV_SRC6_MIX_OFF)) == MCDRV_SRC6_MIX_ON)
+			{
+				sdRet	= MCDRV_ERROR_ARGUMENT;
+			}
+		}
+
+		if((psPathInfo->asDac[bCh].abSrcOnOff[MCDRV_SRC_PDM_BLOCK] & (MCDRV_SRC4_PDM_ON|MCDRV_SRC4_PDM_OFF)) == MCDRV_SRC4_PDM_ON)
+		{
+			if(bADC0IsSrc == 1)
+			{
+				sdRet	= MCDRV_ERROR_ARGUMENT;
+			}
+			else
+			{
+				bPDMIsSrc	= 1;
+			}
+		}
+		if((psPathInfo->asDac[bCh].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK] & (MCDRV_SRC4_ADC0_ON|MCDRV_SRC4_ADC0_OFF)) == MCDRV_SRC4_ADC0_ON)
+		{
+			if(bPDMIsSrc == 1)
+			{
+				sdRet	= MCDRV_ERROR_ARGUMENT;
+			}
+			else
+			{
+				bADC0IsSrc	= 1;
+			}
+		}
+	}
+
+	/*	AE	*/
+	if((psPathInfo->asAe[0].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK] & (MCDRV_SRC3_DIR0_ON|MCDRV_SRC3_DIR0_OFF)) == MCDRV_SRC3_DIR0_ON)
+	{
+		if(((psPathInfo->asAe[0].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK] & (MCDRV_SRC3_DIR1_ON|MCDRV_SRC3_DIR1_OFF)) == MCDRV_SRC3_DIR1_ON)
+		|| ((psPathInfo->asAe[0].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK] & (MCDRV_SRC3_DIR2_ON|MCDRV_SRC3_DIR2_OFF)) == MCDRV_SRC3_DIR2_ON)
+		|| ((psPathInfo->asAe[0].abSrcOnOff[MCDRV_SRC_PDM_BLOCK] & (MCDRV_SRC4_PDM_ON|MCDRV_SRC4_PDM_OFF)) == MCDRV_SRC4_PDM_ON)
+		|| ((psPathInfo->asAe[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK] & (MCDRV_SRC4_ADC0_ON|MCDRV_SRC4_ADC0_OFF)) == MCDRV_SRC4_ADC0_ON)
+		|| ((psPathInfo->asAe[0].abSrcOnOff[MCDRV_SRC_MIX_BLOCK] & (MCDRV_SRC6_MIX_ON|MCDRV_SRC6_MIX_OFF)) == MCDRV_SRC6_MIX_ON))
+		{
+			sdRet	= MCDRV_ERROR_ARGUMENT;
+		}
+	}
+	if((psPathInfo->asAe[0].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK] & (MCDRV_SRC3_DIR1_ON|MCDRV_SRC3_DIR1_OFF)) == MCDRV_SRC3_DIR1_ON)
+	{
+		if(((psPathInfo->asAe[0].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK] & (MCDRV_SRC3_DIR2_ON|MCDRV_SRC3_DIR2_OFF)) == MCDRV_SRC3_DIR2_ON)
+		|| ((psPathInfo->asAe[0].abSrcOnOff[MCDRV_SRC_PDM_BLOCK] & (MCDRV_SRC4_PDM_ON|MCDRV_SRC4_PDM_OFF)) == MCDRV_SRC4_PDM_ON)
+		|| ((psPathInfo->asAe[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK] & (MCDRV_SRC4_ADC0_ON|MCDRV_SRC4_ADC0_OFF)) == MCDRV_SRC4_ADC0_ON)
+		|| ((psPathInfo->asAe[0].abSrcOnOff[MCDRV_SRC_MIX_BLOCK] & (MCDRV_SRC6_MIX_ON|MCDRV_SRC6_MIX_OFF)) == MCDRV_SRC6_MIX_ON))
+		{
+			sdRet	= MCDRV_ERROR_ARGUMENT;
+		}
+	}
+	if((psPathInfo->asAe[0].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK] & (MCDRV_SRC3_DIR2_ON|MCDRV_SRC3_DIR2_OFF)) == MCDRV_SRC3_DIR2_ON)
+	{
+		if(((psPathInfo->asAe[0].abSrcOnOff[MCDRV_SRC_PDM_BLOCK] & (MCDRV_SRC4_PDM_ON|MCDRV_SRC4_PDM_OFF)) == MCDRV_SRC4_PDM_ON)
+		|| ((psPathInfo->asAe[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK] & (MCDRV_SRC4_ADC0_ON|MCDRV_SRC4_ADC0_OFF)) == MCDRV_SRC4_ADC0_ON)
+		|| ((psPathInfo->asAe[0].abSrcOnOff[MCDRV_SRC_MIX_BLOCK] & (MCDRV_SRC6_MIX_ON|MCDRV_SRC6_MIX_OFF)) == MCDRV_SRC6_MIX_ON))
+		{
+			sdRet	= MCDRV_ERROR_ARGUMENT;
+		}
+	}
+	if((psPathInfo->asAe[0].abSrcOnOff[MCDRV_SRC_PDM_BLOCK] & (MCDRV_SRC4_PDM_ON|MCDRV_SRC4_PDM_OFF)) == MCDRV_SRC4_PDM_ON)
+	{
+		if(((psPathInfo->asAe[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK] & (MCDRV_SRC4_ADC0_ON|MCDRV_SRC4_ADC0_OFF)) == MCDRV_SRC4_ADC0_ON)
+		|| ((psPathInfo->asAe[0].abSrcOnOff[MCDRV_SRC_MIX_BLOCK] & (MCDRV_SRC6_MIX_ON|MCDRV_SRC6_MIX_OFF)) == MCDRV_SRC6_MIX_ON))
+		{
+			sdRet	= MCDRV_ERROR_ARGUMENT;
+		}
+	}
+	if((psPathInfo->asAe[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK] & (MCDRV_SRC4_ADC0_ON|MCDRV_SRC4_ADC0_OFF)) == MCDRV_SRC4_ADC0_ON)
+	{
+		if((psPathInfo->asAe[0].abSrcOnOff[MCDRV_SRC_MIX_BLOCK] & (MCDRV_SRC6_MIX_ON|MCDRV_SRC6_MIX_OFF)) == MCDRV_SRC6_MIX_ON)
+		{
+			sdRet	= MCDRV_ERROR_ARGUMENT;
+		}
+	}
+
+	if((psPathInfo->asAe[0].abSrcOnOff[MCDRV_SRC_PDM_BLOCK] & (MCDRV_SRC4_PDM_ON|MCDRV_SRC4_PDM_OFF)) == MCDRV_SRC4_PDM_ON)
+	{
+		if(bADC0IsSrc == 1)
+		{
+			sdRet	= MCDRV_ERROR_ARGUMENT;
+		}
+		else
+		{
+			bPDMIsSrc	= 1;
+		}
+	}
+	if((psPathInfo->asAe[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK] & (MCDRV_SRC4_ADC0_ON|MCDRV_SRC4_ADC0_OFF)) == MCDRV_SRC4_ADC0_ON)
+	{
+		if(bPDMIsSrc == 1)
+		{
+			sdRet	= MCDRV_ERROR_ARGUMENT;
+		}
+		else
+		{
+			bADC0IsSrc	= 1;
+		}
+	}
+	if(((psPathInfo->asAe[0].abSrcOnOff[MCDRV_SRC_MIX_BLOCK] & (MCDRV_SRC6_MIX_ON|MCDRV_SRC6_MIX_OFF)) == MCDRV_SRC6_MIX_ON)
+	&& (((psPathInfo->asMix[0].abSrcOnOff[MCDRV_SRC_AE_BLOCK] & (MCDRV_SRC6_AE_ON|MCDRV_SRC6_AE_OFF)) == MCDRV_SRC6_AE_ON)
+		|| ((sCurPathInfo.asMix[0].abSrcOnOff[MCDRV_SRC_AE_BLOCK] & MCDRV_SRC6_AE_ON) == MCDRV_SRC6_AE_ON)))
+	{
+		sdRet	= MCDRV_ERROR_ARGUMENT;
+	}
+
+	/*	CDSP	*/
+	for(bCh = 0; bCh < 4; bCh++)
+	{
+	}
+
+	/*	ADC0	*/
+	if((psPathInfo->asAdc0[0].abSrcOnOff[MCDRV_SRC_LINE1_L_BLOCK] & (MCDRV_SRC1_LINE1_L_ON|MCDRV_SRC1_LINE1_L_OFF)) == MCDRV_SRC1_LINE1_L_ON)
+	{
+		if(((psPathInfo->asAdc0[0].abSrcOnOff[MCDRV_SRC_LINE1_M_BLOCK] & (MCDRV_SRC1_LINE1_M_ON|MCDRV_SRC1_LINE1_M_OFF)) == MCDRV_SRC1_LINE1_M_ON)
+		|| ((sCurPathInfo.asAdc0[0].abSrcOnOff[MCDRV_SRC_LINE1_M_BLOCK] & (MCDRV_SRC1_LINE1_M_ON|MCDRV_SRC1_LINE1_M_OFF)) == MCDRV_SRC1_LINE1_M_ON))
+		{
+			sdRet	= MCDRV_ERROR_ARGUMENT;
+		}
+	}
+	if((psPathInfo->asAdc0[0].abSrcOnOff[MCDRV_SRC_LINE1_M_BLOCK] & (MCDRV_SRC1_LINE1_M_ON|MCDRV_SRC1_LINE1_M_OFF)) == MCDRV_SRC1_LINE1_M_ON)
+	{
+		if((sCurPathInfo.asAdc0[0].abSrcOnOff[MCDRV_SRC_LINE1_L_BLOCK] & (MCDRV_SRC1_LINE1_L_ON|MCDRV_SRC1_LINE1_L_OFF)) == MCDRV_SRC1_LINE1_L_ON)
+		{
+			sdRet	= MCDRV_ERROR_ARGUMENT;
+		}
+	}
+	if((psPathInfo->asAdc0[1].abSrcOnOff[MCDRV_SRC_LINE1_R_BLOCK] & (MCDRV_SRC1_LINE1_R_ON|MCDRV_SRC1_LINE1_R_OFF)) == MCDRV_SRC1_LINE1_R_ON)
+	{
+		if(((psPathInfo->asAdc0[1].abSrcOnOff[MCDRV_SRC_LINE1_M_BLOCK] & (MCDRV_SRC1_LINE1_M_ON|MCDRV_SRC1_LINE1_M_OFF)) == MCDRV_SRC1_LINE1_M_ON)
+		|| ((sCurPathInfo.asAdc0[1].abSrcOnOff[MCDRV_SRC_LINE1_M_BLOCK] & (MCDRV_SRC1_LINE1_M_ON|MCDRV_SRC1_LINE1_M_OFF)) == MCDRV_SRC1_LINE1_M_ON))
+		{
+			sdRet	= MCDRV_ERROR_ARGUMENT;
+		}
+	}
+	if((psPathInfo->asAdc0[1].abSrcOnOff[MCDRV_SRC_LINE1_M_BLOCK] & (MCDRV_SRC1_LINE1_M_ON|MCDRV_SRC1_LINE1_M_OFF)) == MCDRV_SRC1_LINE1_M_ON)
+	{
+		if((sCurPathInfo.asAdc0[1].abSrcOnOff[MCDRV_SRC_LINE1_R_BLOCK] & (MCDRV_SRC1_LINE1_R_ON|MCDRV_SRC1_LINE1_R_OFF)) == MCDRV_SRC1_LINE1_R_ON)
+		{
+			sdRet	= MCDRV_ERROR_ARGUMENT;
+		}
+	}
+
+	/*	ADC1	*/
+
+	/*	MIX	*/
+	if((psPathInfo->asMix[0].abSrcOnOff[MCDRV_SRC_PDM_BLOCK] & (MCDRV_SRC4_PDM_ON|MCDRV_SRC4_PDM_OFF)) == MCDRV_SRC4_PDM_ON)
+	{
+		if(bADC0IsSrc == 1)
+		{
+			sdRet	= MCDRV_ERROR_ARGUMENT;
+		}
+		else
+		{
+			bPDMIsSrc	= 1;
+		}
+	}
+	if((psPathInfo->asMix[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK] & (MCDRV_SRC4_ADC0_ON|MCDRV_SRC4_ADC0_OFF)) == MCDRV_SRC4_ADC0_ON)
+	{
+		if(bPDMIsSrc == 1)
+		{
+			sdRet	= MCDRV_ERROR_ARGUMENT;
+		}
+		else
+		{
+			bADC0IsSrc	= 1;
+		}
+	}
+	if((psPathInfo->asMix[0].abSrcOnOff[MCDRV_SRC_AE_BLOCK] & (MCDRV_SRC6_AE_ON|MCDRV_SRC6_AE_OFF)) == MCDRV_SRC6_AE_ON)
+	{
+		if(((psPathInfo->asAe[0].abSrcOnOff[MCDRV_SRC_MIX_BLOCK] & (MCDRV_SRC6_MIX_ON|MCDRV_SRC6_MIX_OFF)) == MCDRV_SRC6_MIX_ON)
+		|| ((sCurPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_MIX_BLOCK] & MCDRV_SRC6_MIX_ON) == MCDRV_SRC6_MIX_ON))
+		{
+			sdRet	= MCDRV_ERROR_ARGUMENT;
+		}
+	}
+	if(((psPathInfo->asMix[0].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK] & (MCDRV_SRC3_DIR0_ON|MCDRV_SRC3_DIR0_OFF)) == MCDRV_SRC3_DIR0_ON)
+	&& ((sCurPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK] & (MCDRV_SRC3_DIR0_ON|MCDRV_SRC3_DIR0_OFF)) == MCDRV_SRC3_DIR0_ON))
+	{
+		sdRet	= MCDRV_ERROR_ARGUMENT;
+	}
+	if(((psPathInfo->asMix[0].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK] & (MCDRV_SRC3_DIR1_ON|MCDRV_SRC3_DIR1_OFF)) == MCDRV_SRC3_DIR1_ON)
+	&& ((sCurPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK] & (MCDRV_SRC3_DIR1_ON|MCDRV_SRC3_DIR1_OFF)) == MCDRV_SRC3_DIR1_ON))
+	{
+		sdRet	= MCDRV_ERROR_ARGUMENT;
+	}
+	if(((psPathInfo->asMix[0].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK] & (MCDRV_SRC3_DIR2_ON|MCDRV_SRC3_DIR2_OFF)) == MCDRV_SRC3_DIR2_ON)
+	&& ((sCurPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK] & (MCDRV_SRC3_DIR2_ON|MCDRV_SRC3_DIR2_OFF)) == MCDRV_SRC3_DIR2_ON))
+	{
+		sdRet	= MCDRV_ERROR_ARGUMENT;
+	}
+	if(((psPathInfo->asMix[0].abSrcOnOff[MCDRV_SRC_PDM_BLOCK] & (MCDRV_SRC4_PDM_ON|MCDRV_SRC4_PDM_OFF)) == MCDRV_SRC4_PDM_ON)
+	&& ((sCurPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_PDM_BLOCK] & (MCDRV_SRC4_PDM_ON|MCDRV_SRC4_PDM_OFF)) == MCDRV_SRC4_PDM_ON))
+	{
+		sdRet	= MCDRV_ERROR_ARGUMENT;
+	}
+	if(((psPathInfo->asMix[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK] & (MCDRV_SRC4_ADC0_ON|MCDRV_SRC4_ADC0_OFF)) == MCDRV_SRC4_ADC0_ON)
+	&& ((sCurPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK] & (MCDRV_SRC4_ADC0_ON|MCDRV_SRC4_ADC0_OFF)) == MCDRV_SRC4_ADC0_ON))
+	{
+		sdRet	= MCDRV_ERROR_ARGUMENT;
+	}
+
+	if(((psPathInfo->asAe[0].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK] & (MCDRV_SRC3_DIR0_ON|MCDRV_SRC3_DIR0_OFF)) == MCDRV_SRC3_DIR0_ON)
+	&& (((psPathInfo->asDit0[0].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK] & (MCDRV_SRC3_DIR0_ON|MCDRV_SRC3_DIR0_OFF)) == MCDRV_SRC3_DIR0_ON)
+	 || ((psPathInfo->asDit1[0].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK] & (MCDRV_SRC3_DIR0_ON|MCDRV_SRC3_DIR0_OFF)) == MCDRV_SRC3_DIR0_ON)
+	 || ((psPathInfo->asDit2[0].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK] & (MCDRV_SRC3_DIR0_ON|MCDRV_SRC3_DIR0_OFF)) == MCDRV_SRC3_DIR0_ON)
+	 || ((psPathInfo->asDac[0].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK] & (MCDRV_SRC3_DIR0_ON|MCDRV_SRC3_DIR0_OFF)) == MCDRV_SRC3_DIR0_ON)
+	 || ((psPathInfo->asDac[1].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK] & (MCDRV_SRC3_DIR0_ON|MCDRV_SRC3_DIR0_OFF)) == MCDRV_SRC3_DIR0_ON)
+	 || ((psPathInfo->asMix[0].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK] & (MCDRV_SRC3_DIR0_ON|MCDRV_SRC3_DIR0_OFF)) == MCDRV_SRC3_DIR0_ON)
+	 || ((sCurPathInfo.asDit0[0].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK] & (MCDRV_SRC3_DIR0_ON|MCDRV_SRC3_DIR0_OFF)) == MCDRV_SRC3_DIR0_ON)
+	 || ((sCurPathInfo.asDit1[0].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK] & (MCDRV_SRC3_DIR0_ON|MCDRV_SRC3_DIR0_OFF)) == MCDRV_SRC3_DIR0_ON)
+	 || ((sCurPathInfo.asDit2[0].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK] & (MCDRV_SRC3_DIR0_ON|MCDRV_SRC3_DIR0_OFF)) == MCDRV_SRC3_DIR0_ON)
+	 || ((sCurPathInfo.asDac[0].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK] & (MCDRV_SRC3_DIR0_ON|MCDRV_SRC3_DIR0_OFF)) == MCDRV_SRC3_DIR0_ON)
+	 || ((sCurPathInfo.asDac[1].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK] & (MCDRV_SRC3_DIR0_ON|MCDRV_SRC3_DIR0_OFF)) == MCDRV_SRC3_DIR0_ON)
+	 || ((sCurPathInfo.asMix[0].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK] & (MCDRV_SRC3_DIR0_ON|MCDRV_SRC3_DIR0_OFF)) == MCDRV_SRC3_DIR0_ON)
+	 ))
+	{
+		sdRet	= MCDRV_ERROR_ARGUMENT;
+	}
+	if(((psPathInfo->asAe[0].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK] & (MCDRV_SRC3_DIR1_ON|MCDRV_SRC3_DIR1_OFF)) == MCDRV_SRC3_DIR1_ON)
+	&& (((psPathInfo->asDit0[0].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK] & (MCDRV_SRC3_DIR1_ON|MCDRV_SRC3_DIR1_OFF)) == MCDRV_SRC3_DIR1_ON)
+	 || ((psPathInfo->asDit1[0].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK] & (MCDRV_SRC3_DIR1_ON|MCDRV_SRC3_DIR1_OFF)) == MCDRV_SRC3_DIR1_ON)
+	 || ((psPathInfo->asDit2[0].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK] & (MCDRV_SRC3_DIR1_ON|MCDRV_SRC3_DIR1_OFF)) == MCDRV_SRC3_DIR1_ON)
+	 || ((psPathInfo->asDac[0].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK] & (MCDRV_SRC3_DIR1_ON|MCDRV_SRC3_DIR1_OFF)) == MCDRV_SRC3_DIR1_ON)
+	 || ((psPathInfo->asDac[1].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK] & (MCDRV_SRC3_DIR1_ON|MCDRV_SRC3_DIR1_OFF)) == MCDRV_SRC3_DIR1_ON)
+	 || ((psPathInfo->asMix[0].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK] & (MCDRV_SRC3_DIR1_ON|MCDRV_SRC3_DIR1_OFF)) == MCDRV_SRC3_DIR1_ON)
+	 || ((sCurPathInfo.asDit0[0].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK] & (MCDRV_SRC3_DIR1_ON|MCDRV_SRC3_DIR1_OFF)) == MCDRV_SRC3_DIR1_ON)
+	 || ((sCurPathInfo.asDit1[0].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK] & (MCDRV_SRC3_DIR1_ON|MCDRV_SRC3_DIR1_OFF)) == MCDRV_SRC3_DIR1_ON)
+	 || ((sCurPathInfo.asDit2[0].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK] & (MCDRV_SRC3_DIR1_ON|MCDRV_SRC3_DIR1_OFF)) == MCDRV_SRC3_DIR1_ON)
+	 || ((sCurPathInfo.asDac[0].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK] & (MCDRV_SRC3_DIR1_ON|MCDRV_SRC3_DIR1_OFF)) == MCDRV_SRC3_DIR1_ON)
+	 || ((sCurPathInfo.asDac[1].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK] & (MCDRV_SRC3_DIR1_ON|MCDRV_SRC3_DIR1_OFF)) == MCDRV_SRC3_DIR1_ON)
+	 || ((sCurPathInfo.asMix[0].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK] & (MCDRV_SRC3_DIR1_ON|MCDRV_SRC3_DIR1_OFF)) == MCDRV_SRC3_DIR1_ON)
+	 ))
+	{
+		sdRet	= MCDRV_ERROR_ARGUMENT;
+	}
+	if(((psPathInfo->asAe[0].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK] & (MCDRV_SRC3_DIR2_ON|MCDRV_SRC3_DIR2_OFF)) == MCDRV_SRC3_DIR2_ON)
+	&& (((psPathInfo->asDit0[0].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK] & (MCDRV_SRC3_DIR2_ON|MCDRV_SRC3_DIR2_OFF)) == MCDRV_SRC3_DIR2_ON)
+	 || ((psPathInfo->asDit1[0].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK] & (MCDRV_SRC3_DIR2_ON|MCDRV_SRC3_DIR2_OFF)) == MCDRV_SRC3_DIR2_ON)
+	 || ((psPathInfo->asDit2[0].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK] & (MCDRV_SRC3_DIR2_ON|MCDRV_SRC3_DIR2_OFF)) == MCDRV_SRC3_DIR2_ON)
+	 || ((psPathInfo->asDac[0].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK] & (MCDRV_SRC3_DIR2_ON|MCDRV_SRC3_DIR2_OFF)) == MCDRV_SRC3_DIR2_ON)
+	 || ((psPathInfo->asDac[1].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK] & (MCDRV_SRC3_DIR2_ON|MCDRV_SRC3_DIR2_OFF)) == MCDRV_SRC3_DIR2_ON)
+	 || ((psPathInfo->asMix[0].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK] & (MCDRV_SRC3_DIR2_ON|MCDRV_SRC3_DIR2_OFF)) == MCDRV_SRC3_DIR2_ON)
+	 || ((sCurPathInfo.asDit0[0].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK] & (MCDRV_SRC3_DIR2_ON|MCDRV_SRC3_DIR2_OFF)) == MCDRV_SRC3_DIR2_ON)
+	 || ((sCurPathInfo.asDit1[0].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK] & (MCDRV_SRC3_DIR2_ON|MCDRV_SRC3_DIR2_OFF)) == MCDRV_SRC3_DIR2_ON)
+	 || ((sCurPathInfo.asDit2[0].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK] & (MCDRV_SRC3_DIR2_ON|MCDRV_SRC3_DIR2_OFF)) == MCDRV_SRC3_DIR2_ON)
+	 || ((sCurPathInfo.asDac[0].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK] & (MCDRV_SRC3_DIR2_ON|MCDRV_SRC3_DIR2_OFF)) == MCDRV_SRC3_DIR2_ON)
+	 || ((sCurPathInfo.asDac[1].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK] & (MCDRV_SRC3_DIR2_ON|MCDRV_SRC3_DIR2_OFF)) == MCDRV_SRC3_DIR2_ON)
+	 || ((sCurPathInfo.asMix[0].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK] & (MCDRV_SRC3_DIR2_ON|MCDRV_SRC3_DIR2_OFF)) == MCDRV_SRC3_DIR2_ON)
+	 ))
+	{
+		sdRet	= MCDRV_ERROR_ARGUMENT;
+	}
+	if(((psPathInfo->asAe[0].abSrcOnOff[MCDRV_SRC_PDM_BLOCK] & (MCDRV_SRC4_PDM_ON|MCDRV_SRC4_PDM_OFF)) == MCDRV_SRC4_PDM_ON)
+	&& (((psPathInfo->asDit0[0].abSrcOnOff[MCDRV_SRC_PDM_BLOCK] & (MCDRV_SRC4_PDM_ON|MCDRV_SRC4_PDM_OFF)) == MCDRV_SRC4_PDM_ON)
+	 || ((psPathInfo->asDit1[0].abSrcOnOff[MCDRV_SRC_PDM_BLOCK] & (MCDRV_SRC4_PDM_ON|MCDRV_SRC4_PDM_OFF)) == MCDRV_SRC4_PDM_ON)
+	 || ((psPathInfo->asDit2[0].abSrcOnOff[MCDRV_SRC_PDM_BLOCK] & (MCDRV_SRC4_PDM_ON|MCDRV_SRC4_PDM_OFF)) == MCDRV_SRC4_PDM_ON)
+	 || ((psPathInfo->asDac[0].abSrcOnOff[MCDRV_SRC_PDM_BLOCK] & (MCDRV_SRC4_PDM_ON|MCDRV_SRC4_PDM_OFF)) == MCDRV_SRC4_PDM_ON)
+	 || ((psPathInfo->asDac[1].abSrcOnOff[MCDRV_SRC_PDM_BLOCK] & (MCDRV_SRC4_PDM_ON|MCDRV_SRC4_PDM_OFF)) == MCDRV_SRC4_PDM_ON)
+	 || ((psPathInfo->asMix[0].abSrcOnOff[MCDRV_SRC_PDM_BLOCK] & (MCDRV_SRC4_PDM_ON|MCDRV_SRC4_PDM_OFF)) == MCDRV_SRC4_PDM_ON)
+	 || ((sCurPathInfo.asDit0[0].abSrcOnOff[MCDRV_SRC_PDM_BLOCK] & (MCDRV_SRC4_PDM_ON|MCDRV_SRC4_PDM_OFF)) == MCDRV_SRC4_PDM_ON)
+	 || ((sCurPathInfo.asDit1[0].abSrcOnOff[MCDRV_SRC_PDM_BLOCK] & (MCDRV_SRC4_PDM_ON|MCDRV_SRC4_PDM_OFF)) == MCDRV_SRC4_PDM_ON)
+	 || ((sCurPathInfo.asDit2[0].abSrcOnOff[MCDRV_SRC_PDM_BLOCK] & (MCDRV_SRC4_PDM_ON|MCDRV_SRC4_PDM_OFF)) == MCDRV_SRC4_PDM_ON)
+	 || ((sCurPathInfo.asDac[0].abSrcOnOff[MCDRV_SRC_PDM_BLOCK] & (MCDRV_SRC4_PDM_ON|MCDRV_SRC4_PDM_OFF)) == MCDRV_SRC4_PDM_ON)
+	 || ((sCurPathInfo.asDac[1].abSrcOnOff[MCDRV_SRC_PDM_BLOCK] & (MCDRV_SRC4_PDM_ON|MCDRV_SRC4_PDM_OFF)) == MCDRV_SRC4_PDM_ON)
+	 || ((sCurPathInfo.asMix[0].abSrcOnOff[MCDRV_SRC_PDM_BLOCK] & (MCDRV_SRC4_PDM_ON|MCDRV_SRC4_PDM_OFF)) == MCDRV_SRC4_PDM_ON)))
+	{
+		sdRet	= MCDRV_ERROR_ARGUMENT;
+	}
+	if(((psPathInfo->asAe[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK] & (MCDRV_SRC4_ADC0_ON|MCDRV_SRC4_ADC0_OFF)) == MCDRV_SRC4_ADC0_ON)
+	&& (((psPathInfo->asDit0[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK] & (MCDRV_SRC4_ADC0_ON|MCDRV_SRC4_ADC0_OFF)) == MCDRV_SRC4_ADC0_ON)
+	 || ((psPathInfo->asDit1[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK] & (MCDRV_SRC4_ADC0_ON|MCDRV_SRC4_ADC0_OFF)) == MCDRV_SRC4_ADC0_ON)
+	 || ((psPathInfo->asDit2[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK] & (MCDRV_SRC4_ADC0_ON|MCDRV_SRC4_ADC0_OFF)) == MCDRV_SRC4_ADC0_ON)
+	 || ((psPathInfo->asDac[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK] & (MCDRV_SRC4_ADC0_ON|MCDRV_SRC4_ADC0_OFF)) == MCDRV_SRC4_ADC0_ON)
+	 || ((psPathInfo->asDac[1].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK] & (MCDRV_SRC4_ADC0_ON|MCDRV_SRC4_ADC0_OFF)) == MCDRV_SRC4_ADC0_ON)
+	 || ((psPathInfo->asMix[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK] & (MCDRV_SRC4_ADC0_ON|MCDRV_SRC4_ADC0_OFF)) == MCDRV_SRC4_ADC0_ON)
+	 || ((sCurPathInfo.asDit0[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK] & (MCDRV_SRC4_ADC0_ON|MCDRV_SRC4_ADC0_OFF)) == MCDRV_SRC4_ADC0_ON)
+	 || ((sCurPathInfo.asDit1[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK] & (MCDRV_SRC4_ADC0_ON|MCDRV_SRC4_ADC0_OFF)) == MCDRV_SRC4_ADC0_ON)
+	 || ((sCurPathInfo.asDit2[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK] & (MCDRV_SRC4_ADC0_ON|MCDRV_SRC4_ADC0_OFF)) == MCDRV_SRC4_ADC0_ON)
+	 || ((sCurPathInfo.asDac[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK] & (MCDRV_SRC4_ADC0_ON|MCDRV_SRC4_ADC0_OFF)) == MCDRV_SRC4_ADC0_ON)
+	 || ((sCurPathInfo.asDac[1].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK] & (MCDRV_SRC4_ADC0_ON|MCDRV_SRC4_ADC0_OFF)) == MCDRV_SRC4_ADC0_ON)
+	 || ((sCurPathInfo.asMix[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK] & (MCDRV_SRC4_ADC0_ON|MCDRV_SRC4_ADC0_OFF)) == MCDRV_SRC4_ADC0_ON)))
+	{
+		sdRet	= MCDRV_ERROR_ARGUMENT;
+	}
+	if(((psPathInfo->asAe[0].abSrcOnOff[MCDRV_SRC_MIX_BLOCK] & (MCDRV_SRC6_MIX_ON|MCDRV_SRC6_MIX_OFF)) == MCDRV_SRC6_MIX_ON)
+	&& (((psPathInfo->asDit0[0].abSrcOnOff[MCDRV_SRC_MIX_BLOCK] & (MCDRV_SRC6_MIX_ON|MCDRV_SRC6_MIX_OFF)) == MCDRV_SRC6_MIX_ON)
+	 || ((psPathInfo->asDit1[0].abSrcOnOff[MCDRV_SRC_MIX_BLOCK] & (MCDRV_SRC6_MIX_ON|MCDRV_SRC6_MIX_OFF)) == MCDRV_SRC6_MIX_ON)
+	 || ((psPathInfo->asDit2[0].abSrcOnOff[MCDRV_SRC_MIX_BLOCK] & (MCDRV_SRC6_MIX_ON|MCDRV_SRC6_MIX_OFF)) == MCDRV_SRC6_MIX_ON)
+	 || ((psPathInfo->asDac[0].abSrcOnOff[MCDRV_SRC_MIX_BLOCK] & (MCDRV_SRC6_MIX_ON|MCDRV_SRC6_MIX_OFF)) == MCDRV_SRC6_MIX_ON)
+	 || ((psPathInfo->asDac[1].abSrcOnOff[MCDRV_SRC_MIX_BLOCK] & (MCDRV_SRC6_MIX_ON|MCDRV_SRC6_MIX_OFF)) == MCDRV_SRC6_MIX_ON)
+	 || ((sCurPathInfo.asDit0[0].abSrcOnOff[MCDRV_SRC_MIX_BLOCK] & (MCDRV_SRC6_MIX_ON|MCDRV_SRC6_MIX_OFF)) == MCDRV_SRC6_MIX_ON)
+	 || ((sCurPathInfo.asDit1[0].abSrcOnOff[MCDRV_SRC_MIX_BLOCK] & (MCDRV_SRC6_MIX_ON|MCDRV_SRC6_MIX_OFF)) == MCDRV_SRC6_MIX_ON)
+	 || ((sCurPathInfo.asDit2[0].abSrcOnOff[MCDRV_SRC_MIX_BLOCK] & (MCDRV_SRC6_MIX_ON|MCDRV_SRC6_MIX_OFF)) == MCDRV_SRC6_MIX_ON)
+	 || ((sCurPathInfo.asDac[0].abSrcOnOff[MCDRV_SRC_MIX_BLOCK] & (MCDRV_SRC6_MIX_ON|MCDRV_SRC6_MIX_OFF)) == MCDRV_SRC6_MIX_ON)
+	 || ((sCurPathInfo.asDac[1].abSrcOnOff[MCDRV_SRC_MIX_BLOCK] & (MCDRV_SRC6_MIX_ON|MCDRV_SRC6_MIX_OFF)) == MCDRV_SRC6_MIX_ON)
+	 ))
+	{
+		sdRet	= MCDRV_ERROR_ARGUMENT;
+	}
+
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncOut("ValidatePathParam", &sdRet);
+#endif
+
+	return sdRet;
+}
+
+/****************************************************************************
+ *	ValidateDioParam
+ *
+ *	Description:
+ *			validate digital IO parameters.
+ *	Arguments:
+ *			psDioInfo	digital IO information
+ *			dUpdateInfo	update information
+ *	Return:
+ *			MCDRV_SUCCESS
+ *			MCDRV_ERROR_ARGUMENT
+ *
+ ****************************************************************************/
+static SINT32	ValidateDioParam
+(
+	const MCDRV_DIO_INFO*	psDioInfo,
+	UINT32					dUpdateInfo
+)
+{
+	SINT32				sdRet	= MCDRV_SUCCESS;
+	UINT8				bPort;
+	MCDRV_SRC_TYPE		aeDITSource[IOPORT_NUM];
+	MCDRV_SRC_TYPE		eAESource;
+	MCDRV_SRC_TYPE		eDAC0Source;
+	MCDRV_SRC_TYPE		eDAC1Source;
+	UINT8				bDIRUsed[IOPORT_NUM];
+	MCDRV_DIO_INFO		sDioInfo;
+	MCDRV_DIO_PORT_NO	aePort[IOPORT_NUM]	= {eMCDRV_DIO_0, eMCDRV_DIO_1, eMCDRV_DIO_2};
+
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncIn("ValidateDioParam");
+#endif
+
+	eAESource	= McResCtrl_GetAESource();
+	eDAC0Source	= McResCtrl_GetDACSource(eMCDRV_DAC_MASTER);
+	eDAC1Source	= McResCtrl_GetDACSource(eMCDRV_DAC_VOICE);
+
+
+	McResCtrl_GetDioInfo(&sDioInfo);
+
+	for(bPort = 0; bPort < IOPORT_NUM; bPort++)
+	{
+		aeDITSource[bPort]	= McResCtrl_GetDITSource(aePort[bPort]);
+		bDIRUsed[bPort]		= 0;
+	}
+
+	if(((eAESource == eMCDRV_SRC_DIR0) || (eDAC0Source == eMCDRV_SRC_DIR0) || (eDAC1Source == eMCDRV_SRC_DIR0))
+	|| ((aeDITSource[0] == eMCDRV_SRC_DIR0) || (aeDITSource[1] == eMCDRV_SRC_DIR0) || (aeDITSource[2] == eMCDRV_SRC_DIR0)))
+	{
+		bDIRUsed[0]	= 1;
+	}
+	if(((eAESource == eMCDRV_SRC_DIR1) || (eDAC0Source == eMCDRV_SRC_DIR1) || (eDAC1Source == eMCDRV_SRC_DIR1))
+	|| ((aeDITSource[0] == eMCDRV_SRC_DIR1) || (aeDITSource[1] == eMCDRV_SRC_DIR1) || (aeDITSource[2] == eMCDRV_SRC_DIR1)))
+	{
+		bDIRUsed[1]	= 1;
+	}
+	if(((eAESource == eMCDRV_SRC_DIR2) || (eDAC0Source == eMCDRV_SRC_DIR2) || (eDAC1Source == eMCDRV_SRC_DIR2))
+	|| ((aeDITSource[0] == eMCDRV_SRC_DIR2) || (aeDITSource[1] == eMCDRV_SRC_DIR2) || (aeDITSource[2] == eMCDRV_SRC_DIR2)))
+	{
+		bDIRUsed[2]	= 1;
+	}
+
+	if(((bDIRUsed[0] == 1) && (((dUpdateInfo & MCDRV_DIO0_COM_UPDATE_FLAG) != 0UL) || ((dUpdateInfo & MCDRV_DIO0_DIR_UPDATE_FLAG) != 0UL)))
+	|| ((aeDITSource[0] != eMCDRV_SRC_NONE) && (((dUpdateInfo & MCDRV_DIO0_COM_UPDATE_FLAG) != 0UL) || ((dUpdateInfo & MCDRV_DIO0_DIT_UPDATE_FLAG) != 0UL))))
+	{
+		sdRet	= MCDRV_ERROR_ARGUMENT;
+	}
+	if(((bDIRUsed[1] == 1) && (((dUpdateInfo & MCDRV_DIO1_COM_UPDATE_FLAG) != 0UL) || ((dUpdateInfo & MCDRV_DIO1_DIR_UPDATE_FLAG) != 0UL)))
+	|| ((aeDITSource[1] != eMCDRV_SRC_NONE) && (((dUpdateInfo & MCDRV_DIO1_COM_UPDATE_FLAG) != 0UL) || ((dUpdateInfo & MCDRV_DIO1_DIT_UPDATE_FLAG) != 0UL))))
+	{
+		sdRet	= MCDRV_ERROR_ARGUMENT;
+	}
+	if(((bDIRUsed[2] == 1) && (((dUpdateInfo & MCDRV_DIO2_COM_UPDATE_FLAG) != 0UL) || ((dUpdateInfo & MCDRV_DIO2_DIR_UPDATE_FLAG) != 0UL)))
+	|| ((aeDITSource[2] != eMCDRV_SRC_NONE) && (((dUpdateInfo & MCDRV_DIO2_COM_UPDATE_FLAG) != 0UL) || ((dUpdateInfo & MCDRV_DIO2_DIT_UPDATE_FLAG) != 0UL))))
+	{
+		sdRet	= MCDRV_ERROR_ARGUMENT;
+	}
+
+	if(sdRet == MCDRV_SUCCESS)
+	{
+		if((dUpdateInfo & MCDRV_DIO0_COM_UPDATE_FLAG) != 0UL)
+		{
+			sdRet	= CheckDIOCommon(psDioInfo, 0);
+			if(sdRet == MCDRV_SUCCESS)
+			{
+				sDioInfo.asPortInfo[0].sDioCommon.bInterface	= psDioInfo->asPortInfo[0].sDioCommon.bInterface;
+			}
+		}
+	}
+	if(sdRet == MCDRV_SUCCESS)
+	{
+		if((dUpdateInfo & MCDRV_DIO1_COM_UPDATE_FLAG) != 0UL)
+		{
+			sdRet	= CheckDIOCommon(psDioInfo, 1);
+			if(sdRet == MCDRV_SUCCESS)
+			{
+				sDioInfo.asPortInfo[1].sDioCommon.bInterface	= psDioInfo->asPortInfo[1].sDioCommon.bInterface;
+			}
+		}
+	}
+	if(sdRet == MCDRV_SUCCESS)
+	{
+		if((dUpdateInfo & MCDRV_DIO2_COM_UPDATE_FLAG) != 0UL)
+		{
+			sdRet	= CheckDIOCommon(psDioInfo, 2);
+			if(sdRet == MCDRV_SUCCESS)
+			{
+				sDioInfo.asPortInfo[2].sDioCommon.bInterface	= psDioInfo->asPortInfo[2].sDioCommon.bInterface;
+			}
+		}
+	}
+
+	if(sdRet == MCDRV_SUCCESS)
+	{
+		if((dUpdateInfo & MCDRV_DIO0_DIR_UPDATE_FLAG) != 0UL)
+		{
+			sdRet	= CheckDIODIR(psDioInfo, 0, sDioInfo.asPortInfo[0].sDioCommon.bInterface);
+		}
+	}
+	if(sdRet == MCDRV_SUCCESS)
+	{
+		if((dUpdateInfo & MCDRV_DIO1_DIR_UPDATE_FLAG) != 0UL)
+		{
+			sdRet	= CheckDIODIR(psDioInfo, 1, sDioInfo.asPortInfo[1].sDioCommon.bInterface);
+		}
+	}
+	if(sdRet == MCDRV_SUCCESS)
+	{
+		if((dUpdateInfo & MCDRV_DIO2_DIR_UPDATE_FLAG) != 0UL)
+		{
+			sdRet	= CheckDIODIR(psDioInfo, 2, sDioInfo.asPortInfo[2].sDioCommon.bInterface);
+		}
+	}
+
+	if(sdRet == MCDRV_SUCCESS)
+	{
+		if((dUpdateInfo & MCDRV_DIO0_DIT_UPDATE_FLAG) != 0UL)
+		{
+			sdRet	= CheckDIODIT(psDioInfo, 0, sDioInfo.asPortInfo[0].sDioCommon.bInterface);
+		}
+	}
+	if(sdRet == MCDRV_SUCCESS)
+	{
+		if((dUpdateInfo & MCDRV_DIO1_DIT_UPDATE_FLAG) != 0UL)
+		{
+			sdRet	= CheckDIODIT(psDioInfo, 1, sDioInfo.asPortInfo[1].sDioCommon.bInterface);
+		}
+	}
+	if(sdRet == MCDRV_SUCCESS)
+	{
+		if((dUpdateInfo & MCDRV_DIO2_DIT_UPDATE_FLAG) != 0UL)
+		{
+			sdRet	= CheckDIODIT(psDioInfo, 2, sDioInfo.asPortInfo[2].sDioCommon.bInterface);
+		}
+	}
+
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncOut("ValidateDioParam", &sdRet);
+#endif
+
+	return sdRet;
+}
+
+
+/****************************************************************************
+ *	CheckDIOCommon
+ *
+ *	Description:
+ *			validate Digital IO Common parameters.
+ *	Arguments:
+ *			psDioInfo	digital IO information
+ *			bPort		port number
+ *	Return:
+ *			MCDRV_SUCCESS
+ *			MCDRV_ERROR_ARGUMENT
+ *
+ ****************************************************************************/
+static SINT32	CheckDIOCommon
+(
+	const MCDRV_DIO_INFO*	psDioInfo,
+	UINT8	bPort
+)
+{
+	SINT32	sdRet	= MCDRV_SUCCESS;
+
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncIn("CheckDIOCommon");
+#endif
+
+
+	if(psDioInfo->asPortInfo[bPort].sDioCommon.bInterface == MCDRV_DIO_PCM)
+	{
+		if((psDioInfo->asPortInfo[bPort].sDioCommon.bFs == MCDRV_FS_48000)
+		|| (psDioInfo->asPortInfo[bPort].sDioCommon.bFs == MCDRV_FS_44100)
+		|| (psDioInfo->asPortInfo[bPort].sDioCommon.bFs == MCDRV_FS_32000)
+		|| (psDioInfo->asPortInfo[bPort].sDioCommon.bFs == MCDRV_FS_24000)
+		|| (psDioInfo->asPortInfo[bPort].sDioCommon.bFs == MCDRV_FS_22050)
+		|| (psDioInfo->asPortInfo[bPort].sDioCommon.bFs == MCDRV_FS_12000)
+		|| (psDioInfo->asPortInfo[bPort].sDioCommon.bFs == MCDRV_FS_11025))
+		{
+			sdRet	= MCDRV_ERROR_ARGUMENT;
+		}
+
+		if((psDioInfo->asPortInfo[bPort].sDioCommon.bMasterSlave == MCDRV_DIO_MASTER)
+		&& (psDioInfo->asPortInfo[bPort].sDioCommon.bFs == MCDRV_FS_16000))
+		{
+			if(psDioInfo->asPortInfo[bPort].sDioCommon.bBckFs == MCDRV_BCKFS_512)
+			{
+				sdRet	= MCDRV_ERROR_ARGUMENT;
+			}
+		}
+	}
+	else
+	{
+		if((psDioInfo->asPortInfo[bPort].sDioCommon.bBckFs == MCDRV_BCKFS_512)
+		|| (psDioInfo->asPortInfo[bPort].sDioCommon.bBckFs == MCDRV_BCKFS_256)
+		|| (psDioInfo->asPortInfo[bPort].sDioCommon.bBckFs == MCDRV_BCKFS_128)
+		|| (psDioInfo->asPortInfo[bPort].sDioCommon.bBckFs == MCDRV_BCKFS_16))
+		{
+			sdRet	= MCDRV_ERROR_ARGUMENT;
+		}
+	}
+
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncOut("CheckDIOCommon", &sdRet);
+#endif
+	return sdRet;
+}
+
+/****************************************************************************
+ *	CheckDIODIR
+ *
+ *	Description:
+ *			validate Digital IO DIR parameters.
+ *	Arguments:
+ *			psDioInfo	digital IO information
+ *			bPort		port number
+ *			bInterface	Interface(DA/PCM)
+ *	Return:
+ *			MCDRV_SUCCESS
+ *			MCDRV_ERROR_ARGUMENT
+ *
+ ****************************************************************************/
+static SINT32	CheckDIODIR
+(
+	const MCDRV_DIO_INFO*	psDioInfo,
+	UINT8	bPort,
+	UINT8	bInterface
+)
+{
+	SINT32	sdRet	= MCDRV_SUCCESS;
+
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncIn("CheckDIODIR");
+#endif
+
+
+	if(bInterface == MCDRV_DIO_PCM)
+	{
+		if((psDioInfo->asPortInfo[bPort].sDir.sPcmFormat.bLaw == MCDRV_PCM_ALAW)
+		|| (psDioInfo->asPortInfo[bPort].sDir.sPcmFormat.bLaw == MCDRV_PCM_MULAW))
+		{
+			if((psDioInfo->asPortInfo[bPort].sDir.sPcmFormat.bBitSel == MCDRV_PCM_BITSEL_13)
+			|| (psDioInfo->asPortInfo[bPort].sDir.sPcmFormat.bBitSel == MCDRV_PCM_BITSEL_14)
+			|| (psDioInfo->asPortInfo[bPort].sDir.sPcmFormat.bBitSel == MCDRV_PCM_BITSEL_16))
+			{
+				sdRet	= MCDRV_ERROR_ARGUMENT;
+			}
+		}
+	}
+
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncOut("CheckDIODIR", &sdRet);
+#endif
+	return sdRet;
+}
+
+/****************************************************************************
+ *	CheckDIDIT
+ *
+ *	Description:
+ *			validate Digital IO DIT parameters.
+ *	Arguments:
+ *			psDioInfo	digital IO information
+ *			bPort		port number
+ *			bInterface	Interface(DA/PCM)
+ *	Return:
+ *			MCDRV_SUCCESS
+ *			MCDRV_ERROR_ARGUMENT
+ *
+ ****************************************************************************/
+static SINT32	CheckDIODIT
+(
+	const MCDRV_DIO_INFO*	psDioInfo,
+	UINT8	bPort,
+	UINT8	bInterface
+)
+{
+	SINT32	sdRet	= MCDRV_SUCCESS;
+
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncIn("CheckDIODIT");
+#endif
+
+
+	if(bInterface == MCDRV_DIO_PCM)
+	{
+		if((psDioInfo->asPortInfo[bPort].sDit.sPcmFormat.bLaw == MCDRV_PCM_ALAW)
+		|| (psDioInfo->asPortInfo[bPort].sDit.sPcmFormat.bLaw == MCDRV_PCM_MULAW))
+		{
+			if((psDioInfo->asPortInfo[bPort].sDit.sPcmFormat.bBitSel == MCDRV_PCM_BITSEL_13)
+			|| (psDioInfo->asPortInfo[bPort].sDit.sPcmFormat.bBitSel == MCDRV_PCM_BITSEL_14)
+			|| (psDioInfo->asPortInfo[bPort].sDit.sPcmFormat.bBitSel == MCDRV_PCM_BITSEL_16))
+			{
+				sdRet	= MCDRV_ERROR_ARGUMENT;
+			}
+		}
+	}
+
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncOut("CheckDIODIT", &sdRet);
+#endif
+	return sdRet;
+}
+
+/****************************************************************************
+ *	SetVol
+ *
+ *	Description:
+ *			set volume.
+ *	Arguments:
+ *			dUpdate			target volume items
+ *			eMode			update mode
+ *			pdSVolDoneParam	wait soft volume complete flag
+ *	Return:
+ *			MCDRV_SUCCESS
+ *			MCDRV_ERROR_RESOURCEOVER
+ *
+ ****************************************************************************/
+static SINT32	SetVol
+(
+	UINT32					dUpdate,
+	MCDRV_VOLUPDATE_MODE	eMode,
+	UINT32*					pdSVolDoneParam
+)
+{
+	SINT32	sdRet	= MCDRV_SUCCESS;
+
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncIn("SetVol");
+#endif
+
+	sdRet	= McPacket_AddVol(dUpdate, eMode, pdSVolDoneParam);
+	if(sdRet == MCDRV_SUCCESS)
+	{
+		sdRet	= McDevIf_ExecutePacket();
+	}
+
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncOut("SetVol", &sdRet);
+#endif
+
+	return sdRet;
+}
+
+/****************************************************************************
+ *	PreUpdatePath
+ *
+ *	Description:
+ *			Preprocess update path.
+ *	Arguments:
+ *			pwDACMuteParam	wait DAC mute complete flag
+ *			pwDITMuteParam	wait DIT mute complete flag
+ *	Return:
+ *			MCDRV_SUCCESS
+ *			MCDRV_ERROR_RESOURCEOVER
+ *
+ ****************************************************************************/
+static	SINT32	PreUpdatePath
+(
+	UINT16*	pwDACMuteParam,
+	UINT16*	pwDITMuteParam
+)
+{
+	SINT32	sdRet	= MCDRV_SUCCESS;
+	UINT8	bReg	= 0;
+	UINT8	bReadReg= 0;
+	UINT8	bLAT	= 0;
+
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncIn("PreUpdatePath");
+#endif
+
+	*pwDACMuteParam	= 0;
+	*pwDITMuteParam	= 0;
+
+	switch(McResCtrl_GetDACSource(eMCDRV_DAC_MASTER))
+	{
+	case	eMCDRV_SRC_PDM:
+		bReg	= MCB_DAC_SOURCE_AD;
+		break;
+	case	eMCDRV_SRC_ADC0:
+		bReg	= MCB_DAC_SOURCE_AD;
+		break;
+	case	eMCDRV_SRC_DIR0:
+		bReg	= MCB_DAC_SOURCE_DIR0;
+		break;
+	case	eMCDRV_SRC_DIR1:
+		bReg	= MCB_DAC_SOURCE_DIR1;
+		break;
+	case	eMCDRV_SRC_DIR2:
+		bReg	= MCB_DAC_SOURCE_DIR2;
+		break;
+	case	eMCDRV_SRC_MIX:
+		bReg	= MCB_DAC_SOURCE_MIX;
+		break;
+	default:
+		bReg	= 0;
+	}
+	bReadReg	= McResCtrl_GetRegVal(MCDRV_PACKET_REGTYPE_B_MIXER, MCI_SOURCE);
+	if(((bReadReg & 0xF0) != 0) && (bReg != (bReadReg & 0xF0)))
+	{/*	DAC source changed	*/
+		if((McResCtrl_GetRegVal(MCDRV_PACKET_REGTYPE_B_MIXER, MCI_MASTER_OUTL)&MCB_MASTER_OUTL) != 0)
+		{
+			if(McResCtrl_GetRegVal(MCDRV_PACKET_REGTYPE_B_MIXER, MCI_MASTER_OUTR) != 0)
+			{
+				bLAT	= MCB_MASTER_OLAT;
+			}
+			else
+			{
+				bLAT	= 0;
+			}
+			McDevIf_AddPacket(MCDRV_PACKET_TYPE_WRITE | MCDRV_PACKET_REGTYPE_B_MIXER | (UINT32)MCI_MASTER_OUTL, bLAT);
+		}
+		McDevIf_AddPacket(MCDRV_PACKET_TYPE_WRITE | MCDRV_PACKET_REGTYPE_B_MIXER | (UINT32)MCI_MASTER_OUTR, 0);
+		*pwDACMuteParam	|= (UINT16)(MCB_MASTER_OFLAGL<<8);
+		*pwDACMuteParam	|= MCB_MASTER_OFLAGR;
+	}
+
+	switch(McResCtrl_GetDACSource(eMCDRV_DAC_VOICE))
+	{
+	case	eMCDRV_SRC_PDM:
+		bReg	= MCB_VOICE_SOURCE_AD;
+		break;
+	case	eMCDRV_SRC_ADC0:
+		bReg	= MCB_VOICE_SOURCE_AD;
+		break;
+	case	eMCDRV_SRC_DIR0:
+		bReg	= MCB_VOICE_SOURCE_DIR0;
+		break;
+	case	eMCDRV_SRC_DIR1:
+		bReg	= MCB_VOICE_SOURCE_DIR1;
+		break;
+	case	eMCDRV_SRC_DIR2:
+		bReg	= MCB_VOICE_SOURCE_DIR2;
+		break;
+	case	eMCDRV_SRC_MIX:
+		bReg	= MCB_VOICE_SOURCE_MIX;
+		break;
+	default:
+		bReg	= 0;
+	}
+	if(((bReadReg & 0x0F) != 0) && (bReg != (bReadReg & 0x0F)))
+	{/*	VOICE source changed	*/
+		if((McResCtrl_GetRegVal(MCDRV_PACKET_REGTYPE_B_MIXER, MCI_VOICE_ATTL)&MCB_VOICE_ATTL) != 0)
+		{
+			if(McResCtrl_GetRegVal(MCDRV_PACKET_REGTYPE_B_MIXER, MCI_VOICE_ATTR) != 0)
+			{
+				bLAT	= MCB_VOICE_LAT;
+			}
+			else
+			{
+				bLAT	= 0;
+			}
+			McDevIf_AddPacket(MCDRV_PACKET_TYPE_WRITE | MCDRV_PACKET_REGTYPE_B_MIXER | (UINT32)MCI_VOICE_ATTL, bLAT);
+		}
+		McDevIf_AddPacket(MCDRV_PACKET_TYPE_WRITE | MCDRV_PACKET_REGTYPE_B_MIXER | (UINT32)MCI_VOICE_ATTR, 0);
+		*pwDACMuteParam	|= (UINT16)(MCB_VOICE_FLAGL<<8);
+		*pwDACMuteParam	|= MCB_VOICE_FLAGR;
+	}
+
+	switch(McResCtrl_GetDITSource(eMCDRV_DIO_0))
+	{
+	case	eMCDRV_SRC_PDM:
+		bReg	= MCB_DIT0_SOURCE_AD;
+		break;
+	case	eMCDRV_SRC_ADC0:
+		bReg	= MCB_DIT0_SOURCE_AD;
+		break;
+	case	eMCDRV_SRC_DIR0:
+		bReg	= MCB_DIT0_SOURCE_DIR0;
+		break;
+	case	eMCDRV_SRC_DIR1:
+		bReg	= MCB_DIT0_SOURCE_DIR1;
+		break;
+	case	eMCDRV_SRC_DIR2:
+		bReg	= MCB_DIT0_SOURCE_DIR2;
+		break;
+	case	eMCDRV_SRC_MIX:
+		bReg	= MCB_DIT0_SOURCE_MIX;
+		break;
+	default:
+		bReg	= 0;
+	}
+	bReadReg	= McResCtrl_GetRegVal(MCDRV_PACKET_REGTYPE_B_MIXER, MCI_SRC_SOURCE);
+	if(((bReadReg & 0xF0) != 0) && (bReg != (bReadReg & 0xF0)))
+	{/*	DIT source changed	*/
+		if((McResCtrl_GetRegVal(MCDRV_PACKET_REGTYPE_B_MIXER, MCI_DIT0_INVOLL)&MCB_DIT0_INVOLL) != 0)
+		{
+			if(McResCtrl_GetRegVal(MCDRV_PACKET_REGTYPE_B_MIXER, MCI_DIT0_INVOLR) != 0)
+			{
+				bLAT	= MCB_DIT0_INLAT;
+			}
+			else
+			{
+				bLAT	= 0;
+			}
+			McDevIf_AddPacket(MCDRV_PACKET_TYPE_WRITE | MCDRV_PACKET_REGTYPE_B_MIXER | (UINT32)MCI_DIT0_INVOLL, bLAT);
+		}
+		McDevIf_AddPacket(MCDRV_PACKET_TYPE_WRITE | MCDRV_PACKET_REGTYPE_B_MIXER | (UINT32)MCI_DIT0_INVOLR, 0);
+		*pwDITMuteParam	|= (UINT16)(MCB_DIT0_INVFLAGL<<8);
+		*pwDITMuteParam	|= MCB_DIT0_INVFLAGR;
+	}
+
+	switch(McResCtrl_GetDITSource(eMCDRV_DIO_1))
+	{
+	case	eMCDRV_SRC_PDM:
+		bReg	= MCB_DIT1_SOURCE_AD;
+		break;
+	case	eMCDRV_SRC_ADC0:
+		bReg	= MCB_DIT1_SOURCE_AD;
+		break;
+	case	eMCDRV_SRC_DIR0:
+		bReg	= MCB_DIT1_SOURCE_DIR0;
+		break;
+	case	eMCDRV_SRC_DIR1:
+		bReg	= MCB_DIT1_SOURCE_DIR1;
+		break;
+	case	eMCDRV_SRC_DIR2:
+		bReg	= MCB_DIT1_SOURCE_DIR2;
+		break;
+	case	eMCDRV_SRC_MIX:
+		bReg	= MCB_DIT1_SOURCE_MIX;
+		break;
+	default:
+		bReg	= 0;
+	}
+	if(((bReadReg & 0x0F) != 0) && (bReg != (bReadReg & 0x0F)))
+	{/*	DIT source changed	*/
+		if((McResCtrl_GetRegVal(MCDRV_PACKET_REGTYPE_B_MIXER, MCI_DIT1_INVOLL)&MCB_DIT1_INVOLL) != 0)
+		{
+			if(McResCtrl_GetRegVal(MCDRV_PACKET_REGTYPE_B_MIXER, MCI_DIT1_INVOLR) != 0)
+			{
+				bLAT	= MCB_DIT1_INLAT;
+			}
+			else
+			{
+				bLAT	= 0;
+			}
+			McDevIf_AddPacket(MCDRV_PACKET_TYPE_WRITE | MCDRV_PACKET_REGTYPE_B_MIXER | (UINT32)MCI_DIT1_INVOLL, bLAT);
+		}
+		McDevIf_AddPacket(MCDRV_PACKET_TYPE_WRITE | MCDRV_PACKET_REGTYPE_B_MIXER | (UINT32)MCI_DIT1_INVOLR, 0);
+		*pwDITMuteParam	|= (UINT16)(MCB_DIT1_INVFLAGL<<8);
+		*pwDITMuteParam	|= MCB_DIT1_INVFLAGR;
+	}
+
+	switch(McResCtrl_GetDITSource(eMCDRV_DIO_2))
+	{
+	case	eMCDRV_SRC_PDM:
+		bReg	= MCB_DIT2_SOURCE_AD;
+		break;
+	case	eMCDRV_SRC_ADC0:
+		bReg	= MCB_DIT2_SOURCE_AD;
+		break;
+	case	eMCDRV_SRC_DIR0:
+		bReg	= MCB_DIT2_SOURCE_DIR0;
+		break;
+	case	eMCDRV_SRC_DIR1:
+		bReg	= MCB_DIT2_SOURCE_DIR1;
+		break;
+	case	eMCDRV_SRC_DIR2:
+		bReg	= MCB_DIT2_SOURCE_DIR2;
+		break;
+	case	eMCDRV_SRC_MIX:
+		bReg	= MCB_DIT2_SOURCE_MIX;
+		break;
+	default:
+		bReg	= 0;
+	}
+	bReadReg	= McResCtrl_GetRegVal(MCDRV_PACKET_REGTYPE_B_MIXER, MCI_SRC_SOURCE_1);
+	if(((bReadReg & 0x0F) != 0) && (bReg != (bReadReg & 0x0F)))
+	{/*	DIT source changed	*/
+		if((McResCtrl_GetRegVal(MCDRV_PACKET_REGTYPE_B_MIXER, MCI_DIT2_INVOLL)&MCB_DIT2_INVOLL) != 0)
+		{
+			if(McResCtrl_GetRegVal(MCDRV_PACKET_REGTYPE_B_MIXER, MCI_DIT2_INVOLR) != 0)
+			{
+				bLAT	= MCB_DIT2_INLAT;
+			}
+			else
+			{
+				bLAT	= 0;
+			}
+			McDevIf_AddPacket(MCDRV_PACKET_TYPE_WRITE | MCDRV_PACKET_REGTYPE_B_MIXER | (UINT32)MCI_DIT2_INVOLL, bLAT);
+		}
+		McDevIf_AddPacket(MCDRV_PACKET_TYPE_WRITE | MCDRV_PACKET_REGTYPE_B_MIXER | (UINT32)MCI_DIT2_INVOLR, 0);
+		*pwDITMuteParam	|= (UINT16)(MCB_DIT2_INVFLAGL<<8);
+		*pwDITMuteParam	|= MCB_DIT2_INVFLAGR;
+	}
+
+	sdRet	= McDevIf_ExecutePacket();
+
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncOut("PreUpdatePath", &sdRet);
+#endif
+	/*	do not Execute & Clear	*/
+	return sdRet;
+}
+
+/****************************************************************************
+ *	McDrv_Ctrl
+ *
+ *	Description:
+ *			MC Driver I/F function.
+ *	Arguments:
+ *			dCmd		command #
+ *			pvPrm		parameter
+ *			dPrm		update info
+ *	Return:
+ *			MCDRV_SUCCESS
+ *			MCDRV_ERROR_ARGUMENT
+ *			MCDRV_ERROR_RESOURCEOVER
+ *			MCDRV_ERROR_STATE
+ *
+ ****************************************************************************/
+SINT32	McDrv_Ctrl
+(
+	UINT32	dCmd,
+	void*	pvPrm,
+	UINT32	dPrm
+)
+{
+	SINT32	sdRet	= MCDRV_ERROR;
+
+#if MCDRV_DEBUG_LEVEL
+	McDebugLog_CmdIn(dCmd, pvPrm, dPrm);
+#endif
+
+	if((UINT32)MCDRV_INIT == dCmd)
+	{
+		sdRet	= init((MCDRV_INIT_INFO*)pvPrm);
+	}
+	else if((UINT32)MCDRV_TERM == dCmd)
+	{
+		if(McResCtrl_GetHwId() == MCDRV_HWID_AA)
+		{
+			sdRet	= McDrv_Ctrl_AA(dCmd, pvPrm, dPrm);
+		}
+		else
+		{
+			sdRet	= term();
+		}
+	}
+	else
+	{
+		if(McResCtrl_GetHwId() == MCDRV_HWID_AA)
+		{
+			sdRet	= McDrv_Ctrl_AA(dCmd, pvPrm, dPrm);
+		}
+		else
+		{
+			McSrv_Lock();
+
+			switch (dCmd)
+			{
+			case	MCDRV_UPDATE_CLOCK:
+				sdRet	= update_clock((MCDRV_CLOCK_INFO*)pvPrm);
+				break;
+			case	MCDRV_SWITCH_CLOCK:
+				sdRet	= switch_clock((MCDRV_CLKSW_INFO*)pvPrm);
+				break;
+			case	MCDRV_GET_PATH:
+				sdRet	= get_path((MCDRV_PATH_INFO*)pvPrm);
+				break;
+			case	MCDRV_SET_PATH:
+				sdRet	= set_path((MCDRV_PATH_INFO*)pvPrm);
+				break;
+			case	MCDRV_GET_VOLUME:
+				sdRet	= get_volume((MCDRV_VOL_INFO*)pvPrm);
+				break;
+			case	MCDRV_SET_VOLUME:
+				sdRet	= set_volume((MCDRV_VOL_INFO*)pvPrm);
+				break;
+			case	MCDRV_GET_DIGITALIO:
+				sdRet	= get_digitalio((MCDRV_DIO_INFO*)pvPrm);
+				break;
+			case	MCDRV_SET_DIGITALIO:
+				sdRet	= set_digitalio((MCDRV_DIO_INFO*)pvPrm, dPrm);
+				break;
+			case	MCDRV_GET_DAC:
+				sdRet	= get_dac((MCDRV_DAC_INFO*)pvPrm);
+				break;
+			case	MCDRV_SET_DAC:
+				sdRet	= set_dac((MCDRV_DAC_INFO*)pvPrm, dPrm);
+				break;
+			case	MCDRV_GET_ADC:
+				sdRet	= get_adc((MCDRV_ADC_INFO*)pvPrm);
+				break;
+			case	MCDRV_SET_ADC:
+				sdRet	= set_adc((MCDRV_ADC_INFO*)pvPrm, dPrm);
+				break;
+			case	MCDRV_GET_SP:
+				sdRet	= get_sp((MCDRV_SP_INFO*)pvPrm);
+				break;
+			case	MCDRV_SET_SP:
+				sdRet	= set_sp((MCDRV_SP_INFO*)pvPrm);
+				break;
+			case	MCDRV_GET_DNG:
+				sdRet	= get_dng((MCDRV_DNG_INFO*)pvPrm);
+				break;
+			case	MCDRV_SET_DNG:
+				sdRet	= set_dng((MCDRV_DNG_INFO*)pvPrm, dPrm);
+				break;
+			case	MCDRV_SET_AUDIOENGINE:
+				sdRet	= set_ae((MCDRV_AE_INFO*)pvPrm, dPrm);
+				break;
+			case	MCDRV_GET_PDM:
+				sdRet	= get_pdm((MCDRV_PDM_INFO*)pvPrm);
+				break;
+			case	MCDRV_SET_PDM:
+				sdRet	= set_pdm((MCDRV_PDM_INFO*)pvPrm, dPrm);
+				break;
+			case	MCDRV_CONFIG_GP:
+				sdRet	= config_gp((MCDRV_GP_MODE*)pvPrm);
+				break;
+			case	MCDRV_MASK_GP:
+				sdRet	= mask_gp((UINT8*)pvPrm, dPrm);
+				break;
+			case	MCDRV_GETSET_GP:
+				sdRet	= getset_gp((UINT8*)pvPrm, dPrm);
+				break;
+			case	MCDRV_GET_SYSEQ:
+				sdRet	= get_syseq((MCDRV_SYSEQ_INFO*)pvPrm);
+				break;
+			case	MCDRV_SET_SYSEQ:
+				sdRet	= set_syseq((MCDRV_SYSEQ_INFO*)pvPrm, dPrm);
+				break;
+			case	MCDRV_READ_REG :
+				sdRet	= read_reg((MCDRV_REG_INFO*)pvPrm);
+				break;
+			case	MCDRV_WRITE_REG :
+				sdRet	= write_reg((MCDRV_REG_INFO*)pvPrm);
+				break;
+
+			case	MCDRV_IRQ:
+				break;
+
+			default:
+				break;
+			}
+
+			McSrv_Unlock();
+		}
+	}
+
+#if MCDRV_DEBUG_LEVEL
+	McDebugLog_CmdOut(dCmd, &sdRet, pvPrm);
+#endif
+
+	return sdRet;
+}
diff --git a/sound/soc/codecs/mc1n2/mcdriver.h b/sound/soc/codecs/mc1n2/mcdriver.h
new file mode 100644
index 0000000..a8051d3
--- /dev/null
+++ b/sound/soc/codecs/mc1n2/mcdriver.h
@@ -0,0 +1,906 @@
+/****************************************************************************
+ *
+ *		Copyright(c) 2010 Yamaha Corporation. All rights reserved.
+ *
+ *		Module		: mcdriver.h
+ *
+ *		Description	: MC Driver header
+ *
+ *		Version		: 1.0.0 	2010.07.05
+ *
+ ****************************************************************************/
+
+#ifndef _MCDRIVER_H_
+#define _MCDRIVER_H_
+
+#include "mctypedef.h"
+
+
+
+signed long	McDrv_Ctrl( UINT32 dCmd, void* pvPrm, UINT32 dPrm );
+
+
+
+
+/*	return value	*/
+#define	MCDRV_SUCCESS				((SINT32)0)
+#define	MCDRV_ERROR_ARGUMENT		(-1)
+#define	MCDRV_ERROR_TIMEOUT			(-2)
+#define	MCDRV_ERROR_INIT			(-3)
+#define	MCDRV_ERROR_RESOURCEOVER	(-4)
+#define	MCDRV_ERROR_STATE			(-5)
+
+#define	MCDRV_ERROR					(-10)
+
+
+/*	dCmd	*/
+#define	MCDRV_INIT					(0)
+#define	MCDRV_TERM					(1)
+#define	MCDRV_READ_REG				(2)
+#define	MCDRV_WRITE_REG				(3)
+#define	MCDRV_GET_PATH				(4)
+#define	MCDRV_SET_PATH				(5)
+#define	MCDRV_GET_VOLUME			(6)
+#define	MCDRV_SET_VOLUME			(7)
+#define	MCDRV_GET_DIGITALIO			(8)
+#define	MCDRV_SET_DIGITALIO			(9)
+#define	MCDRV_GET_DAC				(10)
+#define	MCDRV_SET_DAC				(11)
+#define	MCDRV_GET_ADC				(12)
+#define	MCDRV_SET_ADC				(13)
+#define	MCDRV_GET_SP				(14)
+#define	MCDRV_SET_SP				(15)
+#define	MCDRV_GET_DNG				(16)
+#define	MCDRV_SET_DNG				(17)
+#define	MCDRV_SET_AUDIOENGINE		(18)
+#define	MCDRV_SET_AUDIOENGINE_EX	(19)
+#define	MCDRV_SET_CDSP				(20)
+#define	MCDRV_GET_CDSP_PARAM		(21)
+#define	MCDRV_SET_CDSP_PARAM		(22)
+#define	MCDRV_REGISTER_CDSP_CB		(23)
+#define	MCDRV_GET_PDM				(24)
+#define	MCDRV_SET_PDM				(25)
+#define	MCDRV_SET_DTMF				(26)
+#define	MCDRV_CONFIG_GP				(27)
+#define	MCDRV_MASK_GP				(28)
+#define	MCDRV_GETSET_GP				(29)
+#define	MCDRV_GET_PEAK				(30)
+#define	MCDRV_IRQ					(31)
+#define	MCDRV_UPDATE_CLOCK			(32)
+#define	MCDRV_SWITCH_CLOCK			(33)
+#define	MCDRV_GET_SYSEQ				(34)
+#define	MCDRV_SET_SYSEQ				(35)
+
+/*	pvPrm	*/
+/*	init	*/
+/*	MCDRV_INIT_INFO bCkSel setting	*/
+#define	MCDRV_CKSEL_CMOS			(0x00)
+#define	MCDRV_CKSEL_TCXO			(0xC0)
+#define	MCDRV_CKSEL_CMOS_TCXO		(0x80)
+#define	MCDRV_CKSEL_TCXO_CMOS		(0x40)
+
+/*	MCDRV_INIT_INFO bXXXHiz setting	*/
+#define	MCDRV_DAHIZ_LOW				(0)
+#define	MCDRV_DAHIZ_HIZ				(1)
+
+/*	CDRV_INIT_INFO bPcmHiz setting	*/
+#define	MCDRV_PCMHIZ_LOW			(0)
+#define	MCDRV_PCMHIZ_HIZ			(1)
+
+/*	MCDRV_INIT_INFO bSvolStep setting	*/
+#define	MCDRV_SVOLSTEP_0137			(0)
+#define	MCDRV_SVOLSTEP_0274			(1)
+#define	MCDRV_SVOLSTEP_0548			(2)
+#define	MCDRV_SVOLSTEP_1096			(3)
+
+/*	MCDRV_INIT_INFO bLinexxDif setting	*/
+#define	MCDRV_LINE_STEREO			(0)
+#define	MCDRV_LINE_DIF				(1)
+
+/*	MCDRV_INIT_INFO bSpmn setting	*/
+#define	MCDRV_SPMN_ON				(0)
+#define	MCDRV_SPMN_OFF				(1)
+
+/*	MCDRV_INIT_INFO bMicxSng setting	*/
+#define	MCDRV_MIC_DIF				(0)
+#define	MCDRV_MIC_SINGLE			(1)
+
+/*	MCDRV_INIT_INFO bPowerMode setting	*/
+#define	MCDRV_POWMODE_NORMAL		(0)
+#define	MCDRV_POWMODE_CLKON			(1)
+#define	MCDRV_POWMODE_VREFON		(2)
+#define	MCDRV_POWMODE_CLKVREFON		(3)
+#define	MCDRV_POWMODE_FULL			(4)
+
+/* bSpHiz setting */
+#define	MCDRV_SPHIZ_PULLDOWN		(0)
+#define	MCDRV_SPHIZ_HIZ				(1)
+
+/*	MCDRV_INIT_INFO bLdo setting	*/
+#define	MCDRV_LDO_OFF				(0)
+#define	MCDRV_LDO_ON				(1)
+
+/*	MCDRV_INIT_INFO bPadxFunc setting	*/
+#define	MCDRV_PAD_GPIO				(0)
+#define	MCDRV_PAD_PDMCK				(1)
+#define	MCDRV_PAD_PDMDI				(2)
+#define	MCDRV_PAD_IRQ				(3)
+
+/*	MCDRV_INIT_INFO bAvddLev/bVrefLev setting	*/
+#define	MCDRV_OUTLEV_0				(0)
+#define	MCDRV_OUTLEV_1				(1)
+#define	MCDRV_OUTLEV_2				(2)
+#define	MCDRV_OUTLEV_3				(3)
+#define	MCDRV_OUTLEV_4				(4)
+#define	MCDRV_OUTLEV_5				(5)
+#define	MCDRV_OUTLEV_6				(6)
+#define	MCDRV_OUTLEV_7				(7)
+
+/*	MCDRV_INIT_INFO bDclGain setting	*/
+#define	MCDRV_DCLGAIN_0				(0)
+#define	MCDRV_DCLGAIN_6				(1)
+#define	MCDRV_DCLGAIN_12			(2)
+#define	MCDRV_DCLGAIN_18			(3)
+
+/*	MCDRV_INIT_INFO bDclLimit setting	*/
+#define	MCDRV_DCLLIMIT_0			(0)
+#define	MCDRV_DCLLIMIT_116			(1)
+#define	MCDRV_DCLLIMIT_250			(2)
+#define	MCDRV_DCLLIMIT_602			(3)
+
+/*	MCDRV_INIT_INFO bCpMod setting	*/
+#define	MCDRV_CPMOD_ON				(0)
+#define	MCDRV_CPMOD_OFF				(1)
+
+typedef struct
+{
+	UINT32	dAdHpf;
+	UINT32	dMic1Cin;
+	UINT32	dMic2Cin;
+	UINT32	dMic3Cin;
+	UINT32	dLine1Cin;
+	UINT32	dLine2Cin;
+	UINT32	dVrefRdy1;
+	UINT32	dVrefRdy2;
+	UINT32	dHpRdy;
+	UINT32	dSpRdy;
+	UINT32	dPdm;
+	UINT32	dAnaRdyInterval;
+	UINT32	dSvolInterval;
+	UINT32	dAnaRdyTimeOut;
+	UINT32	dSvolTimeOut;
+} MCDRV_WAIT_TIME;
+
+typedef struct
+{
+	UINT8			bCkSel;
+	UINT8			bDivR0;
+	UINT8			bDivF0;
+	UINT8			bDivR1;
+	UINT8			bDivF1;
+	UINT8			bRange0;
+	UINT8			bRange1;
+	UINT8			bBypass;
+	UINT8			bDioSdo0Hiz;
+	UINT8			bDioSdo1Hiz;
+	UINT8			bDioSdo2Hiz;
+	UINT8			bDioClk0Hiz;
+	UINT8			bDioClk1Hiz;
+	UINT8			bDioClk2Hiz;
+	UINT8			bPcmHiz;
+	UINT8			bLineIn1Dif;
+	UINT8			bLineIn2Dif;
+	UINT8			bLineOut1Dif;
+	UINT8			bLineOut2Dif;
+	UINT8			bSpmn;
+	UINT8			bMic1Sng;
+	UINT8			bMic2Sng;
+	UINT8			bMic3Sng;
+	UINT8			bPowerMode;
+	UINT8			bSpHiz;
+	UINT8			bLdo;
+	UINT8			bPad0Func;
+	UINT8			bPad1Func;
+	UINT8			bPad2Func;
+	UINT8			bAvddLev;
+	UINT8			bVrefLev;
+	UINT8			bDclGain;
+	UINT8			bDclLimit;
+	UINT8			bCpMod;
+	UINT8			bReserved1;
+	UINT8			bReserved2;
+	UINT8			bReserved3;
+	UINT8			bReserved4;
+	UINT8			bReserved5;
+	MCDRV_WAIT_TIME	sWaitTime;
+} MCDRV_INIT_INFO;
+
+/*	update clock	*/
+typedef struct
+{
+	UINT8	bCkSel;
+	UINT8	bDivR0;
+	UINT8	bDivF0;
+	UINT8	bDivR1;
+	UINT8	bDivF1;
+	UINT8	bRange0;
+	UINT8	bRange1;
+	UINT8	bBypass;
+} MCDRV_CLOCK_INFO;
+
+/*	switch clock	*/
+/*	MCDRV_CLKSW_INFO bClkSrc setting	*/
+#define	MCDRV_CLKSW_CLKI0	(0x00)
+#define	MCDRV_CLKSW_CLKI1	(0x01)
+
+typedef struct
+{
+	UINT8	bClkSrc;
+} MCDRV_CLKSW_INFO;
+
+/*	set/get path	*/
+#define	SOURCE_BLOCK_NUM			(7)
+#define	MCDRV_SRC_MIC1_BLOCK		(0)
+#define	MCDRV_SRC_MIC2_BLOCK		(0)
+#define	MCDRV_SRC_MIC3_BLOCK		(0)
+#define	MCDRV_SRC_LINE1_L_BLOCK		(1)
+#define	MCDRV_SRC_LINE1_R_BLOCK		(1)
+#define	MCDRV_SRC_LINE1_M_BLOCK		(1)
+#define	MCDRV_SRC_LINE2_L_BLOCK		(2)
+#define	MCDRV_SRC_LINE2_R_BLOCK		(2)
+#define	MCDRV_SRC_LINE2_M_BLOCK		(2)
+#define	MCDRV_SRC_DIR0_BLOCK		(3)
+#define	MCDRV_SRC_DIR1_BLOCK		(3)
+#define	MCDRV_SRC_DIR2_BLOCK		(3)
+#define	MCDRV_SRC_DIR2_DIRECT_BLOCK	(3)
+#define	MCDRV_SRC_DTMF_BLOCK		(4)
+#define	MCDRV_SRC_PDM_BLOCK			(4)
+#define	MCDRV_SRC_ADC0_BLOCK		(4)
+#define	MCDRV_SRC_ADC1_BLOCK		(4)
+#define	MCDRV_SRC_DAC_L_BLOCK		(5)
+#define	MCDRV_SRC_DAC_R_BLOCK		(5)
+#define	MCDRV_SRC_DAC_M_BLOCK		(5)
+#define	MCDRV_SRC_MIX_BLOCK			(6)
+#define	MCDRV_SRC_AE_BLOCK			(6)
+#define	MCDRV_SRC_CDSP_BLOCK		(6)
+#define	MCDRV_SRC_CDSP_DIRECT_BLOCK	(6)
+
+#define	MCDRV_SRC0_MIC1_ON			(0x01)
+#define	MCDRV_SRC0_MIC1_OFF			(0x02)
+#define	MCDRV_SRC0_MIC2_ON			(0x04)
+#define	MCDRV_SRC0_MIC2_OFF			(0x08)
+#define	MCDRV_SRC0_MIC3_ON			(0x10)
+#define	MCDRV_SRC0_MIC3_OFF			(0x20)
+#define	MCDRV_SRC1_LINE1_L_ON		(0x01)
+#define	MCDRV_SRC1_LINE1_L_OFF		(0x02)
+#define	MCDRV_SRC1_LINE1_R_ON		(0x04)
+#define	MCDRV_SRC1_LINE1_R_OFF		(0x08)
+#define	MCDRV_SRC1_LINE1_M_ON		(0x10)
+#define	MCDRV_SRC1_LINE1_M_OFF		(0x20)
+#define	MCDRV_SRC2_LINE2_L_ON		(0x01)
+#define	MCDRV_SRC2_LINE2_L_OFF		(0x02)
+#define	MCDRV_SRC2_LINE2_R_ON		(0x04)
+#define	MCDRV_SRC2_LINE2_R_OFF		(0x08)
+#define	MCDRV_SRC2_LINE2_M_ON		(0x10)
+#define	MCDRV_SRC2_LINE2_M_OFF		(0x20)
+#define	MCDRV_SRC3_DIR0_ON			(0x01)
+#define	MCDRV_SRC3_DIR0_OFF			(0x02)
+#define	MCDRV_SRC3_DIR1_ON			(0x04)
+#define	MCDRV_SRC3_DIR1_OFF			(0x08)
+#define	MCDRV_SRC3_DIR2_ON			(0x10)
+#define	MCDRV_SRC3_DIR2_OFF			(0x20)
+#define	MCDRV_SRC3_DIR2_DIRECT_ON	(0x40)
+#define	MCDRV_SRC3_DIR2_DIRECT_OFF	(0x80)
+#define	MCDRV_SRC4_DTMF_ON			(0x01)
+#define	MCDRV_SRC4_DTMF_OFF			(0x02)
+#define	MCDRV_SRC4_PDM_ON			(0x04)
+#define	MCDRV_SRC4_PDM_OFF			(0x08)
+#define	MCDRV_SRC4_ADC0_ON			(0x10)
+#define	MCDRV_SRC4_ADC0_OFF			(0x20)
+#define	MCDRV_SRC4_ADC1_ON			(0x40)
+#define	MCDRV_SRC4_ADC1_OFF			(0x80)
+#define	MCDRV_SRC5_DAC_L_ON			(0x01)
+#define	MCDRV_SRC5_DAC_L_OFF		(0x02)
+#define	MCDRV_SRC5_DAC_R_ON			(0x04)
+#define	MCDRV_SRC5_DAC_R_OFF		(0x08)
+#define	MCDRV_SRC5_DAC_M_ON			(0x10)
+#define	MCDRV_SRC5_DAC_M_OFF		(0x20)
+#define	MCDRV_SRC6_MIX_ON			(0x01)
+#define	MCDRV_SRC6_MIX_OFF			(0x02)
+#define	MCDRV_SRC6_AE_ON			(0x04)
+#define	MCDRV_SRC6_AE_OFF			(0x08)
+#define	MCDRV_SRC6_CDSP_ON			(0x10)
+#define	MCDRV_SRC6_CDSP_OFF			(0x20)
+#define	MCDRV_SRC6_CDSP_DIRECT_ON	(0x40)
+#define	MCDRV_SRC6_CDSP_DIRECT_OFF	(0x80)
+
+typedef struct
+{
+	UINT8	abSrcOnOff[SOURCE_BLOCK_NUM];
+} MCDRV_CHANNEL;
+
+#define	HP_PATH_CHANNELS		(2)
+#define	SP_PATH_CHANNELS		(2)
+#define	RC_PATH_CHANNELS		(1)
+#define	LOUT1_PATH_CHANNELS		(2)
+#define	LOUT2_PATH_CHANNELS		(2)
+#define	PEAK_PATH_CHANNELS		(1)
+#define	DIT0_PATH_CHANNELS		(1)
+#define	DIT1_PATH_CHANNELS		(1)
+#define	DIT2_PATH_CHANNELS		(1)
+#define	DAC_PATH_CHANNELS		(2)
+#define	AE_PATH_CHANNELS		(1)
+#define	CDSP_PATH_CHANNELS		(4)
+#define	ADC0_PATH_CHANNELS		(2)
+#define	ADC1_PATH_CHANNELS		(1)
+#define	MIX_PATH_CHANNELS		(1)
+#define	BIAS_PATH_CHANNELS		(1)
+
+typedef struct
+{
+	MCDRV_CHANNEL	asHpOut[HP_PATH_CHANNELS];
+	MCDRV_CHANNEL	asSpOut[SP_PATH_CHANNELS];
+	MCDRV_CHANNEL	asRcOut[RC_PATH_CHANNELS];
+	MCDRV_CHANNEL	asLout1[LOUT1_PATH_CHANNELS];
+	MCDRV_CHANNEL	asLout2[LOUT2_PATH_CHANNELS];
+	MCDRV_CHANNEL	asPeak[PEAK_PATH_CHANNELS];
+	MCDRV_CHANNEL	asDit0[DIT0_PATH_CHANNELS];
+	MCDRV_CHANNEL	asDit1[DIT1_PATH_CHANNELS];
+	MCDRV_CHANNEL	asDit2[DIT2_PATH_CHANNELS];
+	MCDRV_CHANNEL	asDac[DAC_PATH_CHANNELS];
+	MCDRV_CHANNEL	asAe[AE_PATH_CHANNELS];
+	MCDRV_CHANNEL	asCdsp[CDSP_PATH_CHANNELS];
+	MCDRV_CHANNEL	asAdc0[ADC0_PATH_CHANNELS];
+	MCDRV_CHANNEL	asAdc1[ADC1_PATH_CHANNELS];
+	MCDRV_CHANNEL	asMix[MIX_PATH_CHANNELS];
+	MCDRV_CHANNEL	asBias[BIAS_PATH_CHANNELS];
+} MCDRV_PATH_INFO;
+
+/*	set/get vol	*/
+#define	MCDRV_VOL_UPDATE		(0x0001)
+
+#define	AD0_VOL_CHANNELS		(2)
+#define	AD1_VOL_CHANNELS		(1)
+#define	AENG6_VOL_CHANNELS		(2)
+#define	PDM_VOL_CHANNELS		(2)
+#define	DTMF_VOL_CHANNELS		(2)
+#define	DIO0_VOL_CHANNELS		(2)
+#define	DIO1_VOL_CHANNELS		(2)
+#define	DIO2_VOL_CHANNELS		(2)
+#define	DTFM_VOL_CHANNELS		(2)
+#define	DAC_VOL_CHANNELS		(2)
+
+#define	LIN1_VOL_CHANNELS		(2)
+#define	LIN2_VOL_CHANNELS		(2)
+#define	MIC1_VOL_CHANNELS		(1)
+#define	MIC2_VOL_CHANNELS		(1)
+#define	MIC3_VOL_CHANNELS		(1)
+#define	HP_VOL_CHANNELS			(2)
+#define	SP_VOL_CHANNELS			(2)
+#define	RC_VOL_CHANNELS			(1)
+#define	LOUT1_VOL_CHANNELS		(2)
+#define	LOUT2_VOL_CHANNELS		(2)
+#define	HPGAIN_VOL_CHANNELS		(1)
+
+typedef struct
+{
+	SINT16	aswD_Ad0[AD0_VOL_CHANNELS];
+	SINT16	aswD_Ad1[AD1_VOL_CHANNELS];
+	SINT16	aswD_Aeng6[AENG6_VOL_CHANNELS];
+	SINT16	aswD_Pdm[PDM_VOL_CHANNELS];
+	SINT16	aswD_Dtmfb[DTMF_VOL_CHANNELS];
+	SINT16	aswD_Dir0[DIO0_VOL_CHANNELS];
+	SINT16	aswD_Dir1[DIO1_VOL_CHANNELS];
+	SINT16	aswD_Dir2[DIO2_VOL_CHANNELS];
+	SINT16	aswD_Ad0Att[AD0_VOL_CHANNELS];
+	SINT16	aswD_Ad1Att[AD1_VOL_CHANNELS];
+	SINT16	aswD_Dir0Att[DIO0_VOL_CHANNELS];
+	SINT16	aswD_Dir1Att[DIO1_VOL_CHANNELS];
+	SINT16	aswD_Dir2Att[DIO2_VOL_CHANNELS];
+	SINT16	aswD_SideTone[PDM_VOL_CHANNELS];
+	SINT16	aswD_DtmfAtt[DTFM_VOL_CHANNELS];
+	SINT16	aswD_DacMaster[DAC_VOL_CHANNELS];
+	SINT16	aswD_DacVoice[DAC_VOL_CHANNELS];
+	SINT16	aswD_DacAtt[DAC_VOL_CHANNELS];
+	SINT16	aswD_Dit0[DIO0_VOL_CHANNELS];
+	SINT16	aswD_Dit1[DIO1_VOL_CHANNELS];
+	SINT16	aswD_Dit2[DIO2_VOL_CHANNELS];
+	SINT16	aswA_Ad0[AD0_VOL_CHANNELS];
+	SINT16	aswA_Ad1[AD1_VOL_CHANNELS];
+	SINT16	aswA_Lin1[LIN1_VOL_CHANNELS];
+	SINT16	aswA_Lin2[LIN2_VOL_CHANNELS];
+	SINT16	aswA_Mic1[MIC1_VOL_CHANNELS];
+	SINT16	aswA_Mic2[MIC2_VOL_CHANNELS];
+	SINT16	aswA_Mic3[MIC3_VOL_CHANNELS];
+	SINT16	aswA_Hp[HP_VOL_CHANNELS];
+	SINT16	aswA_Sp[SP_VOL_CHANNELS];
+	SINT16	aswA_Rc[RC_VOL_CHANNELS];
+	SINT16	aswA_Lout1[LOUT1_VOL_CHANNELS];
+	SINT16	aswA_Lout2[LOUT2_VOL_CHANNELS];
+	SINT16	aswA_Mic1Gain[MIC1_VOL_CHANNELS];
+	SINT16	aswA_Mic2Gain[MIC2_VOL_CHANNELS];
+	SINT16	aswA_Mic3Gain[MIC3_VOL_CHANNELS];
+	SINT16	aswA_HpGain[HPGAIN_VOL_CHANNELS];
+} MCDRV_VOL_INFO;
+
+/*	set/get digitalio	*/
+#define	MCDRV_DIO0_COM_UPDATE_FLAG	((UINT32)0x00000001)
+#define	MCDRV_DIO0_DIR_UPDATE_FLAG	((UINT32)0x00000002)
+#define	MCDRV_DIO0_DIT_UPDATE_FLAG	((UINT32)0x00000004)
+#define	MCDRV_DIO1_COM_UPDATE_FLAG	((UINT32)0x00000008)
+#define	MCDRV_DIO1_DIR_UPDATE_FLAG	((UINT32)0x00000010)
+#define	MCDRV_DIO1_DIT_UPDATE_FLAG	((UINT32)0x00000020)
+#define	MCDRV_DIO2_COM_UPDATE_FLAG	((UINT32)0x00000040)
+#define	MCDRV_DIO2_DIR_UPDATE_FLAG	((UINT32)0x00000080)
+#define	MCDRV_DIO2_DIT_UPDATE_FLAG	((UINT32)0x00000100)
+
+/*	MCDRV_DIO_COMMON bMasterSlave setting	*/
+#define	MCDRV_DIO_SLAVE				(0)
+#define	MCDRV_DIO_MASTER			(1)
+
+/*	MCDRV_DIO_COMMON bDigitalAutoFs setting	*/
+#define	MCDRV_AUTOFS_OFF			(0)
+#define	MCDRV_AUTOFS_ON				(1)
+
+/*	MCDRV_DIO_COMMON bFs setting	*/
+#define	MCDRV_FS_48000				(0)
+#define	MCDRV_FS_44100				(1)
+#define	MCDRV_FS_32000				(2)
+#define	MCDRV_FS_24000				(4)
+#define	MCDRV_FS_22050				(5)
+#define	MCDRV_FS_16000				(6)
+#define	MCDRV_FS_12000				(8)
+#define	MCDRV_FS_11025				(9)
+#define	MCDRV_FS_8000				(10)
+
+/*	MCDRV_DIO_COMMON bBckFs setting	*/
+#define	MCDRV_BCKFS_64				(0)
+#define	MCDRV_BCKFS_48				(1)
+#define	MCDRV_BCKFS_32				(2)
+#define	MCDRV_BCKFS_512				(4)
+#define	MCDRV_BCKFS_256				(5)
+#define	MCDRV_BCKFS_128				(6)
+#define	MCDRV_BCKFS_16				(7)
+
+/*	MCDRV_DIO_COMMON bInterface setting	*/
+#define	MCDRV_DIO_DA				(0)
+#define	MCDRV_DIO_PCM				(1)
+
+/*	MCDRV_DIO_COMMON bBckInvert setting	*/
+#define	MCDRV_BCLK_NORMAL			(0)
+#define	MCDRV_BCLK_INVERT			(1)
+
+/*	MCDRV_DIO_COMMON bPcmHizTim setting	*/
+#define	MCDRV_PCMHIZTIM_FALLING		(0)
+#define	MCDRV_PCMHIZTIM_RISING		(1)
+
+/*	MCDRV_DIO_COMMON bPcmClkDown setting	*/
+#define	MCDRV_PCM_CLKDOWN_OFF		(0)
+#define	MCDRV_PCM_CLKDOWN_HALF		(1)
+
+/*	MCDRV_DIO_COMMON bPcmFrame setting	*/
+#define	MCDRV_PCM_SHORTFRAME		(0)
+#define	MCDRV_PCM_LONGFRAME			(1)
+
+typedef struct
+{
+	UINT8	bMasterSlave;
+	UINT8	bAutoFs;
+	UINT8	bFs;
+	UINT8	bBckFs;
+	UINT8	bInterface;
+	UINT8	bBckInvert;
+	UINT8	bPcmHizTim;
+	UINT8	bPcmClkDown;
+	UINT8	bPcmFrame;
+	UINT8	bPcmHighPeriod;
+} MCDRV_DIO_COMMON;
+
+/*	MCDRV_DA_FORMAT bBitSel setting	*/
+#define	MCDRV_BITSEL_16				(0)
+#define	MCDRV_BITSEL_20				(1)
+#define	MCDRV_BITSEL_24				(2)
+
+/*	MCDRV_DA_FORMAT bMode setting	*/
+#define	MCDRV_DAMODE_HEADALIGN		(0)
+#define	MCDRV_DAMODE_I2S			(1)
+#define	MCDRV_DAMODE_TAILALIGN		(2)
+
+typedef struct
+{
+	UINT8	bBitSel;
+	UINT8	bMode;
+} MCDRV_DA_FORMAT;
+
+/*	MCDRV_PCM_FORMAT bMono setting	*/
+#define	MCDRV_PCM_STEREO			(0)
+#define	MCDRV_PCM_MONO				(1)
+
+/*	MCDRV_PCM_FORMAT bOrder setting	*/
+#define	MCDRV_PCM_MSB_FIRST			(0)
+#define	MCDRV_PCM_LSB_FIRST			(1)
+#define	MCDRV_PCM_MSB_FIRST_SIGN	(2)
+#define	MCDRV_PCM_LSB_FIRST_SIGN	(3)
+#define	MCDRV_PCM_MSB_FIRST_ZERO	(4)
+#define	MCDRV_PCM_LSB_FIRST_ZERO	(5)
+
+/*	MCDRV_PCM_FORMAT bLaw setting	*/
+#define	MCDRV_PCM_LINEAR			(0)
+#define	MCDRV_PCM_ALAW				(1)
+#define	MCDRV_PCM_MULAW				(2)
+
+/*	MCDRV_PCM_FORMAT bBitSel setting	*/
+#define	MCDRV_PCM_BITSEL_8			(0)
+#define	MCDRV_PCM_BITSEL_13			(1)
+#define	MCDRV_PCM_BITSEL_14			(2)
+#define	MCDRV_PCM_BITSEL_16			(3)
+
+typedef struct
+{
+	UINT8	bMono;
+	UINT8	bOrder;
+	UINT8	bLaw;
+	UINT8	bBitSel;
+} MCDRV_PCM_FORMAT;
+
+#define	DIO_CHANNELS		(2)
+typedef struct
+{
+	UINT16				wSrcRate;
+	MCDRV_DA_FORMAT		sDaFormat;
+	MCDRV_PCM_FORMAT	sPcmFormat;
+	UINT8				abSlot[DIO_CHANNELS];
+} MCDRV_DIO_DIR;
+
+typedef struct
+{
+	UINT16				wSrcRate;
+	MCDRV_DA_FORMAT		sDaFormat;
+	MCDRV_PCM_FORMAT	sPcmFormat;
+	UINT8				abSlot[DIO_CHANNELS];
+} MCDRV_DIO_DIT;
+
+typedef struct
+{
+	MCDRV_DIO_COMMON	sDioCommon;
+	MCDRV_DIO_DIR		sDir;
+	MCDRV_DIO_DIT		sDit;
+} MCDRV_DIO_PORT;
+
+#define	IOPORT_NUM			(3)
+typedef struct
+{
+	MCDRV_DIO_PORT	asPortInfo[IOPORT_NUM];
+} MCDRV_DIO_INFO;
+
+/*	set dac	*/
+#define	MCDRV_DAC_MSWP_UPDATE_FLAG	((UINT32)0x01)
+#define	MCDRV_DAC_VSWP_UPDATE_FLAG	((UINT32)0x02)
+#define	MCDRV_DAC_HPF_UPDATE_FLAG	((UINT32)0x04)
+
+/*	MCDRV_DAC_INFO bMasterSwap/bVoiceSwap setting	*/
+#define	MCDRV_DSWAP_OFF			(0)
+#define	MCDRV_DSWAP_SWAP		(1)
+#define	MCDRV_DSWAP_MUTE		(2)
+#define	MCDRV_DSWAP_RMVCENTER	(3)
+#define	MCDRV_DSWAP_MONO		(4)
+#define	MCDRV_DSWAP_MONOHALF	(5)
+#define	MCDRV_DSWAP_BOTHL		(6)
+#define	MCDRV_DSWAP_BOTHR		(7)
+
+/*	MCDRV_DAC_INFO bDcCut setting	*/
+#define	MCDRV_DCCUT_ON			(0)
+#define	MCDRV_DCCUT_OFF			(1)
+
+typedef struct
+{
+	UINT8	bMasterSwap;
+	UINT8	bVoiceSwap;
+	UINT8	bDcCut;
+} MCDRV_DAC_INFO;
+
+/*	set adc	*/
+#define	MCDRV_ADCADJ_UPDATE_FLAG	((UINT32)0x00000001)
+#define	MCDRV_ADCAGC_UPDATE_FLAG	((UINT32)0x00000002)
+#define	MCDRV_ADCMONO_UPDATE_FLAG	((UINT32)0x00000004)
+
+/*	MCDRV_ADC_INFO bAgcAdjust setting	*/
+#define	MCDRV_AGCADJ_24			(0)
+#define	MCDRV_AGCADJ_18			(1)
+#define	MCDRV_AGCADJ_12			(2)
+#define	MCDRV_AGCADJ_0			(3)
+
+/*	MCDRV_ADC_INFO bAgcOn setting	*/
+#define	MCDRV_AGC_OFF			(0)
+#define	MCDRV_AGC_ON			(1)
+
+/*	MCDRV_ADC_INFO bMono setting	*/
+#define	MCDRV_ADC_STEREO		(0)
+#define	MCDRV_ADC_MONO			(1)
+
+typedef struct
+{
+	UINT8	bAgcAdjust;
+	UINT8	bAgcOn;
+	UINT8	bMono;
+} MCDRV_ADC_INFO;
+
+/*	set sp	*/
+/*	MCDRV_SP_INFO bSwap setting	*/
+#define	MCDRV_SPSWAP_OFF		(0)
+#define	MCDRV_SPSWAP_SWAP		(1)
+
+typedef struct
+{
+	UINT8	bSwap;
+} MCDRV_SP_INFO;
+
+/*	set dng	*/
+#define	DNG_ITEM_NUM				(3)
+#define	MCDRV_DNG_ITEM_HP			(0)
+#define	MCDRV_DNG_ITEM_SP			(1)
+#define	MCDRV_DNG_ITEM_RC			(2)
+
+#define	MCDRV_DNGSW_HP_UPDATE_FLAG		((UINT32)0x00000001)
+#define	MCDRV_DNGTHRES_HP_UPDATE_FLAG	((UINT32)0x00000002)
+#define	MCDRV_DNGHOLD_HP_UPDATE_FLAG	((UINT32)0x00000004)
+#define	MCDRV_DNGATK_HP_UPDATE_FLAG		((UINT32)0x00000008)
+#define	MCDRV_DNGREL_HP_UPDATE_FLAG		((UINT32)0x00000010)
+#define	MCDRV_DNGTARGET_HP_UPDATE_FLAG	((UINT32)0x00000020)
+#define	MCDRV_DNGSW_SP_UPDATE_FLAG		((UINT32)0x00000100)
+#define	MCDRV_DNGTHRES_SP_UPDATE_FLAG	((UINT32)0x00000200)
+#define	MCDRV_DNGHOLD_SP_UPDATE_FLAG	((UINT32)0x00000400)
+#define	MCDRV_DNGATK_SP_UPDATE_FLAG		((UINT32)0x00000800)
+#define	MCDRV_DNGREL_SP_UPDATE_FLAG		((UINT32)0x00001000)
+#define	MCDRV_DNGTARGET_SP_UPDATE_FLAG	((UINT32)0x00002000)
+#define	MCDRV_DNGSW_RC_UPDATE_FLAG		((UINT32)0x00010000)
+#define	MCDRV_DNGTHRES_RC_UPDATE_FLAG	((UINT32)0x00020000)
+#define	MCDRV_DNGHOLD_RC_UPDATE_FLAG	((UINT32)0x00040000)
+#define	MCDRV_DNGATK_RC_UPDATE_FLAG		((UINT32)0x00080000)
+#define	MCDRV_DNGREL_RC_UPDATE_FLAG		((UINT32)0x00100000)
+#define	MCDRV_DNGTARGET_RC_UPDATE_FLAG	((UINT32)0x00200000)
+
+/*	MCDRV_DNG_INFO bOnOff setting	*/
+#define	MCDRV_DNG_OFF				(0)
+#define	MCDRV_DNG_ON				(1)
+
+/*	MCDRV_DNG_INFO bThreshold setting	*/
+#define	MCDRV_DNG_THRES_30			(0)
+#define	MCDRV_DNG_THRES_36			(1)
+#define	MCDRV_DNG_THRES_42			(2)
+#define	MCDRV_DNG_THRES_48			(3)
+#define	MCDRV_DNG_THRES_54			(4)
+#define	MCDRV_DNG_THRES_60			(5)
+#define	MCDRV_DNG_THRES_66			(6)
+#define	MCDRV_DNG_THRES_72			(7)
+#define	MCDRV_DNG_THRES_78			(8)
+#define	MCDRV_DNG_THRES_84			(9)
+
+/*	MCDRV_DNG_INFO bHold setting	*/
+#define	MCDRV_DNG_HOLD_30			(0)
+#define	MCDRV_DNG_HOLD_120			(1)
+#define	MCDRV_DNG_HOLD_500			(2)
+
+/*	MCDRV_DNG_INFO bAttack setting	*/
+#define	MCDRV_DNG_ATTACK_25			(0)
+#define	MCDRV_DNG_ATTACK_100		(1)
+#define	MCDRV_DNG_ATTACK_400		(2)
+#define	MCDRV_DNG_ATTACK_800		(3)
+
+/*	MCDRV_DNG_INFO bRelease setting	*/
+#define	MCDRV_DNG_RELEASE_7950		(0)
+#define	MCDRV_DNG_RELEASE_470		(1)
+#define	MCDRV_DNG_RELEASE_940		(2)
+
+/*	MCDRV_DNG_INFO bTarget setting	*/
+#define	MCDRV_DNG_TARGET_6			(0)
+#define	MCDRV_DNG_TARGET_9			(1)
+#define	MCDRV_DNG_TARGET_12			(2)
+#define	MCDRV_DNG_TARGET_15			(3)
+#define	MCDRV_DNG_TARGET_18			(4)
+#define	MCDRV_DNG_TARGET_MUTE		(5)
+
+typedef struct
+{
+	UINT8	abOnOff[DNG_ITEM_NUM];
+	UINT8	abThreshold[DNG_ITEM_NUM];
+	UINT8	abHold[DNG_ITEM_NUM];
+	UINT8	abAttack[DNG_ITEM_NUM];
+	UINT8	abRelease[DNG_ITEM_NUM];
+	UINT8	abTarget[DNG_ITEM_NUM];
+}	MCDRV_DNG_INFO;
+
+/*	set audio engine	*/
+#define	MCDRV_AEUPDATE_FLAG_BEXWIDE_ONOFF	((UINT32)0x00000001)
+#define	MCDRV_AEUPDATE_FLAG_DRC_ONOFF		((UINT32)0x00000002)
+#define	MCDRV_AEUPDATE_FLAG_EQ5_ONOFF		((UINT32)0x00000004)
+#define	MCDRV_AEUPDATE_FLAG_EQ3_ONOFF		((UINT32)0x00000008)
+#define	MCDRV_AEUPDATE_FLAG_BEX				((UINT32)0x00000010)
+#define	MCDRV_AEUPDATE_FLAG_WIDE			((UINT32)0x00000020)
+#define	MCDRV_AEUPDATE_FLAG_DRC				((UINT32)0x00000040)
+#define	MCDRV_AEUPDATE_FLAG_EQ5				((UINT32)0x00000080)
+#define	MCDRV_AEUPDATE_FLAG_EQ3				((UINT32)0x00000100)
+
+/*	MCDRV_AE_INFO bOnOff setting	*/
+#define	MCDRV_BEXWIDE_ON			(0x01)
+#define	MCDRV_DRC_ON				(0x02)
+#define	MCDRV_EQ5_ON				(0x04)
+#define	MCDRV_EQ3_ON				(0x08)
+
+#define	BEX_PARAM_SIZE				(104)
+#define	WIDE_PARAM_SIZE				(20)
+#define	DRC_PARAM_SIZE				(256)
+#define	EQ5_PARAM_SIZE				(105)
+#define	EQ3_PARAM_SIZE				(75)
+
+typedef struct
+{
+	UINT8	bOnOff;
+	UINT8	abBex[BEX_PARAM_SIZE];
+	UINT8	abWide[WIDE_PARAM_SIZE];
+	UINT8	abDrc[DRC_PARAM_SIZE];
+	UINT8	abEq5[EQ5_PARAM_SIZE];
+	UINT8	abEq3[EQ3_PARAM_SIZE];
+}	MCDRV_AE_INFO;
+
+/*	set cdsp param	*/
+typedef struct
+{
+	UINT8	bId;
+	UINT8	abParam[16];
+} MCDRV_CDSPPARAM;
+
+/*	register cdsp cb	*/
+/*	dEvtType	*/
+#define	MCDRV_CDSP_EVT_ERROR		(0)
+#define	MCDRV_CDSP_EVT_PARAM		(1)
+
+/*	dEvtPrm	*/
+#define	MCDRV_CDSP_PRG_ERROR		(0)
+#define	MCDRV_CDSP_PRG_ERROR_FATAL	(1)
+#define	MCDRV_CDSP_SYS_ERROR		(2)
+
+/*	set pdm	*/
+#define	MCDRV_PDMCLK_UPDATE_FLAG	((UINT32)0x00000001)
+#define	MCDRV_PDMADJ_UPDATE_FLAG	((UINT32)0x00000002)
+#define	MCDRV_PDMAGC_UPDATE_FLAG	((UINT32)0x00000004)
+#define	MCDRV_PDMEDGE_UPDATE_FLAG	((UINT32)0x00000008)
+#define	MCDRV_PDMWAIT_UPDATE_FLAG	((UINT32)0x00000010)
+#define	MCDRV_PDMSEL_UPDATE_FLAG	((UINT32)0x00000020)
+#define	MCDRV_PDMMONO_UPDATE_FLAG	((UINT32)0x00000040)
+
+/*	MCDRV_PDM_INFO bClk setting	*/
+#define	MCDRV_PDM_CLK_128			(1)
+#define	MCDRV_PDM_CLK_64			(2)
+#define	MCDRV_PDM_CLK_32			(3)
+
+/*	MCDRV_PDM_INFO bPdmEdge setting	*/
+#define	MCDRV_PDMEDGE_LH			(0)
+#define	MCDRV_PDMEDGE_HL			(1)
+
+/*	MCDRV_PDM_INFO bPdmWait setting	*/
+#define	MCDRV_PDMWAIT_0				(0)
+#define	MCDRV_PDMWAIT_1				(1)
+#define	MCDRV_PDMWAIT_10			(2)
+#define	MCDRV_PDMWAIT_20			(3)
+
+/*	MCDRV_PDM_INFO bPdmSel setting	*/
+#define	MCDRV_PDMSEL_L1R2			(0)
+#define	MCDRV_PDMSEL_L2R1			(1)
+#define	MCDRV_PDMSEL_L1R1			(2)
+#define	MCDRV_PDMSEL_L2R2			(3)
+
+/*	MCDRV_PDM_INFO bMono setting	*/
+#define	MCDRV_PDM_STEREO			(0)
+#define	MCDRV_PDM_MONO				(1)
+
+typedef struct
+{
+	UINT8	bClk;
+	UINT8	bAgcAdjust;
+	UINT8	bAgcOn;
+	UINT8	bPdmEdge;
+	UINT8	bPdmWait;
+	UINT8	bPdmSel;
+	UINT8	bMono;
+} MCDRV_PDM_INFO;
+
+/*	set dtmf	*/
+typedef struct
+{
+	UINT8	bSinGen0Vol;
+	UINT8	bSinGen1Vol;
+	UINT16	wSinGen0Freq;
+	UINT16	wSinGen1Freq;
+	UINT8	bSinGenGate;
+	UINT8	bSinGenMode;
+	UINT8	bSinGenLoop;
+} MCDRV_DTMF_PARAM;
+
+/*	MCDRV_DTMF_INFO bOnOff setting	*/
+#define	MCDRV_DTMF_ON				(0)
+#define	MCDRV_DTMF_OFF				(1)
+
+typedef struct
+{
+	UINT8				bOnOff;
+	MCDRV_DTMF_PARAM	sParam;
+} MCDRV_DTMF_INFO;
+
+/*	config gp	*/
+#define	GPIO_PAD_NUM				(2)
+
+/*	MCDRV_GP_MODE abGpDdr setting	*/
+#define	MCDRV_GPDDR_IN				(0)
+#define	MCDRV_GPDDR_OUT				(1)
+
+/*	MCDRV_GP_MODE abGpMode setting	*/
+#define	MCDRV_GPMODE_RISING			(0)
+#define	MCDRV_GPMODE_FALLING		(1)
+#define	MCDRV_GPMODE_BOTH			(2)
+
+/*	MCDRV_GP_MODE abGpHost setting	*/
+#define	MCDRV_GPHOST_SCU			(0)
+#define	MCDRV_GPHOST_CDSP			(1)
+
+/*	MCDRV_GP_MODE abGpInvert setting	*/
+#define	MCDRV_GPINV_NORMAL			(0)
+#define	MCDRV_GPINV_INVERT			(1)
+
+typedef struct
+{
+	UINT8	abGpDdr[GPIO_PAD_NUM];
+	UINT8	abGpMode[GPIO_PAD_NUM];
+	UINT8	abGpHost[GPIO_PAD_NUM];
+	UINT8	abGpInvert[GPIO_PAD_NUM];
+} MCDRV_GP_MODE;
+
+/*	mask gp	*/
+#define	MCDRV_GPMASK_OFF			(0)
+#define	MCDRV_GPMASK_ON				(1)
+
+#define	MCDRV_GP_PAD0				((UINT32)0)
+#define	MCDRV_GP_PAD1				((UINT32)1)
+
+/*	getset gp	*/
+#define	MCDRV_GP_LOW				(0)
+#define	MCDRV_GP_HIGH				(1)
+
+/*	get peak	*/
+#define	PEAK_CHANNELS				(2)
+typedef struct
+{
+	SINT16	aswPeak[PEAK_CHANNELS];
+} MCDRV_PEAK;
+
+/*	set/get syseq	*/
+#define	MCDRV_SYSEQ_ONOFF_UPDATE_FLAG	((UINT32)0x00000001)
+#define	MCDRV_SYSEQ_PARAM_UPDATE_FLAG	((UINT32)0x00000002)
+
+/*	MCDRV_SYSEQ_INFO bOnOff setting	*/
+#define	MCDRV_SYSEQ_OFF				(0)
+#define	MCDRV_SYSEQ_ON				(1)
+
+typedef struct
+{
+	UINT8	bOnOff;
+	UINT8	abParam[15];
+} MCDRV_SYSEQ_INFO;
+
+/*	read_reg, write_reg	*/
+#define	MCDRV_REGTYPE_A				(0)
+#define	MCDRV_REGTYPE_B_BASE		(1)
+#define	MCDRV_REGTYPE_B_MIXER		(2)
+#define	MCDRV_REGTYPE_B_AE			(3)
+#define	MCDRV_REGTYPE_B_CDSP		(4)
+#define	MCDRV_REGTYPE_B_CODEC		(5)
+#define	MCDRV_REGTYPE_B_ANALOG		(6)
+typedef struct
+{
+	UINT8	bRegType;
+	UINT8	bAddress;
+	UINT8	bData;
+} MCDRV_REG_INFO;
+
+
+#endif /* _MCDRIVER_H_ */
diff --git a/sound/soc/codecs/mc1n2/mcdriver_AA.c b/sound/soc/codecs/mc1n2/mcdriver_AA.c
new file mode 100644
index 0000000..ac61eaf
--- /dev/null
+++ b/sound/soc/codecs/mc1n2/mcdriver_AA.c
@@ -0,0 +1,18276 @@
+/****************************************************************************
+ *
+ *		Copyright(c) 2010-2011 Yamaha Corporation. All rights reserved.
+ *
+ *		Module		: mcdriver.c
+ *
+ *		Description	: MC Driver
+ *
+ *		Version		: 1.0.2		2011.04.18
+ *
+ ****************************************************************************/
+
+
+#include "mcdriver.h"
+#include "mcdriver_AA.h"
+#include "mcservice.h"
+
+
+
+/*******************************************/
+
+/*	Register Definition
+
+	[Naming Rules]
+
+	  MCI_AA_xxx		: Registers
+	  MCI_AA_xxx_DEF	: Default setting of registers
+	  MCB_AA_xxx		: Miscelleneous bit definition
+*/
+
+/*	Registers	*/
+/*	A_ADR	*/
+#define	MCI_AA_RST						(0)
+#define	MCB_AA_RST						(0x01)
+#define	MCI_AA_RST_DEF					(MCB_AA_RST)
+
+#define	MCI_AA_BASE_ADR				(1)
+#define	MCI_AA_BASE_WINDOW				(2)
+
+#define	MCI_AA_HW_ID					(8)
+#define	MCI_AA_HW_ID_DEF				(0x44)
+
+#define	MCI_AA_ANA_ADR					(12)
+#define	MCI_AA_ANA_WINDOW				(13)
+
+#define	MCI_AA_CD_ADR					(14)
+#define	MCI_AA_CD_WINDOW				(15)
+
+#define	MCI_AA_MIX_ADR					(16)
+#define	MCI_AA_MIX_WINDOW				(17)
+
+#define	MCI_AA_AE_ADR					(18)
+#define	MCI_AA_AE_WINDOW				(19)
+
+#define	MCI_AA_BDSP_ST					(20)
+#define	MCB_AA_EQ5ON					(0x80)
+#define	MCB_AA_DRCON					(0x40)
+#define	MCB_AA_EQ3ON					(0x20)
+#define	MCB_AA_DBEXON					(0x08)
+#define	MCB_AA_BDSP_ST					(0x01)
+
+#define	MCI_AA_BDSP_RST				(21)
+#define	MCB_AA_TRAM_RST				(0x02)
+#define	MCB_AA_BDSP_RST				(0x01)
+
+#define	MCI_AA_BDSP_ADR				(22)
+#define	MCI_AA_BDSP_WINDOW				(23)
+
+#define	MCI_AA_CDSP_ADR				(24)
+#define	MCI_AA_CDSP_WINDOW				(25)
+
+/*	B_ADR(BASE)	*/
+#define	MCI_AA_RSTB					(0)
+#define	MCB_AA_RSTB					(0x10)
+#define	MCI_AA_RSTB_DEF				(MCB_AA_RSTB)
+
+#define	MCI_AA_PWM_DIGITAL				(1)
+#define	MCB_AA_PWM_DP2					(0x04)
+#define	MCB_AA_PWM_DP1					(0x02)
+#define	MCB_AA_PWM_DP0					(0x01)
+#define	MCI_AA_PWM_DIGITAL_DEF			(MCB_AA_PWM_DP2 | MCB_AA_PWM_DP1 | MCB_AA_PWM_DP0)
+
+#define	MCI_AA_PWM_DIGITAL_1			(3)
+#define	MCB_AA_PWM_DPPDM				(0x10)
+#define	MCB_AA_PWM_DPDI2				(0x08)
+#define	MCB_AA_PWM_DPDI1				(0x04)
+#define	MCB_AA_PWM_DPDI0				(0x02)
+#define	MCB_AA_PWM_DPB					(0x01)
+#define	MCI_AA_PWM_DIGITAL_1_DEF		(MCB_AA_PWM_DPPDM | MCB_AA_PWM_DPDI2 | MCB_AA_PWM_DPDI1 | MCB_AA_PWM_DPDI0 | MCB_AA_PWM_DPB)
+
+#define	MCI_AA_PWM_DIGITAL_CDSP		(4)
+#define	MCB_AA_PWM_DPCDSP				(0x00)
+#define	MCI_AA_PWM_DIGITAL_CDSP_DEF	(MCB_AA_PWM_DPCDSP)
+
+#define	MCI_AA_PWM_DIGITAL_BDSP		(6)
+#define	MCI_AA_PWM_DIGITAL_BDSP_DEF	(MCB_AA_PWM_DPBDSP)
+#define	MCB_AA_PWM_DPBDSP				(0x01)
+
+#define	MCI_AA_SD_MSK					(9)
+#define	MCB_AA_SDIN_MSK2				(0x80)
+#define	MCB_AA_SDO_DDR2				(0x10)
+#define	MCB_AA_SDIN_MSK1				(0x08)
+#define	MCB_AA_SDO_DDR1				(0x01)
+#define	MCI_AA_SD_MSK_DEF				(MCB_AA_SDIN_MSK2 | MCB_AA_SDIN_MSK1)
+
+#define	MCI_AA_SD_MSK_1				(10)
+#define	MCB_AA_SDIN_MSK0				(0x80)
+#define	MCB_AA_SDO_DDR0				(0x10)
+#define	MCI_AA_SD_MSK_1_DEF			(MCB_AA_SDIN_MSK0)
+
+#define	MCI_AA_BCLK_MSK				(11)
+#define	MCB_AA_BCLK_MSK2				(0x80)
+#define	MCB_AA_BCLK_DDR2				(0x40)
+#define	MCB_AA_LRCK_MSK2				(0x20)
+#define	MCB_AA_LRCK_DDR2				(0x10)
+#define	MCB_AA_BCLK_MSK1				(0x08)
+#define	MCB_AA_BCLK_DDR1				(0x04)
+#define	MCB_AA_LRCK_MSK1				(0x02)
+#define	MCB_AA_LRCK_DDR1				(0x01)
+#define	MCI_AA_BCLK_MSK_DEF			(MCB_AA_BCLK_MSK2 | MCB_AA_LRCK_MSK2 | MCB_AA_BCLK_MSK1 | MCB_AA_LRCK_MSK1)
+
+#define	MCI_AA_BCLK_MSK_1				(12)
+#define	MCB_AA_BCLK_MSK0				(0x80)
+#define	MCB_AA_BCLK_DDR0				(0x40)
+#define	MCB_AA_LRCK_MSK0				(0x20)
+#define	MCB_AA_LRCK_DDR0				(0x10)
+#define	MCB_AA_PCMOUT_HIZ2				(0x08)
+#define	MCB_AA_PCMOUT_HIZ1				(0x04)
+#define	MCB_AA_PCMOUT_HIZ0				(0x02)
+#define	MCB_AA_ROUTER_MS				(0x01)
+#define	MCI_AA_BCLK_MSK_1_DEF			(MCB_AA_BCLK_MSK0 | MCB_AA_LRCK_MSK0)
+
+#define	MCI_AA_BCKP					(13)
+#define	MCB_AA_DI2_BCKP				(0x04)
+#define	MCB_AA_DI1_BCKP				(0x02)
+#define	MCB_AA_DI0_BCKP				(0x01)
+#define	MCI_AA_BCKP_DEF				(0)
+
+#define	MCI_AA_PLL_RST					(14)
+#define	MCB_AA_PLLRST1					(0x00)
+#define	MCB_AA_PLLRST0					(0x01)
+#define	MCI_AA_PLL_RST_DEF				(MCB_AA_PLLRST1 | MCB_AA_PLLRST0)
+
+#define	MCI_AA_DIVR0					(15)
+#define	MCI_AA_DIVR0_DEF				(0x0A)
+
+#define	MCI_AA_DIVF0					(16)
+#define	MCI_AA_DIVF0_DEF				(0x48)
+
+#define	MCI_AA_DIVR1					(17)
+#define	MCI_AA_DIVF1					(18)
+
+#define	MCI_AA_CKSEL					(20)
+#define	MCB_AA_CKSEL					(0x80)
+
+#define	MCI_AA_BYPASS					(21)
+#define	MCB_AA_LOCK1					(0x80)
+#define	MCB_AA_LOCK0					(0x40)
+#define	MCB_AA_BYPASS1					(0x02)
+#define	MCB_AA_BYPASS0					(0x01)
+
+#define	MCI_AA_EPA_IRQ					(22)
+#define	MCB_AA_EPA2_IRQ				(0x04)
+#define	MCB_AA_EPA1_IRQ				(0x02)
+#define	MCB_AA_EPA0_IRQ				(0x01)
+
+#define	MCI_AA_PA_FLG					(23)
+#define	MCB_AA_PA2_FLAG				(0x04)
+#define	MCB_AA_PA1_FLAG				(0x02)
+#define	MCB_AA_PA0_FLAG				(0x01)
+
+#define	MCI_AA_PA_MSK					(25)
+#define	MCB_AA_PA2_MSK					(0x08)
+#define	MCB_AA_PA2_DDR					(0x04)
+#define	MCI_AA_PA_MSK_DEF				(MCB_AA_PA2_MSK)
+
+#define	MCI_AA_PA_MSK_1				(26)
+#define	MCB_AA_PA1_MSK					(0x80)
+#define	MCB_AA_PA1_DDR					(0x40)
+#define	MCB_AA_PA0_MSK					(0x08)
+#define	MCB_AA_PA0_DDR					(0x04)
+#define	MCI_AA_PA_MSK_1_DEF			(MCB_AA_PA1_MSK | MCB_AA_PA0_MSK)
+
+#define	MCI_AA_PA_HOST					(28)
+#define	MCI_AA_PA_HOST_1				(29)
+
+#define	MCI_AA_PA_OUT					(30)
+#define	MCB_AA_PA_OUT					(0x01)
+
+#define	MCI_AA_PA_SCU_PA				(31)
+#define	MCB_AA_PA_SCU_PA0				(0x01)
+#define	MCB_AA_PA_SCU_PA1				(0x02)
+#define	MCB_AA_PA_SCU_PA2				(0x04)
+
+/*	B_ADR(MIX)	*/
+#define	MCI_AA_DIT_INVFLAGL			(0)
+#define	MCB_AA_DIT0_INVFLAGL			(0x20)
+#define	MCB_AA_DIT1_INVFLAGL			(0x10)
+#define	MCB_AA_DIT2_INVFLAGL			(0x08)
+
+#define	MCI_AA_DIT_INVFLAGR			(1)
+#define	MCB_AA_DIT0_INVFLAGR			(0x20)
+#define	MCB_AA_DIT1_INVFLAGR			(0x10)
+#define	MCB_AA_DIT2_INVFLAGR			(0x08)
+
+#define	MCI_AA_DIR_VFLAGL				(2)
+#define	MCB_AA_PDM0_VFLAGL				(0x80)
+#define	MCB_AA_DIR0_VFLAGL				(0x20)
+#define	MCB_AA_DIR1_VFLAGL				(0x10)
+#define	MCB_AA_DIR2_VFLAGL				(0x08)
+
+#define	MCI_AA_DIR_VFLAGR				(3)
+#define	MCB_AA_PDM0_VFLAGR				(0x80)
+#define	MCB_AA_DIR0_VFLAGR				(0x20)
+#define	MCB_AA_DIR1_VFLAGR				(0x10)
+#define	MCB_AA_DIR2_VFLAGR				(0x08)
+
+#define	MCI_AA_AD_VFLAGL				(4)
+#define	MCB_AA_ADC_VFLAGL				(0x80)
+#define	MCB_AA_AENG6_VFLAGL			(0x20)
+
+#define	MCI_AA_AD_VFLAGR				(5)
+#define	MCB_AA_ADC_VFLAGR				(0x80)
+#define	MCB_AA_AENG6_VFLAGR			(0x20)
+
+#define	MCI_AA_AFLAGL					(6)
+#define	MCB_AA_ADC_AFLAGL				(0x40)
+#define	MCB_AA_DIR0_AFLAGL				(0x20)
+#define	MCB_AA_DIR1_AFLAGL				(0x10)
+#define	MCB_AA_DIR2_AFLAGL				(0x04)
+
+#define	MCI_AA_AFLAGR					(7)
+#define	MCB_AA_ADC_AFLAGR				(0x40)
+#define	MCB_AA_DIR0_AFLAGR				(0x20)
+#define	MCB_AA_DIR1_AFLAGR				(0x10)
+#define	MCB_AA_DIR2_AFLAGR				(0x04)
+
+#define	MCI_AA_DAC_INS_FLAG			(8)
+#define	MCB_AA_DAC_INS_FLAG			(0x80)
+
+#define	MCI_AA_INS_FLAG				(9)
+#define	MCB_AA_ADC_INS_FLAG			(0x40)
+#define	MCB_AA_DIR0_INS_FLAG			(0x20)
+#define	MCB_AA_DIR1_INS_FLAG			(0x10)
+#define	MCB_AA_DIR2_INS_FLAG			(0x04)
+
+#define	MCI_AA_DAC_FLAGL				(10)
+#define	MCB_AA_ST_FLAGL				(0x80)
+#define	MCB_AA_MASTER_OFLAGL			(0x40)
+#define	MCB_AA_VOICE_FLAGL				(0x10)
+#define	MCB_AA_DAC_FLAGL				(0x02)
+
+#define	MCI_AA_DAC_FLAGR				(11)
+#define	MCB_AA_ST_FLAGR				(0x80)
+#define	MCB_AA_MASTER_OFLAGR			(0x40)
+#define	MCB_AA_VOICE_FLAGR				(0x10)
+#define	MCB_AA_DAC_FLAGR				(0x02)
+
+#define	MCI_AA_DIT0_INVOLL				(12)
+#define	MCB_AA_DIT0_INLAT				(0x80)
+#define	MCB_AA_DIT0_INVOLL				(0x7F)
+
+#define	MCI_AA_DIT0_INVOLR				(13)
+#define	MCB_AA_DIT0_INVOLR				(0x7F)
+
+#define	MCI_AA_DIT1_INVOLL				(14)
+#define	MCB_AA_DIT1_INLAT				(0x80)
+#define	MCB_AA_DIT1_INVOLL				(0x7F)
+
+#define	MCI_AA_DIT1_INVOLR				(15)
+#define	MCB_AA_DIT1_INVOLR				(0x7F)
+
+#define	MCI_AA_DIT2_INVOLL				(16)
+#define	MCB_AA_DIT2_INLAT				(0x80)
+#define	MCB_AA_DIT2_INVOLL				(0x7F)
+
+#define	MCI_AA_DIT2_INVOLR				(17)
+#define	MCB_AA_DIT2_INVOLR				(0x7F)
+
+#define	MCI_AA_ESRC0_INVOLL			(16)
+#define	MCI_AA_ESRC0_INVOLR			(17)
+
+#define	MCI_AA_PDM0_VOLL				(24)
+#define	MCB_AA_PDM0_INLAT				(0x80)
+#define	MCB_AA_PDM0_VOLL				(0x7F)
+
+#define	MCI_AA_PDM0_VOLR				(25)
+#define	MCB_AA_PDM0_VOLR				(0x7F)
+
+#define	MCI_AA_DIR0_VOLL				(28)
+#define	MCB_AA_DIR0_LAT				(0x80)
+#define	MCB_AA_DIR0_VOLL				(0x7F)
+
+#define	MCI_AA_DIR0_VOLR				(29)
+#define	MCB_AA_DIR0_VOLR				(0x7F)
+
+#define	MCI_AA_DIR1_VOLL				(30)
+#define	MCB_AA_DIR1_LAT				(0x80)
+#define	MCB_AA_DIR1_VOLL				(0x7F)
+
+#define	MCI_AA_DIR1_VOLR				(31)
+#define	MCB_AA_DIR1_VOLR				(0x7F)
+
+#define	MCI_AA_DIR2_VOLL				(32)
+#define	MCB_AA_DIR2_LAT				(0x80)
+#define	MCB_AA_DIR2_VOLL				(0x7F)
+
+#define	MCI_AA_DIR2_VOLR				(33)
+#define	MCB_AA_DIR2_VOLR				(0x7F)
+/*
+#define	MCI_AA_ADC1_VOLL				(38?)
+#define	MCB_AA_ADC1_LAT				(0x80)
+#define	MCB_AA_ADC1_VOLL				(0x7F)
+
+#define	MCI_AA_ADC1_VOLR				(39?)
+#define	MCB_AA_ADC1_VOLR				(0x7F)
+*/
+#define	MCI_AA_ADC_VOLL				(40)
+#define	MCB_AA_ADC_LAT					(0x80)
+#define	MCB_AA_ADC_VOLL				(0x7F)
+
+#define	MCI_AA_ADC_VOLR				(41)
+#define	MCB_AA_ADC_VOLR				(0x7F)
+/*
+#define	MCI_AA_DTMFB_VOLL				(42)
+#define	MCI_AA_DTMFB_VOLR				(43)
+*/
+#define	MCI_AA_AENG6_VOLL				(44)
+#define	MCB_AA_AENG6_LAT				(0x80)
+#define	MCB_AA_AENG6_VOLL				(0x7F)
+
+#define	MCI_AA_AENG6_VOLR				(45)
+#define	MCB_AA_AENG6_VOLR				(0x7F)
+
+#define	MCI_AA_DIT_ININTP				(50)
+#define	MCB_AA_DIT0_ININTP				(0x20)
+#define	MCB_AA_DIT1_ININTP				(0x10)
+#define	MCB_AA_DIT2_ININTP				(0x08)
+#define	MCI_AA_DIT_ININTP_DEF			(MCB_AA_DIT0_ININTP | MCB_AA_DIT1_ININTP | MCB_AA_DIT2_ININTP)
+
+#define	MCI_AA_DIR_INTP				(51)
+#define	MCB_AA_PDM0_INTP				(0x80)
+#define	MCB_AA_DIR0_INTP				(0x20)
+#define	MCB_AA_DIR1_INTP				(0x10)
+#define	MCB_AA_DIR2_INTP				(0x08)
+#define	MCB_AA_ADC2_INTP				(0x01)
+#define	MCI_AA_DIR_INTP_DEF			(MCB_AA_PDM0_INTP | MCB_AA_DIR0_INTP | MCB_AA_DIR1_INTP | MCB_AA_DIR2_INTP)
+
+#define	MCI_AA_ADC_INTP				(52)
+#define	MCB_AA_ADC_INTP				(0x80)
+#define	MCB_AA_AENG6_INTP				(0x20)
+#define	MCI_AA_ADC_INTP_DEF			(MCB_AA_ADC_INTP | MCB_AA_AENG6_INTP)
+
+#define	MCI_AA_ADC_ATTL				(54)
+#define	MCB_AA_ADC_ALAT				(0x80)
+#define	MCB_AA_ADC_ATTL				(0x7F)
+
+#define	MCI_AA_ADC_ATTR				(55)
+#define	MCB_AA_ADC_ATTR				(0x7F)
+
+#define	MCI_AA_DIR0_ATTL				(56)
+#define	MCB_AA_DIR0_ALAT				(0x80)
+#define	MCB_AA_DIR0_ATTL				(0x7F)
+
+#define	MCI_AA_DIR0_ATTR				(57)
+#define	MCB_AA_DIR0_ATTR				(0x7F)
+
+#define	MCI_AA_DIR1_ATTL				(58)
+#define	MCB_AA_DIR1_ALAT				(0x80)
+#define	MCB_AA_DIR1_ATTL				(0x7F)
+
+#define	MCI_AA_DIR1_ATTR				(59)
+#define	MCB_AA_DIR1_ATTR				(0x7F)
+/*
+#define	MCI_AA_ADC2_ATTL				(60)
+#define	MCI_AA_ADC2_ATTR				(61)
+*/
+#define	MCI_AA_DIR2_ATTL				(62)
+#define	MCB_AA_DIR2_ALAT				(0x80)
+#define	MCB_AA_DIR2_ATTL				(0x7F)
+
+#define	MCI_AA_DIR2_ATTR				(63)
+#define	MCB_AA_DIR2_ATTR				(0x7F)
+
+#define	MCI_AA_AINTP					(72)
+#define	MCB_AA_ADC_AINTP				(0x40)
+#define	MCB_AA_DIR0_AINTP				(0x20)
+#define	MCB_AA_DIR1_AINTP				(0x10)
+#define	MCB_AA_DIR2_AINTP				(0x04)
+#define	MCI_AA_AINTP_DEF				(MCB_AA_ADC_AINTP | MCB_AA_DIR0_AINTP | MCB_AA_DIR1_AINTP | MCB_AA_DIR2_AINTP)
+
+#define	MCI_AA_DAC_INS					(74)
+#define	MCB_AA_DAC_INS					(0x80)
+
+#define	MCI_AA_INS						(75)
+#define	MCB_AA_ADC_INS					(0x40)
+#define	MCB_AA_DIR0_INS				(0x20)
+#define	MCB_AA_DIR1_INS				(0x10)
+#define	MCB_AA_DIR2_INS				(0x04)
+
+#define	MCI_AA_IINTP					(76)
+#define	MCB_AA_DAC_IINTP				(0x80)
+#define	MCB_AA_ADC_IINTP				(0x40)
+#define	MCB_AA_DIR0_IINTP				(0x20)
+#define	MCB_AA_DIR1_IINTP				(0x10)
+#define	MCB_AA_DIR2_IINTP				(0x04)
+#define	MCI_AA_IINTP_DEF				(MCB_AA_DAC_IINTP | MCB_AA_ADC_IINTP | MCB_AA_DIR0_IINTP | MCB_AA_DIR1_IINTP | MCB_AA_DIR2_IINTP)
+
+#define	MCI_AA_ST_VOLL					(77)
+#define	MCB_AA_ST_LAT					(0x80)
+#define	MCB_AA_ST_VOLL					(0x7F)
+
+#define	MCI_AA_ST_VOLR					(78)
+#define	MCB_AA_ST_VOLR					(0x7F)
+
+#define	MCI_AA_MASTER_OUTL				(79)
+#define	MCB_AA_MASTER_OLAT				(0x80)
+#define	MCB_AA_MASTER_OUTL				(0x7F)
+
+#define	MCI_AA_MASTER_OUTR				(80)
+#define	MCB_AA_MASTER_OUTR				(0x7F)
+
+#define	MCI_AA_VOICE_ATTL				(83)
+#define	MCB_AA_VOICE_LAT				(0x80)
+#define	MCB_AA_VOICE_ATTL				(0x7F)
+
+#define	MCI_AA_VOICE_ATTR				(84)
+#define	MCB_AA_VOICE_ATTR				(0x7F)
+/*
+#define	MCI_AA_DTMF_ATTL				(85)
+#define	MCI_AA_DTMF_ATTR				(86)
+*/
+#define	MCI_AA_DAC_ATTL				(89)
+#define	MCB_AA_DAC_LAT					(0x80)
+#define	MCB_AA_DAC_ATTL				(0x7F)
+
+#define	MCI_AA_DAC_ATTR				(90)
+#define	MCB_AA_DAC_ATTR				(0x7F)
+
+#define	MCI_AA_DAC_INTP				(93)
+#define	MCB_AA_ST_INTP					(0x80)
+#define	MCB_AA_MASTER_OINTP			(0x40)
+#define	MCB_AA_VOICE_INTP				(0x10)
+/*#define	MCB_AA_DTMF_INTP				(0x08)*/
+#define	MCB_AA_DAC_INTP				(0x02)
+#define	MCI_AA_DAC_INTP_DEF			(MCB_AA_ST_INTP | MCB_AA_MASTER_OINTP | MCB_AA_VOICE_INTP | MCB_AA_DAC_INTP)
+
+#define	MCI_AA_SOURCE					(110)
+#define	MCB_AA_DAC_SOURCE_AD			(0x10)
+#define	MCB_AA_DAC_SOURCE_DIR2			(0x20)
+#define	MCB_AA_DAC_SOURCE_DIR0			(0x30)
+#define	MCB_AA_DAC_SOURCE_DIR1			(0x40)
+#define	MCB_AA_DAC_SOURCE_MIX			(0x70)
+#define	MCB_AA_VOICE_SOURCE_AD			(0x01)
+#define	MCB_AA_VOICE_SOURCE_DIR2		(0x02)
+#define	MCB_AA_VOICE_SOURCE_DIR0		(0x03)
+#define	MCB_AA_VOICE_SOURCE_DIR1		(0x04)
+#define	MCB_AA_VOICE_SOURCE_MIX		(0x07)
+
+#define	MCI_AA_SWP						(111)
+
+#define	MCI_AA_SRC_SOURCE				(112)
+#define	MCB_AA_DIT0_SOURCE_AD			(0x10)
+#define	MCB_AA_DIT0_SOURCE_DIR2		(0x20)
+#define	MCB_AA_DIT0_SOURCE_DIR0		(0x30)
+#define	MCB_AA_DIT0_SOURCE_DIR1		(0x40)
+#define	MCB_AA_DIT0_SOURCE_MIX			(0x70)
+#define	MCB_AA_DIT1_SOURCE_AD			(0x01)
+#define	MCB_AA_DIT1_SOURCE_DIR2		(0x02)
+#define	MCB_AA_DIT1_SOURCE_DIR0		(0x03)
+#define	MCB_AA_DIT1_SOURCE_DIR1		(0x04)
+#define	MCB_AA_DIT1_SOURCE_MIX			(0x07)
+
+#define	MCI_AA_SRC_SOURCE_1			(113)
+#define	MCB_AA_AE_SOURCE_AD			(0x10)
+#define	MCB_AA_AE_SOURCE_DIR2			(0x20)
+#define	MCB_AA_AE_SOURCE_DIR0			(0x30)
+#define	MCB_AA_AE_SOURCE_DIR1			(0x40)
+#define	MCB_AA_AE_SOURCE_MIX			(0x70)
+#define	MCB_AA_DIT2_SOURCE_AD			(0x01)
+#define	MCB_AA_DIT2_SOURCE_DIR2		(0x02)
+#define	MCB_AA_DIT2_SOURCE_DIR0		(0x03)
+#define	MCB_AA_DIT2_SOURCE_DIR1		(0x04)
+#define	MCB_AA_DIT2_SOURCE_MIX			(0x07)
+
+#define	MCI_AA_ESRC_SOURCE				(114)
+
+#define	MCI_AA_AENG6_SOURCE			(115)
+#define	MCB_AA_AENG6_ADC0				(0x00)
+#define	MCB_AA_AENG6_PDM				(0x01)
+
+#define	MCI_AA_EFIFO_SOURCE			(116)
+
+#define	MCI_AA_SRC_SOURCE_2			(117)
+
+#define	MCI_AA_PEAK_METER				(121)
+
+#define	MCI_AA_OVFL					(122)
+#define	MCI_AA_OVFR					(123)
+
+#define	MCI_AA_DIMODE0					(130)
+
+#define	MCI_AA_DIRSRC_RATE0_MSB		(131)
+
+#define	MCI_AA_DIRSRC_RATE0_LSB		(132)
+
+#define	MCI_AA_DITSRC_RATE0_MSB		(133)
+
+#define	MCI_AA_DITSRC_RATE0_LSB		(134)
+
+#define	MCI_AA_DI_FS0					(135)
+
+/*	DI Common Parameter	*/
+#define	MCB_AA_DICOMMON_SRC_RATE_SET	(0x01)
+
+#define	MCI_AA_DI0_SRC					(136)
+
+#define	MCI_AA_DIX0_START				(137)
+#define	MCB_AA_DITIM0_START			(0x40)
+#define	MCB_AA_DIR0_SRC_START			(0x08)
+#define	MCB_AA_DIR0_START				(0x04)
+#define	MCB_AA_DIT0_SRC_START			(0x02)
+#define	MCB_AA_DIT0_START				(0x01)
+
+#define	MCI_AA_DIX0_FMT				(142)
+
+#define	MCI_AA_DIR0_CH					(143)
+#define	MCI_AA_DIR0_CH_DEF				(0x10)
+
+#define	MCI_AA_DIT0_SLOT				(144)
+#define	MCI_AA_DIT0_SLOT_DEF			(0x10)
+
+#define	MCI_AA_HIZ_REDGE0				(145)
+
+#define	MCI_AA_PCM_RX0					(146)
+#define	MCB_AA_PCM_MONO_RX0			(0x80)
+#define	MCI_AA_PCM_RX0_DEF				(MCB_AA_PCM_MONO_RX0)
+
+#define	MCI_AA_PCM_SLOT_RX0			(147)
+
+#define	MCI_AA_PCM_TX0					(148)
+#define	MCB_AA_PCM_MONO_TX0			(0x80)
+#define	MCI_AA_PCM_TX0_DEF				(MCB_AA_PCM_MONO_TX0)
+
+#define	MCI_AA_PCM_SLOT_TX0			(149)
+#define	MCI_AA_PCM_SLOT_TX0_DEF		(0x10)
+
+#define	MCI_AA_DIMODE1					(150)
+
+#define	MCI_AA_DIRSRC_RATE1_MSB		(151)
+#define	MCI_AA_DIRSRC_RATE1_LSB		(152)
+
+#define	MCI_AA_DITSRC_RATE1_MSB		(153)
+#define	MCI_AA_DITSRC_RATE1_LSB		(154)
+
+#define	MCI_AA_DI_FS1					(155)
+
+#define	MCI_AA_DI1_SRC					(156)
+
+#define	MCI_AA_DIX1_START				(157)
+#define	MCB_AA_DITIM1_START			(0x40)
+#define	MCB_AA_DIR1_SRC_START			(0x08)
+#define	MCB_AA_DIR1_START				(0x04)
+#define	MCB_AA_DIT1_SRC_START			(0x02)
+#define	MCB_AA_DIT1_START				(0x01)
+
+#define	MCI_AA_DIX1_FMT				(162)
+
+#define	MCI_AA_DIR1_CH					(163)
+#define	MCB_AA_DIR1_CH1				(0x10)
+#define	MCI_AA_DIR1_CH_DEF				(MCB_AA_DIR1_CH1)
+
+#define	MCI_AA_DIT1_SLOT				(164)
+#define	MCB_AA_DIT1_SLOT1				(0x10)
+#define	MCI_AA_DIT1_SLOT_DEF			(MCB_AA_DIT1_SLOT1)
+
+#define	MCI_AA_HIZ_REDGE1				(165)
+
+#define	MCI_AA_PCM_RX1					(166)
+#define	MCB_AA_PCM_MONO_RX1			(0x80)
+#define	MCI_AA_PCM_RX1_DEF				(MCB_AA_PCM_MONO_RX1)
+
+#define	MCI_AA_PCM_SLOT_RX1			(167)
+
+#define	MCI_AA_PCM_TX1					(168)
+#define	MCB_AA_PCM_MONO_TX1			(0x80)
+#define	MCI_AA_PCM_TX1_DEF				(MCB_AA_PCM_MONO_TX1)
+
+#define	MCI_AA_PCM_SLOT_TX1			(169)
+#define	MCI_AA_PCM_SLOT_TX1_DEF		(0x10)
+
+#define	MCI_AA_DIMODE2					(170)
+
+#define	MCI_AA_DIRSRC_RATE2_MSB		(171)
+#define	MCI_AA_DIRSRC_RATE2_LSB		(172)
+
+#define	MCI_AA_DITSRC_RATE2_MSB		(173)
+#define	MCI_AA_DITSRC_RATE2_LSB		(174)
+
+#define	MCI_AA_DI_FS2					(175)
+
+#define	MCI_AA_DI2_SRC					(176)
+
+#define	MCI_AA_DIX2_START				(177)
+#define	MCB_AA_DITIM2_START			(0x40)
+#define	MCB_AA_DIR2_SRC_START			(0x08)
+#define	MCB_AA_DIR2_START				(0x04)
+#define	MCB_AA_DIT2_SRC_START			(0x02)
+#define	MCB_AA_DIT2_START				(0x01)
+
+#define	MCI_AA_DIX2_FMT				(182)
+
+#define	MCI_AA_DIR2_CH					(183)
+#define	MCB_AA_DIR2_CH1				(0x10)
+#define	MCB_AA_DIR2_CH0				(0x01)
+#define	MCI_AA_DIR2_CH_DEF				(MCB_AA_DIR2_CH1)
+
+#define	MCI_AA_DIT2_SLOT				(184)
+#define	MCB_AA_DIT2_SLOT1				(0x10)
+#define	MCB_AA_DIT2_SLOT0				(0x01)
+#define	MCI_AA_DIT2_SLOT_DEF			(MCB_AA_DIT2_SLOT1)
+
+#define	MCI_AA_HIZ_REDGE2				(185)
+
+#define	MCI_AA_PCM_RX2					(186)
+#define	MCB_AA_PCM_MONO_RX2			(0x80)
+#define	MCI_AA_PCM_RX2_DEF				(MCB_AA_PCM_MONO_RX2)
+
+#define	MCI_AA_PCM_SLOT_RX2			(187)
+
+#define	MCI_AA_PCM_TX2					(188)
+#define	MCB_AA_PCM_MONO_TX2			(0x80)
+#define	MCI_AA_PCM_TX2_DEF				(MCB_AA_PCM_MONO_TX2)
+
+#define	MCI_AA_PCM_SLOT_TX2			(189)
+#define	MCI_AA_PCM_SLOT_TX2_DEF		(0x10)
+
+#define	MCI_AA_CD_START				(192)
+
+#define	MCI_AA_CDI_CH					(193)
+#define	MCI_AA_CDI_CH_DEF				(0xE4)
+
+#define	MCI_AA_CDO_SLOT				(194)
+#define	MCI_AA_CDO_SLOT_DEF			(0xE4)
+
+#define	MCI_AA_PDM_AGC					(200)
+#define	MCI_AA_PDM_AGC_DEF				(0x03)
+
+#define	MCI_AA_PDM_MUTE				(201)
+#define	MCI_AA_PDM_MUTE_DEF			(0x00)
+#define	MCB_AA_PDM_MUTE				(0x01)
+
+#define	MCI_AA_PDM_START				(202)
+#define	MCB_AA_PDM_MN					(0x02)
+#define	MCB_AA_PDM_START				(0x01)
+
+#define	MCI_AA_PDM_STWAIT				(205)
+#define	MCI_AA_PDM_STWAIT_DEF			(0x40)
+
+#define	MCI_AA_HP_ID					(206)
+
+#define	MCI_AA_CHP_H					(207)
+#define	MCI_AA_CHP_H_DEF				(0x3F)
+
+#define	MCI_AA_CHP_M					(208)
+#define	MCI_AA_CHP_M_DEF				(0xEA)
+
+#define	MCI_AA_CHP_L					(209)
+#define	MCI_AA_CHP_L_DEF				(0x94)
+
+#define	MCI_AA_SINGEN0_VOL				(210)
+#define	MCI_AA_SINGEN1_VOL				(211)
+
+#define	MCI_AA_SINGEN_FREQ0_MSB		(212)
+#define	MCI_AA_SINGEN_FREQ0_LSB		(213)
+
+#define	MCI_AA_SINGEN_FREQ1_MSB		(214)
+#define	MCI_AA_SINGEN_FREQ1_LSB		(215)
+
+#define	MCI_AA_SINGEN_GATETIME			(216)
+
+#define	MCI_AA_SINGEN_FLAG				(217)
+
+/*	BADR(AE)	*/
+#define	MCI_AA_BAND0_CEQ0				(0)
+#define	MCI_AA_BAND0_CEQ0_H_DEF		(0x10)
+
+#define	MCI_AA_BAND1_CEQ0				(15)
+#define	MCI_AA_BAND1_CEQ0_H_DEF		(0x10)
+
+#define	MCI_AA_BAND2_CEQ0				(30)
+#define	MCI_AA_BAND2_CEQ0_H_DEF		(0x10)
+
+#define	MCI_AA_BAND3H_CEQ0				(45)
+#define	MCI_AA_BAND3H_CEQ0_H_DEF		(0x10)
+
+#define	MCI_AA_BAND4H_CEQ0				(75)
+#define	MCI_AA_BAND4H_CEQ0_H_DEF		(0x10)
+
+#define	MCI_AA_BAND5_CEQ0				(105)
+#define	MCI_AA_BAND5_CEQ0_H_DEF		(0x10)
+
+#define	MCI_AA_BAND6H_CEQ0				(120)
+#define	MCI_AA_BAND6H_CEQ0_H_DEF		(0x10)
+
+#define	MCI_AA_BAND7H_CEQ0				(150)
+#define	MCI_AA_BAND7H_CEQ0_H_DEF		(0x10)
+
+#define	MCI_AA_PDM_CHP0_H				(240)
+#define	MCI_AA_PDM_CHP0_H_DEF			(0x3F)
+#define	MCI_AA_PDM_CHP0_M				(241)
+#define	MCI_AA_PDM_CHP0_M_DEF			(0xEA)
+#define	MCI_AA_PDM_CHP0_L				(242)
+#define	MCI_AA_PDM_CHP0_L_DEF			(0x94)
+
+#define	MCI_AA_PDM_CHP1_H				(243)
+#define	MCI_AA_PDM_CHP1_H_DEF			(0xC0)
+#define	MCI_AA_PDM_CHP1_M				(244)
+#define	MCI_AA_PDM_CHP1_M_DEF			(0x15)
+#define	MCI_AA_PDM_CHP1_L				(245)
+#define	MCI_AA_PDM_CHP1_L_DEF			(0x6C)
+
+#define	MCI_AA_PDM_CHP2_H				(246)
+#define	MCI_AA_PDM_CHP2_H_DEF			(0x00)
+#define	MCI_AA_PDM_CHP2_M				(247)
+#define	MCI_AA_PDM_CHP2_M_DEF			(0x00)
+#define	MCI_AA_PDM_CHP2_L				(248)
+#define	MCI_AA_PDM_CHP2_L_DEF			(0x00)
+
+#define	MCI_AA_PDM_CHP3_H				(249)
+#define	MCI_AA_PDM_CHP3_H_DEF			(0x3F)
+#define	MCI_AA_PDM_CHP3_M				(250)
+#define	MCI_AA_PDM_CHP3_M_DEF			(0xD5)
+#define	MCI_AA_PDM_CHP3_L				(251)
+#define	MCI_AA_PDM_CHP3_L_DEF			(0x29)
+
+#define	MCI_AA_PDM_CHP4_H				(252)
+#define	MCI_AA_PDM_CHP4_H_DEF			(0x00)
+#define	MCI_AA_PDM_CHP4_M				(253)
+#define	MCI_AA_PDM_CHP4_M_DEF			(0x00)
+#define	MCI_AA_PDM_CHP4_L				(254)
+#define	MCI_AA_PDM_CHP4_L_DEF			(0x00)
+
+/*	B_ADR(CDSP)	*/
+#define	MCI_AA_CDSP_SAVEOFF			(0)
+
+#define	MCI_AA_OFIFO_LVL				(1)
+
+#define	MCI_AA_EFIFO_LVL				(2)
+
+#define	MCI_AA_DEC_POS_24				(4)
+#define	MCI_AA_DEC_POS_16				(5)
+#define	MCI_AA_DEC_POS_8				(6)
+#define	MCI_AA_DEC_POS_0				(7)
+
+#define	MCI_AA_ENC_POS_24				(8)
+#define	MCI_AA_ENC_POS_16				(9)
+#define	MCI_AA_ENC_POS_8				(10)
+#define	MCI_AA_ENC_POS_0				(11)
+
+#define	MCI_AA_DEC_ERR					(12)
+#define	MCI_AA_ENC_ERR					(13)
+
+#define	MCI_AA_FIFO_RST				(14)
+
+#define	MCI_AA_DEC_ENC_START			(15)
+
+#define	MCI_AA_FIFO4CH					(16)
+
+#define	MCI_AA_DEC_CTL15				(19)
+
+#define	MCI_AA_DEC_GPR15				(35)
+
+#define	MCI_AA_DEC_SFR1				(51)
+#define	MCI_AA_DEC_SFR0				(52)
+
+#define	MCI_AA_ENC_CTL15				(53)
+
+#define	MCI_AA_ENC_GPR15				(69)
+
+#define	MCI_AA_ENC_SFR1				(85)
+#define	MCI_AA_ENC_SFR0				(86)
+
+#define	MCI_AA_JOEMP					(92)
+#define	MCB_AA_JOEMP					(0x80)
+#define	MCB_AA_JOPNT					(0x40)
+#define	MCB_AA_OOVF_FLG				(0x08)
+#define	MCB_AA_OUDF_FLG				(0x04)
+#define	MCB_AA_OEMP_FLG				(0x02)
+#define	MCB_AA_OPNT_FLG				(0x01)
+#define	MCI_AA_JOEMP_DEF				(MCB_AA_JOEMP | MCB_AA_OEMP_FLG)
+
+#define	MCI_AA_JEEMP					(93)
+#define	MCB_AA_JEEMP					(0x80)
+#define	MCB_AA_JEPNT					(0x40)
+#define	MCB_AA_EOVF_FLG				(0x08)
+#define	MCB_AA_EUDF_FLG				(0x04)
+#define	MCB_AA_EEMP_FLG				(0x02)
+#define	MCB_AA_EPNT_FLG				(0x01)
+#define	MCI_AA_JEEMP_DEF				(MCB_AA_JEEMP | MCB_AA_EEMP_FLG)
+
+#define	MCI_AA_DEC_FLG					(96)
+#define	MCI_AA_ENC_FLG					(97)
+
+#define	MCI_AA_DEC_GPR_FLG				(98)
+#define	MCI_AA_ENC_GPR_FLG				(99)
+
+#define	MCI_AA_EOPNT					(101)
+
+#define	MCI_AA_EDEC					(105)
+#define	MCI_AA_EENC					(106)
+
+#define	MCI_AA_EDEC_GPR				(107)
+#define	MCI_AA_EENC_GPR				(108)
+
+#define	MCI_AA_CDSP_SRST				(110)
+#define	MCB_AA_CDSP_FMODE				(0x10)
+#define	MCB_AA_CDSP_MSAVE				(0x08)
+#define	MCB_AA_CDSP_SRST				(0x01)
+#define	MCI_AA_CDSP_SRST_DEF			(MCB_AA_CDSP_SRST)
+
+#define	MCI_AA_CDSP_SLEEP				(112)
+
+#define	MCI_AA_CDSP_ERR				(113)
+
+#define	MCI_AA_CDSP_MAR_MSB			(114)
+#define	MCI_AA_CDSP_MAR_LSB			(115)
+
+#define	MCI_AA_OFIFO_IRQ_PNT			(116)
+
+#define	MCI_AA_EFIFO_IRQ_PNT			(122)
+
+#define	MCI_AA_CDSP_FLG				(128)
+
+#define	MCI_AA_ECDSP_ERR				(129)
+
+/*	B_ADR(CD)	*/
+#define	MCI_AA_DPADIF					(1)
+#define	MCB_AA_DPADIF					(0x10)
+#define	MCI_AA_DPADIF_DEF				(MCB_AA_DPADIF)
+
+#define	MCI_AA_CD_HW_ID				(8)
+#define	MCI_AA_CD_HW_ID_DEF			(0x78)
+
+#define	MCI_AA_AD_AGC					(70)
+#define	MCI_AA_AD_AGC_DEF				(0x03)
+
+#define	MCI_AA_AD_MUTE					(71)
+#define	MCI_AA_AD_MUTE_DEF				(0x00)
+#define	MCB_AA_AD_MUTE					(0x01)
+
+#define	MCI_AA_AD_START				(72)
+#define	MCI_AA_AD_START_DEF			(0x00)
+#define	MCB_AA_AD_START				(0x01)
+
+#define	MCI_AA_DCCUTOFF				(77)
+#define	MCI_AA_DCCUTOFF_DEF			(0x00)
+
+#define	MCI_AA_DAC_CONFIG				(78)
+#define	MCI_AA_DAC_CONFIG_DEF			(0x02)
+#define	MCB_AA_NSMUTE					(0x02)
+#define	MCB_AA_DACON					(0x01)
+
+#define	MCI_AA_DCL						(79)
+#define	MCI_AA_DCL_DEF					(0x00)
+
+
+/*	B_ADR(ANA)	*/
+#define	MCI_AA_ANA_RST					(0)
+#define	MCI_AA_ANA_RST_DEF				(0x01)
+
+#define	MCI_AA_PWM_ANALOG_0			(2)
+#define	MCB_AA_PWM_VR					(0x01)
+#define	MCB_AA_PWM_CP					(0x02)
+#define	MCB_AA_PWM_REFA				(0x04)
+#define	MCB_AA_PWM_LDOA				(0x08)
+#define	MCI_AA_PWM_ANALOG_0_DEF		(MCB_AA_PWM_VR|MCB_AA_PWM_CP|MCB_AA_PWM_REFA|MCB_AA_PWM_LDOA)
+
+#define	MCI_AA_PWM_ANALOG_1			(3)
+#define	MCB_AA_PWM_SPL1				(0x01)
+#define	MCB_AA_PWM_SPL2				(0x02)
+#define	MCB_AA_PWM_SPR1				(0x04)
+#define	MCB_AA_PWM_SPR2				(0x08)
+#define	MCB_AA_PWM_HPL					(0x10)
+#define	MCB_AA_PWM_HPR					(0x20)
+#define	MCB_AA_PWM_ADL					(0x40)
+#define	MCB_AA_PWM_ADR					(0x80)
+#define	MCI_AA_PWM_ANALOG_1_DEF		(MCB_AA_PWM_SPL1|MCB_AA_PWM_SPL2|MCB_AA_PWM_SPR1|MCB_AA_PWM_SPR2|MCB_AA_PWM_HPL|MCB_AA_PWM_HPR|MCB_AA_PWM_ADL|MCB_AA_PWM_ADR)
+
+#define	MCI_AA_PWM_ANALOG_2			(4)
+#define	MCB_AA_PWM_LO1L				(0x01)
+#define	MCB_AA_PWM_LO1R				(0x02)
+#define	MCB_AA_PWM_LO2L				(0x04)
+#define	MCB_AA_PWM_LO2R				(0x08)
+#define	MCB_AA_PWM_RC1					(0x10)
+#define	MCB_AA_PWM_RC2					(0x20)
+#define	MCI_AA_PWM_ANALOG_2_DEF		(MCB_AA_PWM_LO1L|MCB_AA_PWM_LO1R|MCB_AA_PWM_LO2L|MCB_AA_PWM_LO2R|MCB_AA_PWM_RC1|MCB_AA_PWM_RC2)
+
+#define	MCI_AA_PWM_ANALOG_3			(5)
+#define	MCB_AA_PWM_MB1					(0x01)
+#define	MCB_AA_PWM_MB2					(0x02)
+#define	MCB_AA_PWM_MB3					(0x04)
+#define	MCB_AA_PWM_DA					(0x08)
+#define	MCI_AA_PWM_ANALOG_3_DEF		(MCB_AA_PWM_MB1|MCB_AA_PWM_MB2|MCB_AA_PWM_MB3|MCB_AA_PWM_DA)
+
+#define	MCI_AA_PWM_ANALOG_4			(6)
+#define	MCB_AA_PWM_MC1					(0x10)
+#define	MCB_AA_PWM_MC2					(0x20)
+#define	MCB_AA_PWM_MC3					(0x40)
+#define	MCB_AA_PWM_LI					(0x80)
+#define	MCI_AA_PWM_ANALOG_4_DEF		(MCB_AA_PWM_MC1|MCB_AA_PWM_MC2|MCB_AA_PWM_MC3|MCB_AA_PWM_LI)
+
+#define	MCI_AA_BUSY1					(12)
+#define	MCB_AA_RC_BUSY					(0x20)
+#define	MCB_AA_HPL_BUSY				(0x10)
+#define	MCB_AA_SPL_BUSY				(0x08)
+
+#define	MCI_AA_BUSY2					(13)
+#define	MCB_AA_HPR_BUSY				(0x10)
+#define	MCB_AA_SPR_BUSY				(0x08)
+
+#define	MCI_AA_AMP						(16)
+#define	MCB_AA_AMPOFF_SP				(0x01)
+#define	MCB_AA_AMPOFF_HP				(0x02)
+#define	MCB_AA_AMPOFF_RC				(0x04)
+
+#define	MCI_AA_DNGATRT					(20)
+#define	MCI_AA_DNGATRT_DEF				(0x22)
+
+#define	MCI_AA_DNGON					(21)
+#define	MCI_AA_DNGON_DEF				(0x34)
+
+#define	MCI_AA_DIF_LINE				(24)
+#define	MCI_AA_DIF_LINE_DEF			(0x00)
+
+#define	MCI_AA_LI1VOL_L				(25)
+#define	MCI_AA_LI1VOL_L_DEF			(0x00)
+#define	MCB_AA_ALAT_LI1				(0x40)
+#define	MCB_AA_LI1VOL_L				(0x1F)
+
+#define	MCI_AA_LI1VOL_R				(26)
+#define	MCI_AA_LI1VOL_R_DEF			(0x00)
+#define	MCB_AA_LI1VOL_R				(0x1F)
+
+#define	MCI_AA_LI2VOL_L				(27)
+#define	MCI_AA_LI2VOL_L_DEF			(0x00)
+#define	MCB_AA_ALAT_LI2				(0x40)
+#define	MCB_AA_LI2VOL_L				(0x1F)
+
+#define	MCI_AA_LI2VOL_R				(28)
+#define	MCI_AA_LI2VOL_R_DEF			(0x00)
+#define	MCB_AA_LI2VOL_R				(0x1F)
+
+#define	MCI_AA_MC1VOL					(29)
+#define	MCI_AA_MC1VOL_DEF				(0x00)
+#define	MCB_AA_MC1VOL					(0x1F)
+
+#define	MCI_AA_MC2VOL					(30)
+#define	MCI_AA_MC2VOL_DEF				(0x00)
+#define	MCB_AA_MC2VOL					(0x1F)
+
+#define	MCI_AA_MC3VOL					(31)
+#define	MCI_AA_MC3VOL_DEF				(0x00)
+#define	MCB_AA_MC3VOL					(0x1F)
+
+#define	MCI_AA_ADVOL_L					(32)
+#define	MCI_AA_ADVOL_L_DEF				(0x00)
+#define	MCB_AA_ALAT_AD					(0x40)
+#define	MCB_AA_ADVOL_L					(0x1F)
+
+#define	MCI_AA_ADVOL_R					(33)
+#define	MCB_AA_ADVOL_R					(0x1F)
+
+#define	MCI_AA_HPVOL_L					(35)
+#define	MCB_AA_ALAT_HP					(0x40)
+#define	MCB_AA_SVOL_HP					(0x20)
+#define	MCB_AA_HPVOL_L					(0x1F)
+#define	MCI_AA_HPVOL_L_DEF				(MCB_AA_SVOL_HP)
+
+#define	MCI_AA_HPVOL_R					(36)
+#define	MCI_AA_HPVOL_R_DEF				(0x00)
+#define	MCB_AA_HPVOL_R					(0x1F)
+
+#define	MCI_AA_SPVOL_L					(37)
+#define	MCB_AA_ALAT_SP					(0x40)
+#define	MCB_AA_SVOL_SP					(0x20)
+#define	MCB_AA_SPVOL_L					(0x1F)
+#define	MCI_AA_SPVOL_L_DEF				(MCB_AA_SVOL_SP)
+
+#define	MCI_AA_SPVOL_R					(38)
+#define	MCI_AA_SPVOL_R_DEF				(0x00)
+#define	MCB_AA_SPVOL_R					(0x1F)
+
+#define	MCI_AA_RCVOL					(39)
+#define	MCB_AA_SVOL_RC					(0x20)
+#define	MCB_AA_RCVOL					(0x1F)
+#define	MCI_AA_RCVOL_DEF				(MCB_AA_SVOL_RC)
+
+#define	MCI_AA_LO1VOL_L				(40)
+#define	MCI_AA_LO1VOL_L_DEF			(0x20)
+#define	MCB_AA_ALAT_LO1				(0x40)
+#define	MCB_AA_LO1VOL_L				(0x1F)
+
+#define	MCI_AA_LO1VOL_R				(41)
+#define	MCI_AA_LO1VOL_R_DEF			(0x00)
+#define	MCB_AA_LO1VOL_R				(0x1F)
+
+#define	MCI_AA_LO2VOL_L				(42)
+#define	MCI_AA_LO2VOL_L_DEF			(0x20)
+#define	MCB_AA_ALAT_LO2				(0x40)
+#define	MCB_AA_LO2VOL_L				(0x1F)
+
+#define	MCI_AA_LO2VOL_R				(43)
+#define	MCI_AA_LO2VOL_R_DEF			(0x00)
+#define	MCB_AA_LO2VOL_R				(0x1F)
+
+#define	MCI_AA_SP_MODE					(44)
+#define	MCB_AA_SPR_HIZ					(0x20)
+#define	MCB_AA_SPL_HIZ					(0x10)
+#define	MCB_AA_SPMN					(0x02)
+#define	MCB_AA_SP_SWAP					(0x01)
+
+#define	MCI_AA_MC_GAIN					(45)
+#define	MCI_AA_MC_GAIN_DEF				(0x00)
+#define	MCB_AA_MC2SNG					(0x40)
+#define	MCB_AA_MC2GAIN					(0x30)
+#define	MCB_AA_MC1SNG					(0x04)
+#define	MCB_AA_MC1GAIN					(0x03)
+
+#define	MCI_AA_MC3_GAIN				(46)
+#define	MCI_AA_MC3_GAIN_DEF			(0x00)
+#define	MCB_AA_MC3SNG					(0x04)
+#define	MCB_AA_MC3GAIN					(0x03)
+
+#define	MCI_AA_RDY_FLAG				(47)
+#define	MCB_AA_LDO_RDY					(0x80)
+#define	MCB_AA_VREF_RDY				(0x40)
+#define	MCB_AA_SPRDY_R					(0x20)
+#define	MCB_AA_SPRDY_L					(0x10)
+#define	MCB_AA_HPRDY_R					(0x08)
+#define	MCB_AA_HPRDY_L					(0x04)
+#define	MCB_AA_CPPDRDY					(0x02)
+
+/*	analog mixer common */
+#define	MCB_AA_LI1MIX					(0x01)
+#define	MCB_AA_M1MIX					(0x08)
+#define	MCB_AA_M2MIX					(0x10)
+#define	MCB_AA_M3MIX					(0x20)
+#define	MCB_AA_DAMIX					(0x40)
+#define	MCB_AA_DARMIX					(0x40)
+#define	MCB_AA_DALMIX					(0x80)
+
+#define	MCB_AA_MONO_DA					(0x40)
+#define	MCB_AA_MONO_LI1				(0x01)
+
+#define	MCI_AA_ADL_MIX					(50)
+#define	MCI_AA_ADL_MONO				(51)
+#define	MCI_AA_ADR_MIX					(52)
+#define	MCI_AA_ADR_MONO				(53)
+
+#define	MCI_AA_LO1L_MIX				(55)
+#define	MCI_AA_LO1L_MONO				(56)
+#define	MCI_AA_LO1R_MIX				(57)
+
+#define	MCI_AA_LO2L_MIX				(58)
+#define	MCI_AA_LO2L_MONO				(59)
+#define	MCI_AA_LO2R_MIX				(60)
+
+#define	MCI_AA_HPL_MIX					(61)
+#define	MCI_AA_HPL_MONO				(62)
+#define	MCI_AA_HPR_MIX					(63)
+
+#define	MCI_AA_SPL_MIX					(64)
+#define	MCI_AA_SPL_MONO				(65)
+#define	MCI_AA_SPR_MIX					(66)
+#define	MCI_AA_SPR_MONO				(67)
+
+#define	MCI_AA_RC_MIX					(69)
+
+#define	MCI_AA_HP_GAIN					(77)
+
+#define	MCI_AA_LEV						(79)
+#define	MCB_AA_AVDDLEV					(0x07)
+#define	MCI_AA_LEV_DEF					(0x24)
+
+#define	MCI_AA_AP_A1					(123)
+#define	MCB_AA_AP_CP_A					(0x10)
+#define	MCB_AA_AP_HPL_A				(0x02)
+#define	MCB_AA_AP_HPR_A				(0x01)
+
+#define	MCI_AA_AP_A2					(124)
+#define	MCB_AA_AP_RC1_A				(0x20)
+#define	MCB_AA_AP_RC2_A				(0x10)
+#define	MCB_AA_AP_SPL1_A				(0x08)
+#define	MCB_AA_AP_SPR1_A				(0x04)
+#define	MCB_AA_AP_SPL2_A				(0x02)
+#define	MCB_AA_AP_SPR2_A				(0x01)
+
+/************************************/
+
+typedef enum
+{
+	eMCDRV_DEV_ID_1N2	= 0,
+	eMCDRV_DEV_ID_1N2B,
+	eMCDRV_DEV_ID_2N,
+	eMCDRV_DEV_ID_3N
+} MCDRV_DEV_ID;
+
+typedef enum
+{
+	eMCDRV_FUNC_LI2	= 0,
+	eMCDRV_FUNC_DIVR1,
+	eMCDRV_FUNC_DIVF1,
+	eMCDRV_FUNC_RANGE,
+	eMCDRV_FUNC_BYPASS,
+	eMCDRV_FUNC_ADC1,
+	eMCDRV_FUNC_PAD2,
+	eMCDRV_FUNC_DBEX,
+	eMCDRV_FUNC_GPMODE,
+	eMCDRV_FUNC_DTMF,
+	eMCDRV_FUNC_IRQ,
+	eMCDRV_FUNC_HWADJ
+} MCDRV_FUNC_KIND;
+
+typedef enum
+{
+	eMCDRV_SLAVE_ADDR_DIG	= 0,
+	eMCDRV_SLAVE_ADDR_ANA
+} MCDRV_SLAVE_ADDR_KIND;
+
+static	MCDRV_DEV_ID	geDevID	= eMCDRV_DEV_ID_1N2;
+
+static	UINT8	gabValid[][4]	=
+{
+/*	MC-1N2	MC-1N2B	MC-2N	MC-3N	*/
+	{0,		0,		0,		1},		/*	DI2		*/
+	{0,		0,		0,		1},		/*	DIVR1	*/
+	{0,		0,		0,		1},		/*	DIVF1	*/
+	{0,		0,		0,		1},		/*	RANGE	*/
+	{0,		0,		0,		1},		/*	BYPASS	*/
+	{0,		0,		0,		1},		/*	ADC1	*/
+	{0,		0,		0,		1},		/*	PAD2	*/
+	{0,		0,		1,		1},		/*	DBEX	*/
+	{0,		0,		0,		1},		/*	GPMODE	*/
+	{0,		0,		0,		1},		/*	DTMF	*/
+	{0,		0,		0,		1},		/*	IRQ		*/
+	{0,		0,		0,		0},		/*	HWADJ	*/
+};
+
+static UINT8	gabSlaveAddr[3][2]	=
+{
+/*	Digital Analog	*/
+	{0x3A,	0x3A},	/*	MC1N2	*/
+	{0x00,	0x00},	/*	MC2N	*/
+	{0x00,	0x00}	/*	MC3N	*/
+};
+
+/****************************************************************************
+ *	McDevProf_SetDevId
+ *
+ *	Description:
+ *			Set device ID.
+ *	Arguments:
+ *			eDevId	device ID
+ *	Return:
+ *			none
+ *
+ ****************************************************************************/
+static void	McDevProf_SetDevId(MCDRV_DEV_ID eDevId)
+{
+	geDevID	= eDevId;
+}
+
+/****************************************************************************
+ *	McDevProf_IsValid
+ *
+ *	Description:
+ *			Validity function.
+ *	Arguments:
+ *			function kind
+ *	Return:
+ *			0:Invalid/1:Valid
+ *
+ ****************************************************************************/
+static UINT8	McDevProf_IsValid
+(
+	MCDRV_FUNC_KIND eFuncKind
+)
+{
+	return gabValid[eFuncKind][geDevID];
+}
+
+/****************************************************************************
+ *	McDevProf_GetSlaveAddr
+ *
+ *	Description:
+ *			get slave address.
+ *	Arguments:
+ *			eSlaveAddrKind	slave address kind
+ *	Return:
+ *			slave address
+ *
+ ****************************************************************************/
+static UINT8	McDevProf_GetSlaveAddr
+(
+	MCDRV_SLAVE_ADDR_KIND eSlaveAddrKind
+)
+{
+	return gabSlaveAddr[geDevID][eSlaveAddrKind];
+}
+
+/**************************************/
+
+/*	UpdateReg parameter	*/
+typedef enum
+{
+	eMCDRV_UPDATE_NORMAL_AA,
+	eMCDRV_UPDATE_FORCE_AA,
+	eMCDRV_UPDATE_DUMMY_AA
+} MCDRV_UPDATE_MODE_AA;
+
+/*	ePacketBufAlloc setting	*/
+typedef enum
+{
+	eMCDRV_PACKETBUF_FREE_AA,
+	eMCDRV_PACKETBUF_ALLOCATED_AA
+} MCDRV_PACKETBUF_ALLOC_AA;
+
+/* packet */
+typedef struct
+{
+	UINT32	dDesc;
+	UINT8	bData;
+} MCDRV_PACKET_AA;
+
+#define	MCDRV_MAX_PACKETS_AA					(256UL)
+
+/*	packet dDesc	*/
+/*	packet type	*/
+#define	MCDRV_PACKET_TYPE_WRITE_AA				(0x10000000UL)
+#define	MCDRV_PACKET_TYPE_FORCE_WRITE_AA		(0x20000000UL)
+#define	MCDRV_PACKET_TYPE_TIMWAIT_AA			(0x30000000UL)
+#define	MCDRV_PACKET_TYPE_EVTWAIT_AA			(0x40000000UL)
+#define	MCDRV_PACKET_TYPE_TERMINATE_AA			(0xF0000000UL)
+
+#define	MCDRV_PACKET_TYPE_MASK_AA				(0xF0000000UL)
+
+/*	reg type	*/
+#define	MCDRV_PACKET_REGTYPE_A_AA				(0x00000000UL)
+#define	MCDRV_PACKET_REGTYPE_B_BASE_AA			(0x00001000UL)
+#define	MCDRV_PACKET_REGTYPE_B_MIXER_AA		(0x00002000UL)
+#define	MCDRV_PACKET_REGTYPE_B_AE_AA			(0x00003000UL)
+#define	MCDRV_PACKET_REGTYPE_B_CDSP_AA			(0x00004000UL)
+#define	MCDRV_PACKET_REGTYPE_B_CODEC_AA		(0x00005000UL)
+#define	MCDRV_PACKET_REGTYPE_B_ANA_AA			(0x00006000UL)
+
+#define	MCDRV_PACKET_REGTYPE_MASK_AA			(0x0000F000UL)
+#define	MCDRV_PACKET_ADR_MASK_AA				(0x00000FFFUL)
+
+/*	event	*/
+#define	MCDRV_EVT_INSFLG_AA					(0x00010000UL)
+#define	MCDRV_EVT_ALLMUTE_AA					(0x00020000UL)
+#define	MCDRV_EVT_DACMUTE_AA					(0x00030000UL)
+#define	MCDRV_EVT_DITMUTE_AA					(0x00040000UL)
+#define	MCDRV_EVT_SVOL_DONE_AA					(0x00050000UL)
+#define	MCDRV_EVT_APM_DONE_AA					(0x00060000UL)
+#define	MCDRV_EVT_ANA_RDY_AA					(0x00070000UL)
+#define	MCDRV_EVT_SYSEQ_FLAG_RESET_AA			(0x00080000UL)
+#define	MCDRV_EVT_CLKBUSY_RESET_AA				(0x00090000UL)
+#define	MCDRV_EVT_CLKSRC_SET_AA				(0x000A0000UL)
+#define	MCDRV_EVT_CLKSRC_RESET_AA				(0x000B0000UL)
+
+#define	MCDRV_PACKET_EVT_MASK_AA				(0x0FFF0000UL)
+#define	MCDRV_PACKET_EVTPRM_MASK_AA			(0x0000FFFFUL)
+
+/*	timer	*/
+#define	MCDRV_PACKET_TIME_MASK_AA				(0x0FFFFFFFUL)
+
+static SINT32	McDevIf_AllocPacketBuf_AA	(void);
+static void		McDevIf_ReleasePacketBuf_AA	(void);
+static void		McDevIf_ClearPacket_AA		(void);
+static void		McDevIf_AddPacket_AA		(UINT32 dDesc, UINT8 bData);
+static void		McDevIf_AddPacketRepeat_AA	(UINT32 dDesc, const UINT8* pbData, UINT16 wDataCount);
+static SINT32	McDevIf_ExecutePacket_AA	(void);
+
+static MCDRV_PACKET_AA*	gpsPacket	= NULL;
+
+
+static MCDRV_PACKET_AA*	McResCtrl_AllocPacketBuf_AA			(void);
+static void				McResCtrl_ReleasePacketBuf_AA		(void);
+static void				McResCtrl_InitRegUpdate_AA			(void);
+static void				McResCtrl_AddRegUpdate_AA			(UINT16 wRegType, UINT16 wAddress, UINT8 bData, MCDRV_UPDATE_MODE_AA eUpdateMode);
+static void				McResCtrl_ExecuteRegUpdate_AA		(void);
+static SINT32			McResCtrl_WaitEvent_AA				(UINT32 dEvent, UINT32 dParam);
+
+
+/****************************************************************************
+ *	McDevIf_AllocPacketBuf_AA
+ *
+ *	@\:
+ *			WX^pPbgpobt@m.
+ *	:
+ *			
+ *	l:
+ *			MCDRV_SUCCESS
+ *			MCDRV_ERROR
+ *
+ ****************************************************************************/
+SINT32	McDevIf_AllocPacketBuf_AA
+(
+	void
+)
+{
+	SINT32	sdRet	= MCDRV_SUCCESS;
+
+	gpsPacket	= McResCtrl_AllocPacketBuf_AA();
+	if(gpsPacket == NULL)
+	{
+		sdRet	= MCDRV_ERROR;
+	}
+	else
+	{
+		McDevIf_ClearPacket_AA();
+	}
+
+	return sdRet;
+}
+
+/****************************************************************************
+ *	McDevIf_ReleasePacketBuf_AA
+ *
+ *	@\:
+ *			WX^pPbgpobt@J.
+ *	:
+ *			
+ *	l:
+ *			
+ *
+ ****************************************************************************/
+void	McDevIf_ReleasePacketBuf_AA
+(
+	void
+)
+{
+	McResCtrl_ReleasePacketBuf_AA();
+}
+
+/****************************************************************************
+ *	McDevIf_ClearPacket_AA
+ *
+ *	@\:
+ *			pPbgNA.
+ *	:
+ *			
+ *	l:
+ *			
+ *
+ ****************************************************************************/
+void	McDevIf_ClearPacket_AA
+(
+	void
+)
+{
+	if(gpsPacket == NULL)
+	{
+		return;
+	}
+
+	gpsPacket[0].dDesc = MCDRV_PACKET_TYPE_TERMINATE_AA;
+}
+
+/****************************************************************************
+ *	McDevIf_AddPacket_AA
+ *
+ *	@\:
+ *			pPbg
+ *	:
+ *			dDesc			pPbg
+ *			bData			pPbgf[^
+ *	l:
+ *			
+ *
+ ****************************************************************************/
+void	McDevIf_AddPacket_AA
+(
+	UINT32			dDesc,
+	UINT8			bData
+)
+{
+	UINT32	i;
+
+	if(gpsPacket == NULL)
+	{
+	}
+	else
+	{
+		for(i = 0; i < MCDRV_MAX_PACKETS_AA; i++)
+		{
+			if(gpsPacket[i].dDesc == MCDRV_PACKET_TYPE_TERMINATE_AA)
+			{
+				break;
+			}
+		}
+		if(i >= MCDRV_MAX_PACKETS_AA)
+		{
+			McDevIf_ExecutePacket_AA();
+			i	= 0;
+		}
+
+		gpsPacket[i].dDesc		= dDesc;
+		gpsPacket[i].bData		= bData;
+		gpsPacket[i+1UL].dDesc	= MCDRV_PACKET_TYPE_TERMINATE_AA;
+	}
+}
+
+/****************************************************************************
+ *	McDevIf_AddPacketRepeat_AA
+ *
+ *	@\:
+ *			WX^Jf[^ZbgpPbg
+ *	:
+ *			dDesc			pPbg
+ *			pbData			pPbgf[^obt@|C^
+ *			wDataCount		pPbgf[^
+ *	l:
+ *			
+ *
+ ****************************************************************************/
+void	McDevIf_AddPacketRepeat_AA
+(
+	UINT32			dDesc,
+	const UINT8*	pbData,
+	UINT16			wDataCount
+)
+{
+	UINT16	wCount;
+
+	for(wCount = 0; wCount < wDataCount; wCount++)
+	{
+		McDevIf_AddPacket_AA(dDesc, pbData[wCount]);
+	}
+}
+
+/****************************************************************************
+ *	McDevIf_ExecutePacket_AA
+ *
+ *	@\:
+ *			WX^V[PXs.
+ *	:
+ *			
+ *	l:
+ *			MCDRV_SUCCESS
+ *			MCDRV_ERROR_ARGUMENT
+ *
+ ****************************************************************************/
+SINT32	McDevIf_ExecutePacket_AA
+(
+	void
+)
+{
+	SINT32	sdRet;
+	SINT16	swPacketIndex;
+	UINT32	dPacketType;
+	UINT32	dParam1;
+	UINT32	dParam2;
+	UINT16	wAddress;
+	UINT16	wRegType;
+	MCDRV_UPDATE_MODE_AA	eUpdateMode;
+
+	if(gpsPacket == NULL)
+	{
+		sdRet	= MCDRV_ERROR_RESOURCEOVER;
+	}
+	else
+	{
+		sdRet	= MCDRV_SUCCESS;
+
+		McResCtrl_InitRegUpdate_AA();
+		swPacketIndex = 0;
+		while ((MCDRV_PACKET_TYPE_TERMINATE_AA != (gpsPacket[swPacketIndex].dDesc & MCDRV_PACKET_TYPE_MASK_AA)) && (sdRet == MCDRV_SUCCESS))
+		{
+			dPacketType = gpsPacket[swPacketIndex].dDesc & MCDRV_PACKET_TYPE_MASK_AA;
+			switch (dPacketType)
+			{
+			case MCDRV_PACKET_TYPE_WRITE_AA:
+			case MCDRV_PACKET_TYPE_FORCE_WRITE_AA:
+				wRegType = (UINT16)(gpsPacket[swPacketIndex].dDesc & MCDRV_PACKET_REGTYPE_MASK_AA);
+				wAddress = (UINT16)(gpsPacket[swPacketIndex].dDesc & MCDRV_PACKET_ADR_MASK_AA);
+				if (MCDRV_PACKET_TYPE_WRITE_AA == dPacketType)
+				{
+					eUpdateMode = eMCDRV_UPDATE_NORMAL_AA;
+				}
+				else if (MCDRV_PACKET_TYPE_FORCE_WRITE_AA == dPacketType)
+				{
+					eUpdateMode = eMCDRV_UPDATE_FORCE_AA;
+				}
+				else
+				{
+					eUpdateMode = eMCDRV_UPDATE_DUMMY_AA;
+				}
+				McResCtrl_AddRegUpdate_AA(wRegType, wAddress, gpsPacket[swPacketIndex].bData, eUpdateMode);
+				break;
+
+			case MCDRV_PACKET_TYPE_TIMWAIT_AA:
+				McResCtrl_ExecuteRegUpdate_AA();
+				McResCtrl_InitRegUpdate_AA();
+				dParam1 = gpsPacket[swPacketIndex].dDesc & MCDRV_PACKET_TIME_MASK_AA;
+				McSrv_Sleep(dParam1);
+				break;
+
+			case MCDRV_PACKET_TYPE_EVTWAIT_AA:
+				McResCtrl_ExecuteRegUpdate_AA();
+				McResCtrl_InitRegUpdate_AA();
+				dParam1 = gpsPacket[swPacketIndex].dDesc & MCDRV_PACKET_EVT_MASK_AA;
+				dParam2 = gpsPacket[swPacketIndex].dDesc & MCDRV_PACKET_EVTPRM_MASK_AA;
+				sdRet = McResCtrl_WaitEvent_AA(dParam1, dParam2);
+				break;
+
+			default:
+				sdRet	= MCDRV_ERROR;
+				break;
+			}
+
+			swPacketIndex++;
+		}
+		if(sdRet == MCDRV_SUCCESS)
+		{
+			McResCtrl_ExecuteRegUpdate_AA();
+		}
+		McDevIf_ClearPacket_AA();
+	}
+
+	return sdRet;
+}
+
+/*****************************************/
+
+/*	power setting	*/
+#define	MCDRV_POWINFO_DIGITAL_DP0_AA		((UINT32)0x0001)
+#define	MCDRV_POWINFO_DIGITAL_DP1_AA		((UINT32)0x0002)
+#define	MCDRV_POWINFO_DIGITAL_DP2_AA		((UINT32)0x0004)
+#define	MCDRV_POWINFO_DIGITAL_DPB_AA		((UINT32)0x0008)
+#define	MCDRV_POWINFO_DIGITAL_DPDI0_AA		((UINT32)0x0010)
+#define	MCDRV_POWINFO_DIGITAL_DPDI1_AA		((UINT32)0x0020)
+#define	MCDRV_POWINFO_DIGITAL_DPDI2_AA		((UINT32)0x0040)
+#define	MCDRV_POWINFO_DIGITAL_DPPDM_AA		((UINT32)0x0080)
+#define	MCDRV_POWINFO_DIGITAL_DPBDSP_AA		((UINT32)0x0100)
+#define	MCDRV_POWINFO_DIGITAL_DPADIF_AA		((UINT32)0x0200)
+#define	MCDRV_POWINFO_DIGITAL_PLLRST0_AA	((UINT32)0x0400)
+typedef struct
+{
+	UINT32	dDigital;
+	UINT8	abAnalog[5];
+} MCDRV_POWER_INFO_AA;
+
+
+#define	MCDRV_BURST_WRITE_ENABLE	(0x01)
+
+/*	eState setting	*/
+typedef enum
+{
+	eMCDRV_STATE_NOTINIT_AA,
+	eMCDRV_STATE_READY_AA
+} MCDRV_STATE_AA;
+
+/*	volume setting	*/
+#define	MCDRV_LOGICAL_VOL_MUTE		(-24576)	/*	-96dB	*/
+#define	MCDRV_LOGICAL_MICGAIN_DEF	(3840)		/*	15dB	*/
+#define	MCDRV_LOGICAL_HPGAIN_DEF	(0)			/*	0dB		*/
+
+#define	MCDRV_VOLUPDATE_ALL_AA			(0xFFFFFFFFUL)
+#define	MCDRV_VOLUPDATE_ANAOUT_ALL_AA	(0x00000001UL)
+
+#define	MCDRV_REG_MUTE	(0x00)
+
+/*	DAC source setting	*/
+typedef enum
+{
+	eMCDRV_DAC_MASTER_AA	= 0,
+	eMCDRV_DAC_VOICE_AA
+} MCDRV_DAC_CH_AA;
+
+/*	DIO port setting	*/
+typedef enum
+{
+	eMCDRV_DIO_0_AA	= 0,
+	eMCDRV_DIO_1_AA,
+	eMCDRV_DIO_2_AA
+} MCDRV_DIO_PORT_NO_AA;
+
+/*	Path source setting	*/
+typedef enum
+{
+	eMCDRV_SRC_NONE_AA			= (0),
+	eMCDRV_SRC_MIC1_AA			= (1<<0),
+	eMCDRV_SRC_MIC2_AA			= (1<<1),
+	eMCDRV_SRC_MIC3_AA			= (1<<2),
+	eMCDRV_SRC_LINE1_L_AA		= (1<<3),
+	eMCDRV_SRC_LINE1_R_AA		= (1<<4),
+	eMCDRV_SRC_LINE1_M_AA		= (1<<5),
+	eMCDRV_SRC_LINE2_L_AA		= (1<<6),
+	eMCDRV_SRC_LINE2_R_AA		= (1<<7),
+	eMCDRV_SRC_LINE2_M_AA		= (1<<8),
+	eMCDRV_SRC_DIR0_AA			= (1<<9),
+	eMCDRV_SRC_DIR1_AA			= (1<<10),
+	eMCDRV_SRC_DIR2_AA			= (1<<11),
+	eMCDRV_SRC_DTMF_AA			= (1<<12),
+	eMCDRV_SRC_PDM_AA			= (1<<13),
+	eMCDRV_SRC_ADC0_AA			= (1<<14),
+	eMCDRV_SRC_ADC1_AA			= (1<<15),
+	eMCDRV_SRC_DAC_L_AA			= (1<<16),
+	eMCDRV_SRC_DAC_R_AA			= (1<<17),
+	eMCDRV_SRC_DAC_M_AA			= (1<<18),
+	eMCDRV_SRC_AE_AA			= (1<<19),
+	eMCDRV_SRC_CDSP_AA			= (1<<20),
+	eMCDRV_SRC_MIX_AA			= (1<<21),
+	eMCDRV_SRC_DIR2_DIRECT_AA	= (1<<22),
+	eMCDRV_SRC_CDSP_DIRECT_AA	= (1<<23)
+} MCDRV_SRC_TYPE_AA;
+
+/*	Path destination setting	*/
+typedef enum
+{
+	eMCDRV_DST_CH0_AA	= 0,
+	eMCDRV_DST_CH1_AA
+} MCDRV_DST_CH;
+typedef enum
+{
+	eMCDRV_DST_HP_AA	= 0,
+	eMCDRV_DST_SP_AA,
+	eMCDRV_DST_RCV_AA,
+	eMCDRV_DST_LOUT1_AA,
+	eMCDRV_DST_LOUT2_AA,
+	eMCDRV_DST_PEAK_AA,
+	eMCDRV_DST_DIT0_AA,
+	eMCDRV_DST_DIT1_AA,
+	eMCDRV_DST_DIT2_AA,
+	eMCDRV_DST_DAC_AA,
+	eMCDRV_DST_AE_AA,
+	eMCDRV_DST_CDSP_AA,
+	eMCDRV_DST_ADC0_AA,
+	eMCDRV_DST_ADC1_AA,
+	eMCDRV_DST_MIX_AA,
+	eMCDRV_DST_BIAS_AA
+} MCDRV_DST_TYPE_AA;
+
+/*	Register accsess availability	*/
+typedef enum
+{
+	eMCDRV_ACCESS_DENY_AA	= 0,
+	eMCDRV_READ_ONLY_AA	= 0x01,
+	eMCDRV_WRITE_ONLY_AA	= 0x02,
+	eMCDRV_READ_WRITE_AA	= eMCDRV_READ_ONLY_AA | eMCDRV_WRITE_ONLY_AA
+} MCDRV_REG_ACCSESS_AA;
+
+
+/* power management sequence mode */
+typedef enum
+{
+	eMCDRV_APM_ON_AA,
+	eMCDRV_APM_OFF_AA
+} MCDRV_PMODE_AA;
+
+#define	MCDRV_A_REG_NUM_AA			(64)
+#define	MCDRV_B_BASE_REG_NUM_AA		(32)
+#define	MCDRV_B_MIXER_REG_NUM_AA	(218)
+#define	MCDRV_B_AE_REG_NUM_AA		(255)
+#define	MCDRV_B_CDSP_REG_NUM_AA		(130)
+#define	MCDRV_B_CODEC_REG_NUM_AA	(128)
+#define	MCDRV_B_ANA_REG_NUM_AA		(128)
+
+/* control packet for serial host interface */
+#define	MCDRV_MAX_CTRL_DATA_NUM	(1024)
+typedef struct
+{
+	UINT8	abData[MCDRV_MAX_CTRL_DATA_NUM];
+	UINT16	wDataNum;
+} MCDRV_SERIAL_CTRL_PACKET_AA;
+
+/*	HWADJ setting	*/
+typedef enum _MCDRV_HWADJ
+{
+	eMCDRV_HWADJ_NOCHANGE	= 0,
+	eMCDRV_HWADJ_THRU,
+	eMCDRV_HWADJ_REC8,
+	eMCDRV_HWADJ_REC44,
+	eMCDRV_HWADJ_REC48,
+	eMCDRV_HWADJ_PLAY8,
+	eMCDRV_HWADJ_PLAY44,
+	eMCDRV_HWADJ_PLAY48
+} MCDRV_HWADJ;
+
+/*	global information	*/
+typedef struct
+{
+	UINT8						bHwId;
+	MCDRV_PACKETBUF_ALLOC_AA		ePacketBufAlloc;
+	UINT8						abRegValA[MCDRV_A_REG_NUM_AA];
+	UINT8						abRegValB_BASE[MCDRV_B_BASE_REG_NUM_AA];
+	UINT8						abRegValB_MIXER[MCDRV_B_MIXER_REG_NUM_AA];
+	UINT8						abRegValB_AE[MCDRV_B_AE_REG_NUM_AA];
+	UINT8						abRegValB_CDSP[MCDRV_B_CDSP_REG_NUM_AA];
+	UINT8						abRegValB_CODEC[MCDRV_B_CODEC_REG_NUM_AA];
+	UINT8						abRegValB_ANA[MCDRV_B_ANA_REG_NUM_AA];
+
+	MCDRV_INIT_INFO				sInitInfo;
+	MCDRV_PATH_INFO				sPathInfo;
+	MCDRV_PATH_INFO				sPathInfoVirtual;
+	MCDRV_VOL_INFO				sVolInfo;
+	MCDRV_DIO_INFO				sDioInfo;
+	MCDRV_DAC_INFO				sDacInfo;
+	MCDRV_ADC_INFO				sAdcInfo;
+	MCDRV_SP_INFO				sSpInfo;
+	MCDRV_DNG_INFO				sDngInfo;
+	MCDRV_AE_INFO				sAeInfo;
+	MCDRV_PDM_INFO				sPdmInfo;
+	MCDRV_GP_MODE				sGpMode;
+	UINT8						abGpMask[GPIO_PAD_NUM];
+
+	MCDRV_SERIAL_CTRL_PACKET_AA	sCtrlPacket;
+	UINT16						wCurSlaveAddress;
+	UINT16						wCurRegType;
+	UINT16						wCurRegAddress;
+	UINT16						wDataContinueCount;
+	UINT16						wPrevAddressIndex;
+
+	MCDRV_PMODE_AA					eAPMode;
+
+	MCDRV_HWADJ					eHwAdj;
+} MCDRV_GLOBAL_INFO_AA;
+
+static SINT32			McResCtrl_SetHwId_AA				(UINT8 bHwId);
+static void				McResCtrl_Init_AA					(const MCDRV_INIT_INFO* psInitInfo);
+static void				McResCtrl_UpdateState_AA			(MCDRV_STATE_AA eState);
+static MCDRV_STATE_AA	McResCtrl_GetState_AA				(void);
+static UINT8			McResCtrl_GetRegVal_AA				(UINT16 wRegType, UINT16 wRegAddr);
+static void				McResCtrl_SetRegVal_AA				(UINT16 wRegType, UINT16 wRegAddr, UINT8 bRegVal);
+
+static void				McResCtrl_GetInitInfo_AA			(MCDRV_INIT_INFO* psInitInfo);
+static void				McResCtrl_SetClockInfo_AA			(const MCDRV_CLOCK_INFO* psClockInfo);
+static void				McResCtrl_SetPathInfo_AA			(const MCDRV_PATH_INFO* psPathInfo);
+static void				McResCtrl_GetPathInfo_AA			(MCDRV_PATH_INFO* psPathInfo);
+static void				McResCtrl_GetPathInfoVirtual_AA		(MCDRV_PATH_INFO* psPathInfo);
+static void				McResCtrl_SetDioInfo_AA				(const MCDRV_DIO_INFO* psDioInfo, UINT32 dUpdateInfo);
+static void				McResCtrl_GetDioInfo_AA				(MCDRV_DIO_INFO* psDioInfo);
+static void				McResCtrl_SetVolInfo_AA				(const MCDRV_VOL_INFO* psVolInfo);
+static void				McResCtrl_GetVolInfo_AA				(MCDRV_VOL_INFO* psVolInfo);
+static void				McResCtrl_SetDacInfo_AA				(const MCDRV_DAC_INFO* psDacInfo, UINT32 dUpdateInfo);
+static void				McResCtrl_GetDacInfo_AA				(MCDRV_DAC_INFO* psDacInfo);
+static void				McResCtrl_SetAdcInfo_AA				(const MCDRV_ADC_INFO* psAdcInfo, UINT32 dUpdateInfo);
+static void				McResCtrl_GetAdcInfo_AA				(MCDRV_ADC_INFO* psAdcInfo);
+static void				McResCtrl_SetSpInfo_AA				(const MCDRV_SP_INFO* psSpInfo);
+static void				McResCtrl_GetSpInfo_AA				(MCDRV_SP_INFO* psSpInfo);
+static void				McResCtrl_SetDngInfo_AA				(const MCDRV_DNG_INFO* psDngInfo, UINT32 dUpdateInfo);
+static void				McResCtrl_GetDngInfo_AA				(MCDRV_DNG_INFO* psDngInfo);
+static void				McResCtrl_SetAeInfo_AA				(const MCDRV_AE_INFO* psAeInfo, UINT32 dUpdateInfo);
+static void				McResCtrl_GetAeInfo_AA				(MCDRV_AE_INFO* psAeInfo);
+static void				McResCtrl_SetPdmInfo_AA				(const MCDRV_PDM_INFO* psPdmInfo, UINT32 dUpdateInfo);
+static void				McResCtrl_GetPdmInfo_AA				(MCDRV_PDM_INFO* psPdmInfo);
+static void				McResCtrl_SetGPMode_AA				(const MCDRV_GP_MODE* psGpMode);
+static void				McResCtrl_GetGPMode_AA				(MCDRV_GP_MODE* psGpMode);
+static void				McResCtrl_SetGPMask_AA				(UINT8 bMask, UINT32 dPadNo);
+static void				McResCtrl_GetGPMask_AA				(UINT8* pabMask);
+
+static void				McResCtrl_GetVolReg_AA				(MCDRV_VOL_INFO* psVolInfo);
+static void				McResCtrl_GetPowerInfo_AA			(MCDRV_POWER_INFO_AA* psPowerInfo);
+static void				McResCtrl_GetPowerInfoRegAccess_AA	(const MCDRV_REG_INFO* psRegInfo, MCDRV_POWER_INFO_AA* psPowerInfo);
+static void				McResCtrl_GetCurPowerInfo_AA		(MCDRV_POWER_INFO_AA* psPowerInfo);
+
+static MCDRV_SRC_TYPE_AA	McResCtrl_GetDACSource_AA		(MCDRV_DAC_CH_AA eCh);
+static MCDRV_SRC_TYPE_AA	McResCtrl_GetDITSource_AA		(MCDRV_DIO_PORT_NO_AA ePort);
+static MCDRV_SRC_TYPE_AA	McResCtrl_GetAESource_AA		(void);
+static UINT8				McResCtrl_IsSrcUsed_AA			(MCDRV_SRC_TYPE_AA ePathSrc);
+static UINT8				McResCtrl_IsDstUsed_AA			(MCDRV_DST_TYPE_AA eType, MCDRV_DST_CH eCh);
+static MCDRV_REG_ACCSESS_AA	McResCtrl_GetRegAccess_AA		(const MCDRV_REG_INFO* psRegInfo);
+
+static MCDRV_PMODE_AA		McResCtrl_GetAPMode_AA			(void);
+
+
+
+static MCDRV_HWADJ		McResCtrl_ConfigHwAdj_AA			(void);
+
+/*************************************/
+
+/* HW_ID */
+#define	MCDRV_HWID_YMU821_AA	(0x78)
+
+/* wait time */
+#define	MCDRV_INTERVAL_MUTE_AA	(1000)
+#define	MCDRV_TIME_OUT_MUTE_AA	(1000)
+
+
+static MCDRV_STATE_AA	geState	= eMCDRV_STATE_NOTINIT_AA;
+
+static MCDRV_GLOBAL_INFO_AA	gsGlobalInfo_AA;
+static MCDRV_PACKET_AA		gasPacket[MCDRV_MAX_PACKETS_AA+1];
+
+/* register next address */
+static const UINT16	gawNextAddressA[MCDRV_A_REG_NUM_AA] =
+{
+	0,		1,		2,		0xFFFF,	0xFFFF,	0xFFFF,	0xFFFF,	0xFFFF,	8,		0xFFFF,	0xFFFF,	0xFFFF,	12,		13,		14,		15,
+	16,		17,		18,		19,		20,		21,		22,		23,		0xFFFF,	0xFFFF,	0xFFFF,	0xFFFF,	0xFFFF,	0xFFFF,	0xFFFF,	0xFFFF,
+	0xFFFF,	0xFFFF,	0xFFFF,	0xFFFF,	0xFFFF,	0xFFFF,	0xFFFF,	0xFFFF,	0xFFFF,	0xFFFF,	0xFFFF,	0xFFFF,	0xFFFF,	0xFFFF,	0xFFFF,	0xFFFF,
+	0xFFFF,	0xFFFF,	0xFFFF,	0xFFFF,	0xFFFF,	0xFFFF,	0xFFFF,	0xFFFF,	0xFFFF,	0xFFFF,	0xFFFF,	0xFFFF,	0xFFFF,	0xFFFF,	0xFFFF,	0xFFFF
+};
+
+static const UINT16	gawNextAddressB_BASE[MCDRV_B_BASE_REG_NUM_AA] =
+{
+	1,		2,		3,		4,		5,		6,		7,		0xFFFF,	9,		10,		11,		12,		13,		14,		15,		16,
+	17,		18,		19,		20,		0xFFFF,	22,		23,		24,		25,		26,		27,		28,		29,		30,		31,		0xFFFF
+};
+
+static const UINT16	gawNextAddressB_MIXER[MCDRV_B_MIXER_REG_NUM_AA] =
+{
+	1,		2,		3,		4,		5,		6,		7,		8,		9,		10,		11,		12,		13,		14,		15,		16,
+	17,		18,		19,		20,		21,		22,		23,		24,		25,		26,		27,		28,		29,		30,		31,		32,
+	33,		34,		35,		36,		37,		38,		39,		40,		41,		42,		43,		44,		45,		46,		47,		48,
+	49,		50,		51,		52,		53,		54,		55,		56,		57,		58,		59,		60,		61,		62,		63,		64,
+	65,		66,		67,		68,		69,		70,		71,		72,		73,		74,		75,		76,		77,		78,		79,		80,
+	81,		82,		83,		84,		85,		86,		87,		88,		89,		90,		91,		92,		93,		94,		95,		96,
+	97,		98,		99,		100,	101,	102,	103,	104,	105,	106,	107,	108,	109,	110,	111,	112,
+	113,	114,	115,	116,	117,	118,	119,	120,	121,	122,	123,	124,	125,	126,	127,	128,
+	129,	130,	131,	132,	133,	134,	135,	136,	137,	138,	139,	140,	141,	142,	143,	144,
+	145,	146,	147,	148,	149,	150,	151,	152,	153,	154,	155,	156,	157,	158,	159,	160,
+	161,	162,	163,	164,	165,	166,	167,	168,	169,	170,	171,	172,	173,	174,	175,	176,
+	177,	178,	179,	180,	181,	182,	183,	184,	185,	186,	187,	188,	189,	190,	191,	192,
+	193,	194,	195,	196,	197,	198,	199,	200,	201,	202,	0xFFFF,	0xFFFF,	0xFFFF,	0xFFFF,	0xFFFF,	0xFFFF,
+	0xFFFF,	0xFFFF,	0xFFFF,	0xFFFF,	0xFFFF,	0xFFFF,	0xFFFF,	0xFFFF,	0xFFFF,	0xFFFF
+};
+
+static const UINT16	gawNextAddressB_AE[MCDRV_B_AE_REG_NUM_AA] =
+{
+	1,		2,		3,		4,		5,		6,		7,		8,		9,		10,		11,		12,		13,		14,		15,		16,
+	17,		18,		19,		20,		21,		22,		23,		24,		25,		26,		27,		28,		29,		30,		31,		32,
+	33,		34,		35,		36,		37,		38,		39,		40,		41,		42,		43,		44,		45,		46,		47,		48,
+	49,		50,		51,		52,		53,		54,		55,		56,		57,		58,		59,		60,		61,		62,		63,		64,
+	65,		66,		67,		68,		69,		70,		71,		72,		73,		74,		75,		76,		77,		78,		79,		80,
+	81,		82,		83,		84,		85,		86,		87,		88,		89,		90,		91,		92,		93,		94,		95,		96,
+	97,		98,		99,		100,	101,	102,	103,	104,	105,	106,	107,	108,	109,	110,	111,	112,
+	113,	114,	115,	116,	117,	118,	119,	120,	121,	122,	123,	124,	125,	126,	127,	128,
+	129,	130,	131,	132,	133,	134,	135,	136,	137,	138,	139,	140,	141,	142,	143,	144,
+	145,	146,	147,	148,	149,	150,	151,	152,	153,	154,	155,	156,	157,	158,	159,	160,
+	161,	162,	163,	164,	165,	166,	167,	168,	169,	170,	171,	172,	173,	174,	175,	176,
+	177,	178,	179,	180,	181,	182,	183,	184,	185,	186,	187,	188,	189,	190,	191,	192,
+	193,	194,	195,	196,	197,	198,	199,	200,	201,	202,	203,	204,	205,	206,	207,	208,
+	209,	210,	211,	212,	213,	214,	215,	216,	217,	218,	219,	220,	221,	222,	223,	224,
+	225,	226,	227,	228,	229,	230,	231,	232,	233,	234,	235,	236,	237,	238,	239,	240,
+	241,	242,	243,	244,	245,	246,	247,	248,	249,	250,	251,	252,	253,	254,	0xFFFF
+};
+
+static const UINT16	gawNextAddressB_CDSP[MCDRV_B_CDSP_REG_NUM_AA] =
+{
+	1,		2,		3,		4,		5,		6,		7,		8,		9,		10,		11,		12,		13,		14,		15,		16,
+	17,		18,		19,		20,		21,		22,		23,		24,		25,		26,		27,		28,		29,		30,		31,		32,
+	33,		34,		35,		36,		37,		38,		39,		40,		41,		42,		43,		44,		45,		46,		47,		48,
+	49,		50,		51,		52,		53,		54,		55,		56,		57,		58,		59,		60,		61,		62,		63,		64,
+	65,		66,		67,		68,		69,		70,		71,		72,		73,		74,		75,		76,		77,		78,		79,		80,
+	81,		82,		83,		84,		85,		86,		87,		88,		89,		90,		91,		92,		93,		94,		95,		96,
+	97,		98,		99,		100,	101,	102,	103,	104,	105,	106,	107,	108,	109,	110,	111,	112,
+	113,	114,	115,	116,	117,	118,	119,	120,	121,	122,	123,	124,	125,	126,	127,	128,
+	129,	0xFFFF
+};
+
+static const UINT16	gawNextAddressB_CODEC[MCDRV_B_CODEC_REG_NUM_AA] =
+{
+	1,		2,		3,		4,		5,		6,		7,		8,		9,		10,		11,		12,		13,		14,		15,		16,
+	17,		18,		19,		20,		21,		22,		23,		24,		25,		26,		27,		28,		29,		30,		31,		32,
+	33,		34,		35,		36,		37,		38,		39,		40,		41,		42,		43,		44,		45,		46,		47,		48,
+	49,		50,		51,		52,		53,		54,		55,		56,		57,		58,		59,		60,		61,		62,		63,		64,
+	65,		66,		67,		68,		69,		70,		71,		72,		73,		74,		75,		76,		77,		78,		79,		80,
+	81,		82,		83,		84,		85,		86,		87,		88,		89,		90,		91,		92,		93,		94,		95,		96,
+	97,		98,		99,		100,	101,	102,	103,	104,	105,	106,	107,	108,	109,	110,	111,	112,
+	113,	114,	115,	116,	117,	118,	119,	120,	121,	122,	123,	124,	125,	126,	127,	0xFFFF
+};
+
+static const UINT16	gawNextAddressB_Ana[MCDRV_B_ANA_REG_NUM_AA] =
+{
+	1,		2,		3,		4,		5,		6,		7,		8,		9,		10,		11,		12,		13,		14,		15,		16,
+	17,		18,		19,		20,		21,		22,		23,		24,		25,		26,		27,		28,		29,		30,		31,		32,
+	33,		34,		35,		36,		37,		38,		39,		40,		41,		42,		43,		44,		45,		46,		47,		48,
+	49,		50,		51,		52,		53,		54,		55,		56,		57,		58,		59,		60,		61,		62,		63,		64,
+	65,		66,		67,		68,		69,		70,		71,		72,		73,		74,		75,		76,		77,		0xFFFF,	79,		80,
+	81,		82,		83,		84,		85,		86,		87,		88,		89,		90,		91,		92,		93,		94,		95,		96,
+	97,		98,		99,		100,	101,	102,	103,	104,	105,	106,	107,	108,	109,	110,	111,	112,
+	113,	114,	115,	116,	117,	118,	119,	120,	121,	122,	123,	124,	125,	126,	127,	0xFFFF
+};
+
+/*	register access available	*/
+static const MCDRV_REG_ACCSESS_AA	gawRegAccessAvailableA[256] =
+{
+	eMCDRV_READ_WRITE_AA,	eMCDRV_READ_WRITE_AA,	eMCDRV_READ_WRITE_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,
+	eMCDRV_READ_ONLY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_READ_WRITE_AA,	eMCDRV_READ_WRITE_AA,	eMCDRV_READ_WRITE_AA,	eMCDRV_READ_WRITE_AA,
+	eMCDRV_READ_WRITE_AA,	eMCDRV_READ_WRITE_AA,	eMCDRV_READ_WRITE_AA,	eMCDRV_WRITE_ONLY_AA,	eMCDRV_READ_WRITE_AA,	eMCDRV_READ_WRITE_AA,	eMCDRV_WRITE_ONLY_AA,	eMCDRV_WRITE_ONLY_AA,
+	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,
+	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,
+	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,
+	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,
+	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,
+	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,
+	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,
+	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,
+	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,
+	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,
+	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,
+	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,
+	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,
+	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,
+	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,
+	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,
+	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,
+	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,
+	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,
+	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,
+	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,
+	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,
+	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,
+	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,
+	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,
+	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,
+	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,
+	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,
+	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,
+};
+static const MCDRV_REG_ACCSESS_AA	gawRegAccessAvailableB_BASE[256] =
+{
+	eMCDRV_READ_WRITE_AA,	eMCDRV_READ_WRITE_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_READ_WRITE_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_READ_WRITE_AA,	eMCDRV_ACCESS_DENY_AA,
+	eMCDRV_ACCESS_DENY_AA,	eMCDRV_READ_WRITE_AA,	eMCDRV_READ_WRITE_AA,	eMCDRV_READ_WRITE_AA,	eMCDRV_READ_WRITE_AA,	eMCDRV_READ_WRITE_AA,	eMCDRV_READ_WRITE_AA,	eMCDRV_READ_WRITE_AA,
+	eMCDRV_READ_WRITE_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_READ_WRITE_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,
+	eMCDRV_ACCESS_DENY_AA,	eMCDRV_READ_WRITE_AA,	eMCDRV_READ_WRITE_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_READ_WRITE_AA,	eMCDRV_READ_WRITE_AA,
+	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,
+	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,
+	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,
+	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,
+	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,
+	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,
+	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,
+	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,
+	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,
+	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,
+	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,
+	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,
+	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,
+	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,
+	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,
+	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,
+	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,
+	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,
+	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,
+	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,
+	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,
+	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,
+	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,
+	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,
+	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,
+	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,
+	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,
+	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,
+};
+static const MCDRV_REG_ACCSESS_AA	gawRegAccessAvailableB_ANA[256] =
+{
+	eMCDRV_READ_WRITE_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_READ_WRITE_AA,	eMCDRV_READ_WRITE_AA,	eMCDRV_READ_WRITE_AA,	eMCDRV_READ_WRITE_AA,	eMCDRV_READ_WRITE_AA,	eMCDRV_ACCESS_DENY_AA,
+	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_READ_ONLY_AA,	eMCDRV_READ_ONLY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,
+	eMCDRV_READ_WRITE_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_READ_WRITE_AA,	eMCDRV_READ_WRITE_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,
+	eMCDRV_READ_WRITE_AA,	eMCDRV_READ_WRITE_AA,	eMCDRV_READ_WRITE_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_READ_WRITE_AA,	eMCDRV_READ_WRITE_AA,	eMCDRV_READ_WRITE_AA,
+	eMCDRV_READ_WRITE_AA,	eMCDRV_READ_WRITE_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_READ_WRITE_AA,	eMCDRV_READ_WRITE_AA,	eMCDRV_READ_WRITE_AA,	eMCDRV_READ_WRITE_AA,	eMCDRV_READ_WRITE_AA,
+	eMCDRV_READ_WRITE_AA,	eMCDRV_READ_WRITE_AA,	eMCDRV_READ_WRITE_AA,	eMCDRV_READ_WRITE_AA,	eMCDRV_READ_WRITE_AA,	eMCDRV_READ_WRITE_AA,	eMCDRV_READ_WRITE_AA,	eMCDRV_READ_ONLY_AA,
+	eMCDRV_READ_WRITE_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_READ_WRITE_AA,	eMCDRV_READ_WRITE_AA,	eMCDRV_READ_WRITE_AA,	eMCDRV_READ_WRITE_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_READ_WRITE_AA,
+	eMCDRV_READ_WRITE_AA,	eMCDRV_READ_WRITE_AA,	eMCDRV_READ_WRITE_AA,	eMCDRV_READ_WRITE_AA,	eMCDRV_READ_WRITE_AA,	eMCDRV_READ_WRITE_AA,	eMCDRV_READ_WRITE_AA,	eMCDRV_READ_WRITE_AA,
+	eMCDRV_READ_WRITE_AA,	eMCDRV_READ_WRITE_AA,	eMCDRV_READ_WRITE_AA,	eMCDRV_READ_WRITE_AA,	eMCDRV_READ_WRITE_AA,	eMCDRV_READ_WRITE_AA,	eMCDRV_READ_ONLY_AA,	eMCDRV_ACCESS_DENY_AA,
+	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_READ_WRITE_AA,	eMCDRV_READ_WRITE_AA,	eMCDRV_READ_WRITE_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_READ_WRITE_AA,
+	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,
+	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,
+	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_READ_ONLY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,
+	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,
+	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,
+	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,
+	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,
+	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,
+	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,
+	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,
+	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,
+	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,
+	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,
+	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,
+	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,
+	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,
+	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,
+	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,
+	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,
+	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,
+	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,
+	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,
+};
+static const MCDRV_REG_ACCSESS_AA	gawRegAccessAvailableB_CODEC[256] =
+{
+	eMCDRV_ACCESS_DENY_AA,	eMCDRV_READ_WRITE_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,
+	eMCDRV_READ_ONLY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,
+	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,
+	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,
+	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,
+	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,
+	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,
+	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,
+	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_READ_WRITE_AA,	eMCDRV_READ_WRITE_AA,
+	eMCDRV_READ_WRITE_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_READ_WRITE_AA,	eMCDRV_READ_WRITE_AA,	eMCDRV_READ_WRITE_AA,
+	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,
+	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,
+	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,
+	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,
+	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,
+	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,
+	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,
+	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,
+	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,
+	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,
+	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,
+	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,
+	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,
+	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,
+	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,
+	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,
+	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,
+	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,
+	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,
+	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,
+	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,
+	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,
+};
+static const MCDRV_REG_ACCSESS_AA	gawRegAccessAvailableB_MIX[256] =
+{
+	eMCDRV_READ_ONLY_AA,	eMCDRV_READ_ONLY_AA,	eMCDRV_READ_ONLY_AA,	eMCDRV_READ_ONLY_AA,	eMCDRV_READ_ONLY_AA,	eMCDRV_READ_ONLY_AA,	eMCDRV_READ_ONLY_AA,	eMCDRV_READ_ONLY_AA,
+	eMCDRV_READ_ONLY_AA,	eMCDRV_READ_ONLY_AA,	eMCDRV_READ_ONLY_AA,	eMCDRV_READ_ONLY_AA,	eMCDRV_READ_WRITE_AA,	eMCDRV_READ_WRITE_AA,	eMCDRV_READ_WRITE_AA,	eMCDRV_READ_WRITE_AA,
+	eMCDRV_READ_WRITE_AA,	eMCDRV_READ_WRITE_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,
+	eMCDRV_READ_WRITE_AA,	eMCDRV_READ_WRITE_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_READ_WRITE_AA,	eMCDRV_READ_WRITE_AA,	eMCDRV_READ_WRITE_AA,	eMCDRV_READ_WRITE_AA,
+	eMCDRV_READ_WRITE_AA,	eMCDRV_READ_WRITE_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,
+	eMCDRV_READ_WRITE_AA,	eMCDRV_READ_WRITE_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_READ_WRITE_AA,	eMCDRV_READ_WRITE_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,
+	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_READ_WRITE_AA,	eMCDRV_READ_WRITE_AA,	eMCDRV_READ_WRITE_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_READ_WRITE_AA,	eMCDRV_READ_WRITE_AA,
+	eMCDRV_READ_WRITE_AA,	eMCDRV_READ_WRITE_AA,	eMCDRV_READ_WRITE_AA,	eMCDRV_READ_WRITE_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_READ_WRITE_AA,	eMCDRV_READ_WRITE_AA,
+	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,
+	eMCDRV_READ_WRITE_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_READ_WRITE_AA,	eMCDRV_READ_WRITE_AA,	eMCDRV_READ_WRITE_AA,	eMCDRV_READ_WRITE_AA,	eMCDRV_READ_WRITE_AA,	eMCDRV_READ_WRITE_AA,
+	eMCDRV_READ_WRITE_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_READ_WRITE_AA,	eMCDRV_READ_WRITE_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,
+	eMCDRV_ACCESS_DENY_AA,	eMCDRV_READ_WRITE_AA,	eMCDRV_READ_WRITE_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_READ_WRITE_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,
+	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,
+	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_READ_WRITE_AA,	eMCDRV_READ_WRITE_AA,
+	eMCDRV_READ_WRITE_AA,	eMCDRV_READ_WRITE_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_READ_WRITE_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,
+	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,
+	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_READ_WRITE_AA,	eMCDRV_READ_WRITE_AA,	eMCDRV_READ_WRITE_AA,	eMCDRV_READ_WRITE_AA,	eMCDRV_READ_WRITE_AA,	eMCDRV_READ_WRITE_AA,
+	eMCDRV_READ_WRITE_AA,	eMCDRV_READ_WRITE_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_READ_WRITE_AA,	eMCDRV_READ_WRITE_AA,
+	eMCDRV_READ_WRITE_AA,	eMCDRV_READ_WRITE_AA,	eMCDRV_READ_WRITE_AA,	eMCDRV_READ_WRITE_AA,	eMCDRV_READ_WRITE_AA,	eMCDRV_READ_WRITE_AA,	eMCDRV_READ_WRITE_AA,	eMCDRV_READ_WRITE_AA,
+	eMCDRV_READ_WRITE_AA,	eMCDRV_READ_WRITE_AA,	eMCDRV_READ_WRITE_AA,	eMCDRV_READ_WRITE_AA,	eMCDRV_READ_WRITE_AA,	eMCDRV_READ_WRITE_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,
+	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_READ_WRITE_AA,	eMCDRV_READ_WRITE_AA,	eMCDRV_READ_WRITE_AA,	eMCDRV_READ_WRITE_AA,	eMCDRV_READ_WRITE_AA,	eMCDRV_READ_WRITE_AA,
+	eMCDRV_READ_WRITE_AA,	eMCDRV_READ_WRITE_AA,	eMCDRV_READ_WRITE_AA,	eMCDRV_READ_WRITE_AA,	eMCDRV_READ_WRITE_AA,	eMCDRV_READ_WRITE_AA,	eMCDRV_READ_WRITE_AA,	eMCDRV_READ_WRITE_AA,
+	eMCDRV_READ_WRITE_AA,	eMCDRV_READ_WRITE_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_READ_WRITE_AA,	eMCDRV_READ_WRITE_AA,
+	eMCDRV_READ_WRITE_AA,	eMCDRV_READ_WRITE_AA,	eMCDRV_READ_WRITE_AA,	eMCDRV_READ_WRITE_AA,	eMCDRV_READ_WRITE_AA,	eMCDRV_READ_WRITE_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,
+	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_READ_WRITE_AA,	eMCDRV_READ_WRITE_AA,
+	eMCDRV_READ_WRITE_AA,	eMCDRV_READ_WRITE_AA,	eMCDRV_READ_WRITE_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_READ_WRITE_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,
+	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,
+	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,
+	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,
+	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,
+	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,
+	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,
+};
+static const MCDRV_REG_ACCSESS_AA	gawRegAccessAvailableB_AE[256] =
+{
+	eMCDRV_WRITE_ONLY_AA,	eMCDRV_WRITE_ONLY_AA,	eMCDRV_WRITE_ONLY_AA,	eMCDRV_WRITE_ONLY_AA,	eMCDRV_WRITE_ONLY_AA,	eMCDRV_WRITE_ONLY_AA,	eMCDRV_WRITE_ONLY_AA,	eMCDRV_WRITE_ONLY_AA,
+	eMCDRV_WRITE_ONLY_AA,	eMCDRV_WRITE_ONLY_AA,	eMCDRV_WRITE_ONLY_AA,	eMCDRV_WRITE_ONLY_AA,	eMCDRV_WRITE_ONLY_AA,	eMCDRV_WRITE_ONLY_AA,	eMCDRV_WRITE_ONLY_AA,	eMCDRV_WRITE_ONLY_AA,
+	eMCDRV_WRITE_ONLY_AA,	eMCDRV_WRITE_ONLY_AA,	eMCDRV_WRITE_ONLY_AA,	eMCDRV_WRITE_ONLY_AA,	eMCDRV_WRITE_ONLY_AA,	eMCDRV_WRITE_ONLY_AA,	eMCDRV_WRITE_ONLY_AA,	eMCDRV_WRITE_ONLY_AA,
+	eMCDRV_WRITE_ONLY_AA,	eMCDRV_WRITE_ONLY_AA,	eMCDRV_WRITE_ONLY_AA,	eMCDRV_WRITE_ONLY_AA,	eMCDRV_WRITE_ONLY_AA,	eMCDRV_WRITE_ONLY_AA,	eMCDRV_WRITE_ONLY_AA,	eMCDRV_WRITE_ONLY_AA,
+	eMCDRV_WRITE_ONLY_AA,	eMCDRV_WRITE_ONLY_AA,	eMCDRV_WRITE_ONLY_AA,	eMCDRV_WRITE_ONLY_AA,	eMCDRV_WRITE_ONLY_AA,	eMCDRV_WRITE_ONLY_AA,	eMCDRV_WRITE_ONLY_AA,	eMCDRV_WRITE_ONLY_AA,
+	eMCDRV_WRITE_ONLY_AA,	eMCDRV_WRITE_ONLY_AA,	eMCDRV_WRITE_ONLY_AA,	eMCDRV_WRITE_ONLY_AA,	eMCDRV_WRITE_ONLY_AA,	eMCDRV_WRITE_ONLY_AA,	eMCDRV_WRITE_ONLY_AA,	eMCDRV_WRITE_ONLY_AA,
+	eMCDRV_WRITE_ONLY_AA,	eMCDRV_WRITE_ONLY_AA,	eMCDRV_WRITE_ONLY_AA,	eMCDRV_WRITE_ONLY_AA,	eMCDRV_WRITE_ONLY_AA,	eMCDRV_WRITE_ONLY_AA,	eMCDRV_WRITE_ONLY_AA,	eMCDRV_WRITE_ONLY_AA,
+	eMCDRV_WRITE_ONLY_AA,	eMCDRV_WRITE_ONLY_AA,	eMCDRV_WRITE_ONLY_AA,	eMCDRV_WRITE_ONLY_AA,	eMCDRV_WRITE_ONLY_AA,	eMCDRV_WRITE_ONLY_AA,	eMCDRV_WRITE_ONLY_AA,	eMCDRV_WRITE_ONLY_AA,
+	eMCDRV_WRITE_ONLY_AA,	eMCDRV_WRITE_ONLY_AA,	eMCDRV_WRITE_ONLY_AA,	eMCDRV_WRITE_ONLY_AA,	eMCDRV_WRITE_ONLY_AA,	eMCDRV_WRITE_ONLY_AA,	eMCDRV_WRITE_ONLY_AA,	eMCDRV_WRITE_ONLY_AA,
+	eMCDRV_WRITE_ONLY_AA,	eMCDRV_WRITE_ONLY_AA,	eMCDRV_WRITE_ONLY_AA,	eMCDRV_WRITE_ONLY_AA,	eMCDRV_WRITE_ONLY_AA,	eMCDRV_WRITE_ONLY_AA,	eMCDRV_WRITE_ONLY_AA,	eMCDRV_WRITE_ONLY_AA,
+	eMCDRV_WRITE_ONLY_AA,	eMCDRV_WRITE_ONLY_AA,	eMCDRV_WRITE_ONLY_AA,	eMCDRV_WRITE_ONLY_AA,	eMCDRV_WRITE_ONLY_AA,	eMCDRV_WRITE_ONLY_AA,	eMCDRV_WRITE_ONLY_AA,	eMCDRV_WRITE_ONLY_AA,
+	eMCDRV_WRITE_ONLY_AA,	eMCDRV_WRITE_ONLY_AA,	eMCDRV_WRITE_ONLY_AA,	eMCDRV_WRITE_ONLY_AA,	eMCDRV_WRITE_ONLY_AA,	eMCDRV_WRITE_ONLY_AA,	eMCDRV_WRITE_ONLY_AA,	eMCDRV_WRITE_ONLY_AA,
+	eMCDRV_WRITE_ONLY_AA,	eMCDRV_WRITE_ONLY_AA,	eMCDRV_WRITE_ONLY_AA,	eMCDRV_WRITE_ONLY_AA,	eMCDRV_WRITE_ONLY_AA,	eMCDRV_WRITE_ONLY_AA,	eMCDRV_WRITE_ONLY_AA,	eMCDRV_WRITE_ONLY_AA,
+	eMCDRV_WRITE_ONLY_AA,	eMCDRV_WRITE_ONLY_AA,	eMCDRV_WRITE_ONLY_AA,	eMCDRV_WRITE_ONLY_AA,	eMCDRV_WRITE_ONLY_AA,	eMCDRV_WRITE_ONLY_AA,	eMCDRV_WRITE_ONLY_AA,	eMCDRV_WRITE_ONLY_AA,
+	eMCDRV_WRITE_ONLY_AA,	eMCDRV_WRITE_ONLY_AA,	eMCDRV_WRITE_ONLY_AA,	eMCDRV_WRITE_ONLY_AA,	eMCDRV_WRITE_ONLY_AA,	eMCDRV_WRITE_ONLY_AA,	eMCDRV_WRITE_ONLY_AA,	eMCDRV_WRITE_ONLY_AA,
+	eMCDRV_WRITE_ONLY_AA,	eMCDRV_WRITE_ONLY_AA,	eMCDRV_WRITE_ONLY_AA,	eMCDRV_WRITE_ONLY_AA,	eMCDRV_WRITE_ONLY_AA,	eMCDRV_WRITE_ONLY_AA,	eMCDRV_WRITE_ONLY_AA,	eMCDRV_WRITE_ONLY_AA,
+	eMCDRV_WRITE_ONLY_AA,	eMCDRV_WRITE_ONLY_AA,	eMCDRV_WRITE_ONLY_AA,	eMCDRV_WRITE_ONLY_AA,	eMCDRV_WRITE_ONLY_AA,	eMCDRV_WRITE_ONLY_AA,	eMCDRV_WRITE_ONLY_AA,	eMCDRV_WRITE_ONLY_AA,
+	eMCDRV_WRITE_ONLY_AA,	eMCDRV_WRITE_ONLY_AA,	eMCDRV_WRITE_ONLY_AA,	eMCDRV_WRITE_ONLY_AA,	eMCDRV_WRITE_ONLY_AA,	eMCDRV_WRITE_ONLY_AA,	eMCDRV_WRITE_ONLY_AA,	eMCDRV_WRITE_ONLY_AA,
+	eMCDRV_WRITE_ONLY_AA,	eMCDRV_WRITE_ONLY_AA,	eMCDRV_WRITE_ONLY_AA,	eMCDRV_WRITE_ONLY_AA,	eMCDRV_WRITE_ONLY_AA,	eMCDRV_WRITE_ONLY_AA,	eMCDRV_WRITE_ONLY_AA,	eMCDRV_WRITE_ONLY_AA,
+	eMCDRV_WRITE_ONLY_AA,	eMCDRV_WRITE_ONLY_AA,	eMCDRV_WRITE_ONLY_AA,	eMCDRV_WRITE_ONLY_AA,	eMCDRV_WRITE_ONLY_AA,	eMCDRV_WRITE_ONLY_AA,	eMCDRV_WRITE_ONLY_AA,	eMCDRV_WRITE_ONLY_AA,
+	eMCDRV_WRITE_ONLY_AA,	eMCDRV_WRITE_ONLY_AA,	eMCDRV_WRITE_ONLY_AA,	eMCDRV_WRITE_ONLY_AA,	eMCDRV_WRITE_ONLY_AA,	eMCDRV_WRITE_ONLY_AA,	eMCDRV_WRITE_ONLY_AA,	eMCDRV_WRITE_ONLY_AA,
+	eMCDRV_WRITE_ONLY_AA,	eMCDRV_WRITE_ONLY_AA,	eMCDRV_WRITE_ONLY_AA,	eMCDRV_WRITE_ONLY_AA,	eMCDRV_WRITE_ONLY_AA,	eMCDRV_WRITE_ONLY_AA,	eMCDRV_WRITE_ONLY_AA,	eMCDRV_WRITE_ONLY_AA,
+	eMCDRV_WRITE_ONLY_AA,	eMCDRV_WRITE_ONLY_AA,	eMCDRV_WRITE_ONLY_AA,	eMCDRV_WRITE_ONLY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,
+	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,
+	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,
+	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,
+	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,
+	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,
+	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,
+	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,
+	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,
+	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,	eMCDRV_ACCESS_DENY_AA,
+};
+
+
+static void		SetRegDefault(void);
+static void		InitPathInfo(void);
+static void		InitVolInfo(void);
+static void		InitDioInfo(void);
+static void		InitDacInfo(void);
+static void		InitAdcInfo(void);
+static void		InitSpInfo(void);
+static void		InitDngInfo(void);
+static void		InitAeInfo(void);
+static void		InitPdmInfo(void);
+static void		InitGpMode(void);
+static void		InitGpMask(void);
+
+static void		SetHPSourceOnOff(const MCDRV_PATH_INFO* psPathInfo);
+static void		SetSPSourceOnOff(const MCDRV_PATH_INFO* psPathInfo);
+static void		SetRCVSourceOnOff(const MCDRV_PATH_INFO* psPathInfo);
+static void		SetLO1SourceOnOff(const MCDRV_PATH_INFO* psPathInfo);
+static void		SetLO2SourceOnOff(const MCDRV_PATH_INFO* psPathInfo);
+static void		SetPMSourceOnOff(const MCDRV_PATH_INFO* psPathInfo);
+static void		SetDIT0SourceOnOff(const MCDRV_PATH_INFO* psPathInfo);
+static void		SetDIT1SourceOnOff(const MCDRV_PATH_INFO* psPathInfo);
+static void		SetDIT2SourceOnOff(const MCDRV_PATH_INFO* psPathInfo);
+static void		SetDACSourceOnOff(const MCDRV_PATH_INFO* psPathInfo);
+static void		SetAESourceOnOff(const MCDRV_PATH_INFO* psPathInfo);
+static void		SetCDSPSourceOnOff(const MCDRV_PATH_INFO* psPathInfo);
+static void		SetADC0SourceOnOff(const MCDRV_PATH_INFO* psPathInfo);
+static void		SetADC1SourceOnOff(const MCDRV_PATH_INFO* psPathInfo);
+static void		SetMixSourceOnOff(const MCDRV_PATH_INFO* psPathInfo);
+static void		SetBiasSourceOnOff(const MCDRV_PATH_INFO* psPathInfo);
+
+static void		SetDIOCommon(const MCDRV_DIO_INFO* psDioInfo, UINT8 bPort);
+static void		SetDIODIR(const MCDRV_DIO_INFO* psDioInfo, UINT8 bPort);
+static void		SetDIODIT(const MCDRV_DIO_INFO* psDioInfo, UINT8 bPort);
+
+static SINT16	GetDigitalVolReg(SINT16 swVol);
+static SINT16	GetADVolReg(SINT16 swVol);
+static SINT16	GetLIVolReg(SINT16 swVol);
+static SINT16	GetMcVolReg(SINT16 swVol);
+static SINT16	GetMcGainReg(SINT16 swVol);
+static SINT16	GetHpVolReg(SINT16 swVol);
+static SINT16	GetHpGainReg(SINT16 swVol);
+static SINT16	GetSpVolReg(SINT16 swVol);
+static SINT16	GetRcVolReg(SINT16 swVol);
+static SINT16	GetLoVolReg(SINT16 swVol);
+
+static SINT32	WaitBitSet(UINT8 bSlaveAddr, UINT16 wRegAddr, UINT8 bBit, UINT32 dCycleTime, UINT32 dTimeOut);
+static SINT32	WaitBitRelease(UINT8 bSlaveAddr, UINT16 wRegAddr, UINT8 bBit, UINT32 dCycleTime, UINT32 dTimeOut);
+
+/****************************************************************************
+ *	McResCtrl_SetHwId_AA
+ *
+ *	Description:
+ *			Set hardware ID.
+ *	Arguments:
+ *			bHwId	hardware ID
+ *	Return:
+ *			MCDRV_SUCCESS
+ *			MCDRV_ERROR_INIT
+ *
+ ****************************************************************************/
+SINT32	McResCtrl_SetHwId_AA
+(
+	UINT8	bHwId
+)
+{
+	gsGlobalInfo_AA.bHwId	= bHwId;
+
+	switch (bHwId)
+	{
+	case MCDRV_HWID_YMU821_AA:
+		McDevProf_SetDevId(eMCDRV_DEV_ID_1N2);
+		break;
+	default:
+		return MCDRV_ERROR_INIT;
+	}
+
+	return MCDRV_SUCCESS;
+}
+
+/****************************************************************************
+ *	McResCtrl_Init_AA
+ *
+ *	Description:
+ *			initialize the resource controller.
+ *	Arguments:
+ *			psInitInfo	pointer to the initialize information struct
+ *	Return:
+ *			none
+ *
+ ****************************************************************************/
+void	McResCtrl_Init_AA
+(
+	const MCDRV_INIT_INFO*	psInitInfo
+)
+{
+	gsGlobalInfo_AA.ePacketBufAlloc	= eMCDRV_PACKETBUF_FREE_AA;
+	SetRegDefault();
+
+	gsGlobalInfo_AA.sInitInfo.bCkSel	= psInitInfo->bCkSel;
+	gsGlobalInfo_AA.sInitInfo.bDivR0	= psInitInfo->bDivR0;
+	gsGlobalInfo_AA.sInitInfo.bDivF0	= psInitInfo->bDivF0;
+	if(McDevProf_IsValid(eMCDRV_FUNC_DIVR1) == 1)
+	{
+		gsGlobalInfo_AA.sInitInfo.bDivR1	= psInitInfo->bDivR1;
+	}
+	else
+	{
+		gsGlobalInfo_AA.sInitInfo.bDivR1	= 0;
+	}
+	if(McDevProf_IsValid(eMCDRV_FUNC_DIVF1) == 1)
+	{
+		gsGlobalInfo_AA.sInitInfo.bDivF1	= psInitInfo->bDivF1;
+	}
+	else
+	{
+		gsGlobalInfo_AA.sInitInfo.bDivF1	= 0;
+	}
+	if(McDevProf_IsValid(eMCDRV_FUNC_RANGE) == 1)
+	{
+		gsGlobalInfo_AA.sInitInfo.bRange0	= psInitInfo->bRange0;
+		gsGlobalInfo_AA.sInitInfo.bRange1	= psInitInfo->bRange1;
+	}
+	else
+	{
+		gsGlobalInfo_AA.sInitInfo.bRange0	= 0;
+		gsGlobalInfo_AA.sInitInfo.bRange1	= 0;
+	}
+	if(McDevProf_IsValid(eMCDRV_FUNC_BYPASS) == 1)
+	{
+		gsGlobalInfo_AA.sInitInfo.bBypass	= psInitInfo->bBypass;
+	}
+	else
+	{
+		gsGlobalInfo_AA.sInitInfo.bBypass	= 0;
+	}
+	gsGlobalInfo_AA.sInitInfo.bDioSdo0Hiz	= psInitInfo->bDioSdo0Hiz;
+	gsGlobalInfo_AA.sInitInfo.bDioSdo1Hiz	= psInitInfo->bDioSdo1Hiz;
+	gsGlobalInfo_AA.sInitInfo.bDioSdo2Hiz	= psInitInfo->bDioSdo2Hiz;
+	gsGlobalInfo_AA.sInitInfo.bDioClk0Hiz	= psInitInfo->bDioClk0Hiz;
+	gsGlobalInfo_AA.sInitInfo.bDioClk1Hiz	= psInitInfo->bDioClk1Hiz;
+	gsGlobalInfo_AA.sInitInfo.bDioClk2Hiz	= psInitInfo->bDioClk2Hiz;
+	gsGlobalInfo_AA.sInitInfo.bPcmHiz		= psInitInfo->bPcmHiz;
+	gsGlobalInfo_AA.sInitInfo.bLineIn1Dif	= psInitInfo->bLineIn1Dif;
+	if(McDevProf_IsValid(eMCDRV_FUNC_LI2) == 1)
+	{
+		gsGlobalInfo_AA.sInitInfo.bLineIn2Dif	= psInitInfo->bLineIn2Dif;
+	}
+	else
+	{
+		gsGlobalInfo_AA.sInitInfo.bLineIn2Dif	= MCDRV_LINE_STEREO;
+	}
+	gsGlobalInfo_AA.sInitInfo.bLineOut1Dif	= psInitInfo->bLineOut1Dif;
+	gsGlobalInfo_AA.sInitInfo.bLineOut2Dif	= psInitInfo->bLineOut2Dif;
+	gsGlobalInfo_AA.sInitInfo.bSpmn		= psInitInfo->bSpmn;
+	gsGlobalInfo_AA.sInitInfo.bMic1Sng		= psInitInfo->bMic1Sng;
+	gsGlobalInfo_AA.sInitInfo.bMic2Sng		= psInitInfo->bMic2Sng;
+	gsGlobalInfo_AA.sInitInfo.bMic3Sng		= psInitInfo->bMic3Sng;
+	gsGlobalInfo_AA.sInitInfo.bPowerMode	= psInitInfo->bPowerMode;
+	gsGlobalInfo_AA.sInitInfo.bSpHiz		= psInitInfo->bSpHiz;
+	gsGlobalInfo_AA.sInitInfo.bLdo			= psInitInfo->bLdo;
+	gsGlobalInfo_AA.sInitInfo.bPad0Func	= psInitInfo->bPad0Func;
+	gsGlobalInfo_AA.sInitInfo.bPad1Func	= psInitInfo->bPad1Func;
+	if(McDevProf_IsValid(eMCDRV_FUNC_PAD2) == 1)
+	{
+		gsGlobalInfo_AA.sInitInfo.bPad2Func	= psInitInfo->bPad2Func;
+	}
+	else
+	{
+		gsGlobalInfo_AA.sInitInfo.bPad2Func	= MCDRV_PAD_GPIO;
+	}
+	gsGlobalInfo_AA.sInitInfo.bAvddLev		= psInitInfo->bAvddLev;
+	gsGlobalInfo_AA.sInitInfo.bVrefLev		= psInitInfo->bVrefLev;
+	gsGlobalInfo_AA.sInitInfo.bDclGain		= psInitInfo->bDclGain;
+	gsGlobalInfo_AA.sInitInfo.bDclLimit	= psInitInfo->bDclLimit;
+	gsGlobalInfo_AA.sInitInfo.bReserved1	= psInitInfo->bReserved1;
+	gsGlobalInfo_AA.sInitInfo.bReserved2	= psInitInfo->bReserved2;
+	gsGlobalInfo_AA.sInitInfo.bReserved3	= psInitInfo->bReserved3;
+	gsGlobalInfo_AA.sInitInfo.bReserved4	= psInitInfo->bReserved4;
+	gsGlobalInfo_AA.sInitInfo.bReserved5	= psInitInfo->bReserved5;
+	gsGlobalInfo_AA.sInitInfo.sWaitTime	= psInitInfo->sWaitTime;
+
+	InitPathInfo();
+	InitVolInfo();
+	InitDioInfo();
+	InitDacInfo();
+	InitAdcInfo();
+	InitSpInfo();
+	InitDngInfo();
+	InitAeInfo();
+	InitPdmInfo();
+	InitGpMode();
+	InitGpMask();
+
+	McResCtrl_InitRegUpdate_AA();
+
+	gsGlobalInfo_AA.eAPMode = eMCDRV_APM_OFF_AA;
+
+	gsGlobalInfo_AA.eHwAdj = eMCDRV_HWADJ_THRU;
+}
+
+/****************************************************************************
+ *	SetRegDefault
+ *
+ *	Description:
+ *			Initialize the virtual registers.
+ *	Arguments:
+ *			none
+ *	Return:
+ *			none
+ *
+ ****************************************************************************/
+static void	SetRegDefault
+(
+	void
+)
+{
+	UINT16	i;
+	for(i = 0; i < MCDRV_A_REG_NUM_AA; i++)
+	{
+		gsGlobalInfo_AA.abRegValA[i]	= 0;
+	}
+	gsGlobalInfo_AA.abRegValA[MCI_AA_RST]		= MCI_AA_RST_DEF;
+	gsGlobalInfo_AA.abRegValA[MCI_AA_HW_ID]	= MCI_AA_HW_ID_DEF;
+
+	for(i = 0; i < MCDRV_B_BASE_REG_NUM_AA; i++)
+	{
+		gsGlobalInfo_AA.abRegValB_BASE[i]	= 0;
+	}
+	gsGlobalInfo_AA.abRegValB_BASE[MCI_AA_RSTB]				= MCI_AA_RSTB_DEF;
+	gsGlobalInfo_AA.abRegValB_BASE[MCI_AA_PWM_DIGITAL]		= MCI_AA_PWM_DIGITAL_DEF;
+	gsGlobalInfo_AA.abRegValB_BASE[MCI_AA_PWM_DIGITAL_1]		= MCI_AA_PWM_DIGITAL_1_DEF;
+	gsGlobalInfo_AA.abRegValB_BASE[MCI_AA_PWM_DIGITAL_CDSP]	= MCI_AA_PWM_DIGITAL_CDSP_DEF;
+	gsGlobalInfo_AA.abRegValB_BASE[MCI_AA_PWM_DIGITAL_BDSP]	= MCI_AA_PWM_DIGITAL_BDSP_DEF;
+	gsGlobalInfo_AA.abRegValB_BASE[MCI_AA_SD_MSK]				= MCI_AA_SD_MSK_DEF;
+	gsGlobalInfo_AA.abRegValB_BASE[MCI_AA_SD_MSK_1]			= MCI_AA_SD_MSK_1_DEF;
+	gsGlobalInfo_AA.abRegValB_BASE[MCI_AA_BCLK_MSK]			= MCI_AA_BCLK_MSK_DEF;
+	gsGlobalInfo_AA.abRegValB_BASE[MCI_AA_BCLK_MSK_1]			= MCI_AA_BCLK_MSK_1_DEF;
+	gsGlobalInfo_AA.abRegValB_BASE[MCI_AA_BCKP]				= MCI_AA_BCKP_DEF;
+	gsGlobalInfo_AA.abRegValB_BASE[MCI_AA_PLL_RST]				= MCI_AA_PLL_RST_DEF;
+	gsGlobalInfo_AA.abRegValB_BASE[MCI_AA_DIVR0]				= MCI_AA_DIVR0_DEF;
+	gsGlobalInfo_AA.abRegValB_BASE[MCI_AA_DIVF0]				= MCI_AA_DIVF0_DEF;
+	gsGlobalInfo_AA.abRegValB_BASE[MCI_AA_PA_MSK]				= MCI_AA_PA_MSK_DEF;
+	gsGlobalInfo_AA.abRegValB_BASE[MCI_AA_PA_MSK_1]			= MCI_AA_PA_MSK_1_DEF;
+
+	for(i = 0; i < MCDRV_B_MIXER_REG_NUM_AA; i++)
+	{
+		gsGlobalInfo_AA.abRegValB_MIXER[i]	= 0;
+	}
+	gsGlobalInfo_AA.abRegValB_MIXER[MCI_AA_DIT_ININTP]	= MCI_AA_DIT_ININTP_DEF;
+	gsGlobalInfo_AA.abRegValB_MIXER[MCI_AA_DIR_INTP]		= MCI_AA_DIR_INTP_DEF;
+	gsGlobalInfo_AA.abRegValB_MIXER[MCI_AA_ADC_INTP]		= MCI_AA_ADC_INTP_DEF;
+	gsGlobalInfo_AA.abRegValB_MIXER[MCI_AA_AINTP]			= MCI_AA_AINTP_DEF;
+	gsGlobalInfo_AA.abRegValB_MIXER[MCI_AA_IINTP]			= MCI_AA_IINTP_DEF;
+	gsGlobalInfo_AA.abRegValB_MIXER[MCI_AA_DAC_INTP]		= MCI_AA_DAC_INTP_DEF;
+	gsGlobalInfo_AA.abRegValB_MIXER[MCI_AA_DIR0_CH]		= MCI_AA_DIR0_CH_DEF;
+	gsGlobalInfo_AA.abRegValB_MIXER[MCI_AA_DIT0_SLOT]		= MCI_AA_DIT0_SLOT_DEF;
+	gsGlobalInfo_AA.abRegValB_MIXER[MCI_AA_PCM_RX0]		= MCI_AA_PCM_RX0_DEF;
+	gsGlobalInfo_AA.abRegValB_MIXER[MCI_AA_PCM_TX0]		= MCI_AA_PCM_TX0_DEF;
+	gsGlobalInfo_AA.abRegValB_MIXER[MCI_AA_PCM_SLOT_TX0]	= MCI_AA_PCM_SLOT_TX0_DEF;
+	gsGlobalInfo_AA.abRegValB_MIXER[MCI_AA_DIR1_CH]		= MCI_AA_DIR1_CH_DEF;
+	gsGlobalInfo_AA.abRegValB_MIXER[MCI_AA_DIT1_SLOT]		= MCI_AA_DIT1_SLOT_DEF;
+	gsGlobalInfo_AA.abRegValB_MIXER[MCI_AA_PCM_RX1]		= MCI_AA_PCM_RX1_DEF;
+	gsGlobalInfo_AA.abRegValB_MIXER[MCI_AA_PCM_TX1]		= MCI_AA_PCM_TX1_DEF;
+	gsGlobalInfo_AA.abRegValB_MIXER[MCI_AA_PCM_SLOT_TX1]	= MCI_AA_PCM_SLOT_TX1_DEF;
+	gsGlobalInfo_AA.abRegValB_MIXER[MCI_AA_DIR2_CH]		= MCI_AA_DIR2_CH_DEF;
+	gsGlobalInfo_AA.abRegValB_MIXER[MCI_AA_DIT2_SLOT]		= MCI_AA_DIT2_SLOT_DEF;
+	gsGlobalInfo_AA.abRegValB_MIXER[MCI_AA_PCM_RX2]		= MCI_AA_PCM_RX2_DEF;
+	gsGlobalInfo_AA.abRegValB_MIXER[MCI_AA_PCM_TX2]		= MCI_AA_PCM_TX2_DEF;
+	gsGlobalInfo_AA.abRegValB_MIXER[MCI_AA_PCM_SLOT_TX2]	= MCI_AA_PCM_SLOT_TX2_DEF;
+	gsGlobalInfo_AA.abRegValB_MIXER[MCI_AA_CDI_CH]		= MCI_AA_CDI_CH_DEF;
+	gsGlobalInfo_AA.abRegValB_MIXER[MCI_AA_CDO_SLOT]		= MCI_AA_CDO_SLOT_DEF;
+	gsGlobalInfo_AA.abRegValB_MIXER[MCI_AA_PDM_AGC]		= MCI_AA_PDM_AGC_DEF;
+	gsGlobalInfo_AA.abRegValB_MIXER[MCI_AA_PDM_MUTE]		= MCI_AA_PDM_MUTE_DEF;
+	gsGlobalInfo_AA.abRegValB_MIXER[MCI_AA_PDM_STWAIT]	= MCI_AA_PDM_STWAIT_DEF;
+	gsGlobalInfo_AA.abRegValB_MIXER[MCI_AA_CHP_H]			= MCI_AA_CHP_H_DEF;
+	gsGlobalInfo_AA.abRegValB_MIXER[MCI_AA_CHP_M]			= MCI_AA_CHP_M_DEF;
+	gsGlobalInfo_AA.abRegValB_MIXER[MCI_AA_CHP_L]			= MCI_AA_CHP_L_DEF;
+
+	for(i = 0; i < MCDRV_B_AE_REG_NUM_AA; i++)
+	{
+		gsGlobalInfo_AA.abRegValB_AE[i]	= 0;
+	}
+	gsGlobalInfo_AA.abRegValB_AE[MCI_AA_BAND0_CEQ0]	= MCI_AA_BAND0_CEQ0_H_DEF;
+	gsGlobalInfo_AA.abRegValB_AE[MCI_AA_BAND1_CEQ0]	= MCI_AA_BAND1_CEQ0_H_DEF;
+	gsGlobalInfo_AA.abRegValB_AE[MCI_AA_BAND2_CEQ0]	= MCI_AA_BAND2_CEQ0_H_DEF;
+	gsGlobalInfo_AA.abRegValB_AE[MCI_AA_BAND3H_CEQ0]	= MCI_AA_BAND3H_CEQ0_H_DEF;
+	gsGlobalInfo_AA.abRegValB_AE[MCI_AA_BAND4H_CEQ0]	= MCI_AA_BAND4H_CEQ0_H_DEF;
+	gsGlobalInfo_AA.abRegValB_AE[MCI_AA_BAND5_CEQ0]	= MCI_AA_BAND5_CEQ0_H_DEF;
+	gsGlobalInfo_AA.abRegValB_AE[MCI_AA_BAND6H_CEQ0]	= MCI_AA_BAND6H_CEQ0_H_DEF;
+	gsGlobalInfo_AA.abRegValB_AE[MCI_AA_BAND7H_CEQ0]	= MCI_AA_BAND7H_CEQ0_H_DEF;
+	gsGlobalInfo_AA.abRegValB_AE[MCI_AA_PDM_CHP0_H]	= MCI_AA_PDM_CHP0_H_DEF;
+	gsGlobalInfo_AA.abRegValB_AE[MCI_AA_PDM_CHP0_M]	= MCI_AA_PDM_CHP0_M_DEF;
+	gsGlobalInfo_AA.abRegValB_AE[MCI_AA_PDM_CHP0_L]	= MCI_AA_PDM_CHP0_L_DEF;
+	gsGlobalInfo_AA.abRegValB_AE[MCI_AA_PDM_CHP1_H]	= MCI_AA_PDM_CHP1_H_DEF;
+	gsGlobalInfo_AA.abRegValB_AE[MCI_AA_PDM_CHP1_M]	= MCI_AA_PDM_CHP1_M_DEF;
+	gsGlobalInfo_AA.abRegValB_AE[MCI_AA_PDM_CHP1_L]	= MCI_AA_PDM_CHP1_L_DEF;
+	gsGlobalInfo_AA.abRegValB_AE[MCI_AA_PDM_CHP3_H]	= MCI_AA_PDM_CHP3_H_DEF;
+	gsGlobalInfo_AA.abRegValB_AE[MCI_AA_PDM_CHP3_M]	= MCI_AA_PDM_CHP3_M_DEF;
+	gsGlobalInfo_AA.abRegValB_AE[MCI_AA_PDM_CHP3_L]	= MCI_AA_PDM_CHP3_L_DEF;
+
+	for(i = 0; i < MCDRV_B_CDSP_REG_NUM_AA; i++)
+	{
+		gsGlobalInfo_AA.abRegValB_CDSP[i]	= 0;
+	}
+	gsGlobalInfo_AA.abRegValB_CDSP[MCI_AA_JOEMP]		= MCI_AA_JOEMP_DEF;
+	gsGlobalInfo_AA.abRegValB_CDSP[MCI_AA_JEEMP]		= MCI_AA_JEEMP_DEF;
+	gsGlobalInfo_AA.abRegValB_CDSP[MCI_AA_CDSP_SRST]	= MCI_AA_CDSP_SRST_DEF;
+
+	for(i = 0; i < MCDRV_B_ANA_REG_NUM_AA; i++)
+	{
+		gsGlobalInfo_AA.abRegValB_ANA[i]	= 0;
+	}
+	gsGlobalInfo_AA.abRegValB_ANA[MCI_AA_ANA_RST]			= MCI_AA_ANA_RST_DEF;
+	gsGlobalInfo_AA.abRegValB_ANA[MCI_AA_PWM_ANALOG_0]	= MCI_AA_PWM_ANALOG_0_DEF;
+	gsGlobalInfo_AA.abRegValB_ANA[MCI_AA_PWM_ANALOG_1]	= MCI_AA_PWM_ANALOG_1_DEF;
+	gsGlobalInfo_AA.abRegValB_ANA[MCI_AA_PWM_ANALOG_2]	= MCI_AA_PWM_ANALOG_2_DEF;
+	gsGlobalInfo_AA.abRegValB_ANA[MCI_AA_PWM_ANALOG_3]	= MCI_AA_PWM_ANALOG_3_DEF;
+	gsGlobalInfo_AA.abRegValB_ANA[MCI_AA_PWM_ANALOG_4]	= MCI_AA_PWM_ANALOG_4_DEF;
+	gsGlobalInfo_AA.abRegValB_ANA[MCI_AA_DNGATRT]			= MCI_AA_DNGATRT_DEF;
+	gsGlobalInfo_AA.abRegValB_ANA[MCI_AA_DNGON]			= MCI_AA_DNGON_DEF;
+	gsGlobalInfo_AA.abRegValB_ANA[MCI_AA_HPVOL_L]			= MCI_AA_HPVOL_L_DEF;
+	gsGlobalInfo_AA.abRegValB_ANA[MCI_AA_SPVOL_L]			= MCI_AA_SPVOL_L_DEF;
+	gsGlobalInfo_AA.abRegValB_ANA[MCI_AA_RCVOL]			= MCI_AA_RCVOL_DEF;
+	gsGlobalInfo_AA.abRegValB_ANA[MCI_AA_LEV]				= MCI_AA_LEV_DEF;
+
+	for(i = 0; i < MCDRV_B_CODEC_REG_NUM_AA; i++)
+	{
+		gsGlobalInfo_AA.abRegValB_CODEC[i]	= 0;
+	}
+	gsGlobalInfo_AA.abRegValB_CODEC[MCI_AA_DPADIF]		= MCI_AA_DPADIF_DEF;
+	gsGlobalInfo_AA.abRegValB_CODEC[MCI_AA_AD_AGC]		= MCI_AA_AD_AGC_DEF;
+	gsGlobalInfo_AA.abRegValB_CODEC[MCI_AA_DAC_CONFIG]	= MCI_AA_DAC_CONFIG_DEF;
+}
+
+/****************************************************************************
+ *	InitPathInfo
+ *
+ *	Description:
+ *			Initialize path info.
+ *	Arguments:
+ *			none
+ *	Return:
+ *			none
+ *
+ ****************************************************************************/
+static void	InitPathInfo
+(
+	void
+)
+{
+	UINT8	bCh, bBlockIdx;
+	UINT8	abOnOff[SOURCE_BLOCK_NUM];
+
+	abOnOff[0]	= (MCDRV_SRC0_MIC1_OFF|MCDRV_SRC0_MIC2_OFF|MCDRV_SRC0_MIC3_OFF);
+	abOnOff[1]	= (MCDRV_SRC1_LINE1_L_OFF|MCDRV_SRC1_LINE1_R_OFF|MCDRV_SRC1_LINE1_M_OFF);
+	abOnOff[2]	= (MCDRV_SRC2_LINE2_L_OFF|MCDRV_SRC2_LINE2_R_OFF|MCDRV_SRC2_LINE2_M_OFF);
+	abOnOff[3]	= (MCDRV_SRC3_DIR0_OFF|MCDRV_SRC3_DIR1_OFF|MCDRV_SRC3_DIR2_OFF|MCDRV_SRC3_DIR2_DIRECT_OFF);
+	abOnOff[4]	= (MCDRV_SRC4_DTMF_OFF|MCDRV_SRC4_PDM_OFF|MCDRV_SRC4_ADC0_OFF|MCDRV_SRC4_ADC1_OFF);
+	abOnOff[5]	= (MCDRV_SRC5_DAC_L_OFF|MCDRV_SRC5_DAC_R_OFF|MCDRV_SRC5_DAC_M_OFF);
+	abOnOff[6]	= (MCDRV_SRC6_MIX_OFF|MCDRV_SRC6_AE_OFF|MCDRV_SRC6_CDSP_OFF|MCDRV_SRC6_CDSP_DIRECT_OFF);
+
+	for(bCh = 0; bCh < HP_PATH_CHANNELS; bCh++)
+	{
+		for(bBlockIdx = 0; bBlockIdx < SOURCE_BLOCK_NUM; bBlockIdx++)
+		{
+			gsGlobalInfo_AA.sPathInfo.asHpOut[bCh].abSrcOnOff[bBlockIdx]	= abOnOff[bBlockIdx];
+		}
+	}
+	for(bCh = 0; bCh < SP_PATH_CHANNELS; bCh++)
+	{
+		for(bBlockIdx = 0; bBlockIdx < SOURCE_BLOCK_NUM; bBlockIdx++)
+		{
+			gsGlobalInfo_AA.sPathInfo.asSpOut[bCh].abSrcOnOff[bBlockIdx]	= abOnOff[bBlockIdx];
+		}
+	}
+	for(bCh = 0; bCh < RC_PATH_CHANNELS; bCh++)
+	{
+		for(bBlockIdx = 0; bBlockIdx < SOURCE_BLOCK_NUM; bBlockIdx++)
+		{
+			gsGlobalInfo_AA.sPathInfo.asRcOut[bCh].abSrcOnOff[bBlockIdx]	= abOnOff[bBlockIdx];
+		}
+	}
+	for(bCh = 0; bCh < LOUT1_PATH_CHANNELS; bCh++)
+	{
+		for(bBlockIdx = 0; bBlockIdx < SOURCE_BLOCK_NUM; bBlockIdx++)
+		{
+			gsGlobalInfo_AA.sPathInfo.asLout1[bCh].abSrcOnOff[bBlockIdx]	= abOnOff[bBlockIdx];
+		}
+	}
+	for(bCh = 0; bCh < LOUT2_PATH_CHANNELS; bCh++)
+	{
+		for(bBlockIdx = 0; bBlockIdx < SOURCE_BLOCK_NUM; bBlockIdx++)
+		{
+			gsGlobalInfo_AA.sPathInfo.asLout2[bCh].abSrcOnOff[bBlockIdx]	= abOnOff[bBlockIdx];
+		}
+	}
+	for(bCh = 0; bCh < PEAK_PATH_CHANNELS; bCh++)
+	{
+		for(bBlockIdx = 0; bBlockIdx < SOURCE_BLOCK_NUM; bBlockIdx++)
+		{
+			gsGlobalInfo_AA.sPathInfo.asPeak[bCh].abSrcOnOff[bBlockIdx]	= abOnOff[bBlockIdx];
+		}
+	}
+	for(bCh = 0; bCh < DIT0_PATH_CHANNELS; bCh++)
+	{
+		for(bBlockIdx = 0; bBlockIdx < SOURCE_BLOCK_NUM; bBlockIdx++)
+		{
+			gsGlobalInfo_AA.sPathInfo.asDit0[bCh].abSrcOnOff[bBlockIdx]	= abOnOff[bBlockIdx];
+		}
+	}
+	for(bCh = 0; bCh < DIT1_PATH_CHANNELS; bCh++)
+	{
+		for(bBlockIdx = 0; bBlockIdx < SOURCE_BLOCK_NUM; bBlockIdx++)
+		{
+			gsGlobalInfo_AA.sPathInfo.asDit1[bCh].abSrcOnOff[bBlockIdx]	= abOnOff[bBlockIdx];
+		}
+	}
+	for(bCh = 0; bCh < DIT2_PATH_CHANNELS; bCh++)
+	{
+		for(bBlockIdx = 0; bBlockIdx < SOURCE_BLOCK_NUM; bBlockIdx++)
+		{
+			gsGlobalInfo_AA.sPathInfo.asDit2[bCh].abSrcOnOff[bBlockIdx]	= abOnOff[bBlockIdx];
+		}
+	}
+	for(bCh = 0; bCh < DAC_PATH_CHANNELS; bCh++)
+	{
+		for(bBlockIdx = 0; bBlockIdx < SOURCE_BLOCK_NUM; bBlockIdx++)
+		{
+			gsGlobalInfo_AA.sPathInfo.asDac[bCh].abSrcOnOff[bBlockIdx]	= abOnOff[bBlockIdx];
+		}
+	}
+	for(bCh = 0; bCh < AE_PATH_CHANNELS; bCh++)
+	{
+		for(bBlockIdx = 0; bBlockIdx < SOURCE_BLOCK_NUM; bBlockIdx++)
+		{
+			gsGlobalInfo_AA.sPathInfo.asAe[bCh].abSrcOnOff[bBlockIdx]	= abOnOff[bBlockIdx];
+		}
+	}
+	for(bCh = 0; bCh < CDSP_PATH_CHANNELS; bCh++)
+	{
+		for(bBlockIdx = 0; bBlockIdx < SOURCE_BLOCK_NUM; bBlockIdx++)
+		{
+			gsGlobalInfo_AA.sPathInfo.asCdsp[bCh].abSrcOnOff[bBlockIdx]	= abOnOff[bBlockIdx];
+		}
+	}
+	for(bCh = 0; bCh < ADC0_PATH_CHANNELS; bCh++)
+	{
+		for(bBlockIdx = 0; bBlockIdx < SOURCE_BLOCK_NUM; bBlockIdx++)
+		{
+			gsGlobalInfo_AA.sPathInfo.asAdc0[bCh].abSrcOnOff[bBlockIdx]	= abOnOff[bBlockIdx];
+		}
+	}
+	for(bCh = 0; bCh < ADC1_PATH_CHANNELS; bCh++)
+	{
+		for(bBlockIdx = 0; bBlockIdx < SOURCE_BLOCK_NUM; bBlockIdx++)
+		{
+			gsGlobalInfo_AA.sPathInfo.asAdc1[bCh].abSrcOnOff[bBlockIdx]	= abOnOff[bBlockIdx];
+		}
+	}
+	for(bCh = 0; bCh < MIX_PATH_CHANNELS; bCh++)
+	{
+		for(bBlockIdx = 0; bBlockIdx < SOURCE_BLOCK_NUM; bBlockIdx++)
+		{
+			gsGlobalInfo_AA.sPathInfo.asMix[bCh].abSrcOnOff[bBlockIdx]	= abOnOff[bBlockIdx];
+		}
+	}
+	for(bCh = 0; bCh < BIAS_PATH_CHANNELS; bCh++)
+	{
+		for(bBlockIdx = 0; bBlockIdx < SOURCE_BLOCK_NUM; bBlockIdx++)
+		{
+			gsGlobalInfo_AA.sPathInfo.asBias[bCh].abSrcOnOff[bBlockIdx]	= abOnOff[bBlockIdx];
+		}
+	}
+	gsGlobalInfo_AA.sPathInfoVirtual	= gsGlobalInfo_AA.sPathInfo;
+}
+
+/****************************************************************************
+ *	InitVolInfo
+ *
+ *	Description:
+ *			Initialize volume info.
+ *	Arguments:
+ *			none
+ *	Return:
+ *			none
+ *
+ ****************************************************************************/
+static void	InitVolInfo
+(
+	void
+)
+{
+	UINT8	bCh;
+	for(bCh = 0; bCh < AD0_VOL_CHANNELS; bCh++)
+	{
+		gsGlobalInfo_AA.sVolInfo.aswD_Ad0[bCh]			= MCDRV_LOGICAL_VOL_MUTE;
+	}
+	for(bCh = 0; bCh < AD1_VOL_CHANNELS; bCh++)
+	{
+		gsGlobalInfo_AA.sVolInfo.aswD_Ad1[bCh]			= MCDRV_LOGICAL_VOL_MUTE;
+	}
+	for(bCh = 0; bCh < AENG6_VOL_CHANNELS; bCh++)
+	{
+		gsGlobalInfo_AA.sVolInfo.aswD_Aeng6[bCh]		= MCDRV_LOGICAL_VOL_MUTE;
+	}
+	for(bCh = 0; bCh < PDM_VOL_CHANNELS; bCh++)
+	{
+		gsGlobalInfo_AA.sVolInfo.aswD_Pdm[bCh]			= MCDRV_LOGICAL_VOL_MUTE;
+	}
+	for(bCh = 0; bCh < DTMF_VOL_CHANNELS; bCh++)
+	{
+		gsGlobalInfo_AA.sVolInfo.aswD_Dtmfb[bCh]		= MCDRV_LOGICAL_VOL_MUTE;
+	}
+	for(bCh = 0; bCh < DIO0_VOL_CHANNELS; bCh++)
+	{
+		gsGlobalInfo_AA.sVolInfo.aswD_Dir0[bCh]		= MCDRV_LOGICAL_VOL_MUTE;
+	}
+	for(bCh = 0; bCh < DIO1_VOL_CHANNELS; bCh++)
+	{
+		gsGlobalInfo_AA.sVolInfo.aswD_Dir1[bCh]		= MCDRV_LOGICAL_VOL_MUTE;
+	}
+	for(bCh = 0; bCh < DIO2_VOL_CHANNELS; bCh++)
+	{
+		gsGlobalInfo_AA.sVolInfo.aswD_Dir2[bCh]		= MCDRV_LOGICAL_VOL_MUTE;
+	}
+	for(bCh = 0; bCh < AD0_VOL_CHANNELS; bCh++)
+	{
+		gsGlobalInfo_AA.sVolInfo.aswD_Ad0Att[bCh]		= MCDRV_LOGICAL_VOL_MUTE;
+	}
+	for(bCh = 0; bCh < AD1_VOL_CHANNELS; bCh++)
+	{
+		gsGlobalInfo_AA.sVolInfo.aswD_Ad1Att[bCh]		= MCDRV_LOGICAL_VOL_MUTE;
+	}
+	for(bCh = 0; bCh < DIO0_VOL_CHANNELS; bCh++)
+	{
+		gsGlobalInfo_AA.sVolInfo.aswD_Dir0Att[bCh]		= MCDRV_LOGICAL_VOL_MUTE;
+	}
+	for(bCh = 0; bCh < DIO1_VOL_CHANNELS; bCh++)
+	{
+		gsGlobalInfo_AA.sVolInfo.aswD_Dir1Att[bCh]		= MCDRV_LOGICAL_VOL_MUTE;
+	}
+	for(bCh = 0; bCh < DIO2_VOL_CHANNELS; bCh++)
+	{
+		gsGlobalInfo_AA.sVolInfo.aswD_Dir2Att[bCh]		= MCDRV_LOGICAL_VOL_MUTE;
+	}
+	for(bCh = 0; bCh < PDM_VOL_CHANNELS; bCh++)
+	{
+		gsGlobalInfo_AA.sVolInfo.aswD_SideTone[bCh]	= MCDRV_LOGICAL_VOL_MUTE;
+	}
+	for(bCh = 0; bCh < DTFM_VOL_CHANNELS; bCh++)
+	{
+		gsGlobalInfo_AA.sVolInfo.aswD_DtmfAtt[bCh]		= MCDRV_LOGICAL_VOL_MUTE;
+	}
+	for(bCh = 0; bCh < DAC_VOL_CHANNELS; bCh++)
+	{
+		gsGlobalInfo_AA.sVolInfo.aswD_DacMaster[bCh]	= MCDRV_LOGICAL_VOL_MUTE;
+	}
+	for(bCh = 0; bCh < DAC_VOL_CHANNELS; bCh++)
+	{
+		gsGlobalInfo_AA.sVolInfo.aswD_DacVoice[bCh]	= MCDRV_LOGICAL_VOL_MUTE;
+	}
+	for(bCh = 0; bCh < DAC_VOL_CHANNELS; bCh++)
+	{
+		gsGlobalInfo_AA.sVolInfo.aswD_DacAtt[bCh]		= MCDRV_LOGICAL_VOL_MUTE;
+	}
+	for(bCh = 0; bCh < DIO0_VOL_CHANNELS; bCh++)
+	{
+		gsGlobalInfo_AA.sVolInfo.aswD_Dit0[bCh]		= MCDRV_LOGICAL_VOL_MUTE;
+	}
+	for(bCh = 0; bCh < DIO1_VOL_CHANNELS; bCh++)
+	{
+		gsGlobalInfo_AA.sVolInfo.aswD_Dit1[bCh]		= MCDRV_LOGICAL_VOL_MUTE;
+	}
+	for(bCh = 0; bCh < DIO2_VOL_CHANNELS; bCh++)
+	{
+		gsGlobalInfo_AA.sVolInfo.aswD_Dit2[bCh]		= MCDRV_LOGICAL_VOL_MUTE;
+	}
+	for(bCh = 0; bCh < AD0_VOL_CHANNELS; bCh++)
+	{
+		gsGlobalInfo_AA.sVolInfo.aswA_Ad0[bCh]			= MCDRV_LOGICAL_VOL_MUTE;
+	}
+	for(bCh = 0; bCh < AD1_VOL_CHANNELS; bCh++)
+	{
+		gsGlobalInfo_AA.sVolInfo.aswA_Ad1[bCh]			= MCDRV_LOGICAL_VOL_MUTE;
+	}
+	for(bCh = 0; bCh < LIN1_VOL_CHANNELS; bCh++)
+	{
+		gsGlobalInfo_AA.sVolInfo.aswA_Lin1[bCh]		= MCDRV_LOGICAL_VOL_MUTE;
+	}
+	for(bCh = 0; bCh < LIN2_VOL_CHANNELS; bCh++)
+	{
+		gsGlobalInfo_AA.sVolInfo.aswA_Lin2[bCh]		= MCDRV_LOGICAL_VOL_MUTE;
+	}
+	for(bCh = 0; bCh < MIC1_VOL_CHANNELS; bCh++)
+	{
+		gsGlobalInfo_AA.sVolInfo.aswA_Mic1[bCh]		= MCDRV_LOGICAL_VOL_MUTE;
+	}
+	for(bCh = 0; bCh < MIC2_VOL_CHANNELS; bCh++)
+	{
+		gsGlobalInfo_AA.sVolInfo.aswA_Mic2[bCh]		= MCDRV_LOGICAL_VOL_MUTE;
+	}
+	for(bCh = 0; bCh < MIC3_VOL_CHANNELS; bCh++)
+	{
+		gsGlobalInfo_AA.sVolInfo.aswA_Mic3[bCh]		= MCDRV_LOGICAL_VOL_MUTE;
+	}
+	for(bCh = 0; bCh < HP_VOL_CHANNELS; bCh++)
+	{
+		gsGlobalInfo_AA.sVolInfo.aswA_Hp[bCh]			= MCDRV_LOGICAL_VOL_MUTE;
+	}
+	for(bCh = 0; bCh < SP_VOL_CHANNELS; bCh++)
+	{
+		gsGlobalInfo_AA.sVolInfo.aswA_Sp[bCh]			= MCDRV_LOGICAL_VOL_MUTE;
+	}
+	for(bCh = 0; bCh < RC_VOL_CHANNELS; bCh++)
+	{
+		gsGlobalInfo_AA.sVolInfo.aswA_Rc[bCh]			= MCDRV_LOGICAL_VOL_MUTE;
+	}
+	for(bCh = 0; bCh < LOUT1_VOL_CHANNELS; bCh++)
+	{
+		gsGlobalInfo_AA.sVolInfo.aswA_Lout1[bCh]		= MCDRV_LOGICAL_VOL_MUTE;
+	}
+	for(bCh = 0; bCh < LOUT2_VOL_CHANNELS; bCh++)
+	{
+		gsGlobalInfo_AA.sVolInfo.aswA_Lout2[bCh]		= MCDRV_LOGICAL_VOL_MUTE;
+	}
+	for(bCh = 0; bCh < MIC1_VOL_CHANNELS; bCh++)
+	{
+		gsGlobalInfo_AA.sVolInfo.aswA_Mic1Gain[bCh]	= MCDRV_LOGICAL_MICGAIN_DEF;
+	}
+	for(bCh = 0; bCh < MIC2_VOL_CHANNELS; bCh++)
+	{
+		gsGlobalInfo_AA.sVolInfo.aswA_Mic2Gain[bCh]	= MCDRV_LOGICAL_MICGAIN_DEF;
+	}
+	for(bCh = 0; bCh < MIC3_VOL_CHANNELS; bCh++)
+	{
+		gsGlobalInfo_AA.sVolInfo.aswA_Mic3Gain[bCh]	= MCDRV_LOGICAL_MICGAIN_DEF;
+	}
+	for(bCh = 0; bCh < HPGAIN_VOL_CHANNELS; bCh++)
+	{
+		gsGlobalInfo_AA.sVolInfo.aswA_HpGain[bCh]		= MCDRV_LOGICAL_HPGAIN_DEF;
+	}
+}
+
+/****************************************************************************
+ *	InitDioInfo
+ *
+ *	Description:
+ *			Initialize Digital I/O info.
+ *	Arguments:
+ *			none
+ *	Return:
+ *			none
+ *
+ ****************************************************************************/
+static void	InitDioInfo
+(
+	void
+)
+{
+	UINT8	bDioIdx, bDioCh;
+	for(bDioIdx = 0; bDioIdx < 3; bDioIdx++)
+	{
+		gsGlobalInfo_AA.sDioInfo.asPortInfo[bDioIdx].sDioCommon.bMasterSlave	= MCDRV_DIO_SLAVE;
+		gsGlobalInfo_AA.sDioInfo.asPortInfo[bDioIdx].sDioCommon.bAutoFs		= MCDRV_AUTOFS_ON;
+		gsGlobalInfo_AA.sDioInfo.asPortInfo[bDioIdx].sDioCommon.bFs			= MCDRV_FS_48000;
+		gsGlobalInfo_AA.sDioInfo.asPortInfo[bDioIdx].sDioCommon.bBckFs			= MCDRV_BCKFS_64;
+		gsGlobalInfo_AA.sDioInfo.asPortInfo[bDioIdx].sDioCommon.bInterface		= MCDRV_DIO_DA;
+		gsGlobalInfo_AA.sDioInfo.asPortInfo[bDioIdx].sDioCommon.bBckInvert		= MCDRV_BCLK_NORMAL;
+		gsGlobalInfo_AA.sDioInfo.asPortInfo[bDioIdx].sDioCommon.bPcmHizTim		= MCDRV_PCMHIZTIM_FALLING;
+		gsGlobalInfo_AA.sDioInfo.asPortInfo[bDioIdx].sDioCommon.bPcmClkDown	= MCDRV_PCM_CLKDOWN_OFF;
+		gsGlobalInfo_AA.sDioInfo.asPortInfo[bDioIdx].sDioCommon.bPcmFrame		= MCDRV_PCM_SHORTFRAME;
+		gsGlobalInfo_AA.sDioInfo.asPortInfo[bDioIdx].sDioCommon.bPcmHighPeriod	= 0;
+
+		gsGlobalInfo_AA.sDioInfo.asPortInfo[bDioIdx].sDir.wSrcRate				= 0x0000;
+		gsGlobalInfo_AA.sDioInfo.asPortInfo[bDioIdx].sDir.sDaFormat.bBitSel	= MCDRV_BITSEL_16;
+		gsGlobalInfo_AA.sDioInfo.asPortInfo[bDioIdx].sDir.sDaFormat.bMode		= MCDRV_DAMODE_HEADALIGN;
+		gsGlobalInfo_AA.sDioInfo.asPortInfo[bDioIdx].sDir.sPcmFormat.bMono		= MCDRV_PCM_MONO;
+		gsGlobalInfo_AA.sDioInfo.asPortInfo[bDioIdx].sDir.sPcmFormat.bOrder	= MCDRV_PCM_MSB_FIRST;
+		gsGlobalInfo_AA.sDioInfo.asPortInfo[bDioIdx].sDir.sPcmFormat.bLaw		= MCDRV_PCM_LINEAR;
+		gsGlobalInfo_AA.sDioInfo.asPortInfo[bDioIdx].sDir.sPcmFormat.bBitSel	= MCDRV_PCM_BITSEL_8;
+		for(bDioCh = 0; bDioCh < DIO_CHANNELS; bDioCh++)
+		{
+			gsGlobalInfo_AA.sDioInfo.asPortInfo[bDioIdx].sDir.abSlot[bDioCh]	= bDioCh;
+		}
+
+		gsGlobalInfo_AA.sDioInfo.asPortInfo[bDioIdx].sDit.wSrcRate				= 0x0000;
+		gsGlobalInfo_AA.sDioInfo.asPortInfo[bDioIdx].sDit.sDaFormat.bBitSel	= MCDRV_BITSEL_16;
+		gsGlobalInfo_AA.sDioInfo.asPortInfo[bDioIdx].sDit.sDaFormat.bMode		= MCDRV_DAMODE_HEADALIGN;
+		gsGlobalInfo_AA.sDioInfo.asPortInfo[bDioIdx].sDit.sPcmFormat.bMono		= MCDRV_PCM_MONO;
+		gsGlobalInfo_AA.sDioInfo.asPortInfo[bDioIdx].sDit.sPcmFormat.bOrder	= MCDRV_PCM_MSB_FIRST;
+		gsGlobalInfo_AA.sDioInfo.asPortInfo[bDioIdx].sDit.sPcmFormat.bLaw		= MCDRV_PCM_LINEAR;
+		gsGlobalInfo_AA.sDioInfo.asPortInfo[bDioIdx].sDit.sPcmFormat.bBitSel	= MCDRV_PCM_BITSEL_8;
+		for(bDioCh = 0; bDioCh < DIO_CHANNELS; bDioCh++)
+		{
+			gsGlobalInfo_AA.sDioInfo.asPortInfo[bDioIdx].sDit.abSlot[bDioCh]	= bDioCh;
+		}
+	}
+}
+
+/****************************************************************************
+ *	InitDacInfo
+ *
+ *	Description:
+ *			Initialize Dac info.
+ *	Arguments:
+ *			none
+ *	Return:
+ *			none
+ *
+ ****************************************************************************/
+static void	InitDacInfo
+(
+	void
+)
+{
+	gsGlobalInfo_AA.sDacInfo.bMasterSwap	= MCDRV_DSWAP_OFF;
+	gsGlobalInfo_AA.sDacInfo.bVoiceSwap	= MCDRV_DSWAP_OFF;
+	gsGlobalInfo_AA.sDacInfo.bDcCut		= MCDRV_DCCUT_ON;
+}
+
+/****************************************************************************
+ *	InitAdcInfo
+ *
+ *	Description:
+ *			Initialize Adc info.
+ *	Arguments:
+ *			none
+ *	Return:
+ *			none
+ *
+ ****************************************************************************/
+static void	InitAdcInfo
+(
+	void
+)
+{
+	gsGlobalInfo_AA.sAdcInfo.bAgcAdjust	= MCDRV_AGCADJ_0;
+	gsGlobalInfo_AA.sAdcInfo.bAgcOn		= MCDRV_AGC_OFF;
+	gsGlobalInfo_AA.sAdcInfo.bMono			= MCDRV_ADC_STEREO;
+}
+
+/****************************************************************************
+ *	InitSpInfo
+ *
+ *	Description:
+ *			Initialize SP info.
+ *	Arguments:
+ *			none
+ *	Return:
+ *			none
+ *
+ ****************************************************************************/
+static void	InitSpInfo
+(
+	void
+)
+{
+	gsGlobalInfo_AA.sSpInfo.bSwap	= MCDRV_SPSWAP_OFF;
+}
+
+/****************************************************************************
+ *	InitDngInfo
+ *
+ *	Description:
+ *			Initialize DNG info.
+ *	Arguments:
+ *			none
+ *	Return:
+ *			none
+ *
+ ****************************************************************************/
+static void	InitDngInfo
+(
+	void
+)
+{
+	gsGlobalInfo_AA.sDngInfo.abOnOff[0]		= MCDRV_DNG_OFF;
+	gsGlobalInfo_AA.sDngInfo.abThreshold[0]	= MCDRV_DNG_THRES_48;
+	gsGlobalInfo_AA.sDngInfo.abHold[0]			= MCDRV_DNG_HOLD_500;
+	gsGlobalInfo_AA.sDngInfo.abAttack[0]		= 2/*MCDRV_DNG_ATTACK_1100*/;
+	gsGlobalInfo_AA.sDngInfo.abRelease[0]		= MCDRV_DNG_RELEASE_940;
+}
+
+/****************************************************************************
+ *	InitAeInfo
+ *
+ *	Description:
+ *			Initialize Audio Engine info.
+ *	Arguments:
+ *			none
+ *	Return:
+ *			none
+ *
+ ****************************************************************************/
+static void	InitAeInfo
+(
+	void
+)
+{
+	if(McDevProf_IsValid(eMCDRV_FUNC_HWADJ) == 1)
+	{
+		gsGlobalInfo_AA.sAeInfo.bOnOff		= MCDRV_EQ3_ON;
+	}
+	else
+	{
+		gsGlobalInfo_AA.sAeInfo.bOnOff		= 0;
+	}
+}
+
+/****************************************************************************
+ *	InitPdmInfo
+ *
+ *	Description:
+ *			Initialize Pdm info.
+ *	Arguments:
+ *			none
+ *	Return:
+ *			none
+ *
+ ****************************************************************************/
+static void	InitPdmInfo
+(
+	void
+)
+{
+	gsGlobalInfo_AA.sPdmInfo.bClk			= MCDRV_PDM_CLK_64;
+	gsGlobalInfo_AA.sPdmInfo.bAgcAdjust	= MCDRV_AGCADJ_0;
+	gsGlobalInfo_AA.sPdmInfo.bAgcOn		= MCDRV_AGC_OFF;
+	gsGlobalInfo_AA.sPdmInfo.bPdmEdge		= MCDRV_PDMEDGE_LH;
+	gsGlobalInfo_AA.sPdmInfo.bPdmWait		= MCDRV_PDMWAIT_10;
+	gsGlobalInfo_AA.sPdmInfo.bPdmSel		= MCDRV_PDMSEL_L1R2;
+	gsGlobalInfo_AA.sPdmInfo.bMono			= MCDRV_PDM_STEREO;
+}
+
+/****************************************************************************
+ *	InitGpMode
+ *
+ *	Description:
+ *			Initialize Gp mode.
+ *	Arguments:
+ *			none
+ *	Return:
+ *			none
+ *
+ ****************************************************************************/
+static void	InitGpMode
+(
+	void
+)
+{
+	UINT8	bGpioIdx;
+	for(bGpioIdx = 0; bGpioIdx < GPIO_PAD_NUM; bGpioIdx++)
+	{
+		gsGlobalInfo_AA.sGpMode.abGpDdr[bGpioIdx]		= MCDRV_GPDDR_IN;
+		gsGlobalInfo_AA.sGpMode.abGpMode[bGpioIdx]		= MCDRV_GPMODE_RISING;
+		gsGlobalInfo_AA.sGpMode.abGpHost[bGpioIdx]		= MCDRV_GPHOST_SCU;
+		gsGlobalInfo_AA.sGpMode.abGpInvert[bGpioIdx]	= MCDRV_GPINV_NORMAL;
+	}
+}
+
+/****************************************************************************
+ *	InitGpMask
+ *
+ *	Description:
+ *			Initialize Gp mask.
+ *	Arguments:
+ *			none
+ *	Return:
+ *			none
+ *
+ ****************************************************************************/
+static void	InitGpMask
+(
+	void
+)
+{
+	UINT8	bGpioIdx;
+	for(bGpioIdx = 0; bGpioIdx < GPIO_PAD_NUM; bGpioIdx++)
+	{
+		gsGlobalInfo_AA.abGpMask[bGpioIdx]		= MCDRV_GPMASK_ON;
+	}
+}
+
+/****************************************************************************
+ *	McResCtrl_UpdateState_AA
+ *
+ *	Description:
+ *			update state.
+ *	Arguments:
+ *			eState	state
+ *	Return:
+ *			none
+ *
+ ****************************************************************************/
+void	McResCtrl_UpdateState_AA
+(
+	MCDRV_STATE_AA	eState
+)
+{
+	geState = eState;
+}
+
+/****************************************************************************
+ *	McResCtrl_GetState_AA
+ *
+ *	Description:
+ *			Get state.
+ *	Arguments:
+ *			none
+ *	Return:
+ *			current state
+ *
+ ****************************************************************************/
+MCDRV_STATE_AA	McResCtrl_GetState_AA
+(
+	void
+)
+{
+	return geState;
+}
+
+/****************************************************************************
+ *	McResCtrl_GetRegVal_AA
+ *
+ *	Description:
+ *			Get register value.
+ *	Arguments:
+ *			wRegType	register type
+ *			wRegAddr	address
+ *	Return:
+ *			register value
+ *
+ ****************************************************************************/
+UINT8	McResCtrl_GetRegVal_AA
+(
+	UINT16	wRegType,
+	UINT16	wRegAddr
+)
+{
+	switch(wRegType)
+	{
+	case	MCDRV_PACKET_REGTYPE_A_AA:
+		return gsGlobalInfo_AA.abRegValA[wRegAddr];
+	case	MCDRV_PACKET_REGTYPE_B_BASE_AA:
+		return gsGlobalInfo_AA.abRegValB_BASE[wRegAddr];
+	case	MCDRV_PACKET_REGTYPE_B_MIXER_AA:
+		return gsGlobalInfo_AA.abRegValB_MIXER[wRegAddr];
+	case	MCDRV_PACKET_REGTYPE_B_AE_AA:
+		return gsGlobalInfo_AA.abRegValB_AE[wRegAddr];
+	case	MCDRV_PACKET_REGTYPE_B_CDSP_AA:
+		return gsGlobalInfo_AA.abRegValB_CDSP[wRegAddr];
+	case	MCDRV_PACKET_REGTYPE_B_CODEC_AA:
+		return gsGlobalInfo_AA.abRegValB_CODEC[wRegAddr];
+	case	MCDRV_PACKET_REGTYPE_B_ANA_AA:
+		return gsGlobalInfo_AA.abRegValB_ANA[wRegAddr];
+	default:
+		break;
+	}
+
+	return 0;
+}
+
+/****************************************************************************
+ *	McResCtrl_SetRegVal_AA
+ *
+ *	Description:
+ *			Set register value.
+ *	Arguments:
+ *			wRegType	register type
+ *			wRegAddr	address
+ *			bRegVal		register value
+ *	Return:
+ *			none
+ *
+ ****************************************************************************/
+void	McResCtrl_SetRegVal_AA
+(
+	UINT16	wRegType,
+	UINT16	wRegAddr,
+	UINT8	bRegVal
+)
+{
+	switch(wRegType)
+	{
+	case	MCDRV_PACKET_REGTYPE_A_AA:
+		gsGlobalInfo_AA.abRegValA[wRegAddr]		= bRegVal;
+		break;
+	case	MCDRV_PACKET_REGTYPE_B_BASE_AA:
+		gsGlobalInfo_AA.abRegValB_BASE[wRegAddr]	= bRegVal;
+		break;
+	case	MCDRV_PACKET_REGTYPE_B_MIXER_AA:
+		gsGlobalInfo_AA.abRegValB_MIXER[wRegAddr]	= bRegVal;
+		break;
+	case	MCDRV_PACKET_REGTYPE_B_AE_AA:
+		gsGlobalInfo_AA.abRegValB_AE[wRegAddr]		= bRegVal;
+		break;
+	case	MCDRV_PACKET_REGTYPE_B_CDSP_AA:
+		gsGlobalInfo_AA.abRegValB_CDSP[wRegAddr]	= bRegVal;
+		break;
+	case	MCDRV_PACKET_REGTYPE_B_CODEC_AA:
+		gsGlobalInfo_AA.abRegValB_CODEC[wRegAddr]	= bRegVal;
+		break;
+	case	MCDRV_PACKET_REGTYPE_B_ANA_AA:
+		gsGlobalInfo_AA.abRegValB_ANA[wRegAddr]	= bRegVal;
+		break;
+	default:
+		break;
+	}
+}
+
+/****************************************************************************
+ *	McResCtrl_GetInitInfo_AA
+ *
+ *	Description:
+ *			Get Initialize information.
+ *	Arguments:
+ *			psInitInfo	Initialize information
+ *	Return:
+ *			none
+ *
+ ****************************************************************************/
+void	McResCtrl_GetInitInfo_AA
+(
+	MCDRV_INIT_INFO*	psInitInfo
+)
+{
+	*psInitInfo	= gsGlobalInfo_AA.sInitInfo;
+}
+
+/****************************************************************************
+ *	McResCtrl_SetClockInfo_AA
+ *
+ *	Description:
+ *			Set clock information.
+ *	Arguments:
+ *			psClockInfo	clock information
+ *	Return:
+ *			none
+ *
+ ****************************************************************************/
+void	McResCtrl_SetClockInfo_AA
+(
+	const MCDRV_CLOCK_INFO* psClockInfo
+)
+{
+
+	gsGlobalInfo_AA.sInitInfo.bCkSel	= psClockInfo->bCkSel;
+	gsGlobalInfo_AA.sInitInfo.bDivR0	= psClockInfo->bDivR0;
+	gsGlobalInfo_AA.sInitInfo.bDivF0	= psClockInfo->bDivF0;
+	if(McDevProf_IsValid(eMCDRV_FUNC_DIVR1) == 1)
+	{
+		gsGlobalInfo_AA.sInitInfo.bDivR1	= psClockInfo->bDivR1;
+	}
+	if(McDevProf_IsValid(eMCDRV_FUNC_DIVF1) == 1)
+	{
+		gsGlobalInfo_AA.sInitInfo.bDivF1	= psClockInfo->bDivF1;
+	}
+	if(McDevProf_IsValid(eMCDRV_FUNC_RANGE) == 1)
+	{
+		gsGlobalInfo_AA.sInitInfo.bRange0	= psClockInfo->bRange0;
+		gsGlobalInfo_AA.sInitInfo.bRange1	= psClockInfo->bRange1;
+	}
+	if(McDevProf_IsValid(eMCDRV_FUNC_BYPASS) == 1)
+	{
+		gsGlobalInfo_AA.sInitInfo.bBypass	= psClockInfo->bBypass;
+	}
+}
+
+/****************************************************************************
+ *	McResCtrl_SetPathInfo_AA
+ *
+ *	Description:
+ *			Set path information.
+ *	Arguments:
+ *			psPathInfo	path information
+ *	Return:
+ *			none
+ *
+ ****************************************************************************/
+void	McResCtrl_SetPathInfo_AA
+(
+	const MCDRV_PATH_INFO*	psPathInfo
+)
+{
+
+	gsGlobalInfo_AA.sPathInfo	= gsGlobalInfo_AA.sPathInfoVirtual;
+
+	/*	HP source on/off	*/
+	SetHPSourceOnOff(psPathInfo);
+
+	/*	SP source on/off	*/
+	SetSPSourceOnOff(psPathInfo);
+
+	/*	RCV source on/off	*/
+	SetRCVSourceOnOff(psPathInfo);
+
+	/*	LOut1 source on/off	*/
+	SetLO1SourceOnOff(psPathInfo);
+
+	/*	LOut2 source on/off	*/
+	SetLO2SourceOnOff(psPathInfo);
+
+	/*	Peak source on/off	*/
+	SetPMSourceOnOff(psPathInfo);
+
+	/*	DIT0 source on/off	*/
+	SetDIT0SourceOnOff(psPathInfo);
+
+	/*	DIT1 source on/off	*/
+	SetDIT1SourceOnOff(psPathInfo);
+
+	/*	DIT2 source on/off	*/
+	SetDIT2SourceOnOff(psPathInfo);
+
+	/*	DAC source on/off	*/
+	SetDACSourceOnOff(psPathInfo);
+
+	/*	AE source on/off	*/
+	SetAESourceOnOff(psPathInfo);
+
+	/*	CDSP source on/off	*/
+	SetCDSPSourceOnOff(psPathInfo);
+
+	/*	ADC0 source on/off	*/
+	SetADC0SourceOnOff(psPathInfo);
+
+	/*	ADC1 source on/off	*/
+	SetADC1SourceOnOff(psPathInfo);
+
+	/*	Mix source on/off	*/
+	SetMixSourceOnOff(psPathInfo);
+
+	/*	Bias source on/off	*/
+	SetBiasSourceOnOff(psPathInfo);
+
+	gsGlobalInfo_AA.sPathInfoVirtual	= gsGlobalInfo_AA.sPathInfo;
+
+	if((McResCtrl_IsDstUsed_AA(eMCDRV_DST_ADC0_AA, eMCDRV_DST_CH0_AA) == 0)
+	&& (McResCtrl_IsDstUsed_AA(eMCDRV_DST_ADC0_AA, eMCDRV_DST_CH1_AA) == 0))
+	{/*	ADC0 source all off	*/
+		gsGlobalInfo_AA.sPathInfo.asDit0[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK]	&= (UINT8)~MCDRV_SRC4_ADC0_ON;
+		gsGlobalInfo_AA.sPathInfo.asDit1[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK]	&= (UINT8)~MCDRV_SRC4_ADC0_ON;
+		gsGlobalInfo_AA.sPathInfo.asDit2[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK]	&= (UINT8)~MCDRV_SRC4_ADC0_ON;
+		gsGlobalInfo_AA.sPathInfo.asDac[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK]	&= (UINT8)~MCDRV_SRC4_ADC0_ON;
+		gsGlobalInfo_AA.sPathInfo.asDac[1].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK]	&= (UINT8)~MCDRV_SRC4_ADC0_ON;
+		gsGlobalInfo_AA.sPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK]		&= (UINT8)~MCDRV_SRC4_ADC0_ON;
+		gsGlobalInfo_AA.sPathInfo.asMix[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK]	&= (UINT8)~MCDRV_SRC4_ADC0_ON;
+		gsGlobalInfo_AA.sPathInfo.asDit0[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK]	|= MCDRV_SRC4_ADC0_OFF;
+		gsGlobalInfo_AA.sPathInfo.asDit1[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK]	|= MCDRV_SRC4_ADC0_OFF;
+		gsGlobalInfo_AA.sPathInfo.asDit2[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK]	|= MCDRV_SRC4_ADC0_OFF;
+		gsGlobalInfo_AA.sPathInfo.asDac[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK]	|= MCDRV_SRC4_ADC0_OFF;
+		gsGlobalInfo_AA.sPathInfo.asDac[1].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK]	|= MCDRV_SRC4_ADC0_OFF;
+		gsGlobalInfo_AA.sPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK]		|= MCDRV_SRC4_ADC0_OFF;
+		gsGlobalInfo_AA.sPathInfo.asMix[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK]	|= MCDRV_SRC4_ADC0_OFF;
+	}
+
+	if((McResCtrl_IsSrcUsed_AA(eMCDRV_SRC_DAC_L_AA) == 0)
+	&& (McResCtrl_IsSrcUsed_AA(eMCDRV_SRC_DAC_M_AA) == 0)
+	&& (McResCtrl_IsSrcUsed_AA(eMCDRV_SRC_DAC_R_AA) == 0))
+	{/*	DAC is unused	*/
+		gsGlobalInfo_AA.sPathInfo.asDac[0].abSrcOnOff[MCDRV_SRC_PDM_BLOCK]		&= (UINT8)~MCDRV_SRC4_PDM_ON;
+		gsGlobalInfo_AA.sPathInfo.asDac[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK]	&= (UINT8)~MCDRV_SRC4_ADC0_ON;
+		gsGlobalInfo_AA.sPathInfo.asDac[0].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR0_ON;
+		gsGlobalInfo_AA.sPathInfo.asDac[0].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR1_ON;
+		gsGlobalInfo_AA.sPathInfo.asDac[0].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR2_ON;
+		gsGlobalInfo_AA.sPathInfo.asDac[0].abSrcOnOff[MCDRV_SRC_MIX_BLOCK]		&= (UINT8)~MCDRV_SRC6_MIX_ON;
+		gsGlobalInfo_AA.sPathInfo.asDac[1].abSrcOnOff[MCDRV_SRC_PDM_BLOCK]		&= (UINT8)~MCDRV_SRC4_PDM_ON;
+		gsGlobalInfo_AA.sPathInfo.asDac[1].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK]	&= (UINT8)~MCDRV_SRC4_ADC0_ON;
+		gsGlobalInfo_AA.sPathInfo.asDac[1].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR0_ON;
+		gsGlobalInfo_AA.sPathInfo.asDac[1].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR1_ON;
+		gsGlobalInfo_AA.sPathInfo.asDac[1].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR2_ON;
+		gsGlobalInfo_AA.sPathInfo.asDac[1].abSrcOnOff[MCDRV_SRC_MIX_BLOCK]		&= (UINT8)~MCDRV_SRC6_MIX_ON;
+		gsGlobalInfo_AA.sPathInfo.asDac[0].abSrcOnOff[MCDRV_SRC_PDM_BLOCK]		|= MCDRV_SRC4_PDM_OFF;
+		gsGlobalInfo_AA.sPathInfo.asDac[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK]	|= MCDRV_SRC4_ADC0_OFF;
+		gsGlobalInfo_AA.sPathInfo.asDac[0].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK]	|= MCDRV_SRC3_DIR0_OFF;
+		gsGlobalInfo_AA.sPathInfo.asDac[0].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK]	|= MCDRV_SRC3_DIR1_OFF;
+		gsGlobalInfo_AA.sPathInfo.asDac[0].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK]	|= MCDRV_SRC3_DIR2_OFF;
+		gsGlobalInfo_AA.sPathInfo.asDac[0].abSrcOnOff[MCDRV_SRC_MIX_BLOCK]		|= MCDRV_SRC6_MIX_OFF;
+		gsGlobalInfo_AA.sPathInfo.asDac[1].abSrcOnOff[MCDRV_SRC_PDM_BLOCK]		|= MCDRV_SRC4_PDM_OFF;
+		gsGlobalInfo_AA.sPathInfo.asDac[1].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK]	|= MCDRV_SRC4_ADC0_OFF;
+		gsGlobalInfo_AA.sPathInfo.asDac[1].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK]	|= MCDRV_SRC3_DIR0_OFF;
+		gsGlobalInfo_AA.sPathInfo.asDac[1].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK]	|= MCDRV_SRC3_DIR1_OFF;
+		gsGlobalInfo_AA.sPathInfo.asDac[1].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK]	|= MCDRV_SRC3_DIR2_OFF;
+		gsGlobalInfo_AA.sPathInfo.asDac[1].abSrcOnOff[MCDRV_SRC_MIX_BLOCK]		|= MCDRV_SRC6_MIX_OFF;
+	}
+
+	if(McResCtrl_GetAESource_AA() == eMCDRV_SRC_NONE_AA)
+	{/*	AE source all off	*/
+		gsGlobalInfo_AA.sPathInfo.asDit0[0].abSrcOnOff[MCDRV_SRC_AE_BLOCK]	&= (UINT8)~MCDRV_SRC6_AE_ON;
+		gsGlobalInfo_AA.sPathInfo.asDit1[0].abSrcOnOff[MCDRV_SRC_AE_BLOCK]	&= (UINT8)~MCDRV_SRC6_AE_ON;
+		gsGlobalInfo_AA.sPathInfo.asDit2[0].abSrcOnOff[MCDRV_SRC_AE_BLOCK]	&= (UINT8)~MCDRV_SRC6_AE_ON;
+		gsGlobalInfo_AA.sPathInfo.asDac[0].abSrcOnOff[MCDRV_SRC_AE_BLOCK]	&= (UINT8)~MCDRV_SRC6_AE_ON;
+		gsGlobalInfo_AA.sPathInfo.asDac[1].abSrcOnOff[MCDRV_SRC_AE_BLOCK]	&= (UINT8)~MCDRV_SRC6_AE_ON;
+		gsGlobalInfo_AA.sPathInfo.asMix[0].abSrcOnOff[MCDRV_SRC_AE_BLOCK]	&= (UINT8)~MCDRV_SRC6_AE_ON;
+		gsGlobalInfo_AA.sPathInfo.asDit0[0].abSrcOnOff[MCDRV_SRC_AE_BLOCK]	|= MCDRV_SRC6_AE_OFF;
+		gsGlobalInfo_AA.sPathInfo.asDit1[0].abSrcOnOff[MCDRV_SRC_AE_BLOCK]	|= MCDRV_SRC6_AE_OFF;
+		gsGlobalInfo_AA.sPathInfo.asDit2[0].abSrcOnOff[MCDRV_SRC_AE_BLOCK]	|= MCDRV_SRC6_AE_OFF;
+		gsGlobalInfo_AA.sPathInfo.asDac[0].abSrcOnOff[MCDRV_SRC_AE_BLOCK]	|= MCDRV_SRC6_AE_OFF;
+		gsGlobalInfo_AA.sPathInfo.asDac[1].abSrcOnOff[MCDRV_SRC_AE_BLOCK]	|= MCDRV_SRC6_AE_OFF;
+		gsGlobalInfo_AA.sPathInfo.asMix[0].abSrcOnOff[MCDRV_SRC_AE_BLOCK]	|= MCDRV_SRC6_AE_OFF;
+	}
+	else if(McResCtrl_IsSrcUsed_AA(eMCDRV_SRC_AE_AA) == 0)
+	{
+		gsGlobalInfo_AA.sPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_PDM_BLOCK]	&= (UINT8)~MCDRV_SRC4_PDM_ON;
+		gsGlobalInfo_AA.sPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK]	&= (UINT8)~MCDRV_SRC4_ADC0_ON;
+		gsGlobalInfo_AA.sPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR0_ON;
+		gsGlobalInfo_AA.sPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR1_ON;
+		gsGlobalInfo_AA.sPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR2_ON;
+		gsGlobalInfo_AA.sPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_MIX_BLOCK]	&= (UINT8)~MCDRV_SRC6_MIX_ON;
+		gsGlobalInfo_AA.sPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_PDM_BLOCK]	|= MCDRV_SRC4_PDM_OFF;
+		gsGlobalInfo_AA.sPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK]	|= MCDRV_SRC4_ADC0_OFF;
+		gsGlobalInfo_AA.sPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK]	|= MCDRV_SRC3_DIR0_OFF;
+		gsGlobalInfo_AA.sPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK]	|= MCDRV_SRC3_DIR1_OFF;
+		gsGlobalInfo_AA.sPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK]	|= MCDRV_SRC3_DIR2_OFF;
+		gsGlobalInfo_AA.sPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_MIX_BLOCK]	|= MCDRV_SRC6_MIX_OFF;
+	}
+
+	if(McResCtrl_IsDstUsed_AA(eMCDRV_DST_MIX_AA, eMCDRV_DST_CH0_AA) == 0)
+	{/*	MIX source all off	*/
+		gsGlobalInfo_AA.sPathInfo.asDit0[0].abSrcOnOff[MCDRV_SRC_MIX_BLOCK]	&= (UINT8)~MCDRV_SRC6_MIX_ON;
+		gsGlobalInfo_AA.sPathInfo.asDit1[0].abSrcOnOff[MCDRV_SRC_MIX_BLOCK]	&= (UINT8)~MCDRV_SRC6_MIX_ON;
+		gsGlobalInfo_AA.sPathInfo.asDit2[0].abSrcOnOff[MCDRV_SRC_MIX_BLOCK]	&= (UINT8)~MCDRV_SRC6_MIX_ON;
+		gsGlobalInfo_AA.sPathInfo.asDac[0].abSrcOnOff[MCDRV_SRC_MIX_BLOCK]		&= (UINT8)~MCDRV_SRC6_MIX_ON;
+		gsGlobalInfo_AA.sPathInfo.asDac[1].abSrcOnOff[MCDRV_SRC_MIX_BLOCK]		&= (UINT8)~MCDRV_SRC6_MIX_ON;
+		gsGlobalInfo_AA.sPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_MIX_BLOCK]		&= (UINT8)~MCDRV_SRC6_MIX_ON;
+		gsGlobalInfo_AA.sPathInfo.asDit0[0].abSrcOnOff[MCDRV_SRC_MIX_BLOCK]	|= MCDRV_SRC6_MIX_OFF;
+		gsGlobalInfo_AA.sPathInfo.asDit1[0].abSrcOnOff[MCDRV_SRC_MIX_BLOCK]	|= MCDRV_SRC6_MIX_OFF;
+		gsGlobalInfo_AA.sPathInfo.asDit2[0].abSrcOnOff[MCDRV_SRC_MIX_BLOCK]	|= MCDRV_SRC6_MIX_OFF;
+		gsGlobalInfo_AA.sPathInfo.asDac[0].abSrcOnOff[MCDRV_SRC_MIX_BLOCK]		|= MCDRV_SRC6_MIX_OFF;
+		gsGlobalInfo_AA.sPathInfo.asDac[1].abSrcOnOff[MCDRV_SRC_MIX_BLOCK]		|= MCDRV_SRC6_MIX_OFF;
+		gsGlobalInfo_AA.sPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_MIX_BLOCK]		|= MCDRV_SRC6_MIX_OFF;
+	}
+	else if(McResCtrl_IsSrcUsed_AA(eMCDRV_SRC_MIX_AA) == 0)
+	{
+		gsGlobalInfo_AA.sPathInfo.asMix[0].abSrcOnOff[MCDRV_SRC_PDM_BLOCK]		&= (UINT8)~MCDRV_SRC4_PDM_ON;
+		gsGlobalInfo_AA.sPathInfo.asMix[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK]	&= (UINT8)~MCDRV_SRC4_ADC0_ON;
+		gsGlobalInfo_AA.sPathInfo.asMix[0].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR0_ON;
+		gsGlobalInfo_AA.sPathInfo.asMix[0].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR1_ON;
+		gsGlobalInfo_AA.sPathInfo.asMix[0].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR2_ON;
+		gsGlobalInfo_AA.sPathInfo.asMix[0].abSrcOnOff[MCDRV_SRC_AE_BLOCK]		&= (UINT8)~MCDRV_SRC6_AE_ON;
+		gsGlobalInfo_AA.sPathInfo.asMix[0].abSrcOnOff[MCDRV_SRC_PDM_BLOCK]		|= MCDRV_SRC4_PDM_OFF;
+		gsGlobalInfo_AA.sPathInfo.asMix[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK]	|= MCDRV_SRC4_ADC0_OFF;
+		gsGlobalInfo_AA.sPathInfo.asMix[0].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK]	|= MCDRV_SRC3_DIR0_OFF;
+		gsGlobalInfo_AA.sPathInfo.asMix[0].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK]	|= MCDRV_SRC3_DIR1_OFF;
+		gsGlobalInfo_AA.sPathInfo.asMix[0].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK]	|= MCDRV_SRC3_DIR2_OFF;
+		gsGlobalInfo_AA.sPathInfo.asMix[0].abSrcOnOff[MCDRV_SRC_AE_BLOCK]		|= MCDRV_SRC6_AE_OFF;
+	}
+
+	if((McResCtrl_GetDACSource_AA(eMCDRV_DAC_MASTER_AA) == eMCDRV_SRC_NONE_AA)
+	&& (McResCtrl_GetDACSource_AA(eMCDRV_DAC_VOICE_AA) == eMCDRV_SRC_NONE_AA))
+	{/*	DAC source all off	*/
+		gsGlobalInfo_AA.sPathInfo.asHpOut[0].abSrcOnOff[MCDRV_SRC_DAC_L_BLOCK]	&= (UINT8)~MCDRV_SRC5_DAC_L_ON;
+		gsGlobalInfo_AA.sPathInfo.asHpOut[0].abSrcOnOff[MCDRV_SRC_DAC_M_BLOCK]	&= (UINT8)~MCDRV_SRC5_DAC_M_ON;
+		gsGlobalInfo_AA.sPathInfo.asHpOut[1].abSrcOnOff[MCDRV_SRC_DAC_R_BLOCK]	&= (UINT8)~MCDRV_SRC5_DAC_R_ON;
+		gsGlobalInfo_AA.sPathInfo.asSpOut[0].abSrcOnOff[MCDRV_SRC_DAC_L_BLOCK]	&= (UINT8)~MCDRV_SRC5_DAC_L_ON;
+		gsGlobalInfo_AA.sPathInfo.asSpOut[0].abSrcOnOff[MCDRV_SRC_DAC_M_BLOCK]	&= (UINT8)~MCDRV_SRC5_DAC_M_ON;
+		gsGlobalInfo_AA.sPathInfo.asSpOut[1].abSrcOnOff[MCDRV_SRC_DAC_R_BLOCK]	&= (UINT8)~MCDRV_SRC5_DAC_R_ON;
+		gsGlobalInfo_AA.sPathInfo.asSpOut[1].abSrcOnOff[MCDRV_SRC_DAC_M_BLOCK]	&= (UINT8)~MCDRV_SRC5_DAC_M_ON;
+		gsGlobalInfo_AA.sPathInfo.asRcOut[0].abSrcOnOff[MCDRV_SRC_DAC_L_BLOCK]	&= (UINT8)~MCDRV_SRC5_DAC_L_ON;
+		gsGlobalInfo_AA.sPathInfo.asRcOut[0].abSrcOnOff[MCDRV_SRC_DAC_R_BLOCK]	&= (UINT8)~MCDRV_SRC5_DAC_R_ON;
+		gsGlobalInfo_AA.sPathInfo.asLout1[0].abSrcOnOff[MCDRV_SRC_DAC_L_BLOCK]	&= (UINT8)~MCDRV_SRC5_DAC_L_ON;
+		gsGlobalInfo_AA.sPathInfo.asLout1[0].abSrcOnOff[MCDRV_SRC_DAC_M_BLOCK]	&= (UINT8)~MCDRV_SRC5_DAC_M_ON;
+		gsGlobalInfo_AA.sPathInfo.asLout1[1].abSrcOnOff[MCDRV_SRC_DAC_R_BLOCK]	&= (UINT8)~MCDRV_SRC5_DAC_R_ON;
+		gsGlobalInfo_AA.sPathInfo.asLout2[0].abSrcOnOff[MCDRV_SRC_DAC_L_BLOCK]	&= (UINT8)~MCDRV_SRC5_DAC_L_ON;
+		gsGlobalInfo_AA.sPathInfo.asLout2[0].abSrcOnOff[MCDRV_SRC_DAC_M_BLOCK]	&= (UINT8)~MCDRV_SRC5_DAC_M_ON;
+		gsGlobalInfo_AA.sPathInfo.asLout2[1].abSrcOnOff[MCDRV_SRC_DAC_R_BLOCK]	&= (UINT8)~MCDRV_SRC5_DAC_R_ON;
+		gsGlobalInfo_AA.sPathInfo.asHpOut[0].abSrcOnOff[MCDRV_SRC_DAC_L_BLOCK]	|= MCDRV_SRC5_DAC_L_OFF;
+		gsGlobalInfo_AA.sPathInfo.asHpOut[0].abSrcOnOff[MCDRV_SRC_DAC_M_BLOCK]	|= MCDRV_SRC5_DAC_M_OFF;
+		gsGlobalInfo_AA.sPathInfo.asHpOut[1].abSrcOnOff[MCDRV_SRC_DAC_R_BLOCK]	|= MCDRV_SRC5_DAC_R_OFF;
+		gsGlobalInfo_AA.sPathInfo.asSpOut[0].abSrcOnOff[MCDRV_SRC_DAC_L_BLOCK]	|= MCDRV_SRC5_DAC_L_OFF;
+		gsGlobalInfo_AA.sPathInfo.asSpOut[0].abSrcOnOff[MCDRV_SRC_DAC_M_BLOCK]	|= MCDRV_SRC5_DAC_M_OFF;
+		gsGlobalInfo_AA.sPathInfo.asSpOut[1].abSrcOnOff[MCDRV_SRC_DAC_R_BLOCK]	|= MCDRV_SRC5_DAC_R_OFF;
+		gsGlobalInfo_AA.sPathInfo.asSpOut[1].abSrcOnOff[MCDRV_SRC_DAC_M_BLOCK]	|= MCDRV_SRC5_DAC_M_OFF;
+		gsGlobalInfo_AA.sPathInfo.asRcOut[0].abSrcOnOff[MCDRV_SRC_DAC_L_BLOCK]	|= MCDRV_SRC5_DAC_L_OFF;
+		gsGlobalInfo_AA.sPathInfo.asRcOut[0].abSrcOnOff[MCDRV_SRC_DAC_R_BLOCK]	|= MCDRV_SRC5_DAC_R_OFF;
+		gsGlobalInfo_AA.sPathInfo.asLout1[0].abSrcOnOff[MCDRV_SRC_DAC_L_BLOCK]	|= MCDRV_SRC5_DAC_L_OFF;
+		gsGlobalInfo_AA.sPathInfo.asLout1[0].abSrcOnOff[MCDRV_SRC_DAC_M_BLOCK]	|= MCDRV_SRC5_DAC_M_OFF;
+		gsGlobalInfo_AA.sPathInfo.asLout1[1].abSrcOnOff[MCDRV_SRC_DAC_R_BLOCK]	|= MCDRV_SRC5_DAC_R_OFF;
+		gsGlobalInfo_AA.sPathInfo.asLout2[0].abSrcOnOff[MCDRV_SRC_DAC_L_BLOCK]	|= MCDRV_SRC5_DAC_L_OFF;
+		gsGlobalInfo_AA.sPathInfo.asLout2[0].abSrcOnOff[MCDRV_SRC_DAC_M_BLOCK]	|= MCDRV_SRC5_DAC_M_OFF;
+		gsGlobalInfo_AA.sPathInfo.asLout2[1].abSrcOnOff[MCDRV_SRC_DAC_R_BLOCK]	|= MCDRV_SRC5_DAC_R_OFF;
+	}
+
+	if(McResCtrl_IsSrcUsed_AA(eMCDRV_SRC_ADC0_AA) == 0)
+	{
+		gsGlobalInfo_AA.sPathInfo.asAdc0[0].abSrcOnOff[MCDRV_SRC_MIC1_BLOCK]		&= (UINT8)~MCDRV_SRC0_MIC1_ON;
+		gsGlobalInfo_AA.sPathInfo.asAdc0[0].abSrcOnOff[MCDRV_SRC_MIC2_BLOCK]		&= (UINT8)~MCDRV_SRC0_MIC2_ON;
+		gsGlobalInfo_AA.sPathInfo.asAdc0[0].abSrcOnOff[MCDRV_SRC_MIC3_BLOCK]		&= (UINT8)~MCDRV_SRC0_MIC3_ON;
+		gsGlobalInfo_AA.sPathInfo.asAdc0[0].abSrcOnOff[MCDRV_SRC_LINE1_L_BLOCK]	&= (UINT8)~MCDRV_SRC1_LINE1_L_ON;
+		gsGlobalInfo_AA.sPathInfo.asAdc0[0].abSrcOnOff[MCDRV_SRC_LINE1_M_BLOCK]	&= (UINT8)~MCDRV_SRC1_LINE1_M_ON;
+		gsGlobalInfo_AA.sPathInfo.asAdc0[1].abSrcOnOff[MCDRV_SRC_MIC1_BLOCK]		&= (UINT8)~MCDRV_SRC0_MIC1_ON;
+		gsGlobalInfo_AA.sPathInfo.asAdc0[1].abSrcOnOff[MCDRV_SRC_MIC2_BLOCK]		&= (UINT8)~MCDRV_SRC0_MIC2_ON;
+		gsGlobalInfo_AA.sPathInfo.asAdc0[1].abSrcOnOff[MCDRV_SRC_MIC3_BLOCK]		&= (UINT8)~MCDRV_SRC0_MIC3_ON;
+		gsGlobalInfo_AA.sPathInfo.asAdc0[1].abSrcOnOff[MCDRV_SRC_LINE1_R_BLOCK]	&= (UINT8)~MCDRV_SRC1_LINE1_R_ON;
+		gsGlobalInfo_AA.sPathInfo.asAdc0[1].abSrcOnOff[MCDRV_SRC_LINE1_M_BLOCK]	&= (UINT8)~MCDRV_SRC1_LINE1_M_ON;
+
+		gsGlobalInfo_AA.sPathInfo.asAdc0[0].abSrcOnOff[MCDRV_SRC_MIC1_BLOCK]		|= MCDRV_SRC0_MIC1_OFF;
+		gsGlobalInfo_AA.sPathInfo.asAdc0[0].abSrcOnOff[MCDRV_SRC_MIC2_BLOCK]		|= MCDRV_SRC0_MIC2_OFF;
+		gsGlobalInfo_AA.sPathInfo.asAdc0[0].abSrcOnOff[MCDRV_SRC_MIC3_BLOCK]		|= MCDRV_SRC0_MIC3_OFF;
+		gsGlobalInfo_AA.sPathInfo.asAdc0[0].abSrcOnOff[MCDRV_SRC_LINE1_L_BLOCK]	|= MCDRV_SRC1_LINE1_L_OFF;
+		gsGlobalInfo_AA.sPathInfo.asAdc0[0].abSrcOnOff[MCDRV_SRC_LINE1_M_BLOCK]	|= MCDRV_SRC1_LINE1_M_OFF;
+		gsGlobalInfo_AA.sPathInfo.asAdc0[1].abSrcOnOff[MCDRV_SRC_MIC1_BLOCK]		|= MCDRV_SRC0_MIC1_OFF;
+		gsGlobalInfo_AA.sPathInfo.asAdc0[1].abSrcOnOff[MCDRV_SRC_MIC2_BLOCK]		|= MCDRV_SRC0_MIC2_OFF;
+		gsGlobalInfo_AA.sPathInfo.asAdc0[1].abSrcOnOff[MCDRV_SRC_MIC3_BLOCK]		|= MCDRV_SRC0_MIC3_OFF;
+		gsGlobalInfo_AA.sPathInfo.asAdc0[1].abSrcOnOff[MCDRV_SRC_LINE1_R_BLOCK]	|= MCDRV_SRC1_LINE1_R_OFF;
+		gsGlobalInfo_AA.sPathInfo.asAdc0[1].abSrcOnOff[MCDRV_SRC_LINE1_M_BLOCK]	|= MCDRV_SRC1_LINE1_M_OFF;
+	}
+}
+
+/****************************************************************************
+ *	SetHPSourceOnOff
+ *
+ *	Description:
+ *			Set HP source On/Off.
+ *	Arguments:
+ *			psPathInfo	path information
+ *	Return:
+ *			none
+ *
+ ****************************************************************************/
+static void	SetHPSourceOnOff
+(
+	const MCDRV_PATH_INFO*	psPathInfo
+)
+{
+	if((psPathInfo->asHpOut[0].abSrcOnOff[MCDRV_SRC_MIC1_BLOCK] & (MCDRV_SRC0_MIC1_ON|MCDRV_SRC0_MIC1_OFF)) == MCDRV_SRC0_MIC1_ON)
+	{
+		gsGlobalInfo_AA.sPathInfo.asHpOut[0].abSrcOnOff[MCDRV_SRC_MIC1_BLOCK]	&= (UINT8)~MCDRV_SRC0_MIC1_OFF;
+		gsGlobalInfo_AA.sPathInfo.asHpOut[0].abSrcOnOff[MCDRV_SRC_MIC1_BLOCK]	|= MCDRV_SRC0_MIC1_ON;
+	}
+	else if((psPathInfo->asHpOut[0].abSrcOnOff[MCDRV_SRC_MIC1_BLOCK] & (MCDRV_SRC0_MIC1_ON|MCDRV_SRC0_MIC1_OFF)) == MCDRV_SRC0_MIC1_OFF)
+	{
+		gsGlobalInfo_AA.sPathInfo.asHpOut[0].abSrcOnOff[MCDRV_SRC_MIC1_BLOCK]	&= (UINT8)~MCDRV_SRC0_MIC1_ON;
+		gsGlobalInfo_AA.sPathInfo.asHpOut[0].abSrcOnOff[MCDRV_SRC_MIC1_BLOCK]	|= MCDRV_SRC0_MIC1_OFF;
+	}
+	if((psPathInfo->asHpOut[0].abSrcOnOff[MCDRV_SRC_MIC2_BLOCK] & (MCDRV_SRC0_MIC2_ON|MCDRV_SRC0_MIC2_OFF)) == MCDRV_SRC0_MIC2_ON)
+	{
+		gsGlobalInfo_AA.sPathInfo.asHpOut[0].abSrcOnOff[MCDRV_SRC_MIC2_BLOCK]	&= (UINT8)~MCDRV_SRC0_MIC2_OFF;
+		gsGlobalInfo_AA.sPathInfo.asHpOut[0].abSrcOnOff[MCDRV_SRC_MIC2_BLOCK]	|= MCDRV_SRC0_MIC2_ON;
+	}
+	else if((psPathInfo->asHpOut[0].abSrcOnOff[MCDRV_SRC_MIC2_BLOCK] & (MCDRV_SRC0_MIC2_ON|MCDRV_SRC0_MIC2_OFF)) == MCDRV_SRC0_MIC2_OFF)
+	{
+		gsGlobalInfo_AA.sPathInfo.asHpOut[0].abSrcOnOff[MCDRV_SRC_MIC2_BLOCK]	&= (UINT8)~MCDRV_SRC0_MIC2_ON;
+		gsGlobalInfo_AA.sPathInfo.asHpOut[0].abSrcOnOff[MCDRV_SRC_MIC2_BLOCK]	|= MCDRV_SRC0_MIC2_OFF;
+	}
+	if((psPathInfo->asHpOut[0].abSrcOnOff[MCDRV_SRC_MIC3_BLOCK] & (MCDRV_SRC0_MIC3_ON|MCDRV_SRC0_MIC3_OFF)) == MCDRV_SRC0_MIC3_ON)
+	{
+		gsGlobalInfo_AA.sPathInfo.asHpOut[0].abSrcOnOff[MCDRV_SRC_MIC3_BLOCK]	&= (UINT8)~MCDRV_SRC0_MIC3_OFF;
+		gsGlobalInfo_AA.sPathInfo.asHpOut[0].abSrcOnOff[MCDRV_SRC_MIC3_BLOCK]	|= MCDRV_SRC0_MIC3_ON;
+	}
+	else if((psPathInfo->asHpOut[0].abSrcOnOff[MCDRV_SRC_MIC3_BLOCK] & (MCDRV_SRC0_MIC3_ON|MCDRV_SRC0_MIC3_OFF)) == MCDRV_SRC0_MIC3_OFF)
+	{
+		gsGlobalInfo_AA.sPathInfo.asHpOut[0].abSrcOnOff[MCDRV_SRC_MIC3_BLOCK]	&= (UINT8)~MCDRV_SRC0_MIC3_ON;
+		gsGlobalInfo_AA.sPathInfo.asHpOut[0].abSrcOnOff[MCDRV_SRC_MIC3_BLOCK]	|= MCDRV_SRC0_MIC3_OFF;
+	}
+
+	if((psPathInfo->asHpOut[0].abSrcOnOff[MCDRV_SRC_LINE1_L_BLOCK] & (MCDRV_SRC1_LINE1_L_ON|MCDRV_SRC1_LINE1_L_OFF)) == MCDRV_SRC1_LINE1_L_ON)
+	{
+		gsGlobalInfo_AA.sPathInfo.asHpOut[0].abSrcOnOff[MCDRV_SRC_LINE1_L_BLOCK]	&= (UINT8)~MCDRV_SRC1_LINE1_L_OFF;
+		gsGlobalInfo_AA.sPathInfo.asHpOut[0].abSrcOnOff[MCDRV_SRC_LINE1_L_BLOCK]	|= MCDRV_SRC1_LINE1_L_ON;
+	}
+	else if((psPathInfo->asHpOut[0].abSrcOnOff[MCDRV_SRC_LINE1_L_BLOCK] & (MCDRV_SRC1_LINE1_L_ON|MCDRV_SRC1_LINE1_L_OFF)) == MCDRV_SRC1_LINE1_L_OFF)
+	{
+		gsGlobalInfo_AA.sPathInfo.asHpOut[0].abSrcOnOff[MCDRV_SRC_LINE1_L_BLOCK]	&= (UINT8)~MCDRV_SRC1_LINE1_L_ON;
+		gsGlobalInfo_AA.sPathInfo.asHpOut[0].abSrcOnOff[MCDRV_SRC_LINE1_L_BLOCK]	|= MCDRV_SRC1_LINE1_L_OFF;
+	}
+	if((psPathInfo->asHpOut[0].abSrcOnOff[MCDRV_SRC_LINE1_M_BLOCK] & (MCDRV_SRC1_LINE1_M_ON|MCDRV_SRC1_LINE1_M_OFF)) == MCDRV_SRC1_LINE1_M_ON)
+	{
+		gsGlobalInfo_AA.sPathInfo.asHpOut[0].abSrcOnOff[MCDRV_SRC_LINE1_M_BLOCK]	&= (UINT8)~MCDRV_SRC1_LINE1_M_OFF;
+		gsGlobalInfo_AA.sPathInfo.asHpOut[0].abSrcOnOff[MCDRV_SRC_LINE1_M_BLOCK]	|= MCDRV_SRC1_LINE1_M_ON;
+	}
+	else if((psPathInfo->asHpOut[0].abSrcOnOff[MCDRV_SRC_LINE1_M_BLOCK] & (MCDRV_SRC1_LINE1_M_ON|MCDRV_SRC1_LINE1_M_OFF)) == MCDRV_SRC1_LINE1_M_OFF)
+	{
+		gsGlobalInfo_AA.sPathInfo.asHpOut[0].abSrcOnOff[MCDRV_SRC_LINE1_M_BLOCK]	&= (UINT8)~MCDRV_SRC1_LINE1_M_ON;
+		gsGlobalInfo_AA.sPathInfo.asHpOut[0].abSrcOnOff[MCDRV_SRC_LINE1_M_BLOCK]	|= MCDRV_SRC1_LINE1_M_OFF;
+	}
+
+	if((psPathInfo->asHpOut[0].abSrcOnOff[MCDRV_SRC_DAC_L_BLOCK] & (MCDRV_SRC5_DAC_L_ON|MCDRV_SRC5_DAC_L_OFF)) == MCDRV_SRC5_DAC_L_ON)
+	{
+		gsGlobalInfo_AA.sPathInfo.asHpOut[0].abSrcOnOff[MCDRV_SRC_DAC_L_BLOCK]	&= (UINT8)~MCDRV_SRC5_DAC_L_OFF;
+		gsGlobalInfo_AA.sPathInfo.asHpOut[0].abSrcOnOff[MCDRV_SRC_DAC_L_BLOCK]	|= MCDRV_SRC5_DAC_L_ON;
+	}
+	else if((psPathInfo->asHpOut[0].abSrcOnOff[MCDRV_SRC_DAC_L_BLOCK] & (MCDRV_SRC5_DAC_L_ON|MCDRV_SRC5_DAC_L_OFF)) == MCDRV_SRC5_DAC_L_OFF)
+	{
+		gsGlobalInfo_AA.sPathInfo.asHpOut[0].abSrcOnOff[MCDRV_SRC_DAC_L_BLOCK]	&= (UINT8)~MCDRV_SRC5_DAC_L_ON;
+		gsGlobalInfo_AA.sPathInfo.asHpOut[0].abSrcOnOff[MCDRV_SRC_DAC_L_BLOCK]	|= MCDRV_SRC5_DAC_L_OFF;
+	}
+	if((psPathInfo->asHpOut[0].abSrcOnOff[MCDRV_SRC_DAC_M_BLOCK] & (MCDRV_SRC5_DAC_M_ON|MCDRV_SRC5_DAC_M_OFF)) == MCDRV_SRC5_DAC_M_ON)
+	{
+		gsGlobalInfo_AA.sPathInfo.asHpOut[0].abSrcOnOff[MCDRV_SRC_DAC_M_BLOCK]	&= (UINT8)~MCDRV_SRC5_DAC_M_OFF;
+		gsGlobalInfo_AA.sPathInfo.asHpOut[0].abSrcOnOff[MCDRV_SRC_DAC_M_BLOCK]	|= MCDRV_SRC5_DAC_M_ON;
+	}
+	else if((psPathInfo->asHpOut[0].abSrcOnOff[MCDRV_SRC_DAC_M_BLOCK] & (MCDRV_SRC5_DAC_M_ON|MCDRV_SRC5_DAC_M_OFF)) == MCDRV_SRC5_DAC_M_OFF)
+	{
+		gsGlobalInfo_AA.sPathInfo.asHpOut[0].abSrcOnOff[MCDRV_SRC_DAC_M_BLOCK]	&= (UINT8)~MCDRV_SRC5_DAC_M_ON;
+		gsGlobalInfo_AA.sPathInfo.asHpOut[0].abSrcOnOff[MCDRV_SRC_DAC_M_BLOCK]	|= MCDRV_SRC5_DAC_M_OFF;
+	}
+
+	if((psPathInfo->asHpOut[1].abSrcOnOff[MCDRV_SRC_MIC1_BLOCK] & (MCDRV_SRC0_MIC1_ON|MCDRV_SRC0_MIC1_OFF)) == MCDRV_SRC0_MIC1_ON)
+	{
+		gsGlobalInfo_AA.sPathInfo.asHpOut[1].abSrcOnOff[MCDRV_SRC_MIC1_BLOCK]	&= (UINT8)~MCDRV_SRC0_MIC1_OFF;
+		gsGlobalInfo_AA.sPathInfo.asHpOut[1].abSrcOnOff[MCDRV_SRC_MIC1_BLOCK]	|= MCDRV_SRC0_MIC1_ON;
+	}
+	else if((psPathInfo->asHpOut[1].abSrcOnOff[MCDRV_SRC_MIC1_BLOCK] & (MCDRV_SRC0_MIC1_ON|MCDRV_SRC0_MIC1_OFF)) == MCDRV_SRC0_MIC1_OFF)
+	{
+		gsGlobalInfo_AA.sPathInfo.asHpOut[1].abSrcOnOff[MCDRV_SRC_MIC1_BLOCK]	&= (UINT8)~MCDRV_SRC0_MIC1_ON;
+		gsGlobalInfo_AA.sPathInfo.asHpOut[1].abSrcOnOff[MCDRV_SRC_MIC1_BLOCK]	|= MCDRV_SRC0_MIC1_OFF;
+	}
+	if((psPathInfo->asHpOut[1].abSrcOnOff[MCDRV_SRC_MIC2_BLOCK] & (MCDRV_SRC0_MIC2_ON|MCDRV_SRC0_MIC2_OFF)) == MCDRV_SRC0_MIC2_ON)
+	{
+		gsGlobalInfo_AA.sPathInfo.asHpOut[1].abSrcOnOff[MCDRV_SRC_MIC2_BLOCK]	&= (UINT8)~MCDRV_SRC0_MIC2_OFF;
+		gsGlobalInfo_AA.sPathInfo.asHpOut[1].abSrcOnOff[MCDRV_SRC_MIC2_BLOCK]	|= MCDRV_SRC0_MIC2_ON;
+	}
+	else if((psPathInfo->asHpOut[1].abSrcOnOff[MCDRV_SRC_MIC2_BLOCK] & (MCDRV_SRC0_MIC2_ON|MCDRV_SRC0_MIC2_OFF)) == MCDRV_SRC0_MIC2_OFF)
+	{
+		gsGlobalInfo_AA.sPathInfo.asHpOut[1].abSrcOnOff[MCDRV_SRC_MIC2_BLOCK]	&= (UINT8)~MCDRV_SRC0_MIC2_ON;
+		gsGlobalInfo_AA.sPathInfo.asHpOut[1].abSrcOnOff[MCDRV_SRC_MIC2_BLOCK]	|= MCDRV_SRC0_MIC2_OFF;
+	}
+	if((psPathInfo->asHpOut[1].abSrcOnOff[MCDRV_SRC_MIC3_BLOCK] & (MCDRV_SRC0_MIC3_ON|MCDRV_SRC0_MIC3_OFF)) == MCDRV_SRC0_MIC3_ON)
+	{
+		gsGlobalInfo_AA.sPathInfo.asHpOut[1].abSrcOnOff[MCDRV_SRC_MIC3_BLOCK]	&= (UINT8)~MCDRV_SRC0_MIC3_OFF;
+		gsGlobalInfo_AA.sPathInfo.asHpOut[1].abSrcOnOff[MCDRV_SRC_MIC3_BLOCK]	|= MCDRV_SRC0_MIC3_ON;
+	}
+	else if((psPathInfo->asHpOut[1].abSrcOnOff[MCDRV_SRC_MIC3_BLOCK] & (MCDRV_SRC0_MIC3_ON|MCDRV_SRC0_MIC3_OFF)) == MCDRV_SRC0_MIC3_OFF)
+	{
+		gsGlobalInfo_AA.sPathInfo.asHpOut[1].abSrcOnOff[MCDRV_SRC_MIC3_BLOCK]	&= (UINT8)~MCDRV_SRC0_MIC3_ON;
+		gsGlobalInfo_AA.sPathInfo.asHpOut[1].abSrcOnOff[MCDRV_SRC_MIC3_BLOCK]	|= MCDRV_SRC0_MIC3_OFF;
+	}
+
+	if((psPathInfo->asHpOut[1].abSrcOnOff[MCDRV_SRC_LINE1_R_BLOCK] & (MCDRV_SRC1_LINE1_R_ON|MCDRV_SRC1_LINE1_R_OFF)) == MCDRV_SRC1_LINE1_R_ON)
+	{
+		gsGlobalInfo_AA.sPathInfo.asHpOut[1].abSrcOnOff[MCDRV_SRC_LINE1_R_BLOCK]	&= (UINT8)~MCDRV_SRC1_LINE1_R_OFF;
+		gsGlobalInfo_AA.sPathInfo.asHpOut[1].abSrcOnOff[MCDRV_SRC_LINE1_R_BLOCK]	|= MCDRV_SRC1_LINE1_R_ON;
+	}
+	else if((psPathInfo->asHpOut[1].abSrcOnOff[MCDRV_SRC_LINE1_R_BLOCK] & (MCDRV_SRC1_LINE1_R_ON|MCDRV_SRC1_LINE1_R_OFF)) == MCDRV_SRC1_LINE1_R_OFF)
+	{
+		gsGlobalInfo_AA.sPathInfo.asHpOut[1].abSrcOnOff[MCDRV_SRC_LINE1_R_BLOCK]	&= (UINT8)~MCDRV_SRC1_LINE1_R_ON;
+		gsGlobalInfo_AA.sPathInfo.asHpOut[1].abSrcOnOff[MCDRV_SRC_LINE1_R_BLOCK]	|= MCDRV_SRC1_LINE1_R_OFF;
+	}
+
+	if((psPathInfo->asHpOut[1].abSrcOnOff[MCDRV_SRC_DAC_R_BLOCK] & (MCDRV_SRC5_DAC_R_ON|MCDRV_SRC5_DAC_R_OFF)) == MCDRV_SRC5_DAC_R_ON)
+	{
+		gsGlobalInfo_AA.sPathInfo.asHpOut[1].abSrcOnOff[MCDRV_SRC_DAC_R_BLOCK]	&= (UINT8)~MCDRV_SRC5_DAC_R_OFF;
+		gsGlobalInfo_AA.sPathInfo.asHpOut[1].abSrcOnOff[MCDRV_SRC_DAC_R_BLOCK]	|= MCDRV_SRC5_DAC_R_ON;
+	}
+	else if((psPathInfo->asHpOut[1].abSrcOnOff[MCDRV_SRC_DAC_R_BLOCK] & (MCDRV_SRC5_DAC_R_ON|MCDRV_SRC5_DAC_R_OFF)) == MCDRV_SRC5_DAC_R_OFF)
+	{
+		gsGlobalInfo_AA.sPathInfo.asHpOut[1].abSrcOnOff[MCDRV_SRC_DAC_R_BLOCK]	&= (UINT8)~MCDRV_SRC5_DAC_R_ON;
+		gsGlobalInfo_AA.sPathInfo.asHpOut[1].abSrcOnOff[MCDRV_SRC_DAC_R_BLOCK]	|= MCDRV_SRC5_DAC_R_OFF;
+	}
+}
+
+/****************************************************************************
+ *	SetSPSourceOnOff
+ *
+ *	Description:
+ *			Set SP source On/Off.
+ *	Arguments:
+ *			psPathInfo	path information
+ *	Return:
+ *			none
+ *
+ ****************************************************************************/
+static void	SetSPSourceOnOff
+(
+	const MCDRV_PATH_INFO*	psPathInfo
+)
+{
+	if((psPathInfo->asSpOut[0].abSrcOnOff[MCDRV_SRC_LINE1_L_BLOCK] & (MCDRV_SRC1_LINE1_L_ON|MCDRV_SRC1_LINE1_L_OFF)) == MCDRV_SRC1_LINE1_L_ON)
+	{
+		gsGlobalInfo_AA.sPathInfo.asSpOut[0].abSrcOnOff[MCDRV_SRC_LINE1_L_BLOCK]	&= (UINT8)~MCDRV_SRC1_LINE1_L_OFF;
+		gsGlobalInfo_AA.sPathInfo.asSpOut[0].abSrcOnOff[MCDRV_SRC_LINE1_L_BLOCK]	|= MCDRV_SRC1_LINE1_L_ON;
+	}
+	else if((psPathInfo->asSpOut[0].abSrcOnOff[MCDRV_SRC_LINE1_L_BLOCK] & (MCDRV_SRC1_LINE1_L_ON|MCDRV_SRC1_LINE1_L_OFF)) == MCDRV_SRC1_LINE1_L_OFF)
+	{
+		gsGlobalInfo_AA.sPathInfo.asSpOut[0].abSrcOnOff[MCDRV_SRC_LINE1_L_BLOCK]	&= (UINT8)~MCDRV_SRC1_LINE1_L_ON;
+		gsGlobalInfo_AA.sPathInfo.asSpOut[0].abSrcOnOff[MCDRV_SRC_LINE1_L_BLOCK]	|= MCDRV_SRC1_LINE1_L_OFF;
+	}
+	if((psPathInfo->asSpOut[0].abSrcOnOff[MCDRV_SRC_LINE1_M_BLOCK] & (MCDRV_SRC1_LINE1_M_ON|MCDRV_SRC1_LINE1_M_OFF)) == MCDRV_SRC1_LINE1_M_ON)
+	{
+		gsGlobalInfo_AA.sPathInfo.asSpOut[0].abSrcOnOff[MCDRV_SRC_LINE1_M_BLOCK]	&= (UINT8)~MCDRV_SRC1_LINE1_M_OFF;
+		gsGlobalInfo_AA.sPathInfo.asSpOut[0].abSrcOnOff[MCDRV_SRC_LINE1_M_BLOCK]	|= MCDRV_SRC1_LINE1_M_ON;
+	}
+	else if((psPathInfo->asSpOut[0].abSrcOnOff[MCDRV_SRC_LINE1_M_BLOCK] & (MCDRV_SRC1_LINE1_M_ON|MCDRV_SRC1_LINE1_M_OFF)) == MCDRV_SRC1_LINE1_M_OFF)
+	{
+		gsGlobalInfo_AA.sPathInfo.asSpOut[0].abSrcOnOff[MCDRV_SRC_LINE1_M_BLOCK]	&= (UINT8)~MCDRV_SRC1_LINE1_M_ON;
+		gsGlobalInfo_AA.sPathInfo.asSpOut[0].abSrcOnOff[MCDRV_SRC_LINE1_M_BLOCK]	|= MCDRV_SRC1_LINE1_M_OFF;
+	}
+
+	if((psPathInfo->asSpOut[0].abSrcOnOff[MCDRV_SRC_DAC_L_BLOCK] & (MCDRV_SRC5_DAC_L_ON|MCDRV_SRC5_DAC_L_OFF)) == MCDRV_SRC5_DAC_L_ON)
+	{
+		gsGlobalInfo_AA.sPathInfo.asSpOut[0].abSrcOnOff[MCDRV_SRC_DAC_L_BLOCK]	&= (UINT8)~MCDRV_SRC5_DAC_L_OFF;
+		gsGlobalInfo_AA.sPathInfo.asSpOut[0].abSrcOnOff[MCDRV_SRC_DAC_L_BLOCK]	|= MCDRV_SRC5_DAC_L_ON;
+	}
+	else if((psPathInfo->asSpOut[0].abSrcOnOff[MCDRV_SRC_DAC_L_BLOCK] & (MCDRV_SRC5_DAC_L_ON|MCDRV_SRC5_DAC_L_OFF)) == MCDRV_SRC5_DAC_L_OFF)
+	{
+		gsGlobalInfo_AA.sPathInfo.asSpOut[0].abSrcOnOff[MCDRV_SRC_DAC_L_BLOCK]	&= (UINT8)~MCDRV_SRC5_DAC_L_ON;
+		gsGlobalInfo_AA.sPathInfo.asSpOut[0].abSrcOnOff[MCDRV_SRC_DAC_L_BLOCK]	|= MCDRV_SRC5_DAC_L_OFF;
+	}
+	if((psPathInfo->asSpOut[0].abSrcOnOff[MCDRV_SRC_DAC_M_BLOCK] & (MCDRV_SRC5_DAC_M_ON|MCDRV_SRC5_DAC_M_OFF)) == MCDRV_SRC5_DAC_M_ON)
+	{
+		gsGlobalInfo_AA.sPathInfo.asSpOut[0].abSrcOnOff[MCDRV_SRC_DAC_M_BLOCK]	&= (UINT8)~MCDRV_SRC5_DAC_M_OFF;
+		gsGlobalInfo_AA.sPathInfo.asSpOut[0].abSrcOnOff[MCDRV_SRC_DAC_M_BLOCK]	|= MCDRV_SRC5_DAC_M_ON;
+	}
+	else if((psPathInfo->asSpOut[0].abSrcOnOff[MCDRV_SRC_DAC_M_BLOCK] & (MCDRV_SRC5_DAC_M_ON|MCDRV_SRC5_DAC_M_OFF)) == MCDRV_SRC5_DAC_M_OFF)
+	{
+		gsGlobalInfo_AA.sPathInfo.asSpOut[0].abSrcOnOff[MCDRV_SRC_DAC_M_BLOCK]	&= (UINT8)~MCDRV_SRC5_DAC_M_ON;
+		gsGlobalInfo_AA.sPathInfo.asSpOut[0].abSrcOnOff[MCDRV_SRC_DAC_M_BLOCK]	|= MCDRV_SRC5_DAC_M_OFF;
+	}
+
+	if((psPathInfo->asSpOut[1].abSrcOnOff[MCDRV_SRC_LINE1_R_BLOCK] & (MCDRV_SRC1_LINE1_R_ON|MCDRV_SRC1_LINE1_R_OFF)) == MCDRV_SRC1_LINE1_R_ON)
+	{
+		gsGlobalInfo_AA.sPathInfo.asSpOut[1].abSrcOnOff[MCDRV_SRC_LINE1_R_BLOCK]	&= (UINT8)~MCDRV_SRC1_LINE1_R_OFF;
+		gsGlobalInfo_AA.sPathInfo.asSpOut[1].abSrcOnOff[MCDRV_SRC_LINE1_R_BLOCK]	|= MCDRV_SRC1_LINE1_R_ON;
+	}
+	else if((psPathInfo->asSpOut[1].abSrcOnOff[MCDRV_SRC_LINE1_R_BLOCK] & (MCDRV_SRC1_LINE1_R_ON|MCDRV_SRC1_LINE1_R_OFF)) == MCDRV_SRC1_LINE1_R_OFF)
+	{
+		gsGlobalInfo_AA.sPathInfo.asSpOut[1].abSrcOnOff[MCDRV_SRC_LINE1_R_BLOCK]	&= (UINT8)~MCDRV_SRC1_LINE1_R_ON;
+		gsGlobalInfo_AA.sPathInfo.asSpOut[1].abSrcOnOff[MCDRV_SRC_LINE1_R_BLOCK]	|= MCDRV_SRC1_LINE1_R_OFF;
+	}
+	if((psPathInfo->asSpOut[1].abSrcOnOff[MCDRV_SRC_LINE1_M_BLOCK] & (MCDRV_SRC1_LINE1_M_ON|MCDRV_SRC1_LINE1_M_OFF)) == MCDRV_SRC1_LINE1_M_ON)
+	{
+		gsGlobalInfo_AA.sPathInfo.asSpOut[1].abSrcOnOff[MCDRV_SRC_LINE1_M_BLOCK]	&= (UINT8)~MCDRV_SRC1_LINE1_M_OFF;
+		gsGlobalInfo_AA.sPathInfo.asSpOut[1].abSrcOnOff[MCDRV_SRC_LINE1_M_BLOCK]	|= MCDRV_SRC1_LINE1_M_ON;
+	}
+	else if((psPathInfo->asSpOut[1].abSrcOnOff[MCDRV_SRC_LINE1_M_BLOCK] & (MCDRV_SRC1_LINE1_M_ON|MCDRV_SRC1_LINE1_M_OFF)) == MCDRV_SRC1_LINE1_M_OFF)
+	{
+		gsGlobalInfo_AA.sPathInfo.asSpOut[1].abSrcOnOff[MCDRV_SRC_LINE1_M_BLOCK]	&= (UINT8)~MCDRV_SRC1_LINE1_M_ON;
+		gsGlobalInfo_AA.sPathInfo.asSpOut[1].abSrcOnOff[MCDRV_SRC_LINE1_M_BLOCK]	|= MCDRV_SRC1_LINE1_M_OFF;
+	}
+
+	if((psPathInfo->asSpOut[1].abSrcOnOff[MCDRV_SRC_DAC_R_BLOCK] & (MCDRV_SRC5_DAC_R_ON|MCDRV_SRC5_DAC_R_OFF)) == MCDRV_SRC5_DAC_R_ON)
+	{
+		gsGlobalInfo_AA.sPathInfo.asSpOut[1].abSrcOnOff[MCDRV_SRC_DAC_R_BLOCK]	&= (UINT8)~MCDRV_SRC5_DAC_R_OFF;
+		gsGlobalInfo_AA.sPathInfo.asSpOut[1].abSrcOnOff[MCDRV_SRC_DAC_R_BLOCK]	|= MCDRV_SRC5_DAC_R_ON;
+	}
+	else if((psPathInfo->asSpOut[1].abSrcOnOff[MCDRV_SRC_DAC_R_BLOCK] & (MCDRV_SRC5_DAC_R_ON|MCDRV_SRC5_DAC_R_OFF)) == MCDRV_SRC5_DAC_R_OFF)
+	{
+		gsGlobalInfo_AA.sPathInfo.asSpOut[1].abSrcOnOff[MCDRV_SRC_DAC_R_BLOCK]	&= (UINT8)~MCDRV_SRC5_DAC_R_ON;
+		gsGlobalInfo_AA.sPathInfo.asSpOut[1].abSrcOnOff[MCDRV_SRC_DAC_R_BLOCK]	|= MCDRV_SRC5_DAC_R_OFF;
+	}
+	if((psPathInfo->asSpOut[1].abSrcOnOff[MCDRV_SRC_DAC_M_BLOCK] & (MCDRV_SRC5_DAC_M_ON|MCDRV_SRC5_DAC_M_OFF)) == MCDRV_SRC5_DAC_M_ON)
+	{
+		gsGlobalInfo_AA.sPathInfo.asSpOut[1].abSrcOnOff[MCDRV_SRC_DAC_M_BLOCK]	&= (UINT8)~MCDRV_SRC5_DAC_M_OFF;
+		gsGlobalInfo_AA.sPathInfo.asSpOut[1].abSrcOnOff[MCDRV_SRC_DAC_M_BLOCK]	|= MCDRV_SRC5_DAC_M_ON;
+	}
+	else if((psPathInfo->asSpOut[1].abSrcOnOff[MCDRV_SRC_DAC_M_BLOCK] & (MCDRV_SRC5_DAC_M_ON|MCDRV_SRC5_DAC_M_OFF)) == MCDRV_SRC5_DAC_M_OFF)
+	{
+		gsGlobalInfo_AA.sPathInfo.asSpOut[1].abSrcOnOff[MCDRV_SRC_DAC_M_BLOCK]	&= (UINT8)~MCDRV_SRC5_DAC_M_ON;
+		gsGlobalInfo_AA.sPathInfo.asSpOut[1].abSrcOnOff[MCDRV_SRC_DAC_M_BLOCK]	|= MCDRV_SRC5_DAC_M_OFF;
+	}
+}
+
+/****************************************************************************
+ *	SetRCVSourceOnOff
+ *
+ *	Description:
+ *			Set RCV source On/Off.
+ *	Arguments:
+ *			psPathInfo	path information
+ *	Return:
+ *			none
+ *
+ ****************************************************************************/
+static void	SetRCVSourceOnOff
+(
+	const MCDRV_PATH_INFO*	psPathInfo
+)
+{
+	if((psPathInfo->asRcOut[0].abSrcOnOff[MCDRV_SRC_MIC1_BLOCK] & (MCDRV_SRC0_MIC1_ON|MCDRV_SRC0_MIC1_OFF)) == MCDRV_SRC0_MIC1_ON)
+	{
+		gsGlobalInfo_AA.sPathInfo.asRcOut[0].abSrcOnOff[MCDRV_SRC_MIC1_BLOCK]	&= (UINT8)~MCDRV_SRC0_MIC1_OFF;
+		gsGlobalInfo_AA.sPathInfo.asRcOut[0].abSrcOnOff[MCDRV_SRC_MIC1_BLOCK]	|= MCDRV_SRC0_MIC1_ON;
+	}
+	else if((psPathInfo->asRcOut[0].abSrcOnOff[MCDRV_SRC_MIC1_BLOCK] & (MCDRV_SRC0_MIC1_ON|MCDRV_SRC0_MIC1_OFF)) == MCDRV_SRC0_MIC1_OFF)
+	{
+		gsGlobalInfo_AA.sPathInfo.asRcOut[0].abSrcOnOff[MCDRV_SRC_MIC1_BLOCK]	&= (UINT8)~MCDRV_SRC0_MIC1_ON;
+		gsGlobalInfo_AA.sPathInfo.asRcOut[0].abSrcOnOff[MCDRV_SRC_MIC1_BLOCK]	|= MCDRV_SRC0_MIC1_OFF;
+	}
+	if((psPathInfo->asRcOut[0].abSrcOnOff[MCDRV_SRC_MIC2_BLOCK] & (MCDRV_SRC0_MIC2_ON|MCDRV_SRC0_MIC2_OFF)) == MCDRV_SRC0_MIC2_ON)
+	{
+		gsGlobalInfo_AA.sPathInfo.asRcOut[0].abSrcOnOff[MCDRV_SRC_MIC2_BLOCK]	&= (UINT8)~MCDRV_SRC0_MIC2_OFF;
+		gsGlobalInfo_AA.sPathInfo.asRcOut[0].abSrcOnOff[MCDRV_SRC_MIC2_BLOCK]	|= MCDRV_SRC0_MIC2_ON;
+	}
+	else if((psPathInfo->asRcOut[0].abSrcOnOff[MCDRV_SRC_MIC2_BLOCK] & (MCDRV_SRC0_MIC2_ON|MCDRV_SRC0_MIC2_OFF)) == MCDRV_SRC0_MIC2_OFF)
+	{
+		gsGlobalInfo_AA.sPathInfo.asRcOut[0].abSrcOnOff[MCDRV_SRC_MIC2_BLOCK]	&= (UINT8)~MCDRV_SRC0_MIC2_ON;
+		gsGlobalInfo_AA.sPathInfo.asRcOut[0].abSrcOnOff[MCDRV_SRC_MIC2_BLOCK]	|= MCDRV_SRC0_MIC2_OFF;
+	}
+	if((psPathInfo->asRcOut[0].abSrcOnOff[MCDRV_SRC_MIC3_BLOCK] & (MCDRV_SRC0_MIC3_ON|MCDRV_SRC0_MIC3_OFF)) == MCDRV_SRC0_MIC3_ON)
+	{
+		gsGlobalInfo_AA.sPathInfo.asRcOut[0].abSrcOnOff[MCDRV_SRC_MIC3_BLOCK]	&= (UINT8)~MCDRV_SRC0_MIC3_OFF;
+		gsGlobalInfo_AA.sPathInfo.asRcOut[0].abSrcOnOff[MCDRV_SRC_MIC3_BLOCK]	|= MCDRV_SRC0_MIC3_ON;
+	}
+	else if((psPathInfo->asRcOut[0].abSrcOnOff[MCDRV_SRC_MIC3_BLOCK] & (MCDRV_SRC0_MIC3_ON|MCDRV_SRC0_MIC3_OFF)) == MCDRV_SRC0_MIC3_OFF)
+	{
+		gsGlobalInfo_AA.sPathInfo.asRcOut[0].abSrcOnOff[MCDRV_SRC_MIC3_BLOCK]	&= (UINT8)~MCDRV_SRC0_MIC3_ON;
+		gsGlobalInfo_AA.sPathInfo.asRcOut[0].abSrcOnOff[MCDRV_SRC_MIC3_BLOCK]	|= MCDRV_SRC0_MIC3_OFF;
+	}
+
+	if((psPathInfo->asRcOut[0].abSrcOnOff[MCDRV_SRC_LINE1_M_BLOCK] & (MCDRV_SRC1_LINE1_M_ON|MCDRV_SRC1_LINE1_M_OFF)) == MCDRV_SRC1_LINE1_M_ON)
+	{
+		gsGlobalInfo_AA.sPathInfo.asRcOut[0].abSrcOnOff[MCDRV_SRC_LINE1_M_BLOCK]	&= (UINT8)~MCDRV_SRC1_LINE1_M_OFF;
+		gsGlobalInfo_AA.sPathInfo.asRcOut[0].abSrcOnOff[MCDRV_SRC_LINE1_M_BLOCK]	|= MCDRV_SRC1_LINE1_M_ON;
+	}
+	else if((psPathInfo->asRcOut[0].abSrcOnOff[MCDRV_SRC_LINE1_M_BLOCK] & (MCDRV_SRC1_LINE1_M_ON|MCDRV_SRC1_LINE1_M_OFF)) == MCDRV_SRC1_LINE1_M_OFF)
+	{
+		gsGlobalInfo_AA.sPathInfo.asRcOut[0].abSrcOnOff[MCDRV_SRC_LINE1_M_BLOCK]	&= (UINT8)~MCDRV_SRC1_LINE1_M_ON;
+		gsGlobalInfo_AA.sPathInfo.asRcOut[0].abSrcOnOff[MCDRV_SRC_LINE1_M_BLOCK]	|= MCDRV_SRC1_LINE1_M_OFF;
+	}
+
+	if((psPathInfo->asRcOut[0].abSrcOnOff[MCDRV_SRC_DAC_L_BLOCK] & (MCDRV_SRC5_DAC_L_ON|MCDRV_SRC5_DAC_L_OFF)) == MCDRV_SRC5_DAC_L_ON)
+	{
+		gsGlobalInfo_AA.sPathInfo.asRcOut[0].abSrcOnOff[MCDRV_SRC_DAC_L_BLOCK]	&= (UINT8)~MCDRV_SRC5_DAC_L_OFF;
+		gsGlobalInfo_AA.sPathInfo.asRcOut[0].abSrcOnOff[MCDRV_SRC_DAC_L_BLOCK]	|= MCDRV_SRC5_DAC_L_ON;
+	}
+	else if((psPathInfo->asRcOut[0].abSrcOnOff[MCDRV_SRC_DAC_L_BLOCK] & (MCDRV_SRC5_DAC_L_ON|MCDRV_SRC5_DAC_L_OFF)) == MCDRV_SRC5_DAC_L_OFF)
+	{
+		gsGlobalInfo_AA.sPathInfo.asRcOut[0].abSrcOnOff[MCDRV_SRC_DAC_L_BLOCK]	&= (UINT8)~MCDRV_SRC5_DAC_L_ON;
+		gsGlobalInfo_AA.sPathInfo.asRcOut[0].abSrcOnOff[MCDRV_SRC_DAC_L_BLOCK]	|= MCDRV_SRC5_DAC_L_OFF;
+	}
+
+	if((psPathInfo->asRcOut[0].abSrcOnOff[MCDRV_SRC_DAC_R_BLOCK] & (MCDRV_SRC5_DAC_R_ON|MCDRV_SRC5_DAC_R_OFF)) == MCDRV_SRC5_DAC_R_ON)
+	{
+		gsGlobalInfo_AA.sPathInfo.asRcOut[0].abSrcOnOff[MCDRV_SRC_DAC_R_BLOCK]	&= (UINT8)~MCDRV_SRC5_DAC_R_OFF;
+		gsGlobalInfo_AA.sPathInfo.asRcOut[0].abSrcOnOff[MCDRV_SRC_DAC_R_BLOCK]	|= MCDRV_SRC5_DAC_R_ON;
+	}
+	else if((psPathInfo->asRcOut[0].abSrcOnOff[MCDRV_SRC_DAC_R_BLOCK] & (MCDRV_SRC5_DAC_R_ON|MCDRV_SRC5_DAC_R_OFF)) == MCDRV_SRC5_DAC_R_OFF)
+	{
+		gsGlobalInfo_AA.sPathInfo.asRcOut[0].abSrcOnOff[MCDRV_SRC_DAC_R_BLOCK]	&= (UINT8)~MCDRV_SRC5_DAC_R_ON;
+		gsGlobalInfo_AA.sPathInfo.asRcOut[0].abSrcOnOff[MCDRV_SRC_DAC_R_BLOCK]	|= MCDRV_SRC5_DAC_R_OFF;
+	}
+}
+
+/****************************************************************************
+ *	SetLO1SourceOnOff
+ *
+ *	Description:
+ *			Set LOut1 source On/Off.
+ *	Arguments:
+ *			psPathInfo	path information
+ *	Return:
+ *			none
+ *
+ ****************************************************************************/
+static void	SetLO1SourceOnOff
+(
+	const MCDRV_PATH_INFO*	psPathInfo
+)
+{
+	if((psPathInfo->asLout1[0].abSrcOnOff[MCDRV_SRC_MIC1_BLOCK] & (MCDRV_SRC0_MIC1_ON|MCDRV_SRC0_MIC1_OFF)) == MCDRV_SRC0_MIC1_ON)
+	{
+		gsGlobalInfo_AA.sPathInfo.asLout1[0].abSrcOnOff[MCDRV_SRC_MIC1_BLOCK]	&= (UINT8)~MCDRV_SRC0_MIC1_OFF;
+		gsGlobalInfo_AA.sPathInfo.asLout1[0].abSrcOnOff[MCDRV_SRC_MIC1_BLOCK]	|= MCDRV_SRC0_MIC1_ON;
+	}
+	else if((psPathInfo->asLout1[0].abSrcOnOff[MCDRV_SRC_MIC1_BLOCK] & (MCDRV_SRC0_MIC1_ON|MCDRV_SRC0_MIC1_OFF)) == MCDRV_SRC0_MIC1_OFF)
+	{
+		gsGlobalInfo_AA.sPathInfo.asLout1[0].abSrcOnOff[MCDRV_SRC_MIC1_BLOCK]	&= (UINT8)~MCDRV_SRC0_MIC1_ON;
+		gsGlobalInfo_AA.sPathInfo.asLout1[0].abSrcOnOff[MCDRV_SRC_MIC1_BLOCK]	|= MCDRV_SRC0_MIC1_OFF;
+	}
+	if((psPathInfo->asLout1[0].abSrcOnOff[MCDRV_SRC_MIC2_BLOCK] & (MCDRV_SRC0_MIC2_ON|MCDRV_SRC0_MIC2_OFF)) == MCDRV_SRC0_MIC2_ON)
+	{
+		gsGlobalInfo_AA.sPathInfo.asLout1[0].abSrcOnOff[MCDRV_SRC_MIC2_BLOCK]	&= (UINT8)~MCDRV_SRC0_MIC2_OFF;
+		gsGlobalInfo_AA.sPathInfo.asLout1[0].abSrcOnOff[MCDRV_SRC_MIC2_BLOCK]	|= MCDRV_SRC0_MIC2_ON;
+	}
+	else if((psPathInfo->asLout1[0].abSrcOnOff[MCDRV_SRC_MIC2_BLOCK] & (MCDRV_SRC0_MIC2_ON|MCDRV_SRC0_MIC2_OFF)) == MCDRV_SRC0_MIC2_OFF)
+	{
+		gsGlobalInfo_AA.sPathInfo.asLout1[0].abSrcOnOff[MCDRV_SRC_MIC2_BLOCK]	&= (UINT8)~MCDRV_SRC0_MIC2_ON;
+		gsGlobalInfo_AA.sPathInfo.asLout1[0].abSrcOnOff[MCDRV_SRC_MIC2_BLOCK]	|= MCDRV_SRC0_MIC2_OFF;
+	}
+	if((psPathInfo->asLout1[0].abSrcOnOff[MCDRV_SRC_MIC3_BLOCK] & (MCDRV_SRC0_MIC3_ON|MCDRV_SRC0_MIC3_OFF)) == MCDRV_SRC0_MIC3_ON)
+	{
+		gsGlobalInfo_AA.sPathInfo.asLout1[0].abSrcOnOff[MCDRV_SRC_MIC3_BLOCK]	&= (UINT8)~MCDRV_SRC0_MIC3_OFF;
+		gsGlobalInfo_AA.sPathInfo.asLout1[0].abSrcOnOff[MCDRV_SRC_MIC3_BLOCK]	|= MCDRV_SRC0_MIC3_ON;
+	}
+	else if((psPathInfo->asLout1[0].abSrcOnOff[MCDRV_SRC_MIC3_BLOCK] & (MCDRV_SRC0_MIC3_ON|MCDRV_SRC0_MIC3_OFF)) == MCDRV_SRC0_MIC3_OFF)
+	{
+		gsGlobalInfo_AA.sPathInfo.asLout1[0].abSrcOnOff[MCDRV_SRC_MIC3_BLOCK]	&= (UINT8)~MCDRV_SRC0_MIC3_ON;
+		gsGlobalInfo_AA.sPathInfo.asLout1[0].abSrcOnOff[MCDRV_SRC_MIC3_BLOCK]	|= MCDRV_SRC0_MIC3_OFF;
+	}
+
+	if((psPathInfo->asLout1[0].abSrcOnOff[MCDRV_SRC_LINE1_L_BLOCK] & (MCDRV_SRC1_LINE1_L_ON|MCDRV_SRC1_LINE1_L_OFF)) == MCDRV_SRC1_LINE1_L_ON)
+	{
+		gsGlobalInfo_AA.sPathInfo.asLout1[0].abSrcOnOff[MCDRV_SRC_LINE1_L_BLOCK]	&= (UINT8)~MCDRV_SRC1_LINE1_L_OFF;
+		gsGlobalInfo_AA.sPathInfo.asLout1[0].abSrcOnOff[MCDRV_SRC_LINE1_L_BLOCK]	|= MCDRV_SRC1_LINE1_L_ON;
+	}
+	else if((psPathInfo->asLout1[0].abSrcOnOff[MCDRV_SRC_LINE1_L_BLOCK] & (MCDRV_SRC1_LINE1_L_ON|MCDRV_SRC1_LINE1_L_OFF)) == MCDRV_SRC1_LINE1_L_OFF)
+	{
+		gsGlobalInfo_AA.sPathInfo.asLout1[0].abSrcOnOff[MCDRV_SRC_LINE1_L_BLOCK]	&= (UINT8)~MCDRV_SRC1_LINE1_L_ON;
+		gsGlobalInfo_AA.sPathInfo.asLout1[0].abSrcOnOff[MCDRV_SRC_LINE1_L_BLOCK]	|= MCDRV_SRC1_LINE1_L_OFF;
+	}
+	if((psPathInfo->asLout1[0].abSrcOnOff[MCDRV_SRC_LINE1_M_BLOCK] & (MCDRV_SRC1_LINE1_M_ON|MCDRV_SRC1_LINE1_M_OFF)) == MCDRV_SRC1_LINE1_M_ON)
+	{
+		gsGlobalInfo_AA.sPathInfo.asLout1[0].abSrcOnOff[MCDRV_SRC_LINE1_M_BLOCK]	&= (UINT8)~MCDRV_SRC1_LINE1_M_OFF;
+		gsGlobalInfo_AA.sPathInfo.asLout1[0].abSrcOnOff[MCDRV_SRC_LINE1_M_BLOCK]	|= MCDRV_SRC1_LINE1_M_ON;
+	}
+	else if((psPathInfo->asLout1[0].abSrcOnOff[MCDRV_SRC_LINE1_M_BLOCK] & (MCDRV_SRC1_LINE1_M_ON|MCDRV_SRC1_LINE1_M_OFF)) == MCDRV_SRC1_LINE1_M_OFF)
+	{
+		gsGlobalInfo_AA.sPathInfo.asLout1[0].abSrcOnOff[MCDRV_SRC_LINE1_M_BLOCK]	&= (UINT8)~MCDRV_SRC1_LINE1_M_ON;
+		gsGlobalInfo_AA.sPathInfo.asLout1[0].abSrcOnOff[MCDRV_SRC_LINE1_M_BLOCK]	|= MCDRV_SRC1_LINE1_M_OFF;
+	}
+
+	if((psPathInfo->asLout1[0].abSrcOnOff[MCDRV_SRC_DAC_L_BLOCK] & (MCDRV_SRC5_DAC_L_ON|MCDRV_SRC5_DAC_L_OFF)) == MCDRV_SRC5_DAC_L_ON)
+	{
+		gsGlobalInfo_AA.sPathInfo.asLout1[0].abSrcOnOff[MCDRV_SRC_DAC_L_BLOCK]	&= (UINT8)~MCDRV_SRC5_DAC_L_OFF;
+		gsGlobalInfo_AA.sPathInfo.asLout1[0].abSrcOnOff[MCDRV_SRC_DAC_L_BLOCK]	|= MCDRV_SRC5_DAC_L_ON;
+	}
+	else if((psPathInfo->asLout1[0].abSrcOnOff[MCDRV_SRC_DAC_L_BLOCK] & (MCDRV_SRC5_DAC_L_ON|MCDRV_SRC5_DAC_L_OFF)) == MCDRV_SRC5_DAC_L_OFF)
+	{
+		gsGlobalInfo_AA.sPathInfo.asLout1[0].abSrcOnOff[MCDRV_SRC_DAC_L_BLOCK]	&= (UINT8)~MCDRV_SRC5_DAC_L_ON;
+		gsGlobalInfo_AA.sPathInfo.asLout1[0].abSrcOnOff[MCDRV_SRC_DAC_L_BLOCK]	|= MCDRV_SRC5_DAC_L_OFF;
+	}
+	if((psPathInfo->asLout1[0].abSrcOnOff[MCDRV_SRC_DAC_M_BLOCK] & (MCDRV_SRC5_DAC_M_ON|MCDRV_SRC5_DAC_M_OFF)) == MCDRV_SRC5_DAC_M_ON)
+	{
+		gsGlobalInfo_AA.sPathInfo.asLout1[0].abSrcOnOff[MCDRV_SRC_DAC_M_BLOCK]	&= (UINT8)~MCDRV_SRC5_DAC_M_OFF;
+		gsGlobalInfo_AA.sPathInfo.asLout1[0].abSrcOnOff[MCDRV_SRC_DAC_M_BLOCK]	|= MCDRV_SRC5_DAC_M_ON;
+	}
+	else if((psPathInfo->asLout1[0].abSrcOnOff[MCDRV_SRC_DAC_M_BLOCK] & (MCDRV_SRC5_DAC_M_ON|MCDRV_SRC5_DAC_M_OFF)) == MCDRV_SRC5_DAC_M_OFF)
+	{
+		gsGlobalInfo_AA.sPathInfo.asLout1[0].abSrcOnOff[MCDRV_SRC_DAC_M_BLOCK]	&= (UINT8)~MCDRV_SRC5_DAC_M_ON;
+		gsGlobalInfo_AA.sPathInfo.asLout1[0].abSrcOnOff[MCDRV_SRC_DAC_M_BLOCK]	|= MCDRV_SRC5_DAC_M_OFF;
+	}
+
+	if((psPathInfo->asLout1[1].abSrcOnOff[MCDRV_SRC_MIC1_BLOCK] & (MCDRV_SRC0_MIC1_ON|MCDRV_SRC0_MIC1_OFF)) == MCDRV_SRC0_MIC1_ON)
+	{
+		gsGlobalInfo_AA.sPathInfo.asLout1[1].abSrcOnOff[MCDRV_SRC_MIC1_BLOCK]	&= (UINT8)~MCDRV_SRC0_MIC1_OFF;
+		gsGlobalInfo_AA.sPathInfo.asLout1[1].abSrcOnOff[MCDRV_SRC_MIC1_BLOCK]	|= MCDRV_SRC0_MIC1_ON;
+	}
+	else if((psPathInfo->asLout1[1].abSrcOnOff[MCDRV_SRC_MIC1_BLOCK] & (MCDRV_SRC0_MIC1_ON|MCDRV_SRC0_MIC1_OFF)) == MCDRV_SRC0_MIC1_OFF)
+	{
+		gsGlobalInfo_AA.sPathInfo.asLout1[1].abSrcOnOff[MCDRV_SRC_MIC1_BLOCK]	&= (UINT8)~MCDRV_SRC0_MIC1_ON;
+		gsGlobalInfo_AA.sPathInfo.asLout1[1].abSrcOnOff[MCDRV_SRC_MIC1_BLOCK]	|= MCDRV_SRC0_MIC1_OFF;
+	}
+	if((psPathInfo->asLout1[1].abSrcOnOff[MCDRV_SRC_MIC2_BLOCK] & (MCDRV_SRC0_MIC2_ON|MCDRV_SRC0_MIC2_OFF)) == MCDRV_SRC0_MIC2_ON)
+	{
+		gsGlobalInfo_AA.sPathInfo.asLout1[1].abSrcOnOff[MCDRV_SRC_MIC2_BLOCK]	&= (UINT8)~MCDRV_SRC0_MIC2_OFF;
+		gsGlobalInfo_AA.sPathInfo.asLout1[1].abSrcOnOff[MCDRV_SRC_MIC2_BLOCK]	|= MCDRV_SRC0_MIC2_ON;
+	}
+	else if((psPathInfo->asLout1[1].abSrcOnOff[MCDRV_SRC_MIC2_BLOCK] & (MCDRV_SRC0_MIC2_ON|MCDRV_SRC0_MIC2_OFF)) == MCDRV_SRC0_MIC2_OFF)
+	{
+		gsGlobalInfo_AA.sPathInfo.asLout1[1].abSrcOnOff[MCDRV_SRC_MIC2_BLOCK]	&= (UINT8)~MCDRV_SRC0_MIC2_ON;
+		gsGlobalInfo_AA.sPathInfo.asLout1[1].abSrcOnOff[MCDRV_SRC_MIC2_BLOCK]	|= MCDRV_SRC0_MIC2_OFF;
+	}
+	if((psPathInfo->asLout1[1].abSrcOnOff[MCDRV_SRC_MIC3_BLOCK] & (MCDRV_SRC0_MIC3_ON|MCDRV_SRC0_MIC3_OFF)) == MCDRV_SRC0_MIC3_ON)
+	{
+		gsGlobalInfo_AA.sPathInfo.asLout1[1].abSrcOnOff[MCDRV_SRC_MIC3_BLOCK]	&= (UINT8)~MCDRV_SRC0_MIC3_OFF;
+		gsGlobalInfo_AA.sPathInfo.asLout1[1].abSrcOnOff[MCDRV_SRC_MIC3_BLOCK]	|= MCDRV_SRC0_MIC3_ON;
+	}
+	else if((psPathInfo->asLout1[1].abSrcOnOff[MCDRV_SRC_MIC3_BLOCK] & (MCDRV_SRC0_MIC3_ON|MCDRV_SRC0_MIC3_OFF)) == MCDRV_SRC0_MIC3_OFF)
+	{
+		gsGlobalInfo_AA.sPathInfo.asLout1[1].abSrcOnOff[MCDRV_SRC_MIC3_BLOCK]	&= (UINT8)~MCDRV_SRC0_MIC3_ON;
+		gsGlobalInfo_AA.sPathInfo.asLout1[1].abSrcOnOff[MCDRV_SRC_MIC3_BLOCK]	|= MCDRV_SRC0_MIC3_OFF;
+	}
+
+	if((psPathInfo->asLout1[1].abSrcOnOff[MCDRV_SRC_LINE1_R_BLOCK] & (MCDRV_SRC1_LINE1_R_ON|MCDRV_SRC1_LINE1_R_OFF)) == MCDRV_SRC1_LINE1_R_ON)
+	{
+		gsGlobalInfo_AA.sPathInfo.asLout1[1].abSrcOnOff[MCDRV_SRC_LINE1_R_BLOCK]	&= (UINT8)~MCDRV_SRC1_LINE1_R_OFF;
+		gsGlobalInfo_AA.sPathInfo.asLout1[1].abSrcOnOff[MCDRV_SRC_LINE1_R_BLOCK]	|= MCDRV_SRC1_LINE1_R_ON;
+	}
+	else if((psPathInfo->asLout1[1].abSrcOnOff[MCDRV_SRC_LINE1_R_BLOCK] & (MCDRV_SRC1_LINE1_R_ON|MCDRV_SRC1_LINE1_R_OFF)) == MCDRV_SRC1_LINE1_R_OFF)
+	{
+		gsGlobalInfo_AA.sPathInfo.asLout1[1].abSrcOnOff[MCDRV_SRC_LINE1_R_BLOCK]	&= (UINT8)~MCDRV_SRC1_LINE1_R_ON;
+		gsGlobalInfo_AA.sPathInfo.asLout1[1].abSrcOnOff[MCDRV_SRC_LINE1_R_BLOCK]	|= MCDRV_SRC1_LINE1_R_OFF;
+	}
+
+	if((psPathInfo->asLout1[1].abSrcOnOff[MCDRV_SRC_DAC_R_BLOCK] & (MCDRV_SRC5_DAC_R_ON|MCDRV_SRC5_DAC_R_OFF)) == MCDRV_SRC5_DAC_R_ON)
+	{
+		gsGlobalInfo_AA.sPathInfo.asLout1[1].abSrcOnOff[MCDRV_SRC_DAC_R_BLOCK]	&= (UINT8)~MCDRV_SRC5_DAC_R_OFF;
+		gsGlobalInfo_AA.sPathInfo.asLout1[1].abSrcOnOff[MCDRV_SRC_DAC_R_BLOCK]	|= MCDRV_SRC5_DAC_R_ON;
+	}
+	else if((psPathInfo->asLout1[1].abSrcOnOff[MCDRV_SRC_DAC_R_BLOCK] & (MCDRV_SRC5_DAC_R_ON|MCDRV_SRC5_DAC_R_OFF)) == MCDRV_SRC5_DAC_R_OFF)
+	{
+		gsGlobalInfo_AA.sPathInfo.asLout1[1].abSrcOnOff[MCDRV_SRC_DAC_R_BLOCK]	&= (UINT8)~MCDRV_SRC5_DAC_R_ON;
+		gsGlobalInfo_AA.sPathInfo.asLout1[1].abSrcOnOff[MCDRV_SRC_DAC_R_BLOCK]	|= MCDRV_SRC5_DAC_R_OFF;
+	}
+}
+
+/****************************************************************************
+ *	SetLO2SourceOnOff
+ *
+ *	Description:
+ *			Set LOut2 source On/Off.
+ *	Arguments:
+ *			psPathInfo	path information
+ *	Return:
+ *			none
+ *
+ ****************************************************************************/
+static void	SetLO2SourceOnOff
+(
+	const MCDRV_PATH_INFO*	psPathInfo
+)
+{
+	if((psPathInfo->asLout2[0].abSrcOnOff[MCDRV_SRC_MIC1_BLOCK] & (MCDRV_SRC0_MIC1_ON|MCDRV_SRC0_MIC1_OFF)) == MCDRV_SRC0_MIC1_ON)
+	{
+		gsGlobalInfo_AA.sPathInfo.asLout2[0].abSrcOnOff[MCDRV_SRC_MIC1_BLOCK]	&= (UINT8)~MCDRV_SRC0_MIC1_OFF;
+		gsGlobalInfo_AA.sPathInfo.asLout2[0].abSrcOnOff[MCDRV_SRC_MIC1_BLOCK]	|= MCDRV_SRC0_MIC1_ON;
+	}
+	else if((psPathInfo->asLout2[0].abSrcOnOff[MCDRV_SRC_MIC1_BLOCK] & (MCDRV_SRC0_MIC1_ON|MCDRV_SRC0_MIC1_OFF)) == MCDRV_SRC0_MIC1_OFF)
+	{
+		gsGlobalInfo_AA.sPathInfo.asLout2[0].abSrcOnOff[MCDRV_SRC_MIC1_BLOCK]	&= (UINT8)~MCDRV_SRC0_MIC1_ON;
+		gsGlobalInfo_AA.sPathInfo.asLout2[0].abSrcOnOff[MCDRV_SRC_MIC1_BLOCK]	|= MCDRV_SRC0_MIC1_OFF;
+	}
+	if((psPathInfo->asLout2[0].abSrcOnOff[MCDRV_SRC_MIC2_BLOCK] & (MCDRV_SRC0_MIC2_ON|MCDRV_SRC0_MIC2_OFF)) == MCDRV_SRC0_MIC2_ON)
+	{
+		gsGlobalInfo_AA.sPathInfo.asLout2[0].abSrcOnOff[MCDRV_SRC_MIC2_BLOCK]	&= (UINT8)~MCDRV_SRC0_MIC2_OFF;
+		gsGlobalInfo_AA.sPathInfo.asLout2[0].abSrcOnOff[MCDRV_SRC_MIC2_BLOCK]	|= MCDRV_SRC0_MIC2_ON;
+	}
+	else if((psPathInfo->asLout2[0].abSrcOnOff[MCDRV_SRC_MIC2_BLOCK] & (MCDRV_SRC0_MIC2_ON|MCDRV_SRC0_MIC2_OFF)) == MCDRV_SRC0_MIC2_OFF)
+	{
+		gsGlobalInfo_AA.sPathInfo.asLout2[0].abSrcOnOff[MCDRV_SRC_MIC2_BLOCK]	&= (UINT8)~MCDRV_SRC0_MIC2_ON;
+		gsGlobalInfo_AA.sPathInfo.asLout2[0].abSrcOnOff[MCDRV_SRC_MIC2_BLOCK]	|= MCDRV_SRC0_MIC2_OFF;
+	}
+	if((psPathInfo->asLout2[0].abSrcOnOff[MCDRV_SRC_MIC3_BLOCK] & (MCDRV_SRC0_MIC3_ON|MCDRV_SRC0_MIC3_OFF)) == MCDRV_SRC0_MIC3_ON)
+	{
+		gsGlobalInfo_AA.sPathInfo.asLout2[0].abSrcOnOff[MCDRV_SRC_MIC3_BLOCK]	&= (UINT8)~MCDRV_SRC0_MIC3_OFF;
+		gsGlobalInfo_AA.sPathInfo.asLout2[0].abSrcOnOff[MCDRV_SRC_MIC3_BLOCK]	|= MCDRV_SRC0_MIC3_ON;
+	}
+	else if((psPathInfo->asLout2[0].abSrcOnOff[MCDRV_SRC_MIC3_BLOCK] & (MCDRV_SRC0_MIC3_ON|MCDRV_SRC0_MIC3_OFF)) == MCDRV_SRC0_MIC3_OFF)
+	{
+		gsGlobalInfo_AA.sPathInfo.asLout2[0].abSrcOnOff[MCDRV_SRC_MIC3_BLOCK]	&= (UINT8)~MCDRV_SRC0_MIC3_ON;
+		gsGlobalInfo_AA.sPathInfo.asLout2[0].abSrcOnOff[MCDRV_SRC_MIC3_BLOCK]	|= MCDRV_SRC0_MIC3_OFF;
+	}
+
+	if((psPathInfo->asLout2[0].abSrcOnOff[MCDRV_SRC_LINE1_L_BLOCK] & (MCDRV_SRC1_LINE1_L_ON|MCDRV_SRC1_LINE1_L_OFF)) == MCDRV_SRC1_LINE1_L_ON)
+	{
+		gsGlobalInfo_AA.sPathInfo.asLout2[0].abSrcOnOff[MCDRV_SRC_LINE1_L_BLOCK]	&= (UINT8)~MCDRV_SRC1_LINE1_L_OFF;
+		gsGlobalInfo_AA.sPathInfo.asLout2[0].abSrcOnOff[MCDRV_SRC_LINE1_L_BLOCK]	|= MCDRV_SRC1_LINE1_L_ON;
+	}
+	else if((psPathInfo->asLout2[0].abSrcOnOff[MCDRV_SRC_LINE1_L_BLOCK] & (MCDRV_SRC1_LINE1_L_ON|MCDRV_SRC1_LINE1_L_OFF)) == MCDRV_SRC1_LINE1_L_OFF)
+	{
+		gsGlobalInfo_AA.sPathInfo.asLout2[0].abSrcOnOff[MCDRV_SRC_LINE1_L_BLOCK]	&= (UINT8)~MCDRV_SRC1_LINE1_L_ON;
+		gsGlobalInfo_AA.sPathInfo.asLout2[0].abSrcOnOff[MCDRV_SRC_LINE1_L_BLOCK]	|= MCDRV_SRC1_LINE1_L_OFF;
+	}
+	if((psPathInfo->asLout2[0].abSrcOnOff[MCDRV_SRC_LINE1_M_BLOCK] & (MCDRV_SRC1_LINE1_M_ON|MCDRV_SRC1_LINE1_M_OFF)) == MCDRV_SRC1_LINE1_M_ON)
+	{
+		gsGlobalInfo_AA.sPathInfo.asLout2[0].abSrcOnOff[MCDRV_SRC_LINE1_M_BLOCK]	&= (UINT8)~MCDRV_SRC1_LINE1_M_OFF;
+		gsGlobalInfo_AA.sPathInfo.asLout2[0].abSrcOnOff[MCDRV_SRC_LINE1_M_BLOCK]	|= MCDRV_SRC1_LINE1_M_ON;
+	}
+	else if((psPathInfo->asLout2[0].abSrcOnOff[MCDRV_SRC_LINE1_M_BLOCK] & (MCDRV_SRC1_LINE1_M_ON|MCDRV_SRC1_LINE1_M_OFF)) == MCDRV_SRC1_LINE1_M_OFF)
+	{
+		gsGlobalInfo_AA.sPathInfo.asLout2[0].abSrcOnOff[MCDRV_SRC_LINE1_M_BLOCK]	&= (UINT8)~MCDRV_SRC1_LINE1_M_ON;
+		gsGlobalInfo_AA.sPathInfo.asLout2[0].abSrcOnOff[MCDRV_SRC_LINE1_M_BLOCK]	|= MCDRV_SRC1_LINE1_M_OFF;
+	}
+
+	if((psPathInfo->asLout2[0].abSrcOnOff[MCDRV_SRC_DAC_L_BLOCK] & (MCDRV_SRC5_DAC_L_ON|MCDRV_SRC5_DAC_L_OFF)) == MCDRV_SRC5_DAC_L_ON)
+	{
+		gsGlobalInfo_AA.sPathInfo.asLout2[0].abSrcOnOff[MCDRV_SRC_DAC_L_BLOCK]	&= (UINT8)~MCDRV_SRC5_DAC_L_OFF;
+		gsGlobalInfo_AA.sPathInfo.asLout2[0].abSrcOnOff[MCDRV_SRC_DAC_L_BLOCK]	|= MCDRV_SRC5_DAC_L_ON;
+	}
+	else if((psPathInfo->asLout2[0].abSrcOnOff[MCDRV_SRC_DAC_L_BLOCK] & (MCDRV_SRC5_DAC_L_ON|MCDRV_SRC5_DAC_L_OFF)) == MCDRV_SRC5_DAC_L_OFF)
+	{
+		gsGlobalInfo_AA.sPathInfo.asLout2[0].abSrcOnOff[MCDRV_SRC_DAC_L_BLOCK]	&= (UINT8)~MCDRV_SRC5_DAC_L_ON;
+		gsGlobalInfo_AA.sPathInfo.asLout2[0].abSrcOnOff[MCDRV_SRC_DAC_L_BLOCK]	|= MCDRV_SRC5_DAC_L_OFF;
+	}
+	if((psPathInfo->asLout2[0].abSrcOnOff[MCDRV_SRC_DAC_M_BLOCK] & (MCDRV_SRC5_DAC_M_ON|MCDRV_SRC5_DAC_M_OFF)) == MCDRV_SRC5_DAC_M_ON)
+	{
+		gsGlobalInfo_AA.sPathInfo.asLout2[0].abSrcOnOff[MCDRV_SRC_DAC_M_BLOCK]	&= (UINT8)~MCDRV_SRC5_DAC_M_OFF;
+		gsGlobalInfo_AA.sPathInfo.asLout2[0].abSrcOnOff[MCDRV_SRC_DAC_M_BLOCK]	|= MCDRV_SRC5_DAC_M_ON;
+	}
+	else if((psPathInfo->asLout2[0].abSrcOnOff[MCDRV_SRC_DAC_M_BLOCK] & (MCDRV_SRC5_DAC_M_ON|MCDRV_SRC5_DAC_M_OFF)) == MCDRV_SRC5_DAC_M_OFF)
+	{
+		gsGlobalInfo_AA.sPathInfo.asLout2[0].abSrcOnOff[MCDRV_SRC_DAC_M_BLOCK]	&= (UINT8)~MCDRV_SRC5_DAC_M_ON;
+		gsGlobalInfo_AA.sPathInfo.asLout2[0].abSrcOnOff[MCDRV_SRC_DAC_M_BLOCK]	|= MCDRV_SRC5_DAC_M_OFF;
+	}
+
+	if((psPathInfo->asLout2[1].abSrcOnOff[MCDRV_SRC_MIC1_BLOCK] & (MCDRV_SRC0_MIC1_ON|MCDRV_SRC0_MIC1_OFF)) == MCDRV_SRC0_MIC1_ON)
+	{
+		gsGlobalInfo_AA.sPathInfo.asLout2[1].abSrcOnOff[MCDRV_SRC_MIC1_BLOCK]	&= (UINT8)~MCDRV_SRC0_MIC1_OFF;
+		gsGlobalInfo_AA.sPathInfo.asLout2[1].abSrcOnOff[MCDRV_SRC_MIC1_BLOCK]	|= MCDRV_SRC0_MIC1_ON;
+	}
+	else if((psPathInfo->asLout2[1].abSrcOnOff[MCDRV_SRC_MIC1_BLOCK] & (MCDRV_SRC0_MIC1_ON|MCDRV_SRC0_MIC1_OFF)) == MCDRV_SRC0_MIC1_OFF)
+	{
+		gsGlobalInfo_AA.sPathInfo.asLout2[1].abSrcOnOff[MCDRV_SRC_MIC1_BLOCK]	&= (UINT8)~MCDRV_SRC0_MIC1_ON;
+		gsGlobalInfo_AA.sPathInfo.asLout2[1].abSrcOnOff[MCDRV_SRC_MIC1_BLOCK]	|= MCDRV_SRC0_MIC1_OFF;
+	}
+	if((psPathInfo->asLout2[1].abSrcOnOff[MCDRV_SRC_MIC2_BLOCK] & (MCDRV_SRC0_MIC2_ON|MCDRV_SRC0_MIC2_OFF)) == MCDRV_SRC0_MIC2_ON)
+	{
+		gsGlobalInfo_AA.sPathInfo.asLout2[1].abSrcOnOff[MCDRV_SRC_MIC2_BLOCK]	&= (UINT8)~MCDRV_SRC0_MIC2_OFF;
+		gsGlobalInfo_AA.sPathInfo.asLout2[1].abSrcOnOff[MCDRV_SRC_MIC2_BLOCK]	|= MCDRV_SRC0_MIC2_ON;
+	}
+	else if((psPathInfo->asLout2[1].abSrcOnOff[MCDRV_SRC_MIC2_BLOCK] & (MCDRV_SRC0_MIC2_ON|MCDRV_SRC0_MIC2_OFF)) == MCDRV_SRC0_MIC2_OFF)
+	{
+		gsGlobalInfo_AA.sPathInfo.asLout2[1].abSrcOnOff[MCDRV_SRC_MIC2_BLOCK]	&= (UINT8)~MCDRV_SRC0_MIC2_ON;
+		gsGlobalInfo_AA.sPathInfo.asLout2[1].abSrcOnOff[MCDRV_SRC_MIC2_BLOCK]	|= MCDRV_SRC0_MIC2_OFF;
+	}
+	if((psPathInfo->asLout2[1].abSrcOnOff[MCDRV_SRC_MIC3_BLOCK] & (MCDRV_SRC0_MIC3_ON|MCDRV_SRC0_MIC3_OFF)) == MCDRV_SRC0_MIC3_ON)
+	{
+		gsGlobalInfo_AA.sPathInfo.asLout2[1].abSrcOnOff[MCDRV_SRC_MIC3_BLOCK]	&= (UINT8)~MCDRV_SRC0_MIC3_OFF;
+		gsGlobalInfo_AA.sPathInfo.asLout2[1].abSrcOnOff[MCDRV_SRC_MIC3_BLOCK]	|= MCDRV_SRC0_MIC3_ON;
+	}
+	else if((psPathInfo->asLout2[1].abSrcOnOff[MCDRV_SRC_MIC3_BLOCK] & (MCDRV_SRC0_MIC3_ON|MCDRV_SRC0_MIC3_OFF)) == MCDRV_SRC0_MIC3_OFF)
+	{
+		gsGlobalInfo_AA.sPathInfo.asLout2[1].abSrcOnOff[MCDRV_SRC_MIC3_BLOCK]	&= (UINT8)~MCDRV_SRC0_MIC3_ON;
+		gsGlobalInfo_AA.sPathInfo.asLout2[1].abSrcOnOff[MCDRV_SRC_MIC3_BLOCK]	|= MCDRV_SRC0_MIC3_OFF;
+	}
+
+	if((psPathInfo->asLout2[1].abSrcOnOff[MCDRV_SRC_LINE1_R_BLOCK] & (MCDRV_SRC1_LINE1_R_ON|MCDRV_SRC1_LINE1_R_OFF)) == MCDRV_SRC1_LINE1_R_ON)
+	{
+		gsGlobalInfo_AA.sPathInfo.asLout2[1].abSrcOnOff[MCDRV_SRC_LINE1_R_BLOCK]	&= (UINT8)~MCDRV_SRC1_LINE1_R_OFF;
+		gsGlobalInfo_AA.sPathInfo.asLout2[1].abSrcOnOff[MCDRV_SRC_LINE1_R_BLOCK]	|= MCDRV_SRC1_LINE1_R_ON;
+	}
+	else if((psPathInfo->asLout2[1].abSrcOnOff[MCDRV_SRC_LINE1_R_BLOCK] & (MCDRV_SRC1_LINE1_R_ON|MCDRV_SRC1_LINE1_R_OFF)) == MCDRV_SRC1_LINE1_R_OFF)
+	{
+		gsGlobalInfo_AA.sPathInfo.asLout2[1].abSrcOnOff[MCDRV_SRC_LINE1_R_BLOCK]	&= (UINT8)~MCDRV_SRC1_LINE1_R_ON;
+		gsGlobalInfo_AA.sPathInfo.asLout2[1].abSrcOnOff[MCDRV_SRC_LINE1_R_BLOCK]	|= MCDRV_SRC1_LINE1_R_OFF;
+	}
+
+	if((psPathInfo->asLout2[1].abSrcOnOff[MCDRV_SRC_DAC_R_BLOCK] & (MCDRV_SRC5_DAC_R_ON|MCDRV_SRC5_DAC_R_OFF)) == MCDRV_SRC5_DAC_R_ON)
+	{
+		gsGlobalInfo_AA.sPathInfo.asLout2[1].abSrcOnOff[MCDRV_SRC_DAC_R_BLOCK]	&= (UINT8)~MCDRV_SRC5_DAC_R_OFF;
+		gsGlobalInfo_AA.sPathInfo.asLout2[1].abSrcOnOff[MCDRV_SRC_DAC_R_BLOCK]	|= MCDRV_SRC5_DAC_R_ON;
+	}
+	else if((psPathInfo->asLout2[1].abSrcOnOff[MCDRV_SRC_DAC_R_BLOCK] & (MCDRV_SRC5_DAC_R_ON|MCDRV_SRC5_DAC_R_OFF)) == MCDRV_SRC5_DAC_R_OFF)
+	{
+		gsGlobalInfo_AA.sPathInfo.asLout2[1].abSrcOnOff[MCDRV_SRC_DAC_R_BLOCK]	&= (UINT8)~MCDRV_SRC5_DAC_R_ON;
+		gsGlobalInfo_AA.sPathInfo.asLout2[1].abSrcOnOff[MCDRV_SRC_DAC_R_BLOCK]	|= MCDRV_SRC5_DAC_R_OFF;
+	}
+}
+
+/****************************************************************************
+ *	SetPMSourceOnOff
+ *
+ *	Description:
+ *			Set PeakMeter source On/Off.
+ *	Arguments:
+ *			psPathInfo	path information
+ *	Return:
+ *			none
+ *
+ ****************************************************************************/
+static void	SetPMSourceOnOff
+(
+	const MCDRV_PATH_INFO*	psPathInfo
+)
+{
+	(void)psPathInfo;
+}
+
+/****************************************************************************
+ *	SetDIT0SourceOnOff
+ *
+ *	Description:
+ *			Set DIT0 source On/Off.
+ *	Arguments:
+ *			psPathInfo	path information
+ *	Return:
+ *			none
+ *
+ ****************************************************************************/
+static void	SetDIT0SourceOnOff
+(
+	const MCDRV_PATH_INFO*	psPathInfo
+)
+{
+	if((psPathInfo->asDit0[0].abSrcOnOff[MCDRV_SRC_PDM_BLOCK] & (MCDRV_SRC4_PDM_ON|MCDRV_SRC4_PDM_OFF)) == MCDRV_SRC4_PDM_ON
+	&& gsGlobalInfo_AA.sInitInfo.bPad0Func == MCDRV_PAD_PDMCK)
+	{
+		gsGlobalInfo_AA.sPathInfo.asDit0[0].abSrcOnOff[MCDRV_SRC_PDM_BLOCK]	&= (UINT8)~MCDRV_SRC4_PDM_OFF;
+		gsGlobalInfo_AA.sPathInfo.asDit0[0].abSrcOnOff[MCDRV_SRC_PDM_BLOCK]	|= MCDRV_SRC4_PDM_ON;
+		gsGlobalInfo_AA.sPathInfo.asDit0[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK]	&= (UINT8)~MCDRV_SRC4_ADC0_ON;
+		gsGlobalInfo_AA.sPathInfo.asDit0[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK]	|= MCDRV_SRC4_ADC0_OFF;
+		gsGlobalInfo_AA.sPathInfo.asDit0[0].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR0_ON;
+		gsGlobalInfo_AA.sPathInfo.asDit0[0].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK]	|= MCDRV_SRC3_DIR0_OFF;
+		gsGlobalInfo_AA.sPathInfo.asDit0[0].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR1_ON;
+		gsGlobalInfo_AA.sPathInfo.asDit0[0].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK]	|= MCDRV_SRC3_DIR1_OFF;
+		gsGlobalInfo_AA.sPathInfo.asDit0[0].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR2_ON;
+		gsGlobalInfo_AA.sPathInfo.asDit0[0].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK]	|= MCDRV_SRC3_DIR2_OFF;
+		gsGlobalInfo_AA.sPathInfo.asDit0[0].abSrcOnOff[MCDRV_SRC_AE_BLOCK]		&= (UINT8)~MCDRV_SRC6_AE_ON;
+		gsGlobalInfo_AA.sPathInfo.asDit0[0].abSrcOnOff[MCDRV_SRC_AE_BLOCK]		|= MCDRV_SRC6_AE_OFF;
+		gsGlobalInfo_AA.sPathInfo.asDit0[0].abSrcOnOff[MCDRV_SRC_MIX_BLOCK]	&= (UINT8)~MCDRV_SRC6_MIX_ON;
+		gsGlobalInfo_AA.sPathInfo.asDit0[0].abSrcOnOff[MCDRV_SRC_MIX_BLOCK]	|= MCDRV_SRC6_MIX_OFF;
+	}
+	else if((psPathInfo->asDit0[0].abSrcOnOff[MCDRV_SRC_PDM_BLOCK] & (MCDRV_SRC4_PDM_ON|MCDRV_SRC4_PDM_OFF)) == MCDRV_SRC4_PDM_OFF)
+	{
+		gsGlobalInfo_AA.sPathInfo.asDit0[0].abSrcOnOff[MCDRV_SRC_PDM_BLOCK]	&= (UINT8)~MCDRV_SRC4_PDM_ON;
+		gsGlobalInfo_AA.sPathInfo.asDit0[0].abSrcOnOff[MCDRV_SRC_PDM_BLOCK]	|= MCDRV_SRC4_PDM_OFF;
+	}
+
+	if((psPathInfo->asDit0[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK] & (MCDRV_SRC4_ADC0_ON|MCDRV_SRC4_ADC0_OFF)) == MCDRV_SRC4_ADC0_ON)
+	{
+		gsGlobalInfo_AA.sPathInfo.asDit0[0].abSrcOnOff[MCDRV_SRC_PDM_BLOCK]	&= (UINT8)~MCDRV_SRC4_PDM_ON;
+		gsGlobalInfo_AA.sPathInfo.asDit0[0].abSrcOnOff[MCDRV_SRC_PDM_BLOCK]	|= MCDRV_SRC4_PDM_OFF;
+		gsGlobalInfo_AA.sPathInfo.asDit0[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK]	&= (UINT8)~MCDRV_SRC4_ADC0_OFF;
+		gsGlobalInfo_AA.sPathInfo.asDit0[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK]	|= MCDRV_SRC4_ADC0_ON;
+		gsGlobalInfo_AA.sPathInfo.asDit0[0].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR0_ON;
+		gsGlobalInfo_AA.sPathInfo.asDit0[0].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK]	|= MCDRV_SRC3_DIR0_OFF;
+		gsGlobalInfo_AA.sPathInfo.asDit0[0].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR1_ON;
+		gsGlobalInfo_AA.sPathInfo.asDit0[0].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK]	|= MCDRV_SRC3_DIR1_OFF;
+		gsGlobalInfo_AA.sPathInfo.asDit0[0].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR2_ON;
+		gsGlobalInfo_AA.sPathInfo.asDit0[0].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK]	|= MCDRV_SRC3_DIR2_OFF;
+		gsGlobalInfo_AA.sPathInfo.asDit0[0].abSrcOnOff[MCDRV_SRC_AE_BLOCK]		&= (UINT8)~MCDRV_SRC6_AE_ON;
+		gsGlobalInfo_AA.sPathInfo.asDit0[0].abSrcOnOff[MCDRV_SRC_AE_BLOCK]		|= MCDRV_SRC6_AE_OFF;
+		gsGlobalInfo_AA.sPathInfo.asDit0[0].abSrcOnOff[MCDRV_SRC_MIX_BLOCK]	&= (UINT8)~MCDRV_SRC6_MIX_ON;
+		gsGlobalInfo_AA.sPathInfo.asDit0[0].abSrcOnOff[MCDRV_SRC_MIX_BLOCK]	|= MCDRV_SRC6_MIX_OFF;
+	}
+	else if((psPathInfo->asDit0[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK] & (MCDRV_SRC4_ADC0_ON|MCDRV_SRC4_ADC0_OFF)) == MCDRV_SRC4_ADC0_OFF)
+	{
+		gsGlobalInfo_AA.sPathInfo.asDit0[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK]	&= (UINT8)~MCDRV_SRC4_ADC0_ON;
+		gsGlobalInfo_AA.sPathInfo.asDit0[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK]	|= MCDRV_SRC4_ADC0_OFF;
+	}
+
+	if((psPathInfo->asDit0[0].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK] & (MCDRV_SRC3_DIR0_ON|MCDRV_SRC3_DIR0_OFF)) == MCDRV_SRC3_DIR0_ON)
+	{
+		gsGlobalInfo_AA.sPathInfo.asDit0[0].abSrcOnOff[MCDRV_SRC_PDM_BLOCK]	&= (UINT8)~MCDRV_SRC4_PDM_ON;
+		gsGlobalInfo_AA.sPathInfo.asDit0[0].abSrcOnOff[MCDRV_SRC_PDM_BLOCK]	|= MCDRV_SRC4_PDM_OFF;
+		gsGlobalInfo_AA.sPathInfo.asDit0[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK]	&= (UINT8)~MCDRV_SRC4_ADC0_ON;
+		gsGlobalInfo_AA.sPathInfo.asDit0[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK]	|= MCDRV_SRC4_ADC0_OFF;
+		gsGlobalInfo_AA.sPathInfo.asDit0[0].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR0_OFF;
+		gsGlobalInfo_AA.sPathInfo.asDit0[0].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK]	|= MCDRV_SRC3_DIR0_ON;
+		gsGlobalInfo_AA.sPathInfo.asDit0[0].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR1_ON;
+		gsGlobalInfo_AA.sPathInfo.asDit0[0].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK]	|= MCDRV_SRC3_DIR1_OFF;
+		gsGlobalInfo_AA.sPathInfo.asDit0[0].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR2_ON;
+		gsGlobalInfo_AA.sPathInfo.asDit0[0].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK]	|= MCDRV_SRC3_DIR2_OFF;
+		gsGlobalInfo_AA.sPathInfo.asDit0[0].abSrcOnOff[MCDRV_SRC_AE_BLOCK]		&= (UINT8)~MCDRV_SRC6_AE_ON;
+		gsGlobalInfo_AA.sPathInfo.asDit0[0].abSrcOnOff[MCDRV_SRC_AE_BLOCK]		|= MCDRV_SRC6_AE_OFF;
+		gsGlobalInfo_AA.sPathInfo.asDit0[0].abSrcOnOff[MCDRV_SRC_MIX_BLOCK]	&= (UINT8)~MCDRV_SRC6_MIX_ON;
+		gsGlobalInfo_AA.sPathInfo.asDit0[0].abSrcOnOff[MCDRV_SRC_MIX_BLOCK]	|= MCDRV_SRC6_MIX_OFF;
+	}
+	else if((psPathInfo->asDit0[0].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK] & (MCDRV_SRC3_DIR0_ON|MCDRV_SRC3_DIR0_OFF)) == MCDRV_SRC3_DIR0_OFF)
+	{
+		gsGlobalInfo_AA.sPathInfo.asDit0[0].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR0_ON;
+		gsGlobalInfo_AA.sPathInfo.asDit0[0].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK]	|= MCDRV_SRC3_DIR0_OFF;
+	}
+	if((psPathInfo->asDit0[0].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK] & (MCDRV_SRC3_DIR1_ON|MCDRV_SRC3_DIR1_OFF)) == MCDRV_SRC3_DIR1_ON)
+	{
+		gsGlobalInfo_AA.sPathInfo.asDit0[0].abSrcOnOff[MCDRV_SRC_PDM_BLOCK]	&= (UINT8)~MCDRV_SRC4_PDM_ON;
+		gsGlobalInfo_AA.sPathInfo.asDit0[0].abSrcOnOff[MCDRV_SRC_PDM_BLOCK]	|= MCDRV_SRC4_PDM_OFF;
+		gsGlobalInfo_AA.sPathInfo.asDit0[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK]	&= (UINT8)~MCDRV_SRC4_ADC0_ON;
+		gsGlobalInfo_AA.sPathInfo.asDit0[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK]	|= MCDRV_SRC4_ADC0_OFF;
+		gsGlobalInfo_AA.sPathInfo.asDit0[0].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR0_ON;
+		gsGlobalInfo_AA.sPathInfo.asDit0[0].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK]	|= MCDRV_SRC3_DIR0_OFF;
+		gsGlobalInfo_AA.sPathInfo.asDit0[0].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR1_OFF;
+		gsGlobalInfo_AA.sPathInfo.asDit0[0].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK]	|= MCDRV_SRC3_DIR1_ON;
+		gsGlobalInfo_AA.sPathInfo.asDit0[0].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR2_ON;
+		gsGlobalInfo_AA.sPathInfo.asDit0[0].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK]	|= MCDRV_SRC3_DIR2_OFF;
+		gsGlobalInfo_AA.sPathInfo.asDit0[0].abSrcOnOff[MCDRV_SRC_AE_BLOCK]		&= (UINT8)~MCDRV_SRC6_AE_ON;
+		gsGlobalInfo_AA.sPathInfo.asDit0[0].abSrcOnOff[MCDRV_SRC_AE_BLOCK]		|= MCDRV_SRC6_AE_OFF;
+		gsGlobalInfo_AA.sPathInfo.asDit0[0].abSrcOnOff[MCDRV_SRC_MIX_BLOCK]	&= (UINT8)~MCDRV_SRC6_MIX_ON;
+		gsGlobalInfo_AA.sPathInfo.asDit0[0].abSrcOnOff[MCDRV_SRC_MIX_BLOCK]	|= MCDRV_SRC6_MIX_OFF;
+	}
+	else if((psPathInfo->asDit0[0].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK] & (MCDRV_SRC3_DIR1_ON|MCDRV_SRC3_DIR1_OFF)) == MCDRV_SRC3_DIR1_OFF)
+	{
+		gsGlobalInfo_AA.sPathInfo.asDit0[0].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR1_ON;
+		gsGlobalInfo_AA.sPathInfo.asDit0[0].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK]	|= MCDRV_SRC3_DIR1_OFF;
+	}
+	if((psPathInfo->asDit0[0].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK] & (MCDRV_SRC3_DIR2_ON|MCDRV_SRC3_DIR2_OFF)) == MCDRV_SRC3_DIR2_ON)
+	{
+		gsGlobalInfo_AA.sPathInfo.asDit0[0].abSrcOnOff[MCDRV_SRC_PDM_BLOCK]	&= (UINT8)~MCDRV_SRC4_PDM_ON;
+		gsGlobalInfo_AA.sPathInfo.asDit0[0].abSrcOnOff[MCDRV_SRC_PDM_BLOCK]	|= MCDRV_SRC4_PDM_OFF;
+		gsGlobalInfo_AA.sPathInfo.asDit0[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK]	&= (UINT8)~MCDRV_SRC4_ADC0_ON;
+		gsGlobalInfo_AA.sPathInfo.asDit0[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK]	|= MCDRV_SRC4_ADC0_OFF;
+		gsGlobalInfo_AA.sPathInfo.asDit0[0].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR0_ON;
+		gsGlobalInfo_AA.sPathInfo.asDit0[0].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK]	|= MCDRV_SRC3_DIR0_OFF;
+		gsGlobalInfo_AA.sPathInfo.asDit0[0].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR1_ON;
+		gsGlobalInfo_AA.sPathInfo.asDit0[0].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK]	|= MCDRV_SRC3_DIR1_OFF;
+		gsGlobalInfo_AA.sPathInfo.asDit0[0].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR2_OFF;
+		gsGlobalInfo_AA.sPathInfo.asDit0[0].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK]	|= MCDRV_SRC3_DIR2_ON;
+		gsGlobalInfo_AA.sPathInfo.asDit0[0].abSrcOnOff[MCDRV_SRC_AE_BLOCK]		&= (UINT8)~MCDRV_SRC6_AE_ON;
+		gsGlobalInfo_AA.sPathInfo.asDit0[0].abSrcOnOff[MCDRV_SRC_AE_BLOCK]		|= MCDRV_SRC6_AE_OFF;
+		gsGlobalInfo_AA.sPathInfo.asDit0[0].abSrcOnOff[MCDRV_SRC_MIX_BLOCK]	&= (UINT8)~MCDRV_SRC6_MIX_ON;
+		gsGlobalInfo_AA.sPathInfo.asDit0[0].abSrcOnOff[MCDRV_SRC_MIX_BLOCK]	|= MCDRV_SRC6_MIX_OFF;
+	}
+	else if((psPathInfo->asDit0[0].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK] & (MCDRV_SRC3_DIR2_ON|MCDRV_SRC3_DIR2_OFF)) == MCDRV_SRC3_DIR2_OFF)
+	{
+		gsGlobalInfo_AA.sPathInfo.asDit0[0].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR2_ON;
+		gsGlobalInfo_AA.sPathInfo.asDit0[0].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK]	|= MCDRV_SRC3_DIR2_OFF;
+	}
+
+	if((psPathInfo->asDit0[0].abSrcOnOff[MCDRV_SRC_AE_BLOCK] & (MCDRV_SRC6_AE_ON|MCDRV_SRC6_AE_OFF)) == MCDRV_SRC6_AE_ON)
+	{
+		gsGlobalInfo_AA.sPathInfo.asDit0[0].abSrcOnOff[MCDRV_SRC_PDM_BLOCK]	&= (UINT8)~MCDRV_SRC4_PDM_ON;
+		gsGlobalInfo_AA.sPathInfo.asDit0[0].abSrcOnOff[MCDRV_SRC_PDM_BLOCK]	|= MCDRV_SRC4_PDM_OFF;
+		gsGlobalInfo_AA.sPathInfo.asDit0[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK]	&= (UINT8)~MCDRV_SRC4_ADC0_ON;
+		gsGlobalInfo_AA.sPathInfo.asDit0[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK]	|= MCDRV_SRC4_ADC0_OFF;
+		gsGlobalInfo_AA.sPathInfo.asDit0[0].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR0_ON;
+		gsGlobalInfo_AA.sPathInfo.asDit0[0].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK]	|= MCDRV_SRC3_DIR0_OFF;
+		gsGlobalInfo_AA.sPathInfo.asDit0[0].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR1_ON;
+		gsGlobalInfo_AA.sPathInfo.asDit0[0].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK]	|= MCDRV_SRC3_DIR1_OFF;
+		gsGlobalInfo_AA.sPathInfo.asDit0[0].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR2_ON;
+		gsGlobalInfo_AA.sPathInfo.asDit0[0].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK]	|= MCDRV_SRC3_DIR2_OFF;
+		gsGlobalInfo_AA.sPathInfo.asDit0[0].abSrcOnOff[MCDRV_SRC_AE_BLOCK]		&= (UINT8)~MCDRV_SRC6_AE_OFF;
+		gsGlobalInfo_AA.sPathInfo.asDit0[0].abSrcOnOff[MCDRV_SRC_AE_BLOCK]		|= MCDRV_SRC6_AE_ON;
+		gsGlobalInfo_AA.sPathInfo.asDit0[0].abSrcOnOff[MCDRV_SRC_MIX_BLOCK]	&= (UINT8)~MCDRV_SRC6_MIX_ON;
+		gsGlobalInfo_AA.sPathInfo.asDit0[0].abSrcOnOff[MCDRV_SRC_MIX_BLOCK]	|= MCDRV_SRC6_MIX_OFF;
+	}
+	else if((psPathInfo->asDit0[0].abSrcOnOff[MCDRV_SRC_AE_BLOCK] & (MCDRV_SRC6_AE_ON|MCDRV_SRC6_AE_OFF)) == MCDRV_SRC6_AE_OFF)
+	{
+		gsGlobalInfo_AA.sPathInfo.asDit0[0].abSrcOnOff[MCDRV_SRC_AE_BLOCK]		&= (UINT8)~MCDRV_SRC6_AE_ON;
+		gsGlobalInfo_AA.sPathInfo.asDit0[0].abSrcOnOff[MCDRV_SRC_AE_BLOCK]		|= MCDRV_SRC6_AE_OFF;
+	}
+
+	if((psPathInfo->asDit0[0].abSrcOnOff[MCDRV_SRC_MIX_BLOCK] & (MCDRV_SRC6_MIX_ON|MCDRV_SRC6_MIX_OFF)) == MCDRV_SRC6_MIX_ON)
+	{
+		gsGlobalInfo_AA.sPathInfo.asDit0[0].abSrcOnOff[MCDRV_SRC_PDM_BLOCK]	&= (UINT8)~MCDRV_SRC4_PDM_ON;
+		gsGlobalInfo_AA.sPathInfo.asDit0[0].abSrcOnOff[MCDRV_SRC_PDM_BLOCK]	|= MCDRV_SRC4_PDM_OFF;
+		gsGlobalInfo_AA.sPathInfo.asDit0[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK]	&= (UINT8)~MCDRV_SRC4_ADC0_ON;
+		gsGlobalInfo_AA.sPathInfo.asDit0[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK]	|= MCDRV_SRC4_ADC0_OFF;
+		gsGlobalInfo_AA.sPathInfo.asDit0[0].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR0_ON;
+		gsGlobalInfo_AA.sPathInfo.asDit0[0].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK]	|= MCDRV_SRC3_DIR0_OFF;
+		gsGlobalInfo_AA.sPathInfo.asDit0[0].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR1_ON;
+		gsGlobalInfo_AA.sPathInfo.asDit0[0].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK]	|= MCDRV_SRC3_DIR1_OFF;
+		gsGlobalInfo_AA.sPathInfo.asDit0[0].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR2_ON;
+		gsGlobalInfo_AA.sPathInfo.asDit0[0].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK]	|= MCDRV_SRC3_DIR2_OFF;
+		gsGlobalInfo_AA.sPathInfo.asDit0[0].abSrcOnOff[MCDRV_SRC_AE_BLOCK]		&= (UINT8)~MCDRV_SRC6_AE_ON;
+		gsGlobalInfo_AA.sPathInfo.asDit0[0].abSrcOnOff[MCDRV_SRC_AE_BLOCK]		|= MCDRV_SRC6_AE_OFF;
+		gsGlobalInfo_AA.sPathInfo.asDit0[0].abSrcOnOff[MCDRV_SRC_MIX_BLOCK]	&= (UINT8)~MCDRV_SRC6_MIX_OFF;
+		gsGlobalInfo_AA.sPathInfo.asDit0[0].abSrcOnOff[MCDRV_SRC_MIX_BLOCK]	|= MCDRV_SRC6_MIX_ON;
+	}
+	else if((psPathInfo->asDit0[0].abSrcOnOff[MCDRV_SRC_MIX_BLOCK] & (MCDRV_SRC6_MIX_ON|MCDRV_SRC6_MIX_OFF)) == MCDRV_SRC6_MIX_OFF)
+	{
+		gsGlobalInfo_AA.sPathInfo.asDit0[0].abSrcOnOff[MCDRV_SRC_MIX_BLOCK]	&= (UINT8)~MCDRV_SRC6_MIX_ON;
+		gsGlobalInfo_AA.sPathInfo.asDit0[0].abSrcOnOff[MCDRV_SRC_MIX_BLOCK]	|= MCDRV_SRC6_MIX_OFF;
+	}
+}
+
+/****************************************************************************
+ *	SetDIT1SourceOnOff
+ *
+ *	Description:
+ *			Set DIT1 source On/Off.
+ *	Arguments:
+ *			psPathInfo	path information
+ *	Return:
+ *			none
+ *
+ ****************************************************************************/
+static void	SetDIT1SourceOnOff
+(
+	const MCDRV_PATH_INFO*	psPathInfo
+)
+{
+	if((psPathInfo->asDit1[0].abSrcOnOff[MCDRV_SRC_PDM_BLOCK] & (MCDRV_SRC4_PDM_ON|MCDRV_SRC4_PDM_OFF)) == MCDRV_SRC4_PDM_ON
+	&& gsGlobalInfo_AA.sInitInfo.bPad0Func == MCDRV_PAD_PDMCK)
+	{
+		gsGlobalInfo_AA.sPathInfo.asDit1[0].abSrcOnOff[MCDRV_SRC_PDM_BLOCK]	&= (UINT8)~MCDRV_SRC4_PDM_OFF;
+		gsGlobalInfo_AA.sPathInfo.asDit1[0].abSrcOnOff[MCDRV_SRC_PDM_BLOCK]	|= MCDRV_SRC4_PDM_ON;
+		gsGlobalInfo_AA.sPathInfo.asDit1[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK]	&= (UINT8)~MCDRV_SRC4_ADC0_ON;
+		gsGlobalInfo_AA.sPathInfo.asDit1[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK]	|= MCDRV_SRC4_ADC0_OFF;
+		gsGlobalInfo_AA.sPathInfo.asDit1[0].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR0_ON;
+		gsGlobalInfo_AA.sPathInfo.asDit1[0].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK]	|= MCDRV_SRC3_DIR0_OFF;
+		gsGlobalInfo_AA.sPathInfo.asDit1[0].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR1_ON;
+		gsGlobalInfo_AA.sPathInfo.asDit1[0].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK]	|= MCDRV_SRC3_DIR1_OFF;
+		gsGlobalInfo_AA.sPathInfo.asDit1[0].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR2_ON;
+		gsGlobalInfo_AA.sPathInfo.asDit1[0].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK]	|= MCDRV_SRC3_DIR2_OFF;
+		gsGlobalInfo_AA.sPathInfo.asDit1[0].abSrcOnOff[MCDRV_SRC_AE_BLOCK]		&= (UINT8)~MCDRV_SRC6_AE_ON;
+		gsGlobalInfo_AA.sPathInfo.asDit1[0].abSrcOnOff[MCDRV_SRC_AE_BLOCK]		|= MCDRV_SRC6_AE_OFF;
+		gsGlobalInfo_AA.sPathInfo.asDit1[0].abSrcOnOff[MCDRV_SRC_MIX_BLOCK]	&= (UINT8)~MCDRV_SRC6_MIX_ON;
+		gsGlobalInfo_AA.sPathInfo.asDit1[0].abSrcOnOff[MCDRV_SRC_MIX_BLOCK]	|= MCDRV_SRC6_MIX_OFF;
+	}
+	else if((psPathInfo->asDit1[0].abSrcOnOff[MCDRV_SRC_PDM_BLOCK] & (MCDRV_SRC4_PDM_ON|MCDRV_SRC4_PDM_OFF)) == MCDRV_SRC4_PDM_OFF)
+	{
+		gsGlobalInfo_AA.sPathInfo.asDit1[0].abSrcOnOff[MCDRV_SRC_PDM_BLOCK]	&= (UINT8)~MCDRV_SRC4_PDM_ON;
+		gsGlobalInfo_AA.sPathInfo.asDit1[0].abSrcOnOff[MCDRV_SRC_PDM_BLOCK]	|= MCDRV_SRC4_PDM_OFF;
+	}
+
+	if((psPathInfo->asDit1[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK] & (MCDRV_SRC4_ADC0_ON|MCDRV_SRC4_ADC0_OFF)) == MCDRV_SRC4_ADC0_ON)
+	{
+		gsGlobalInfo_AA.sPathInfo.asDit1[0].abSrcOnOff[MCDRV_SRC_PDM_BLOCK]	&= (UINT8)~MCDRV_SRC4_PDM_ON;
+		gsGlobalInfo_AA.sPathInfo.asDit1[0].abSrcOnOff[MCDRV_SRC_PDM_BLOCK]	|= MCDRV_SRC4_PDM_OFF;
+		gsGlobalInfo_AA.sPathInfo.asDit1[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK]	&= (UINT8)~MCDRV_SRC4_ADC0_OFF;
+		gsGlobalInfo_AA.sPathInfo.asDit1[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK]	|= MCDRV_SRC4_ADC0_ON;
+		gsGlobalInfo_AA.sPathInfo.asDit1[0].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR0_ON;
+		gsGlobalInfo_AA.sPathInfo.asDit1[0].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK]	|= MCDRV_SRC3_DIR0_OFF;
+		gsGlobalInfo_AA.sPathInfo.asDit1[0].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR1_ON;
+		gsGlobalInfo_AA.sPathInfo.asDit1[0].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK]	|= MCDRV_SRC3_DIR1_OFF;
+		gsGlobalInfo_AA.sPathInfo.asDit1[0].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR2_ON;
+		gsGlobalInfo_AA.sPathInfo.asDit1[0].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK]	|= MCDRV_SRC3_DIR2_OFF;
+		gsGlobalInfo_AA.sPathInfo.asDit1[0].abSrcOnOff[MCDRV_SRC_AE_BLOCK]		&= (UINT8)~MCDRV_SRC6_AE_ON;
+		gsGlobalInfo_AA.sPathInfo.asDit1[0].abSrcOnOff[MCDRV_SRC_AE_BLOCK]		|= MCDRV_SRC6_AE_OFF;
+		gsGlobalInfo_AA.sPathInfo.asDit1[0].abSrcOnOff[MCDRV_SRC_MIX_BLOCK]	&= (UINT8)~MCDRV_SRC6_MIX_ON;
+		gsGlobalInfo_AA.sPathInfo.asDit1[0].abSrcOnOff[MCDRV_SRC_MIX_BLOCK]	|= MCDRV_SRC6_MIX_OFF;
+	}
+	else if((psPathInfo->asDit1[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK] & (MCDRV_SRC4_ADC0_ON|MCDRV_SRC4_ADC0_OFF)) == MCDRV_SRC4_ADC0_OFF)
+	{
+		gsGlobalInfo_AA.sPathInfo.asDit1[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK]	&= (UINT8)~MCDRV_SRC4_ADC0_ON;
+		gsGlobalInfo_AA.sPathInfo.asDit1[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK]	|= MCDRV_SRC4_ADC0_OFF;
+	}
+
+	if((psPathInfo->asDit1[0].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK] & (MCDRV_SRC3_DIR0_ON|MCDRV_SRC3_DIR0_OFF)) == MCDRV_SRC3_DIR0_ON)
+	{
+		gsGlobalInfo_AA.sPathInfo.asDit1[0].abSrcOnOff[MCDRV_SRC_PDM_BLOCK]	&= (UINT8)~MCDRV_SRC4_PDM_ON;
+		gsGlobalInfo_AA.sPathInfo.asDit1[0].abSrcOnOff[MCDRV_SRC_PDM_BLOCK]	|= MCDRV_SRC4_PDM_OFF;
+		gsGlobalInfo_AA.sPathInfo.asDit1[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK]	&= (UINT8)~MCDRV_SRC4_ADC0_ON;
+		gsGlobalInfo_AA.sPathInfo.asDit1[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK]	|= MCDRV_SRC4_ADC0_OFF;
+		gsGlobalInfo_AA.sPathInfo.asDit1[0].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR0_OFF;
+		gsGlobalInfo_AA.sPathInfo.asDit1[0].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK]	|= MCDRV_SRC3_DIR0_ON;
+		gsGlobalInfo_AA.sPathInfo.asDit1[0].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR1_ON;
+		gsGlobalInfo_AA.sPathInfo.asDit1[0].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK]	|= MCDRV_SRC3_DIR1_OFF;
+		gsGlobalInfo_AA.sPathInfo.asDit1[0].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR2_ON;
+		gsGlobalInfo_AA.sPathInfo.asDit1[0].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK]	|= MCDRV_SRC3_DIR2_OFF;
+		gsGlobalInfo_AA.sPathInfo.asDit1[0].abSrcOnOff[MCDRV_SRC_AE_BLOCK]		&= (UINT8)~MCDRV_SRC6_AE_ON;
+		gsGlobalInfo_AA.sPathInfo.asDit1[0].abSrcOnOff[MCDRV_SRC_AE_BLOCK]		|= MCDRV_SRC6_AE_OFF;
+		gsGlobalInfo_AA.sPathInfo.asDit1[0].abSrcOnOff[MCDRV_SRC_MIX_BLOCK]	&= (UINT8)~MCDRV_SRC6_MIX_ON;
+		gsGlobalInfo_AA.sPathInfo.asDit1[0].abSrcOnOff[MCDRV_SRC_MIX_BLOCK]	|= MCDRV_SRC6_MIX_OFF;
+	}
+	else if((psPathInfo->asDit1[0].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK] & (MCDRV_SRC3_DIR0_ON|MCDRV_SRC3_DIR0_OFF)) == MCDRV_SRC3_DIR0_OFF)
+	{
+		gsGlobalInfo_AA.sPathInfo.asDit1[0].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR0_ON;
+		gsGlobalInfo_AA.sPathInfo.asDit1[0].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK]	|= MCDRV_SRC3_DIR0_OFF;
+	}
+	if((psPathInfo->asDit1[0].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK] & (MCDRV_SRC3_DIR1_ON|MCDRV_SRC3_DIR1_OFF)) == MCDRV_SRC3_DIR1_ON)
+	{
+		gsGlobalInfo_AA.sPathInfo.asDit1[0].abSrcOnOff[MCDRV_SRC_PDM_BLOCK]	&= (UINT8)~MCDRV_SRC4_PDM_ON;
+		gsGlobalInfo_AA.sPathInfo.asDit1[0].abSrcOnOff[MCDRV_SRC_PDM_BLOCK]	|= MCDRV_SRC4_PDM_OFF;
+		gsGlobalInfo_AA.sPathInfo.asDit1[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK]	&= (UINT8)~MCDRV_SRC4_ADC0_ON;
+		gsGlobalInfo_AA.sPathInfo.asDit1[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK]	|= MCDRV_SRC4_ADC0_OFF;
+		gsGlobalInfo_AA.sPathInfo.asDit1[0].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR0_ON;
+		gsGlobalInfo_AA.sPathInfo.asDit1[0].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK]	|= MCDRV_SRC3_DIR0_OFF;
+		gsGlobalInfo_AA.sPathInfo.asDit1[0].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR1_OFF;
+		gsGlobalInfo_AA.sPathInfo.asDit1[0].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK]	|= MCDRV_SRC3_DIR1_ON;
+		gsGlobalInfo_AA.sPathInfo.asDit1[0].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR2_ON;
+		gsGlobalInfo_AA.sPathInfo.asDit1[0].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK]	|= MCDRV_SRC3_DIR2_OFF;
+		gsGlobalInfo_AA.sPathInfo.asDit1[0].abSrcOnOff[MCDRV_SRC_AE_BLOCK]		&= (UINT8)~MCDRV_SRC6_AE_ON;
+		gsGlobalInfo_AA.sPathInfo.asDit1[0].abSrcOnOff[MCDRV_SRC_AE_BLOCK]		|= MCDRV_SRC6_AE_OFF;
+		gsGlobalInfo_AA.sPathInfo.asDit1[0].abSrcOnOff[MCDRV_SRC_MIX_BLOCK]	&= (UINT8)~MCDRV_SRC6_MIX_ON;
+		gsGlobalInfo_AA.sPathInfo.asDit1[0].abSrcOnOff[MCDRV_SRC_MIX_BLOCK]	|= MCDRV_SRC6_MIX_OFF;
+	}
+	else if((psPathInfo->asDit1[0].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK] & (MCDRV_SRC3_DIR1_ON|MCDRV_SRC3_DIR1_OFF)) == MCDRV_SRC3_DIR1_OFF)
+	{
+		gsGlobalInfo_AA.sPathInfo.asDit1[0].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR1_ON;
+		gsGlobalInfo_AA.sPathInfo.asDit1[0].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK]	|= MCDRV_SRC3_DIR1_OFF;
+	}
+	if((psPathInfo->asDit1[0].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK] & (MCDRV_SRC3_DIR2_ON|MCDRV_SRC3_DIR2_OFF)) == MCDRV_SRC3_DIR2_ON)
+	{
+		gsGlobalInfo_AA.sPathInfo.asDit1[0].abSrcOnOff[MCDRV_SRC_PDM_BLOCK]	&= (UINT8)~MCDRV_SRC4_PDM_ON;
+		gsGlobalInfo_AA.sPathInfo.asDit1[0].abSrcOnOff[MCDRV_SRC_PDM_BLOCK]	|= MCDRV_SRC4_PDM_OFF;
+		gsGlobalInfo_AA.sPathInfo.asDit1[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK]	&= (UINT8)~MCDRV_SRC4_ADC0_ON;
+		gsGlobalInfo_AA.sPathInfo.asDit1[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK]	|= MCDRV_SRC4_ADC0_OFF;
+		gsGlobalInfo_AA.sPathInfo.asDit1[0].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR0_ON;
+		gsGlobalInfo_AA.sPathInfo.asDit1[0].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK]	|= MCDRV_SRC3_DIR0_OFF;
+		gsGlobalInfo_AA.sPathInfo.asDit1[0].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR1_ON;
+		gsGlobalInfo_AA.sPathInfo.asDit1[0].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK]	|= MCDRV_SRC3_DIR1_OFF;
+		gsGlobalInfo_AA.sPathInfo.asDit1[0].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR2_OFF;
+		gsGlobalInfo_AA.sPathInfo.asDit1[0].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK]	|= MCDRV_SRC3_DIR2_ON;
+		gsGlobalInfo_AA.sPathInfo.asDit1[0].abSrcOnOff[MCDRV_SRC_AE_BLOCK]		&= (UINT8)~MCDRV_SRC6_AE_ON;
+		gsGlobalInfo_AA.sPathInfo.asDit1[0].abSrcOnOff[MCDRV_SRC_AE_BLOCK]		|= MCDRV_SRC6_AE_OFF;
+		gsGlobalInfo_AA.sPathInfo.asDit1[0].abSrcOnOff[MCDRV_SRC_MIX_BLOCK]	&= (UINT8)~MCDRV_SRC6_MIX_ON;
+		gsGlobalInfo_AA.sPathInfo.asDit1[0].abSrcOnOff[MCDRV_SRC_MIX_BLOCK]	|= MCDRV_SRC6_MIX_OFF;
+	}
+	else if((psPathInfo->asDit1[0].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK] & (MCDRV_SRC3_DIR2_ON|MCDRV_SRC3_DIR2_OFF)) == MCDRV_SRC3_DIR2_OFF)
+	{
+		gsGlobalInfo_AA.sPathInfo.asDit1[0].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR2_ON;
+		gsGlobalInfo_AA.sPathInfo.asDit1[0].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK]	|= MCDRV_SRC3_DIR2_OFF;
+	}
+
+	if((psPathInfo->asDit1[0].abSrcOnOff[MCDRV_SRC_AE_BLOCK] & (MCDRV_SRC6_AE_ON|MCDRV_SRC6_AE_OFF)) == MCDRV_SRC6_AE_ON)
+	{
+		gsGlobalInfo_AA.sPathInfo.asDit1[0].abSrcOnOff[MCDRV_SRC_PDM_BLOCK]	&= (UINT8)~MCDRV_SRC4_PDM_ON;
+		gsGlobalInfo_AA.sPathInfo.asDit1[0].abSrcOnOff[MCDRV_SRC_PDM_BLOCK]	|= MCDRV_SRC4_PDM_OFF;
+		gsGlobalInfo_AA.sPathInfo.asDit1[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK]	&= (UINT8)~MCDRV_SRC4_ADC0_ON;
+		gsGlobalInfo_AA.sPathInfo.asDit1[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK]	|= MCDRV_SRC4_ADC0_OFF;
+		gsGlobalInfo_AA.sPathInfo.asDit1[0].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR0_ON;
+		gsGlobalInfo_AA.sPathInfo.asDit1[0].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK]	|= MCDRV_SRC3_DIR0_OFF;
+		gsGlobalInfo_AA.sPathInfo.asDit1[0].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR1_ON;
+		gsGlobalInfo_AA.sPathInfo.asDit1[0].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK]	|= MCDRV_SRC3_DIR1_OFF;
+		gsGlobalInfo_AA.sPathInfo.asDit1[0].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR2_ON;
+		gsGlobalInfo_AA.sPathInfo.asDit1[0].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK]	|= MCDRV_SRC3_DIR2_OFF;
+		gsGlobalInfo_AA.sPathInfo.asDit1[0].abSrcOnOff[MCDRV_SRC_AE_BLOCK]		&= (UINT8)~MCDRV_SRC6_AE_OFF;
+		gsGlobalInfo_AA.sPathInfo.asDit1[0].abSrcOnOff[MCDRV_SRC_AE_BLOCK]		|= MCDRV_SRC6_AE_ON;
+		gsGlobalInfo_AA.sPathInfo.asDit1[0].abSrcOnOff[MCDRV_SRC_MIX_BLOCK]	&= (UINT8)~MCDRV_SRC6_MIX_ON;
+		gsGlobalInfo_AA.sPathInfo.asDit1[0].abSrcOnOff[MCDRV_SRC_MIX_BLOCK]	|= MCDRV_SRC6_MIX_OFF;
+	}
+	else if((psPathInfo->asDit1[0].abSrcOnOff[MCDRV_SRC_AE_BLOCK] & (MCDRV_SRC6_AE_ON|MCDRV_SRC6_AE_OFF)) == MCDRV_SRC6_AE_OFF)
+	{
+		gsGlobalInfo_AA.sPathInfo.asDit1[0].abSrcOnOff[MCDRV_SRC_AE_BLOCK]		&= (UINT8)~MCDRV_SRC6_AE_ON;
+		gsGlobalInfo_AA.sPathInfo.asDit1[0].abSrcOnOff[MCDRV_SRC_AE_BLOCK]		|= MCDRV_SRC6_AE_OFF;
+	}
+
+	if((psPathInfo->asDit1[0].abSrcOnOff[MCDRV_SRC_MIX_BLOCK] & (MCDRV_SRC6_MIX_ON|MCDRV_SRC6_MIX_OFF)) == MCDRV_SRC6_MIX_ON)
+	{
+		gsGlobalInfo_AA.sPathInfo.asDit1[0].abSrcOnOff[MCDRV_SRC_PDM_BLOCK]	&= (UINT8)~MCDRV_SRC4_PDM_ON;
+		gsGlobalInfo_AA.sPathInfo.asDit1[0].abSrcOnOff[MCDRV_SRC_PDM_BLOCK]	|= MCDRV_SRC4_PDM_OFF;
+		gsGlobalInfo_AA.sPathInfo.asDit1[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK]	&= (UINT8)~MCDRV_SRC4_ADC0_ON;
+		gsGlobalInfo_AA.sPathInfo.asDit1[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK]	|= MCDRV_SRC4_ADC0_OFF;
+		gsGlobalInfo_AA.sPathInfo.asDit1[0].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR0_ON;
+		gsGlobalInfo_AA.sPathInfo.asDit1[0].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK]	|= MCDRV_SRC3_DIR0_OFF;
+		gsGlobalInfo_AA.sPathInfo.asDit1[0].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR1_ON;
+		gsGlobalInfo_AA.sPathInfo.asDit1[0].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK]	|= MCDRV_SRC3_DIR1_OFF;
+		gsGlobalInfo_AA.sPathInfo.asDit1[0].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR2_ON;
+		gsGlobalInfo_AA.sPathInfo.asDit1[0].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK]	|= MCDRV_SRC3_DIR2_OFF;
+		gsGlobalInfo_AA.sPathInfo.asDit1[0].abSrcOnOff[MCDRV_SRC_AE_BLOCK]		&= (UINT8)~MCDRV_SRC6_AE_ON;
+		gsGlobalInfo_AA.sPathInfo.asDit1[0].abSrcOnOff[MCDRV_SRC_AE_BLOCK]		|= MCDRV_SRC6_AE_OFF;
+		gsGlobalInfo_AA.sPathInfo.asDit1[0].abSrcOnOff[MCDRV_SRC_MIX_BLOCK]	&= (UINT8)~MCDRV_SRC6_MIX_OFF;
+		gsGlobalInfo_AA.sPathInfo.asDit1[0].abSrcOnOff[MCDRV_SRC_MIX_BLOCK]	|= MCDRV_SRC6_MIX_ON;
+	}
+	else if((psPathInfo->asDit1[0].abSrcOnOff[MCDRV_SRC_MIX_BLOCK] & (MCDRV_SRC6_MIX_ON|MCDRV_SRC6_MIX_OFF)) == MCDRV_SRC6_MIX_OFF)
+	{
+		gsGlobalInfo_AA.sPathInfo.asDit1[0].abSrcOnOff[MCDRV_SRC_MIX_BLOCK]	&= (UINT8)~MCDRV_SRC6_MIX_ON;
+		gsGlobalInfo_AA.sPathInfo.asDit1[0].abSrcOnOff[MCDRV_SRC_MIX_BLOCK]	|= MCDRV_SRC6_MIX_OFF;
+	}
+}
+
+/****************************************************************************
+ *	SetDIT2SourceOnOff
+ *
+ *	Description:
+ *			Set DIT2 source On/Off.
+ *	Arguments:
+ *			psPathInfo	path information
+ *	Return:
+ *			none
+ *
+ ****************************************************************************/
+static void	SetDIT2SourceOnOff
+(
+	const MCDRV_PATH_INFO*	psPathInfo
+)
+{
+	if((psPathInfo->asDit2[0].abSrcOnOff[MCDRV_SRC_PDM_BLOCK] & (MCDRV_SRC4_PDM_ON|MCDRV_SRC4_PDM_OFF)) == MCDRV_SRC4_PDM_ON
+	&& gsGlobalInfo_AA.sInitInfo.bPad0Func == MCDRV_PAD_PDMCK)
+	{
+		gsGlobalInfo_AA.sPathInfo.asDit2[0].abSrcOnOff[MCDRV_SRC_PDM_BLOCK]	&= (UINT8)~MCDRV_SRC4_PDM_OFF;
+		gsGlobalInfo_AA.sPathInfo.asDit2[0].abSrcOnOff[MCDRV_SRC_PDM_BLOCK]	|= MCDRV_SRC4_PDM_ON;
+		gsGlobalInfo_AA.sPathInfo.asDit2[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK]	&= (UINT8)~MCDRV_SRC4_ADC0_ON;
+		gsGlobalInfo_AA.sPathInfo.asDit2[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK]	|= MCDRV_SRC4_ADC0_OFF;
+		gsGlobalInfo_AA.sPathInfo.asDit2[0].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR0_ON;
+		gsGlobalInfo_AA.sPathInfo.asDit2[0].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK]	|= MCDRV_SRC3_DIR0_OFF;
+		gsGlobalInfo_AA.sPathInfo.asDit2[0].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR1_ON;
+		gsGlobalInfo_AA.sPathInfo.asDit2[0].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK]	|= MCDRV_SRC3_DIR1_OFF;
+		gsGlobalInfo_AA.sPathInfo.asDit2[0].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR2_ON;
+		gsGlobalInfo_AA.sPathInfo.asDit2[0].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK]	|= MCDRV_SRC3_DIR2_OFF;
+		gsGlobalInfo_AA.sPathInfo.asDit2[0].abSrcOnOff[MCDRV_SRC_AE_BLOCK]		&= (UINT8)~MCDRV_SRC6_AE_ON;
+		gsGlobalInfo_AA.sPathInfo.asDit2[0].abSrcOnOff[MCDRV_SRC_AE_BLOCK]		|= MCDRV_SRC6_AE_OFF;
+		gsGlobalInfo_AA.sPathInfo.asDit2[0].abSrcOnOff[MCDRV_SRC_MIX_BLOCK]	&= (UINT8)~MCDRV_SRC6_MIX_ON;
+		gsGlobalInfo_AA.sPathInfo.asDit2[0].abSrcOnOff[MCDRV_SRC_MIX_BLOCK]	|= MCDRV_SRC6_MIX_OFF;
+	}
+	else if((psPathInfo->asDit2[0].abSrcOnOff[MCDRV_SRC_PDM_BLOCK] & (MCDRV_SRC4_PDM_ON|MCDRV_SRC4_PDM_OFF)) == MCDRV_SRC4_PDM_OFF)
+	{
+		gsGlobalInfo_AA.sPathInfo.asDit2[0].abSrcOnOff[MCDRV_SRC_PDM_BLOCK]	&= (UINT8)~MCDRV_SRC4_PDM_ON;
+		gsGlobalInfo_AA.sPathInfo.asDit2[0].abSrcOnOff[MCDRV_SRC_PDM_BLOCK]	|= MCDRV_SRC4_PDM_OFF;
+	}
+
+	if((psPathInfo->asDit2[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK] & (MCDRV_SRC4_ADC0_ON|MCDRV_SRC4_ADC0_OFF)) == MCDRV_SRC4_ADC0_ON)
+	{
+		gsGlobalInfo_AA.sPathInfo.asDit2[0].abSrcOnOff[MCDRV_SRC_PDM_BLOCK]	&= (UINT8)~MCDRV_SRC4_PDM_ON;
+		gsGlobalInfo_AA.sPathInfo.asDit2[0].abSrcOnOff[MCDRV_SRC_PDM_BLOCK]	|= MCDRV_SRC4_PDM_OFF;
+		gsGlobalInfo_AA.sPathInfo.asDit2[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK]	&= (UINT8)~MCDRV_SRC4_ADC0_OFF;
+		gsGlobalInfo_AA.sPathInfo.asDit2[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK]	|= MCDRV_SRC4_ADC0_ON;
+		gsGlobalInfo_AA.sPathInfo.asDit2[0].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR0_ON;
+		gsGlobalInfo_AA.sPathInfo.asDit2[0].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK]	|= MCDRV_SRC3_DIR0_OFF;
+		gsGlobalInfo_AA.sPathInfo.asDit2[0].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR1_ON;
+		gsGlobalInfo_AA.sPathInfo.asDit2[0].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK]	|= MCDRV_SRC3_DIR1_OFF;
+		gsGlobalInfo_AA.sPathInfo.asDit2[0].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR2_ON;
+		gsGlobalInfo_AA.sPathInfo.asDit2[0].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK]	|= MCDRV_SRC3_DIR2_OFF;
+		gsGlobalInfo_AA.sPathInfo.asDit2[0].abSrcOnOff[MCDRV_SRC_AE_BLOCK]		&= (UINT8)~MCDRV_SRC6_AE_ON;
+		gsGlobalInfo_AA.sPathInfo.asDit2[0].abSrcOnOff[MCDRV_SRC_AE_BLOCK]		|= MCDRV_SRC6_AE_OFF;
+		gsGlobalInfo_AA.sPathInfo.asDit2[0].abSrcOnOff[MCDRV_SRC_MIX_BLOCK]	&= (UINT8)~MCDRV_SRC6_MIX_ON;
+		gsGlobalInfo_AA.sPathInfo.asDit2[0].abSrcOnOff[MCDRV_SRC_MIX_BLOCK]	|= MCDRV_SRC6_MIX_OFF;
+	}
+	else if((psPathInfo->asDit2[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK] & (MCDRV_SRC4_ADC0_ON|MCDRV_SRC4_ADC0_OFF)) == MCDRV_SRC4_ADC0_OFF)
+	{
+		gsGlobalInfo_AA.sPathInfo.asDit2[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK]	&= (UINT8)~MCDRV_SRC4_ADC0_ON;
+		gsGlobalInfo_AA.sPathInfo.asDit2[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK]	|= MCDRV_SRC4_ADC0_OFF;
+	}
+
+	if((psPathInfo->asDit2[0].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK] & (MCDRV_SRC3_DIR0_ON|MCDRV_SRC3_DIR0_OFF)) == MCDRV_SRC3_DIR0_ON)
+	{
+		gsGlobalInfo_AA.sPathInfo.asDit2[0].abSrcOnOff[MCDRV_SRC_PDM_BLOCK]	&= (UINT8)~MCDRV_SRC4_PDM_ON;
+		gsGlobalInfo_AA.sPathInfo.asDit2[0].abSrcOnOff[MCDRV_SRC_PDM_BLOCK]	|= MCDRV_SRC4_PDM_OFF;
+		gsGlobalInfo_AA.sPathInfo.asDit2[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK]	&= (UINT8)~MCDRV_SRC4_ADC0_ON;
+		gsGlobalInfo_AA.sPathInfo.asDit2[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK]	|= MCDRV_SRC4_ADC0_OFF;
+		gsGlobalInfo_AA.sPathInfo.asDit2[0].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR0_OFF;
+		gsGlobalInfo_AA.sPathInfo.asDit2[0].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK]	|= MCDRV_SRC3_DIR0_ON;
+		gsGlobalInfo_AA.sPathInfo.asDit2[0].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR1_ON;
+		gsGlobalInfo_AA.sPathInfo.asDit2[0].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK]	|= MCDRV_SRC3_DIR1_OFF;
+		gsGlobalInfo_AA.sPathInfo.asDit2[0].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR2_ON;
+		gsGlobalInfo_AA.sPathInfo.asDit2[0].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK]	|= MCDRV_SRC3_DIR2_OFF;
+		gsGlobalInfo_AA.sPathInfo.asDit2[0].abSrcOnOff[MCDRV_SRC_AE_BLOCK]		&= (UINT8)~MCDRV_SRC6_AE_ON;
+		gsGlobalInfo_AA.sPathInfo.asDit2[0].abSrcOnOff[MCDRV_SRC_AE_BLOCK]		|= MCDRV_SRC6_AE_OFF;
+		gsGlobalInfo_AA.sPathInfo.asDit2[0].abSrcOnOff[MCDRV_SRC_MIX_BLOCK]	&= (UINT8)~MCDRV_SRC6_MIX_ON;
+		gsGlobalInfo_AA.sPathInfo.asDit2[0].abSrcOnOff[MCDRV_SRC_MIX_BLOCK]	|= MCDRV_SRC6_MIX_OFF;
+	}
+	else if((psPathInfo->asDit2[0].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK] & (MCDRV_SRC3_DIR0_ON|MCDRV_SRC3_DIR0_OFF)) == MCDRV_SRC3_DIR0_OFF)
+	{
+		gsGlobalInfo_AA.sPathInfo.asDit2[0].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR0_ON;
+		gsGlobalInfo_AA.sPathInfo.asDit2[0].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK]	|= MCDRV_SRC3_DIR0_OFF;
+	}
+	if((psPathInfo->asDit2[0].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK] & (MCDRV_SRC3_DIR1_ON|MCDRV_SRC3_DIR1_OFF)) == MCDRV_SRC3_DIR1_ON)
+	{
+		gsGlobalInfo_AA.sPathInfo.asDit2[0].abSrcOnOff[MCDRV_SRC_PDM_BLOCK]	&= (UINT8)~MCDRV_SRC4_PDM_ON;
+		gsGlobalInfo_AA.sPathInfo.asDit2[0].abSrcOnOff[MCDRV_SRC_PDM_BLOCK]	|= MCDRV_SRC4_PDM_OFF;
+		gsGlobalInfo_AA.sPathInfo.asDit2[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK]	&= (UINT8)~MCDRV_SRC4_ADC0_ON;
+		gsGlobalInfo_AA.sPathInfo.asDit2[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK]	|= MCDRV_SRC4_ADC0_OFF;
+		gsGlobalInfo_AA.sPathInfo.asDit2[0].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR0_ON;
+		gsGlobalInfo_AA.sPathInfo.asDit2[0].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK]	|= MCDRV_SRC3_DIR0_OFF;
+		gsGlobalInfo_AA.sPathInfo.asDit2[0].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR1_OFF;
+		gsGlobalInfo_AA.sPathInfo.asDit2[0].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK]	|= MCDRV_SRC3_DIR1_ON;
+		gsGlobalInfo_AA.sPathInfo.asDit2[0].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR2_ON;
+		gsGlobalInfo_AA.sPathInfo.asDit2[0].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK]	|= MCDRV_SRC3_DIR2_OFF;
+		gsGlobalInfo_AA.sPathInfo.asDit2[0].abSrcOnOff[MCDRV_SRC_AE_BLOCK]		&= (UINT8)~MCDRV_SRC6_AE_ON;
+		gsGlobalInfo_AA.sPathInfo.asDit2[0].abSrcOnOff[MCDRV_SRC_AE_BLOCK]		|= MCDRV_SRC6_AE_OFF;
+		gsGlobalInfo_AA.sPathInfo.asDit2[0].abSrcOnOff[MCDRV_SRC_MIX_BLOCK]	&= (UINT8)~MCDRV_SRC6_MIX_ON;
+		gsGlobalInfo_AA.sPathInfo.asDit2[0].abSrcOnOff[MCDRV_SRC_MIX_BLOCK]	|= MCDRV_SRC6_MIX_OFF;
+	}
+	else if((psPathInfo->asDit2[0].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK] & (MCDRV_SRC3_DIR1_ON|MCDRV_SRC3_DIR1_OFF)) == MCDRV_SRC3_DIR1_OFF)
+	{
+		gsGlobalInfo_AA.sPathInfo.asDit2[0].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR1_ON;
+		gsGlobalInfo_AA.sPathInfo.asDit2[0].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK]	|= MCDRV_SRC3_DIR1_OFF;
+	}
+	if((psPathInfo->asDit2[0].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK] & (MCDRV_SRC3_DIR2_ON|MCDRV_SRC3_DIR2_OFF)) == MCDRV_SRC3_DIR2_ON)
+	{
+		gsGlobalInfo_AA.sPathInfo.asDit2[0].abSrcOnOff[MCDRV_SRC_PDM_BLOCK]	&= (UINT8)~MCDRV_SRC4_PDM_ON;
+		gsGlobalInfo_AA.sPathInfo.asDit2[0].abSrcOnOff[MCDRV_SRC_PDM_BLOCK]	|= MCDRV_SRC4_PDM_OFF;
+		gsGlobalInfo_AA.sPathInfo.asDit2[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK]	&= (UINT8)~MCDRV_SRC4_ADC0_ON;
+		gsGlobalInfo_AA.sPathInfo.asDit2[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK]	|= MCDRV_SRC4_ADC0_OFF;
+		gsGlobalInfo_AA.sPathInfo.asDit2[0].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR0_ON;
+		gsGlobalInfo_AA.sPathInfo.asDit2[0].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK]	|= MCDRV_SRC3_DIR0_OFF;
+		gsGlobalInfo_AA.sPathInfo.asDit2[0].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR1_ON;
+		gsGlobalInfo_AA.sPathInfo.asDit2[0].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK]	|= MCDRV_SRC3_DIR1_OFF;
+		gsGlobalInfo_AA.sPathInfo.asDit2[0].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR2_OFF;
+		gsGlobalInfo_AA.sPathInfo.asDit2[0].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK]	|= MCDRV_SRC3_DIR2_ON;
+		gsGlobalInfo_AA.sPathInfo.asDit2[0].abSrcOnOff[MCDRV_SRC_AE_BLOCK]		&= (UINT8)~MCDRV_SRC6_AE_ON;
+		gsGlobalInfo_AA.sPathInfo.asDit2[0].abSrcOnOff[MCDRV_SRC_AE_BLOCK]		|= MCDRV_SRC6_AE_OFF;
+		gsGlobalInfo_AA.sPathInfo.asDit2[0].abSrcOnOff[MCDRV_SRC_MIX_BLOCK]	&= (UINT8)~MCDRV_SRC6_MIX_ON;
+		gsGlobalInfo_AA.sPathInfo.asDit2[0].abSrcOnOff[MCDRV_SRC_MIX_BLOCK]	|= MCDRV_SRC6_MIX_OFF;
+	}
+	else if((psPathInfo->asDit2[0].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK] & (MCDRV_SRC3_DIR2_ON|MCDRV_SRC3_DIR2_OFF)) == MCDRV_SRC3_DIR2_OFF)
+	{
+		gsGlobalInfo_AA.sPathInfo.asDit2[0].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR2_ON;
+		gsGlobalInfo_AA.sPathInfo.asDit2[0].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK]	|= MCDRV_SRC3_DIR2_OFF;
+	}
+
+	if((psPathInfo->asDit2[0].abSrcOnOff[MCDRV_SRC_AE_BLOCK] & (MCDRV_SRC6_AE_ON|MCDRV_SRC6_AE_OFF)) == MCDRV_SRC6_AE_ON)
+	{
+		gsGlobalInfo_AA.sPathInfo.asDit2[0].abSrcOnOff[MCDRV_SRC_PDM_BLOCK]	&= (UINT8)~MCDRV_SRC4_PDM_ON;
+		gsGlobalInfo_AA.sPathInfo.asDit2[0].abSrcOnOff[MCDRV_SRC_PDM_BLOCK]	|= MCDRV_SRC4_PDM_OFF;
+		gsGlobalInfo_AA.sPathInfo.asDit2[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK]	&= (UINT8)~MCDRV_SRC4_ADC0_ON;
+		gsGlobalInfo_AA.sPathInfo.asDit2[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK]	|= MCDRV_SRC4_ADC0_OFF;
+		gsGlobalInfo_AA.sPathInfo.asDit2[0].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR0_ON;
+		gsGlobalInfo_AA.sPathInfo.asDit2[0].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK]	|= MCDRV_SRC3_DIR0_OFF;
+		gsGlobalInfo_AA.sPathInfo.asDit2[0].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR1_ON;
+		gsGlobalInfo_AA.sPathInfo.asDit2[0].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK]	|= MCDRV_SRC3_DIR1_OFF;
+		gsGlobalInfo_AA.sPathInfo.asDit2[0].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR2_ON;
+		gsGlobalInfo_AA.sPathInfo.asDit2[0].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK]	|= MCDRV_SRC3_DIR2_OFF;
+		gsGlobalInfo_AA.sPathInfo.asDit2[0].abSrcOnOff[MCDRV_SRC_AE_BLOCK]		&= (UINT8)~MCDRV_SRC6_AE_OFF;
+		gsGlobalInfo_AA.sPathInfo.asDit2[0].abSrcOnOff[MCDRV_SRC_AE_BLOCK]		|= MCDRV_SRC6_AE_ON;
+		gsGlobalInfo_AA.sPathInfo.asDit2[0].abSrcOnOff[MCDRV_SRC_MIX_BLOCK]	&= (UINT8)~MCDRV_SRC6_MIX_ON;
+		gsGlobalInfo_AA.sPathInfo.asDit2[0].abSrcOnOff[MCDRV_SRC_MIX_BLOCK]	|= MCDRV_SRC6_MIX_OFF;
+	}
+	else if((psPathInfo->asDit2[0].abSrcOnOff[MCDRV_SRC_AE_BLOCK] & (MCDRV_SRC6_AE_ON|MCDRV_SRC6_AE_OFF)) == MCDRV_SRC6_AE_OFF)
+	{
+		gsGlobalInfo_AA.sPathInfo.asDit2[0].abSrcOnOff[MCDRV_SRC_AE_BLOCK]		&= (UINT8)~MCDRV_SRC6_AE_ON;
+		gsGlobalInfo_AA.sPathInfo.asDit2[0].abSrcOnOff[MCDRV_SRC_AE_BLOCK]		|= MCDRV_SRC6_AE_OFF;
+	}
+
+	if((psPathInfo->asDit2[0].abSrcOnOff[MCDRV_SRC_MIX_BLOCK] & (MCDRV_SRC6_MIX_ON|MCDRV_SRC6_MIX_OFF)) == MCDRV_SRC6_MIX_ON)
+	{
+		gsGlobalInfo_AA.sPathInfo.asDit2[0].abSrcOnOff[MCDRV_SRC_PDM_BLOCK]	&= (UINT8)~MCDRV_SRC4_PDM_ON;
+		gsGlobalInfo_AA.sPathInfo.asDit2[0].abSrcOnOff[MCDRV_SRC_PDM_BLOCK]	|= MCDRV_SRC4_PDM_OFF;
+		gsGlobalInfo_AA.sPathInfo.asDit2[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK]	&= (UINT8)~MCDRV_SRC4_ADC0_ON;
+		gsGlobalInfo_AA.sPathInfo.asDit2[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK]	|= MCDRV_SRC4_ADC0_OFF;
+		gsGlobalInfo_AA.sPathInfo.asDit2[0].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR0_ON;
+		gsGlobalInfo_AA.sPathInfo.asDit2[0].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK]	|= MCDRV_SRC3_DIR0_OFF;
+		gsGlobalInfo_AA.sPathInfo.asDit2[0].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR1_ON;
+		gsGlobalInfo_AA.sPathInfo.asDit2[0].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK]	|= MCDRV_SRC3_DIR1_OFF;
+		gsGlobalInfo_AA.sPathInfo.asDit2[0].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR2_ON;
+		gsGlobalInfo_AA.sPathInfo.asDit2[0].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK]	|= MCDRV_SRC3_DIR2_OFF;
+		gsGlobalInfo_AA.sPathInfo.asDit2[0].abSrcOnOff[MCDRV_SRC_AE_BLOCK]		&= (UINT8)~MCDRV_SRC6_AE_ON;
+		gsGlobalInfo_AA.sPathInfo.asDit2[0].abSrcOnOff[MCDRV_SRC_AE_BLOCK]		|= MCDRV_SRC6_AE_OFF;
+		gsGlobalInfo_AA.sPathInfo.asDit2[0].abSrcOnOff[MCDRV_SRC_MIX_BLOCK]	&= (UINT8)~MCDRV_SRC6_MIX_OFF;
+		gsGlobalInfo_AA.sPathInfo.asDit2[0].abSrcOnOff[MCDRV_SRC_MIX_BLOCK]	|= MCDRV_SRC6_MIX_ON;
+	}
+	else if((psPathInfo->asDit2[0].abSrcOnOff[MCDRV_SRC_MIX_BLOCK] & (MCDRV_SRC6_MIX_ON|MCDRV_SRC6_MIX_OFF)) == MCDRV_SRC6_MIX_OFF)
+	{
+		gsGlobalInfo_AA.sPathInfo.asDit2[0].abSrcOnOff[MCDRV_SRC_MIX_BLOCK]	&= (UINT8)~MCDRV_SRC6_MIX_ON;
+		gsGlobalInfo_AA.sPathInfo.asDit2[0].abSrcOnOff[MCDRV_SRC_MIX_BLOCK]	|= MCDRV_SRC6_MIX_OFF;
+	}
+}
+
+/****************************************************************************
+ *	SetDACSourceOnOff
+ *
+ *	Description:
+ *			Set DAC source On/Off.
+ *	Arguments:
+ *			psPathInfo	path information
+ *	Return:
+ *			none
+ *
+ ****************************************************************************/
+static void	SetDACSourceOnOff
+(
+	const MCDRV_PATH_INFO*	psPathInfo
+)
+{
+	UINT8	bCh;
+	for(bCh = 0; bCh < DAC_PATH_CHANNELS; bCh++)
+	{
+		if((psPathInfo->asDac[bCh].abSrcOnOff[MCDRV_SRC_PDM_BLOCK] & (MCDRV_SRC4_PDM_ON|MCDRV_SRC4_PDM_OFF)) == MCDRV_SRC4_PDM_ON
+		&& gsGlobalInfo_AA.sInitInfo.bPad0Func == MCDRV_PAD_PDMCK)
+		{
+			gsGlobalInfo_AA.sPathInfo.asDac[bCh].abSrcOnOff[MCDRV_SRC_PDM_BLOCK]	&= (UINT8)~MCDRV_SRC4_PDM_OFF;
+			gsGlobalInfo_AA.sPathInfo.asDac[bCh].abSrcOnOff[MCDRV_SRC_PDM_BLOCK]	|= MCDRV_SRC4_PDM_ON;
+			gsGlobalInfo_AA.sPathInfo.asDac[bCh].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK]	&= (UINT8)~MCDRV_SRC4_ADC0_ON;
+			gsGlobalInfo_AA.sPathInfo.asDac[bCh].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK]	|= MCDRV_SRC4_ADC0_OFF;
+			gsGlobalInfo_AA.sPathInfo.asDac[bCh].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR0_ON;
+			gsGlobalInfo_AA.sPathInfo.asDac[bCh].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK]	|= MCDRV_SRC3_DIR0_OFF;
+			gsGlobalInfo_AA.sPathInfo.asDac[bCh].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR1_ON;
+			gsGlobalInfo_AA.sPathInfo.asDac[bCh].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK]	|= MCDRV_SRC3_DIR1_OFF;
+			gsGlobalInfo_AA.sPathInfo.asDac[bCh].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR2_ON;
+			gsGlobalInfo_AA.sPathInfo.asDac[bCh].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK]	|= MCDRV_SRC3_DIR2_OFF;
+			gsGlobalInfo_AA.sPathInfo.asDac[bCh].abSrcOnOff[MCDRV_SRC_AE_BLOCK]	&= (UINT8)~MCDRV_SRC6_AE_ON;
+			gsGlobalInfo_AA.sPathInfo.asDac[bCh].abSrcOnOff[MCDRV_SRC_AE_BLOCK]	|= MCDRV_SRC6_AE_OFF;
+			gsGlobalInfo_AA.sPathInfo.asDac[bCh].abSrcOnOff[MCDRV_SRC_MIX_BLOCK]	&= (UINT8)~MCDRV_SRC6_MIX_ON;
+			gsGlobalInfo_AA.sPathInfo.asDac[bCh].abSrcOnOff[MCDRV_SRC_MIX_BLOCK]	|= MCDRV_SRC6_MIX_OFF;
+		}
+		else if((psPathInfo->asDac[bCh].abSrcOnOff[MCDRV_SRC_PDM_BLOCK] & (MCDRV_SRC4_PDM_ON|MCDRV_SRC4_PDM_OFF)) == MCDRV_SRC4_PDM_OFF)
+		{
+			gsGlobalInfo_AA.sPathInfo.asDac[bCh].abSrcOnOff[MCDRV_SRC_PDM_BLOCK]	&= (UINT8)~MCDRV_SRC4_PDM_ON;
+			gsGlobalInfo_AA.sPathInfo.asDac[bCh].abSrcOnOff[MCDRV_SRC_PDM_BLOCK]	|= MCDRV_SRC4_PDM_OFF;
+		}
+
+		if((psPathInfo->asDac[bCh].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK] & (MCDRV_SRC4_ADC0_ON|MCDRV_SRC4_ADC0_OFF)) == MCDRV_SRC4_ADC0_ON)
+		{
+			gsGlobalInfo_AA.sPathInfo.asDac[bCh].abSrcOnOff[MCDRV_SRC_PDM_BLOCK]	&= (UINT8)~MCDRV_SRC4_PDM_ON;
+			gsGlobalInfo_AA.sPathInfo.asDac[bCh].abSrcOnOff[MCDRV_SRC_PDM_BLOCK]	|= MCDRV_SRC4_PDM_OFF;
+			gsGlobalInfo_AA.sPathInfo.asDac[bCh].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK]	&= (UINT8)~MCDRV_SRC4_ADC0_OFF;
+			gsGlobalInfo_AA.sPathInfo.asDac[bCh].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK]	|= MCDRV_SRC4_ADC0_ON;
+			gsGlobalInfo_AA.sPathInfo.asDac[bCh].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR0_ON;
+			gsGlobalInfo_AA.sPathInfo.asDac[bCh].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK]	|= MCDRV_SRC3_DIR0_OFF;
+			gsGlobalInfo_AA.sPathInfo.asDac[bCh].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR1_ON;
+			gsGlobalInfo_AA.sPathInfo.asDac[bCh].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK]	|= MCDRV_SRC3_DIR1_OFF;
+			gsGlobalInfo_AA.sPathInfo.asDac[bCh].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR2_ON;
+			gsGlobalInfo_AA.sPathInfo.asDac[bCh].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK]	|= MCDRV_SRC3_DIR2_OFF;
+			gsGlobalInfo_AA.sPathInfo.asDac[bCh].abSrcOnOff[MCDRV_SRC_AE_BLOCK]	&= (UINT8)~MCDRV_SRC6_AE_ON;
+			gsGlobalInfo_AA.sPathInfo.asDac[bCh].abSrcOnOff[MCDRV_SRC_AE_BLOCK]	|= MCDRV_SRC6_AE_OFF;
+			gsGlobalInfo_AA.sPathInfo.asDac[bCh].abSrcOnOff[MCDRV_SRC_MIX_BLOCK]	&= (UINT8)~MCDRV_SRC6_MIX_ON;
+			gsGlobalInfo_AA.sPathInfo.asDac[bCh].abSrcOnOff[MCDRV_SRC_MIX_BLOCK]	|= MCDRV_SRC6_MIX_OFF;
+		}
+		else if((psPathInfo->asDac[bCh].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK] & (MCDRV_SRC4_ADC0_ON|MCDRV_SRC4_ADC0_OFF)) == MCDRV_SRC4_ADC0_OFF)
+		{
+			gsGlobalInfo_AA.sPathInfo.asDac[bCh].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK]	&= (UINT8)~MCDRV_SRC4_ADC0_ON;
+			gsGlobalInfo_AA.sPathInfo.asDac[bCh].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK]	|= MCDRV_SRC4_ADC0_OFF;
+		}
+
+		if((psPathInfo->asDac[bCh].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK] & (MCDRV_SRC3_DIR0_ON|MCDRV_SRC3_DIR0_OFF)) == MCDRV_SRC3_DIR0_ON)
+		{
+			gsGlobalInfo_AA.sPathInfo.asDac[bCh].abSrcOnOff[MCDRV_SRC_PDM_BLOCK]	&= (UINT8)~MCDRV_SRC4_PDM_ON;
+			gsGlobalInfo_AA.sPathInfo.asDac[bCh].abSrcOnOff[MCDRV_SRC_PDM_BLOCK]	|= MCDRV_SRC4_PDM_OFF;
+			gsGlobalInfo_AA.sPathInfo.asDac[bCh].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK]	&= (UINT8)~MCDRV_SRC4_ADC0_ON;
+			gsGlobalInfo_AA.sPathInfo.asDac[bCh].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK]	|= MCDRV_SRC4_ADC0_OFF;
+			gsGlobalInfo_AA.sPathInfo.asDac[bCh].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR0_OFF;
+			gsGlobalInfo_AA.sPathInfo.asDac[bCh].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK]	|= MCDRV_SRC3_DIR0_ON;
+			gsGlobalInfo_AA.sPathInfo.asDac[bCh].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR1_ON;
+			gsGlobalInfo_AA.sPathInfo.asDac[bCh].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK]	|= MCDRV_SRC3_DIR1_OFF;
+			gsGlobalInfo_AA.sPathInfo.asDac[bCh].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR2_ON;
+			gsGlobalInfo_AA.sPathInfo.asDac[bCh].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK]	|= MCDRV_SRC3_DIR2_OFF;
+			gsGlobalInfo_AA.sPathInfo.asDac[bCh].abSrcOnOff[MCDRV_SRC_AE_BLOCK]	&= (UINT8)~MCDRV_SRC6_AE_ON;
+			gsGlobalInfo_AA.sPathInfo.asDac[bCh].abSrcOnOff[MCDRV_SRC_AE_BLOCK]	|= MCDRV_SRC6_AE_OFF;
+			gsGlobalInfo_AA.sPathInfo.asDac[bCh].abSrcOnOff[MCDRV_SRC_MIX_BLOCK]	&= (UINT8)~MCDRV_SRC6_MIX_ON;
+			gsGlobalInfo_AA.sPathInfo.asDac[bCh].abSrcOnOff[MCDRV_SRC_MIX_BLOCK]	|= MCDRV_SRC6_MIX_OFF;
+		}
+		else if((psPathInfo->asDac[bCh].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK] & (MCDRV_SRC3_DIR0_ON|MCDRV_SRC3_DIR0_OFF)) == MCDRV_SRC3_DIR0_OFF)
+		{
+			gsGlobalInfo_AA.sPathInfo.asDac[bCh].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR0_ON;
+			gsGlobalInfo_AA.sPathInfo.asDac[bCh].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK]	|= MCDRV_SRC3_DIR0_OFF;
+		}
+		if((psPathInfo->asDac[bCh].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK] & (MCDRV_SRC3_DIR1_ON|MCDRV_SRC3_DIR1_OFF)) == MCDRV_SRC3_DIR1_ON)
+		{
+			gsGlobalInfo_AA.sPathInfo.asDac[bCh].abSrcOnOff[MCDRV_SRC_PDM_BLOCK]	&= (UINT8)~MCDRV_SRC4_PDM_ON;
+			gsGlobalInfo_AA.sPathInfo.asDac[bCh].abSrcOnOff[MCDRV_SRC_PDM_BLOCK]	|= MCDRV_SRC4_PDM_OFF;
+			gsGlobalInfo_AA.sPathInfo.asDac[bCh].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK]	&= (UINT8)~MCDRV_SRC4_ADC0_ON;
+			gsGlobalInfo_AA.sPathInfo.asDac[bCh].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK]	|= MCDRV_SRC4_ADC0_OFF;
+			gsGlobalInfo_AA.sPathInfo.asDac[bCh].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR0_ON;
+			gsGlobalInfo_AA.sPathInfo.asDac[bCh].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK]	|= MCDRV_SRC3_DIR0_OFF;
+			gsGlobalInfo_AA.sPathInfo.asDac[bCh].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR1_OFF;
+			gsGlobalInfo_AA.sPathInfo.asDac[bCh].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK]	|= MCDRV_SRC3_DIR1_ON;
+			gsGlobalInfo_AA.sPathInfo.asDac[bCh].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR2_ON;
+			gsGlobalInfo_AA.sPathInfo.asDac[bCh].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK]	|= MCDRV_SRC3_DIR2_OFF;
+			gsGlobalInfo_AA.sPathInfo.asDac[bCh].abSrcOnOff[MCDRV_SRC_AE_BLOCK]	&= (UINT8)~MCDRV_SRC6_AE_ON;
+			gsGlobalInfo_AA.sPathInfo.asDac[bCh].abSrcOnOff[MCDRV_SRC_AE_BLOCK]	|= MCDRV_SRC6_AE_OFF;
+			gsGlobalInfo_AA.sPathInfo.asDac[bCh].abSrcOnOff[MCDRV_SRC_MIX_BLOCK]	&= (UINT8)~MCDRV_SRC6_MIX_ON;
+			gsGlobalInfo_AA.sPathInfo.asDac[bCh].abSrcOnOff[MCDRV_SRC_MIX_BLOCK]	|= MCDRV_SRC6_MIX_OFF;
+		}
+		else if((psPathInfo->asDac[bCh].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK] & (MCDRV_SRC3_DIR1_ON|MCDRV_SRC3_DIR1_OFF)) == MCDRV_SRC3_DIR1_OFF)
+		{
+			gsGlobalInfo_AA.sPathInfo.asDac[bCh].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR1_ON;
+			gsGlobalInfo_AA.sPathInfo.asDac[bCh].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK]	|= MCDRV_SRC3_DIR1_OFF;
+		}
+		if((psPathInfo->asDac[bCh].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK] & (MCDRV_SRC3_DIR2_ON|MCDRV_SRC3_DIR2_OFF)) == MCDRV_SRC3_DIR2_ON)
+		{
+			gsGlobalInfo_AA.sPathInfo.asDac[bCh].abSrcOnOff[MCDRV_SRC_PDM_BLOCK]	&= (UINT8)~MCDRV_SRC4_PDM_ON;
+			gsGlobalInfo_AA.sPathInfo.asDac[bCh].abSrcOnOff[MCDRV_SRC_PDM_BLOCK]	|= MCDRV_SRC4_PDM_OFF;
+			gsGlobalInfo_AA.sPathInfo.asDac[bCh].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK]	&= (UINT8)~MCDRV_SRC4_ADC0_ON;
+			gsGlobalInfo_AA.sPathInfo.asDac[bCh].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK]	|= MCDRV_SRC4_ADC0_OFF;
+			gsGlobalInfo_AA.sPathInfo.asDac[bCh].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR0_ON;
+			gsGlobalInfo_AA.sPathInfo.asDac[bCh].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK]	|= MCDRV_SRC3_DIR0_OFF;
+			gsGlobalInfo_AA.sPathInfo.asDac[bCh].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR1_ON;
+			gsGlobalInfo_AA.sPathInfo.asDac[bCh].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK]	|= MCDRV_SRC3_DIR1_OFF;
+			gsGlobalInfo_AA.sPathInfo.asDac[bCh].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR2_OFF;
+			gsGlobalInfo_AA.sPathInfo.asDac[bCh].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK]	|= MCDRV_SRC3_DIR2_ON;
+			gsGlobalInfo_AA.sPathInfo.asDac[bCh].abSrcOnOff[MCDRV_SRC_AE_BLOCK]	&= (UINT8)~MCDRV_SRC6_AE_ON;
+			gsGlobalInfo_AA.sPathInfo.asDac[bCh].abSrcOnOff[MCDRV_SRC_AE_BLOCK]	|= MCDRV_SRC6_AE_OFF;
+			gsGlobalInfo_AA.sPathInfo.asDac[bCh].abSrcOnOff[MCDRV_SRC_MIX_BLOCK]	&= (UINT8)~MCDRV_SRC6_MIX_ON;
+			gsGlobalInfo_AA.sPathInfo.asDac[bCh].abSrcOnOff[MCDRV_SRC_MIX_BLOCK]	|= MCDRV_SRC6_MIX_OFF;
+		}
+		else if((psPathInfo->asDac[bCh].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK] & (MCDRV_SRC3_DIR2_ON|MCDRV_SRC3_DIR2_OFF)) == MCDRV_SRC3_DIR2_OFF)
+		{
+			gsGlobalInfo_AA.sPathInfo.asDac[bCh].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR2_ON;
+			gsGlobalInfo_AA.sPathInfo.asDac[bCh].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK]	|= MCDRV_SRC3_DIR2_OFF;
+		}
+
+		if((psPathInfo->asDac[bCh].abSrcOnOff[MCDRV_SRC_AE_BLOCK] & (MCDRV_SRC6_AE_ON|MCDRV_SRC6_AE_OFF)) == MCDRV_SRC6_AE_ON)
+		{
+			gsGlobalInfo_AA.sPathInfo.asDac[bCh].abSrcOnOff[MCDRV_SRC_PDM_BLOCK]	&= (UINT8)~MCDRV_SRC4_PDM_ON;
+			gsGlobalInfo_AA.sPathInfo.asDac[bCh].abSrcOnOff[MCDRV_SRC_PDM_BLOCK]	|= MCDRV_SRC4_PDM_OFF;
+			gsGlobalInfo_AA.sPathInfo.asDac[bCh].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK]	&= (UINT8)~MCDRV_SRC4_ADC0_ON;
+			gsGlobalInfo_AA.sPathInfo.asDac[bCh].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK]	|= MCDRV_SRC4_ADC0_OFF;
+			gsGlobalInfo_AA.sPathInfo.asDac[bCh].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR0_ON;
+			gsGlobalInfo_AA.sPathInfo.asDac[bCh].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK]	|= MCDRV_SRC3_DIR0_OFF;
+			gsGlobalInfo_AA.sPathInfo.asDac[bCh].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR1_ON;
+			gsGlobalInfo_AA.sPathInfo.asDac[bCh].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK]	|= MCDRV_SRC3_DIR1_OFF;
+			gsGlobalInfo_AA.sPathInfo.asDac[bCh].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR2_ON;
+			gsGlobalInfo_AA.sPathInfo.asDac[bCh].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK]	|= MCDRV_SRC3_DIR2_OFF;
+			gsGlobalInfo_AA.sPathInfo.asDac[bCh].abSrcOnOff[MCDRV_SRC_AE_BLOCK]	&= (UINT8)~MCDRV_SRC6_AE_OFF;
+			gsGlobalInfo_AA.sPathInfo.asDac[bCh].abSrcOnOff[MCDRV_SRC_AE_BLOCK]	|= MCDRV_SRC6_AE_ON;
+			gsGlobalInfo_AA.sPathInfo.asDac[bCh].abSrcOnOff[MCDRV_SRC_MIX_BLOCK]	&= (UINT8)~MCDRV_SRC6_MIX_ON;
+			gsGlobalInfo_AA.sPathInfo.asDac[bCh].abSrcOnOff[MCDRV_SRC_MIX_BLOCK]	|= MCDRV_SRC6_MIX_OFF;
+		}
+		else if((psPathInfo->asDac[bCh].abSrcOnOff[MCDRV_SRC_AE_BLOCK] & (MCDRV_SRC6_AE_ON|MCDRV_SRC6_AE_OFF)) == MCDRV_SRC6_AE_OFF)
+		{
+			gsGlobalInfo_AA.sPathInfo.asDac[bCh].abSrcOnOff[MCDRV_SRC_AE_BLOCK]	&= (UINT8)~MCDRV_SRC6_AE_ON;
+			gsGlobalInfo_AA.sPathInfo.asDac[bCh].abSrcOnOff[MCDRV_SRC_AE_BLOCK]	|= MCDRV_SRC6_AE_OFF;
+		}
+
+		if((psPathInfo->asDac[bCh].abSrcOnOff[MCDRV_SRC_MIX_BLOCK] & (MCDRV_SRC6_MIX_ON|MCDRV_SRC6_MIX_OFF)) == MCDRV_SRC6_MIX_ON)
+		{
+			gsGlobalInfo_AA.sPathInfo.asDac[bCh].abSrcOnOff[MCDRV_SRC_PDM_BLOCK]	&= (UINT8)~MCDRV_SRC4_PDM_ON;
+			gsGlobalInfo_AA.sPathInfo.asDac[bCh].abSrcOnOff[MCDRV_SRC_PDM_BLOCK]	|= MCDRV_SRC4_PDM_OFF;
+			gsGlobalInfo_AA.sPathInfo.asDac[bCh].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK]	&= (UINT8)~MCDRV_SRC4_ADC0_ON;
+			gsGlobalInfo_AA.sPathInfo.asDac[bCh].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK]	|= MCDRV_SRC4_ADC0_OFF;
+			gsGlobalInfo_AA.sPathInfo.asDac[bCh].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR0_ON;
+			gsGlobalInfo_AA.sPathInfo.asDac[bCh].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK]	|= MCDRV_SRC3_DIR0_OFF;
+			gsGlobalInfo_AA.sPathInfo.asDac[bCh].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR1_ON;
+			gsGlobalInfo_AA.sPathInfo.asDac[bCh].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK]	|= MCDRV_SRC3_DIR1_OFF;
+			gsGlobalInfo_AA.sPathInfo.asDac[bCh].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR2_ON;
+			gsGlobalInfo_AA.sPathInfo.asDac[bCh].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK]	|= MCDRV_SRC3_DIR2_OFF;
+			gsGlobalInfo_AA.sPathInfo.asDac[bCh].abSrcOnOff[MCDRV_SRC_AE_BLOCK]	&= (UINT8)~MCDRV_SRC6_AE_ON;
+			gsGlobalInfo_AA.sPathInfo.asDac[bCh].abSrcOnOff[MCDRV_SRC_AE_BLOCK]	|= MCDRV_SRC6_AE_OFF;
+			gsGlobalInfo_AA.sPathInfo.asDac[bCh].abSrcOnOff[MCDRV_SRC_MIX_BLOCK]	&= (UINT8)~MCDRV_SRC6_MIX_OFF;
+			gsGlobalInfo_AA.sPathInfo.asDac[bCh].abSrcOnOff[MCDRV_SRC_MIX_BLOCK]	|= MCDRV_SRC6_MIX_ON;
+		}
+		else if((psPathInfo->asDac[bCh].abSrcOnOff[MCDRV_SRC_MIX_BLOCK] & (MCDRV_SRC6_MIX_ON|MCDRV_SRC6_MIX_OFF)) == MCDRV_SRC6_MIX_OFF)
+		{
+			gsGlobalInfo_AA.sPathInfo.asDac[bCh].abSrcOnOff[MCDRV_SRC_MIX_BLOCK]	&= (UINT8)~MCDRV_SRC6_MIX_ON;
+			gsGlobalInfo_AA.sPathInfo.asDac[bCh].abSrcOnOff[MCDRV_SRC_MIX_BLOCK]	|= MCDRV_SRC6_MIX_OFF;
+		}
+	}
+}
+
+/****************************************************************************
+ *	SetAESourceOnOff
+ *
+ *	Description:
+ *			Set AE source On/Off.
+ *	Arguments:
+ *			psPathInfo	path information
+ *	Return:
+ *			none
+ *
+ ****************************************************************************/
+static void	SetAESourceOnOff
+(
+	const MCDRV_PATH_INFO*	psPathInfo
+)
+{
+	if((psPathInfo->asAe[0].abSrcOnOff[MCDRV_SRC_PDM_BLOCK] & (MCDRV_SRC4_PDM_ON|MCDRV_SRC4_PDM_OFF)) == MCDRV_SRC4_PDM_ON
+	&& gsGlobalInfo_AA.sInitInfo.bPad0Func == MCDRV_PAD_PDMCK)
+	{
+		gsGlobalInfo_AA.sPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_PDM_BLOCK]	&= (UINT8)~MCDRV_SRC4_PDM_OFF;
+		gsGlobalInfo_AA.sPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_PDM_BLOCK]	|= MCDRV_SRC4_PDM_ON;
+		gsGlobalInfo_AA.sPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK]	&= (UINT8)~MCDRV_SRC4_ADC0_ON;
+		gsGlobalInfo_AA.sPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK]	|= MCDRV_SRC4_ADC0_OFF;
+		gsGlobalInfo_AA.sPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR0_ON;
+		gsGlobalInfo_AA.sPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK]	|= MCDRV_SRC3_DIR0_OFF;
+		gsGlobalInfo_AA.sPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR1_ON;
+		gsGlobalInfo_AA.sPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK]	|= MCDRV_SRC3_DIR1_OFF;
+		gsGlobalInfo_AA.sPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR2_ON;
+		gsGlobalInfo_AA.sPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK]	|= MCDRV_SRC3_DIR2_OFF;
+		gsGlobalInfo_AA.sPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_MIX_BLOCK]	&= (UINT8)~MCDRV_SRC6_MIX_ON;
+		gsGlobalInfo_AA.sPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_MIX_BLOCK]	|= MCDRV_SRC6_MIX_OFF;
+	}
+	else if((psPathInfo->asAe[0].abSrcOnOff[MCDRV_SRC_PDM_BLOCK] & (MCDRV_SRC4_PDM_ON|MCDRV_SRC4_PDM_OFF)) == MCDRV_SRC4_PDM_OFF)
+	{
+		gsGlobalInfo_AA.sPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_PDM_BLOCK]	&= (UINT8)~MCDRV_SRC4_PDM_ON;
+		gsGlobalInfo_AA.sPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_PDM_BLOCK]	|= MCDRV_SRC4_PDM_OFF;
+	}
+
+	if((psPathInfo->asAe[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK] & (MCDRV_SRC4_ADC0_ON|MCDRV_SRC4_ADC0_OFF)) == MCDRV_SRC4_ADC0_ON)
+	{
+		gsGlobalInfo_AA.sPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_PDM_BLOCK]	&= (UINT8)~MCDRV_SRC4_PDM_ON;
+		gsGlobalInfo_AA.sPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_PDM_BLOCK]	|= MCDRV_SRC4_PDM_OFF;
+		gsGlobalInfo_AA.sPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK]	&= (UINT8)~MCDRV_SRC4_ADC0_OFF;
+		gsGlobalInfo_AA.sPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK]	|= MCDRV_SRC4_ADC0_ON;
+		gsGlobalInfo_AA.sPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR0_ON;
+		gsGlobalInfo_AA.sPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK]	|= MCDRV_SRC3_DIR0_OFF;
+		gsGlobalInfo_AA.sPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR1_ON;
+		gsGlobalInfo_AA.sPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK]	|= MCDRV_SRC3_DIR1_OFF;
+		gsGlobalInfo_AA.sPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR2_ON;
+		gsGlobalInfo_AA.sPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK]	|= MCDRV_SRC3_DIR2_OFF;
+		gsGlobalInfo_AA.sPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_MIX_BLOCK]	&= (UINT8)~MCDRV_SRC6_MIX_ON;
+		gsGlobalInfo_AA.sPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_MIX_BLOCK]	|= MCDRV_SRC6_MIX_OFF;
+	}
+	else if((psPathInfo->asAe[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK] & (MCDRV_SRC4_ADC0_ON|MCDRV_SRC4_ADC0_OFF)) == MCDRV_SRC4_ADC0_OFF)
+	{
+		gsGlobalInfo_AA.sPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK]	&= (UINT8)~MCDRV_SRC4_ADC0_ON;
+		gsGlobalInfo_AA.sPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK]	|= MCDRV_SRC4_ADC0_OFF;
+	}
+
+	if((psPathInfo->asAe[0].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK] & (MCDRV_SRC3_DIR0_ON|MCDRV_SRC3_DIR0_OFF)) == MCDRV_SRC3_DIR0_ON)
+	{
+		gsGlobalInfo_AA.sPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_PDM_BLOCK]	&= (UINT8)~MCDRV_SRC4_PDM_ON;
+		gsGlobalInfo_AA.sPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_PDM_BLOCK]	|= MCDRV_SRC4_PDM_OFF;
+		gsGlobalInfo_AA.sPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK]	&= (UINT8)~MCDRV_SRC4_ADC0_ON;
+		gsGlobalInfo_AA.sPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK]	|= MCDRV_SRC4_ADC0_OFF;
+		gsGlobalInfo_AA.sPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR0_OFF;
+		gsGlobalInfo_AA.sPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK]	|= MCDRV_SRC3_DIR0_ON;
+		gsGlobalInfo_AA.sPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR1_ON;
+		gsGlobalInfo_AA.sPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK]	|= MCDRV_SRC3_DIR1_OFF;
+		gsGlobalInfo_AA.sPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR2_ON;
+		gsGlobalInfo_AA.sPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK]	|= MCDRV_SRC3_DIR2_OFF;
+		gsGlobalInfo_AA.sPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_MIX_BLOCK]	&= (UINT8)~MCDRV_SRC6_MIX_ON;
+		gsGlobalInfo_AA.sPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_MIX_BLOCK]	|= MCDRV_SRC6_MIX_OFF;
+	}
+	else if((psPathInfo->asAe[0].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK] & (MCDRV_SRC3_DIR0_ON|MCDRV_SRC3_DIR0_OFF)) == MCDRV_SRC3_DIR0_OFF)
+	{
+		gsGlobalInfo_AA.sPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR0_ON;
+		gsGlobalInfo_AA.sPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK]	|= MCDRV_SRC3_DIR0_OFF;
+	}
+	if((psPathInfo->asAe[0].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK] & (MCDRV_SRC3_DIR1_ON|MCDRV_SRC3_DIR1_OFF)) == MCDRV_SRC3_DIR1_ON)
+	{
+		gsGlobalInfo_AA.sPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_PDM_BLOCK]	&= (UINT8)~MCDRV_SRC4_PDM_ON;
+		gsGlobalInfo_AA.sPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_PDM_BLOCK]	|= MCDRV_SRC4_PDM_OFF;
+		gsGlobalInfo_AA.sPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK]	&= (UINT8)~MCDRV_SRC4_ADC0_ON;
+		gsGlobalInfo_AA.sPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK]	|= MCDRV_SRC4_ADC0_OFF;
+		gsGlobalInfo_AA.sPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR0_ON;
+		gsGlobalInfo_AA.sPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK]	|= MCDRV_SRC3_DIR0_OFF;
+		gsGlobalInfo_AA.sPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR1_OFF;
+		gsGlobalInfo_AA.sPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK]	|= MCDRV_SRC3_DIR1_ON;
+		gsGlobalInfo_AA.sPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR2_ON;
+		gsGlobalInfo_AA.sPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK]	|= MCDRV_SRC3_DIR2_OFF;
+		gsGlobalInfo_AA.sPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_MIX_BLOCK]	&= (UINT8)~MCDRV_SRC6_MIX_ON;
+		gsGlobalInfo_AA.sPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_MIX_BLOCK]	|= MCDRV_SRC6_MIX_OFF;
+	}
+	else if((psPathInfo->asAe[0].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK] & (MCDRV_SRC3_DIR1_ON|MCDRV_SRC3_DIR1_OFF)) == MCDRV_SRC3_DIR1_OFF)
+	{
+		gsGlobalInfo_AA.sPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR1_ON;
+		gsGlobalInfo_AA.sPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK]	|= MCDRV_SRC3_DIR1_OFF;
+	}
+	if((psPathInfo->asAe[0].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK] & (MCDRV_SRC3_DIR2_ON|MCDRV_SRC3_DIR2_OFF)) == MCDRV_SRC3_DIR2_ON)
+	{
+		gsGlobalInfo_AA.sPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_PDM_BLOCK]	&= (UINT8)~MCDRV_SRC4_PDM_ON;
+		gsGlobalInfo_AA.sPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_PDM_BLOCK]	|= MCDRV_SRC4_PDM_OFF;
+		gsGlobalInfo_AA.sPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK]	&= (UINT8)~MCDRV_SRC4_ADC0_ON;
+		gsGlobalInfo_AA.sPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK]	|= MCDRV_SRC4_ADC0_OFF;
+		gsGlobalInfo_AA.sPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR0_ON;
+		gsGlobalInfo_AA.sPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK]	|= MCDRV_SRC3_DIR0_OFF;
+		gsGlobalInfo_AA.sPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR1_ON;
+		gsGlobalInfo_AA.sPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK]	|= MCDRV_SRC3_DIR1_OFF;
+		gsGlobalInfo_AA.sPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR2_OFF;
+		gsGlobalInfo_AA.sPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK]	|= MCDRV_SRC3_DIR2_ON;
+		gsGlobalInfo_AA.sPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_MIX_BLOCK]	&= (UINT8)~MCDRV_SRC6_MIX_ON;
+		gsGlobalInfo_AA.sPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_MIX_BLOCK]	|= MCDRV_SRC6_MIX_OFF;
+	}
+	else if((psPathInfo->asAe[0].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK] & (MCDRV_SRC3_DIR2_ON|MCDRV_SRC3_DIR2_OFF)) == MCDRV_SRC3_DIR2_OFF)
+	{
+		gsGlobalInfo_AA.sPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR2_ON;
+		gsGlobalInfo_AA.sPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK]	|= MCDRV_SRC3_DIR2_OFF;
+	}
+
+	if((psPathInfo->asAe[0].abSrcOnOff[MCDRV_SRC_MIX_BLOCK] & (MCDRV_SRC6_MIX_ON|MCDRV_SRC6_MIX_OFF)) == MCDRV_SRC6_MIX_ON)
+	{
+		gsGlobalInfo_AA.sPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_PDM_BLOCK]	&= (UINT8)~MCDRV_SRC4_PDM_ON;
+		gsGlobalInfo_AA.sPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_PDM_BLOCK]	|= MCDRV_SRC4_PDM_OFF;
+		gsGlobalInfo_AA.sPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK]	&= (UINT8)~MCDRV_SRC4_ADC0_ON;
+		gsGlobalInfo_AA.sPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK]	|= MCDRV_SRC4_ADC0_OFF;
+		gsGlobalInfo_AA.sPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR0_ON;
+		gsGlobalInfo_AA.sPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK]	|= MCDRV_SRC3_DIR0_OFF;
+		gsGlobalInfo_AA.sPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR1_ON;
+		gsGlobalInfo_AA.sPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK]	|= MCDRV_SRC3_DIR1_OFF;
+		gsGlobalInfo_AA.sPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR2_ON;
+		gsGlobalInfo_AA.sPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK]	|= MCDRV_SRC3_DIR2_OFF;
+		gsGlobalInfo_AA.sPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_MIX_BLOCK]	&= (UINT8)~MCDRV_SRC6_MIX_OFF;
+		gsGlobalInfo_AA.sPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_MIX_BLOCK]	|= MCDRV_SRC6_MIX_ON;
+	}
+	else if((psPathInfo->asAe[0].abSrcOnOff[MCDRV_SRC_MIX_BLOCK] & (MCDRV_SRC6_MIX_ON|MCDRV_SRC6_MIX_OFF)) == MCDRV_SRC6_MIX_OFF)
+	{
+		gsGlobalInfo_AA.sPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_MIX_BLOCK]	&= (UINT8)~MCDRV_SRC6_MIX_ON;
+		gsGlobalInfo_AA.sPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_MIX_BLOCK]	|= MCDRV_SRC6_MIX_OFF;
+	}
+}
+
+/****************************************************************************
+ *	SetCDSPSourceOnOff
+ *
+ *	Description:
+ *			Set CDSP source On/Off.
+ *	Arguments:
+ *			psPathInfo	path information
+ *	Return:
+ *			none
+ *
+ ****************************************************************************/
+static void	SetCDSPSourceOnOff
+(
+	const MCDRV_PATH_INFO*	psPathInfo
+)
+{
+	(void)psPathInfo;
+}
+
+/****************************************************************************
+ *	SetADC0SourceOnOff
+ *
+ *	Description:
+ *			Set ADC0 source On/Off.
+ *	Arguments:
+ *			psPathInfo	path information
+ *	Return:
+ *			none
+ *
+ ****************************************************************************/
+static void	SetADC0SourceOnOff
+(
+	const MCDRV_PATH_INFO*	psPathInfo
+)
+{
+	if((psPathInfo->asAdc0[0].abSrcOnOff[MCDRV_SRC_MIC1_BLOCK] & (MCDRV_SRC0_MIC1_ON|MCDRV_SRC0_MIC1_OFF)) == MCDRV_SRC0_MIC1_ON)
+	{
+		gsGlobalInfo_AA.sPathInfo.asAdc0[0].abSrcOnOff[MCDRV_SRC_MIC1_BLOCK]	&= (UINT8)~MCDRV_SRC0_MIC1_OFF;
+		gsGlobalInfo_AA.sPathInfo.asAdc0[0].abSrcOnOff[MCDRV_SRC_MIC1_BLOCK]	|= MCDRV_SRC0_MIC1_ON;
+	}
+	else if((psPathInfo->asAdc0[0].abSrcOnOff[MCDRV_SRC_MIC1_BLOCK] & (MCDRV_SRC0_MIC1_ON|MCDRV_SRC0_MIC1_OFF)) == MCDRV_SRC0_MIC1_OFF)
+	{
+		gsGlobalInfo_AA.sPathInfo.asAdc0[0].abSrcOnOff[MCDRV_SRC_MIC1_BLOCK]	&= (UINT8)~MCDRV_SRC0_MIC1_ON;
+		gsGlobalInfo_AA.sPathInfo.asAdc0[0].abSrcOnOff[MCDRV_SRC_MIC1_BLOCK]	|= MCDRV_SRC0_MIC1_OFF;
+	}
+	if((psPathInfo->asAdc0[0].abSrcOnOff[MCDRV_SRC_MIC2_BLOCK] & (MCDRV_SRC0_MIC2_ON|MCDRV_SRC0_MIC2_OFF)) == MCDRV_SRC0_MIC2_ON)
+	{
+		gsGlobalInfo_AA.sPathInfo.asAdc0[0].abSrcOnOff[MCDRV_SRC_MIC2_BLOCK]	&= (UINT8)~MCDRV_SRC0_MIC2_OFF;
+		gsGlobalInfo_AA.sPathInfo.asAdc0[0].abSrcOnOff[MCDRV_SRC_MIC2_BLOCK]	|= MCDRV_SRC0_MIC2_ON;
+	}
+	else if((psPathInfo->asAdc0[0].abSrcOnOff[MCDRV_SRC_MIC2_BLOCK] & (MCDRV_SRC0_MIC2_ON|MCDRV_SRC0_MIC2_OFF)) == MCDRV_SRC0_MIC2_OFF)
+	{
+		gsGlobalInfo_AA.sPathInfo.asAdc0[0].abSrcOnOff[MCDRV_SRC_MIC2_BLOCK]	&= (UINT8)~MCDRV_SRC0_MIC2_ON;
+		gsGlobalInfo_AA.sPathInfo.asAdc0[0].abSrcOnOff[MCDRV_SRC_MIC2_BLOCK]	|= MCDRV_SRC0_MIC2_OFF;
+	}
+	if((psPathInfo->asAdc0[0].abSrcOnOff[MCDRV_SRC_MIC3_BLOCK] & (MCDRV_SRC0_MIC3_ON|MCDRV_SRC0_MIC3_OFF)) == MCDRV_SRC0_MIC3_ON)
+	{
+		gsGlobalInfo_AA.sPathInfo.asAdc0[0].abSrcOnOff[MCDRV_SRC_MIC3_BLOCK]	&= (UINT8)~MCDRV_SRC0_MIC3_OFF;
+		gsGlobalInfo_AA.sPathInfo.asAdc0[0].abSrcOnOff[MCDRV_SRC_MIC3_BLOCK]	|= MCDRV_SRC0_MIC3_ON;
+	}
+	else if((psPathInfo->asAdc0[0].abSrcOnOff[MCDRV_SRC_MIC3_BLOCK] & (MCDRV_SRC0_MIC3_ON|MCDRV_SRC0_MIC3_OFF)) == MCDRV_SRC0_MIC3_OFF)
+	{
+		gsGlobalInfo_AA.sPathInfo.asAdc0[0].abSrcOnOff[MCDRV_SRC_MIC3_BLOCK]	&= (UINT8)~MCDRV_SRC0_MIC3_ON;
+		gsGlobalInfo_AA.sPathInfo.asAdc0[0].abSrcOnOff[MCDRV_SRC_MIC3_BLOCK]	|= MCDRV_SRC0_MIC3_OFF;
+	}
+
+	if((psPathInfo->asAdc0[0].abSrcOnOff[MCDRV_SRC_LINE1_L_BLOCK] & (MCDRV_SRC1_LINE1_L_ON|MCDRV_SRC1_LINE1_L_OFF)) == MCDRV_SRC1_LINE1_L_ON)
+	{
+		gsGlobalInfo_AA.sPathInfo.asAdc0[0].abSrcOnOff[MCDRV_SRC_LINE1_L_BLOCK]	&= (UINT8)~MCDRV_SRC1_LINE1_L_OFF;
+		gsGlobalInfo_AA.sPathInfo.asAdc0[0].abSrcOnOff[MCDRV_SRC_LINE1_L_BLOCK]	|= MCDRV_SRC1_LINE1_L_ON;
+	}
+	else if((psPathInfo->asAdc0[0].abSrcOnOff[MCDRV_SRC_LINE1_L_BLOCK] & (MCDRV_SRC1_LINE1_L_ON|MCDRV_SRC1_LINE1_L_OFF)) == MCDRV_SRC1_LINE1_L_OFF)
+	{
+		gsGlobalInfo_AA.sPathInfo.asAdc0[0].abSrcOnOff[MCDRV_SRC_LINE1_L_BLOCK]	&= (UINT8)~MCDRV_SRC1_LINE1_L_ON;
+		gsGlobalInfo_AA.sPathInfo.asAdc0[0].abSrcOnOff[MCDRV_SRC_LINE1_L_BLOCK]	|= MCDRV_SRC1_LINE1_L_OFF;
+	}
+	if((psPathInfo->asAdc0[0].abSrcOnOff[MCDRV_SRC_LINE1_M_BLOCK] & (MCDRV_SRC1_LINE1_M_ON|MCDRV_SRC1_LINE1_M_OFF)) == MCDRV_SRC1_LINE1_M_ON)
+	{
+		gsGlobalInfo_AA.sPathInfo.asAdc0[0].abSrcOnOff[MCDRV_SRC_LINE1_M_BLOCK]	&= (UINT8)~MCDRV_SRC1_LINE1_M_OFF;
+		gsGlobalInfo_AA.sPathInfo.asAdc0[0].abSrcOnOff[MCDRV_SRC_LINE1_M_BLOCK]	|= MCDRV_SRC1_LINE1_M_ON;
+	}
+	else if((psPathInfo->asAdc0[0].abSrcOnOff[MCDRV_SRC_LINE1_M_BLOCK] & (MCDRV_SRC1_LINE1_M_ON|MCDRV_SRC1_LINE1_M_OFF)) == MCDRV_SRC1_LINE1_M_OFF)
+	{
+		gsGlobalInfo_AA.sPathInfo.asAdc0[0].abSrcOnOff[MCDRV_SRC_LINE1_M_BLOCK]	&= (UINT8)~MCDRV_SRC1_LINE1_M_ON;
+		gsGlobalInfo_AA.sPathInfo.asAdc0[0].abSrcOnOff[MCDRV_SRC_LINE1_M_BLOCK]	|= MCDRV_SRC1_LINE1_M_OFF;
+	}
+
+	if((psPathInfo->asAdc0[1].abSrcOnOff[MCDRV_SRC_MIC1_BLOCK] & (MCDRV_SRC0_MIC1_ON|MCDRV_SRC0_MIC1_OFF)) == MCDRV_SRC0_MIC1_ON)
+	{
+		gsGlobalInfo_AA.sPathInfo.asAdc0[1].abSrcOnOff[MCDRV_SRC_MIC1_BLOCK]	&= (UINT8)~MCDRV_SRC0_MIC1_OFF;
+		gsGlobalInfo_AA.sPathInfo.asAdc0[1].abSrcOnOff[MCDRV_SRC_MIC1_BLOCK]	|= MCDRV_SRC0_MIC1_ON;
+	}
+	else if((psPathInfo->asAdc0[1].abSrcOnOff[MCDRV_SRC_MIC1_BLOCK] & (MCDRV_SRC0_MIC1_ON|MCDRV_SRC0_MIC1_OFF)) == MCDRV_SRC0_MIC1_OFF)
+	{
+		gsGlobalInfo_AA.sPathInfo.asAdc0[1].abSrcOnOff[MCDRV_SRC_MIC1_BLOCK]	&= (UINT8)~MCDRV_SRC0_MIC1_ON;
+		gsGlobalInfo_AA.sPathInfo.asAdc0[1].abSrcOnOff[MCDRV_SRC_MIC1_BLOCK]	|= MCDRV_SRC0_MIC1_OFF;
+	}
+	if((psPathInfo->asAdc0[1].abSrcOnOff[MCDRV_SRC_MIC2_BLOCK] & (MCDRV_SRC0_MIC2_ON|MCDRV_SRC0_MIC2_OFF)) == MCDRV_SRC0_MIC2_ON)
+	{
+		gsGlobalInfo_AA.sPathInfo.asAdc0[1].abSrcOnOff[MCDRV_SRC_MIC2_BLOCK]	&= (UINT8)~MCDRV_SRC0_MIC2_OFF;
+		gsGlobalInfo_AA.sPathInfo.asAdc0[1].abSrcOnOff[MCDRV_SRC_MIC2_BLOCK]	|= MCDRV_SRC0_MIC2_ON;
+	}
+	else if((psPathInfo->asAdc0[1].abSrcOnOff[MCDRV_SRC_MIC2_BLOCK] & (MCDRV_SRC0_MIC2_ON|MCDRV_SRC0_MIC2_OFF)) == MCDRV_SRC0_MIC2_OFF)
+	{
+		gsGlobalInfo_AA.sPathInfo.asAdc0[1].abSrcOnOff[MCDRV_SRC_MIC2_BLOCK]	&= (UINT8)~MCDRV_SRC0_MIC2_ON;
+		gsGlobalInfo_AA.sPathInfo.asAdc0[1].abSrcOnOff[MCDRV_SRC_MIC2_BLOCK]	|= MCDRV_SRC0_MIC2_OFF;
+	}
+	if((psPathInfo->asAdc0[1].abSrcOnOff[MCDRV_SRC_MIC3_BLOCK] & (MCDRV_SRC0_MIC3_ON|MCDRV_SRC0_MIC3_OFF)) == MCDRV_SRC0_MIC3_ON)
+	{
+		gsGlobalInfo_AA.sPathInfo.asAdc0[1].abSrcOnOff[MCDRV_SRC_MIC3_BLOCK]	&= (UINT8)~MCDRV_SRC0_MIC3_OFF;
+		gsGlobalInfo_AA.sPathInfo.asAdc0[1].abSrcOnOff[MCDRV_SRC_MIC3_BLOCK]	|= MCDRV_SRC0_MIC3_ON;
+	}
+	else if((psPathInfo->asAdc0[1].abSrcOnOff[MCDRV_SRC_MIC3_BLOCK] & (MCDRV_SRC0_MIC3_ON|MCDRV_SRC0_MIC3_OFF)) == MCDRV_SRC0_MIC3_OFF)
+	{
+		gsGlobalInfo_AA.sPathInfo.asAdc0[1].abSrcOnOff[MCDRV_SRC_MIC3_BLOCK]	&= (UINT8)~MCDRV_SRC0_MIC3_ON;
+		gsGlobalInfo_AA.sPathInfo.asAdc0[1].abSrcOnOff[MCDRV_SRC_MIC3_BLOCK]	|= MCDRV_SRC0_MIC3_OFF;
+	}
+
+	if((psPathInfo->asAdc0[1].abSrcOnOff[MCDRV_SRC_LINE1_R_BLOCK] & (MCDRV_SRC1_LINE1_R_ON|MCDRV_SRC1_LINE1_R_OFF)) == MCDRV_SRC1_LINE1_R_ON)
+	{
+		gsGlobalInfo_AA.sPathInfo.asAdc0[1].abSrcOnOff[MCDRV_SRC_LINE1_R_BLOCK]	&= (UINT8)~MCDRV_SRC1_LINE1_R_OFF;
+		gsGlobalInfo_AA.sPathInfo.asAdc0[1].abSrcOnOff[MCDRV_SRC_LINE1_R_BLOCK]	|= MCDRV_SRC1_LINE1_R_ON;
+	}
+	else if((psPathInfo->asAdc0[1].abSrcOnOff[MCDRV_SRC_LINE1_R_BLOCK] & (MCDRV_SRC1_LINE1_R_ON|MCDRV_SRC1_LINE1_R_OFF)) == MCDRV_SRC1_LINE1_R_OFF)
+	{
+		gsGlobalInfo_AA.sPathInfo.asAdc0[1].abSrcOnOff[MCDRV_SRC_LINE1_R_BLOCK]	&= (UINT8)~MCDRV_SRC1_LINE1_R_ON;
+		gsGlobalInfo_AA.sPathInfo.asAdc0[1].abSrcOnOff[MCDRV_SRC_LINE1_R_BLOCK]	|= MCDRV_SRC1_LINE1_R_OFF;
+	}
+	if((psPathInfo->asAdc0[1].abSrcOnOff[MCDRV_SRC_LINE1_M_BLOCK] & (MCDRV_SRC1_LINE1_M_ON|MCDRV_SRC1_LINE1_M_OFF)) == MCDRV_SRC1_LINE1_M_ON)
+	{
+		gsGlobalInfo_AA.sPathInfo.asAdc0[1].abSrcOnOff[MCDRV_SRC_LINE1_M_BLOCK]	&= (UINT8)~MCDRV_SRC1_LINE1_M_OFF;
+		gsGlobalInfo_AA.sPathInfo.asAdc0[1].abSrcOnOff[MCDRV_SRC_LINE1_M_BLOCK]	|= MCDRV_SRC1_LINE1_M_ON;
+	}
+	else if((psPathInfo->asAdc0[1].abSrcOnOff[MCDRV_SRC_LINE1_M_BLOCK] & (MCDRV_SRC1_LINE1_M_ON|MCDRV_SRC1_LINE1_M_OFF)) == MCDRV_SRC1_LINE1_M_OFF)
+	{
+		gsGlobalInfo_AA.sPathInfo.asAdc0[1].abSrcOnOff[MCDRV_SRC_LINE1_M_BLOCK]	&= (UINT8)~MCDRV_SRC1_LINE1_M_ON;
+		gsGlobalInfo_AA.sPathInfo.asAdc0[1].abSrcOnOff[MCDRV_SRC_LINE1_M_BLOCK]	|= MCDRV_SRC1_LINE1_M_OFF;
+	}
+}
+
+/****************************************************************************
+ *	SetADC1SourceOnOff
+ *
+ *	Description:
+ *			Set ADC1 source On/Off.
+ *	Arguments:
+ *			psPathInfo	path information
+ *	Return:
+ *			none
+ *
+ ****************************************************************************/
+static void	SetADC1SourceOnOff
+(
+	const MCDRV_PATH_INFO*	psPathInfo
+)
+{
+	(void)psPathInfo;
+}
+
+/****************************************************************************
+ *	SetMixSourceOnOff
+ *
+ *	Description:
+ *			Set Mix source On/Off.
+ *	Arguments:
+ *			psPathInfo	path information
+ *	Return:
+ *			none
+ *
+ ****************************************************************************/
+static void	SetMixSourceOnOff
+(
+	const MCDRV_PATH_INFO*	psPathInfo
+)
+{
+	if((psPathInfo->asMix[0].abSrcOnOff[MCDRV_SRC_PDM_BLOCK] & (MCDRV_SRC4_PDM_ON|MCDRV_SRC4_PDM_OFF)) == MCDRV_SRC4_PDM_ON
+	&& gsGlobalInfo_AA.sInitInfo.bPad0Func == MCDRV_PAD_PDMCK)
+	{
+		gsGlobalInfo_AA.sPathInfo.asMix[0].abSrcOnOff[MCDRV_SRC_PDM_BLOCK]	&= (UINT8)~MCDRV_SRC4_PDM_OFF;
+		gsGlobalInfo_AA.sPathInfo.asMix[0].abSrcOnOff[MCDRV_SRC_PDM_BLOCK]	|= MCDRV_SRC4_PDM_ON;
+	}
+	else if((psPathInfo->asMix[0].abSrcOnOff[MCDRV_SRC_PDM_BLOCK] & (MCDRV_SRC4_PDM_ON|MCDRV_SRC4_PDM_OFF)) == MCDRV_SRC4_PDM_OFF)
+	{
+		gsGlobalInfo_AA.sPathInfo.asMix[0].abSrcOnOff[MCDRV_SRC_PDM_BLOCK]	&= (UINT8)~MCDRV_SRC4_PDM_ON;
+		gsGlobalInfo_AA.sPathInfo.asMix[0].abSrcOnOff[MCDRV_SRC_PDM_BLOCK]	|= MCDRV_SRC4_PDM_OFF;
+	}
+
+	if((psPathInfo->asMix[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK] & (MCDRV_SRC4_ADC0_ON|MCDRV_SRC4_ADC0_OFF)) == MCDRV_SRC4_ADC0_ON)
+	{
+		gsGlobalInfo_AA.sPathInfo.asMix[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK]	&= (UINT8)~MCDRV_SRC4_ADC0_OFF;
+		gsGlobalInfo_AA.sPathInfo.asMix[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK]	|= MCDRV_SRC4_ADC0_ON;
+	}
+	else if((psPathInfo->asMix[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK] & (MCDRV_SRC4_ADC0_ON|MCDRV_SRC4_ADC0_OFF)) == MCDRV_SRC4_ADC0_OFF)
+	{
+		gsGlobalInfo_AA.sPathInfo.asMix[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK]	&= (UINT8)~MCDRV_SRC4_ADC0_ON;
+		gsGlobalInfo_AA.sPathInfo.asMix[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK]	|= MCDRV_SRC4_ADC0_OFF;
+	}
+
+	if((psPathInfo->asMix[0].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK] & (MCDRV_SRC3_DIR0_ON|MCDRV_SRC3_DIR0_OFF)) == MCDRV_SRC3_DIR0_ON)
+	{
+		gsGlobalInfo_AA.sPathInfo.asMix[0].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR0_OFF;
+		gsGlobalInfo_AA.sPathInfo.asMix[0].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK]	|= MCDRV_SRC3_DIR0_ON;
+	}
+	else if((psPathInfo->asMix[0].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK] & (MCDRV_SRC3_DIR0_ON|MCDRV_SRC3_DIR0_OFF)) == MCDRV_SRC3_DIR0_OFF)
+	{
+		gsGlobalInfo_AA.sPathInfo.asMix[0].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR0_ON;
+		gsGlobalInfo_AA.sPathInfo.asMix[0].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK]	|= MCDRV_SRC3_DIR0_OFF;
+	}
+	if((psPathInfo->asMix[0].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK] & (MCDRV_SRC3_DIR1_ON|MCDRV_SRC3_DIR1_OFF)) == MCDRV_SRC3_DIR1_ON)
+	{
+		gsGlobalInfo_AA.sPathInfo.asMix[0].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR1_OFF;
+		gsGlobalInfo_AA.sPathInfo.asMix[0].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK]	|= MCDRV_SRC3_DIR1_ON;
+	}
+	else if((psPathInfo->asMix[0].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK] & (MCDRV_SRC3_DIR1_ON|MCDRV_SRC3_DIR1_OFF)) == MCDRV_SRC3_DIR1_OFF)
+	{
+		gsGlobalInfo_AA.sPathInfo.asMix[0].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR1_ON;
+		gsGlobalInfo_AA.sPathInfo.asMix[0].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK]	|= MCDRV_SRC3_DIR1_OFF;
+	}
+	if((psPathInfo->asMix[0].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK] & (MCDRV_SRC3_DIR2_ON|MCDRV_SRC3_DIR2_OFF)) == MCDRV_SRC3_DIR2_ON)
+	{
+		gsGlobalInfo_AA.sPathInfo.asMix[0].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR2_OFF;
+		gsGlobalInfo_AA.sPathInfo.asMix[0].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK]	|= MCDRV_SRC3_DIR2_ON;
+	}
+	else if((psPathInfo->asMix[0].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK] & (MCDRV_SRC3_DIR2_ON|MCDRV_SRC3_DIR2_OFF)) == MCDRV_SRC3_DIR2_OFF)
+	{
+		gsGlobalInfo_AA.sPathInfo.asMix[0].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR2_ON;
+		gsGlobalInfo_AA.sPathInfo.asMix[0].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK]	|= MCDRV_SRC3_DIR2_OFF;
+	}
+
+	if((psPathInfo->asMix[0].abSrcOnOff[MCDRV_SRC_AE_BLOCK] & (MCDRV_SRC6_AE_ON|MCDRV_SRC6_AE_OFF)) == MCDRV_SRC6_AE_ON)
+	{
+		gsGlobalInfo_AA.sPathInfo.asMix[0].abSrcOnOff[MCDRV_SRC_AE_BLOCK]	&= (UINT8)~MCDRV_SRC6_AE_OFF;
+		gsGlobalInfo_AA.sPathInfo.asMix[0].abSrcOnOff[MCDRV_SRC_AE_BLOCK]	|= MCDRV_SRC6_AE_ON;
+	}
+	else if((psPathInfo->asMix[0].abSrcOnOff[MCDRV_SRC_AE_BLOCK] & (MCDRV_SRC6_AE_ON|MCDRV_SRC6_AE_OFF)) == MCDRV_SRC6_AE_OFF)
+	{
+		gsGlobalInfo_AA.sPathInfo.asMix[0].abSrcOnOff[MCDRV_SRC_AE_BLOCK]	&= (UINT8)~MCDRV_SRC6_AE_ON;
+		gsGlobalInfo_AA.sPathInfo.asMix[0].abSrcOnOff[MCDRV_SRC_AE_BLOCK]	|= MCDRV_SRC6_AE_OFF;
+	}
+}
+
+/****************************************************************************
+ *	SetExtBiasOnOff
+ *
+ *	Description:
+ *			Set Bias source On/Off.
+ *	Arguments:
+ *			psPathInfo	path information
+ *	Return:
+ *			none
+ *
+ ****************************************************************************/
+static void	SetBiasSourceOnOff
+(
+	const MCDRV_PATH_INFO*	psPathInfo
+)
+{
+	if((psPathInfo->asBias[0].abSrcOnOff[MCDRV_SRC_MIC1_BLOCK] & (MCDRV_SRC0_MIC1_ON|MCDRV_SRC0_MIC1_OFF)) == MCDRV_SRC0_MIC1_ON)
+	{
+		gsGlobalInfo_AA.sPathInfo.asBias[0].abSrcOnOff[MCDRV_SRC_MIC1_BLOCK]	&= (UINT8)~MCDRV_SRC0_MIC1_OFF;
+		gsGlobalInfo_AA.sPathInfo.asBias[0].abSrcOnOff[MCDRV_SRC_MIC1_BLOCK]	|= MCDRV_SRC0_MIC1_ON;
+	}
+	else if((psPathInfo->asBias[0].abSrcOnOff[MCDRV_SRC_MIC1_BLOCK] & (MCDRV_SRC0_MIC1_ON|MCDRV_SRC0_MIC1_OFF)) == MCDRV_SRC0_MIC1_OFF)
+	{
+		gsGlobalInfo_AA.sPathInfo.asBias[0].abSrcOnOff[MCDRV_SRC_MIC1_BLOCK]	&= (UINT8)~MCDRV_SRC0_MIC1_ON;
+		gsGlobalInfo_AA.sPathInfo.asBias[0].abSrcOnOff[MCDRV_SRC_MIC1_BLOCK]	|= MCDRV_SRC0_MIC1_OFF;
+	}
+	if((psPathInfo->asBias[0].abSrcOnOff[MCDRV_SRC_MIC2_BLOCK] & (MCDRV_SRC0_MIC2_ON|MCDRV_SRC0_MIC2_OFF)) == MCDRV_SRC0_MIC2_ON)
+	{
+		gsGlobalInfo_AA.sPathInfo.asBias[0].abSrcOnOff[MCDRV_SRC_MIC2_BLOCK]	&= (UINT8)~MCDRV_SRC0_MIC2_OFF;
+		gsGlobalInfo_AA.sPathInfo.asBias[0].abSrcOnOff[MCDRV_SRC_MIC2_BLOCK]	|= MCDRV_SRC0_MIC2_ON;
+	}
+	else if((psPathInfo->asBias[0].abSrcOnOff[MCDRV_SRC_MIC2_BLOCK] & (MCDRV_SRC0_MIC2_ON|MCDRV_SRC0_MIC2_OFF)) == MCDRV_SRC0_MIC2_OFF)
+	{
+		gsGlobalInfo_AA.sPathInfo.asBias[0].abSrcOnOff[MCDRV_SRC_MIC2_BLOCK]	&= (UINT8)~MCDRV_SRC0_MIC2_ON;
+		gsGlobalInfo_AA.sPathInfo.asBias[0].abSrcOnOff[MCDRV_SRC_MIC2_BLOCK]	|= MCDRV_SRC0_MIC2_OFF;
+	}
+	if((psPathInfo->asBias[0].abSrcOnOff[MCDRV_SRC_MIC3_BLOCK] & (MCDRV_SRC0_MIC3_ON|MCDRV_SRC0_MIC3_OFF)) == MCDRV_SRC0_MIC3_ON)
+	{
+		gsGlobalInfo_AA.sPathInfo.asBias[0].abSrcOnOff[MCDRV_SRC_MIC3_BLOCK]	&= (UINT8)~MCDRV_SRC0_MIC3_OFF;
+		gsGlobalInfo_AA.sPathInfo.asBias[0].abSrcOnOff[MCDRV_SRC_MIC3_BLOCK]	|= MCDRV_SRC0_MIC3_ON;
+	}
+	else if((psPathInfo->asBias[0].abSrcOnOff[MCDRV_SRC_MIC3_BLOCK] & (MCDRV_SRC0_MIC3_ON|MCDRV_SRC0_MIC3_OFF)) == MCDRV_SRC0_MIC3_OFF)
+	{
+		gsGlobalInfo_AA.sPathInfo.asBias[0].abSrcOnOff[MCDRV_SRC_MIC3_BLOCK]	&= (UINT8)~MCDRV_SRC0_MIC3_ON;
+		gsGlobalInfo_AA.sPathInfo.asBias[0].abSrcOnOff[MCDRV_SRC_MIC3_BLOCK]	|= MCDRV_SRC0_MIC3_OFF;
+	}
+}
+
+/****************************************************************************
+ *	McResCtrl_GetPathInfo_AA
+ *
+ *	Description:
+ *			Get path information.
+ *	Arguments:
+ *			psPathInfo	path information
+ *	Return:
+ *			none
+ *
+ ****************************************************************************/
+void	McResCtrl_GetPathInfo_AA
+(
+	MCDRV_PATH_INFO*	psPathInfo
+)
+{
+	*psPathInfo	= gsGlobalInfo_AA.sPathInfo;
+}
+
+/****************************************************************************
+ *	McResCtrl_GetPathInfoVirtual_AA
+ *
+ *	Description:
+ *			Get virtaul path information.
+ *	Arguments:
+ *			psPathInfo	virtaul path information
+ *	Return:
+ *			none
+ *
+ ****************************************************************************/
+void	McResCtrl_GetPathInfoVirtual_AA
+(
+	MCDRV_PATH_INFO*	psPathInfo
+)
+{
+	*psPathInfo	= gsGlobalInfo_AA.sPathInfoVirtual;
+}
+
+/****************************************************************************
+ *	McResCtrl_SetDioInfo_AA
+ *
+ *	Description:
+ *			Set digital io information.
+ *	Arguments:
+ *			psDioInfo	digital io information
+ *			dUpdateInfo	update information
+ *	Return:
+ *			none
+ *
+ ****************************************************************************/
+void	McResCtrl_SetDioInfo_AA
+(
+	const MCDRV_DIO_INFO*	psDioInfo,
+	UINT32	dUpdateInfo
+)
+{
+
+	if((dUpdateInfo & MCDRV_DIO0_COM_UPDATE_FLAG) != 0)
+	{
+		SetDIOCommon(psDioInfo, 0);
+	}
+	if((dUpdateInfo & MCDRV_DIO1_COM_UPDATE_FLAG) != 0)
+	{
+		SetDIOCommon(psDioInfo, 1);
+	}
+	if((dUpdateInfo & MCDRV_DIO2_COM_UPDATE_FLAG) != 0)
+	{
+		SetDIOCommon(psDioInfo, 2);
+	}
+
+	if((dUpdateInfo & MCDRV_DIO0_DIR_UPDATE_FLAG) != 0)
+	{
+		SetDIODIR(psDioInfo, 0);
+	}
+	if((dUpdateInfo & MCDRV_DIO1_DIR_UPDATE_FLAG) != 0)
+	{
+		SetDIODIR(psDioInfo, 1);
+	}
+	if((dUpdateInfo & MCDRV_DIO2_DIR_UPDATE_FLAG) != 0)
+	{
+		SetDIODIR(psDioInfo, 2);
+	}
+
+	if((dUpdateInfo & MCDRV_DIO0_DIT_UPDATE_FLAG) != 0)
+	{
+		SetDIODIT(psDioInfo, 0);
+	}
+	if((dUpdateInfo & MCDRV_DIO1_DIT_UPDATE_FLAG) != 0)
+	{
+		SetDIODIT(psDioInfo, 1);
+	}
+	if((dUpdateInfo & MCDRV_DIO2_DIT_UPDATE_FLAG) != 0)
+	{
+		SetDIODIT(psDioInfo, 2);
+	}
+}
+
+/****************************************************************************
+ *	SetDIOCommon
+ *
+ *	Description:
+ *			Set digital io common information.
+ *	Arguments:
+ *			psDioInfo	digital io information
+ *			bPort		port number
+ *	Return:
+ *			none
+ *
+ ****************************************************************************/
+static void	SetDIOCommon
+(
+	const MCDRV_DIO_INFO*	psDioInfo,
+	UINT8	bPort
+)
+{
+	if(psDioInfo->asPortInfo[bPort].sDioCommon.bMasterSlave == MCDRV_DIO_SLAVE
+	|| psDioInfo->asPortInfo[bPort].sDioCommon.bMasterSlave == MCDRV_DIO_MASTER)
+	{
+		gsGlobalInfo_AA.sDioInfo.asPortInfo[bPort].sDioCommon.bMasterSlave	= psDioInfo->asPortInfo[bPort].sDioCommon.bMasterSlave;
+	}
+	if(psDioInfo->asPortInfo[bPort].sDioCommon.bAutoFs == MCDRV_AUTOFS_OFF
+	|| psDioInfo->asPortInfo[bPort].sDioCommon.bAutoFs == MCDRV_AUTOFS_ON)
+	{
+		gsGlobalInfo_AA.sDioInfo.asPortInfo[bPort].sDioCommon.bAutoFs	= psDioInfo->asPortInfo[bPort].sDioCommon.bAutoFs;
+	}
+	if(psDioInfo->asPortInfo[bPort].sDioCommon.bFs == MCDRV_FS_48000
+	|| psDioInfo->asPortInfo[bPort].sDioCommon.bFs == MCDRV_FS_44100
+	|| psDioInfo->asPortInfo[bPort].sDioCommon.bFs == MCDRV_FS_32000
+	|| psDioInfo->asPortInfo[bPort].sDioCommon.bFs == MCDRV_FS_24000
+	|| psDioInfo->asPortInfo[bPort].sDioCommon.bFs == MCDRV_FS_22050
+	|| psDioInfo->asPortInfo[bPort].sDioCommon.bFs == MCDRV_FS_16000
+	|| psDioInfo->asPortInfo[bPort].sDioCommon.bFs == MCDRV_FS_12000
+	|| psDioInfo->asPortInfo[bPort].sDioCommon.bFs == MCDRV_FS_11025
+	|| psDioInfo->asPortInfo[bPort].sDioCommon.bFs == MCDRV_FS_8000)
+	{
+		gsGlobalInfo_AA.sDioInfo.asPortInfo[bPort].sDioCommon.bFs	= psDioInfo->asPortInfo[bPort].sDioCommon.bFs;
+	}
+	if(psDioInfo->asPortInfo[bPort].sDioCommon.bBckFs == MCDRV_BCKFS_64
+	|| psDioInfo->asPortInfo[bPort].sDioCommon.bBckFs == MCDRV_BCKFS_48
+	|| psDioInfo->asPortInfo[bPort].sDioCommon.bBckFs == MCDRV_BCKFS_32
+	|| psDioInfo->asPortInfo[bPort].sDioCommon.bBckFs == MCDRV_BCKFS_512
+	|| psDioInfo->asPortInfo[bPort].sDioCommon.bBckFs == MCDRV_BCKFS_256
+	|| psDioInfo->asPortInfo[bPort].sDioCommon.bBckFs == MCDRV_BCKFS_128
+	|| psDioInfo->asPortInfo[bPort].sDioCommon.bBckFs == MCDRV_BCKFS_16)
+	{
+		gsGlobalInfo_AA.sDioInfo.asPortInfo[bPort].sDioCommon.bBckFs	= psDioInfo->asPortInfo[bPort].sDioCommon.bBckFs;
+	}
+	if(psDioInfo->asPortInfo[bPort].sDioCommon.bInterface == MCDRV_DIO_DA
+	|| psDioInfo->asPortInfo[bPort].sDioCommon.bInterface == MCDRV_DIO_PCM)
+	{
+		gsGlobalInfo_AA.sDioInfo.asPortInfo[bPort].sDioCommon.bInterface	= psDioInfo->asPortInfo[bPort].sDioCommon.bInterface;
+	}
+	if(psDioInfo->asPortInfo[bPort].sDioCommon.bBckInvert == MCDRV_BCLK_NORMAL
+	|| psDioInfo->asPortInfo[bPort].sDioCommon.bBckInvert == MCDRV_BCLK_INVERT)
+	{
+		gsGlobalInfo_AA.sDioInfo.asPortInfo[bPort].sDioCommon.bBckInvert	= psDioInfo->asPortInfo[bPort].sDioCommon.bBckInvert;
+	}
+	if(psDioInfo->asPortInfo[bPort].sDioCommon.bInterface == MCDRV_DIO_PCM)
+	{
+		if(psDioInfo->asPortInfo[bPort].sDioCommon.bPcmHizTim == MCDRV_PCMHIZTIM_FALLING
+		|| psDioInfo->asPortInfo[bPort].sDioCommon.bPcmHizTim == MCDRV_PCMHIZTIM_RISING)
+		{
+			gsGlobalInfo_AA.sDioInfo.asPortInfo[bPort].sDioCommon.bPcmHizTim	= psDioInfo->asPortInfo[bPort].sDioCommon.bPcmHizTim;
+		}
+		if(psDioInfo->asPortInfo[bPort].sDioCommon.bPcmClkDown == MCDRV_PCM_CLKDOWN_OFF
+		|| psDioInfo->asPortInfo[bPort].sDioCommon.bPcmClkDown == MCDRV_PCM_CLKDOWN_HALF)
+		{
+			gsGlobalInfo_AA.sDioInfo.asPortInfo[bPort].sDioCommon.bPcmClkDown	= psDioInfo->asPortInfo[bPort].sDioCommon.bPcmClkDown;
+		}
+		if(psDioInfo->asPortInfo[bPort].sDioCommon.bPcmFrame == MCDRV_PCM_SHORTFRAME
+		|| psDioInfo->asPortInfo[bPort].sDioCommon.bPcmFrame == MCDRV_PCM_LONGFRAME)
+		{
+			gsGlobalInfo_AA.sDioInfo.asPortInfo[bPort].sDioCommon.bPcmFrame	= psDioInfo->asPortInfo[bPort].sDioCommon.bPcmFrame;
+		}
+		if(psDioInfo->asPortInfo[bPort].sDioCommon.bPcmHighPeriod <= 31)
+		{
+			gsGlobalInfo_AA.sDioInfo.asPortInfo[bPort].sDioCommon.bPcmHighPeriod	= psDioInfo->asPortInfo[bPort].sDioCommon.bPcmHighPeriod;
+		}
+	}
+}
+
+/****************************************************************************
+ *	SetDIODIR
+ *
+ *	Description:
+ *			Set digital io dir information.
+ *	Arguments:
+ *			psDioInfo	digital io information
+ *			bPort		port number
+ *	Return:
+ *			none
+ *
+ ****************************************************************************/
+static void	SetDIODIR
+(
+	const MCDRV_DIO_INFO*	psDioInfo,
+	UINT8	bPort
+)
+{
+	UINT8	bDIOCh;
+
+	gsGlobalInfo_AA.sDioInfo.asPortInfo[bPort].sDir.wSrcRate	= psDioInfo->asPortInfo[bPort].sDir.wSrcRate;
+	if(gsGlobalInfo_AA.sDioInfo.asPortInfo[bPort].sDioCommon.bInterface == MCDRV_DIO_DA)
+	{
+		if(psDioInfo->asPortInfo[bPort].sDir.sDaFormat.bBitSel == MCDRV_BITSEL_16
+		|| psDioInfo->asPortInfo[bPort].sDir.sDaFormat.bBitSel == MCDRV_BITSEL_20
+		|| psDioInfo->asPortInfo[bPort].sDir.sDaFormat.bBitSel == MCDRV_BITSEL_24)
+		{
+			gsGlobalInfo_AA.sDioInfo.asPortInfo[bPort].sDir.sDaFormat.bBitSel	= psDioInfo->asPortInfo[bPort].sDir.sDaFormat.bBitSel;
+		}
+		if(psDioInfo->asPortInfo[bPort].sDir.sDaFormat.bMode == MCDRV_DAMODE_HEADALIGN
+		|| psDioInfo->asPortInfo[bPort].sDir.sDaFormat.bMode == MCDRV_DAMODE_I2S
+		|| psDioInfo->asPortInfo[bPort].sDir.sDaFormat.bMode == MCDRV_DAMODE_TAILALIGN)
+		{
+			gsGlobalInfo_AA.sDioInfo.asPortInfo[bPort].sDir.sDaFormat.bMode	= psDioInfo->asPortInfo[bPort].sDir.sDaFormat.bMode;
+		}
+	}
+	else if(gsGlobalInfo_AA.sDioInfo.asPortInfo[bPort].sDioCommon.bInterface == MCDRV_DIO_PCM)
+	{
+		if(psDioInfo->asPortInfo[bPort].sDir.sPcmFormat.bMono == MCDRV_PCM_STEREO
+		|| psDioInfo->asPortInfo[bPort].sDir.sPcmFormat.bMono == MCDRV_PCM_MONO)
+		{
+			gsGlobalInfo_AA.sDioInfo.asPortInfo[bPort].sDir.sPcmFormat.bMono	= psDioInfo->asPortInfo[bPort].sDir.sPcmFormat.bMono;
+		}
+		if(psDioInfo->asPortInfo[bPort].sDir.sPcmFormat.bOrder == MCDRV_PCM_MSB_FIRST
+		|| psDioInfo->asPortInfo[bPort].sDir.sPcmFormat.bOrder == MCDRV_PCM_LSB_FIRST
+		|| psDioInfo->asPortInfo[bPort].sDir.sPcmFormat.bOrder == MCDRV_PCM_MSB_FIRST_SIGN
+		|| psDioInfo->asPortInfo[bPort].sDir.sPcmFormat.bOrder == MCDRV_PCM_LSB_FIRST_SIGN
+		|| psDioInfo->asPortInfo[bPort].sDir.sPcmFormat.bOrder == MCDRV_PCM_MSB_FIRST_ZERO
+		|| psDioInfo->asPortInfo[bPort].sDir.sPcmFormat.bOrder == MCDRV_PCM_LSB_FIRST_ZERO)
+		{
+			gsGlobalInfo_AA.sDioInfo.asPortInfo[bPort].sDir.sPcmFormat.bOrder	= psDioInfo->asPortInfo[bPort].sDir.sPcmFormat.bOrder;
+		}
+		if(psDioInfo->asPortInfo[bPort].sDir.sPcmFormat.bLaw == MCDRV_PCM_LINEAR
+		|| psDioInfo->asPortInfo[bPort].sDir.sPcmFormat.bLaw == MCDRV_PCM_ALAW
+		|| psDioInfo->asPortInfo[bPort].sDir.sPcmFormat.bLaw == MCDRV_PCM_MULAW)
+		{
+			gsGlobalInfo_AA.sDioInfo.asPortInfo[bPort].sDir.sPcmFormat.bLaw	= psDioInfo->asPortInfo[bPort].sDir.sPcmFormat.bLaw;
+		}
+		if(psDioInfo->asPortInfo[bPort].sDir.sPcmFormat.bBitSel == MCDRV_PCM_BITSEL_8
+		|| psDioInfo->asPortInfo[bPort].sDir.sPcmFormat.bBitSel == MCDRV_PCM_BITSEL_13
+		|| psDioInfo->asPortInfo[bPort].sDir.sPcmFormat.bBitSel == MCDRV_PCM_BITSEL_14
+		|| psDioInfo->asPortInfo[bPort].sDir.sPcmFormat.bBitSel == MCDRV_PCM_BITSEL_16)
+		{
+			gsGlobalInfo_AA.sDioInfo.asPortInfo[bPort].sDir.sPcmFormat.bBitSel	= psDioInfo->asPortInfo[bPort].sDir.sPcmFormat.bBitSel;
+		}
+	}
+	for(bDIOCh = 0; bDIOCh < DIO_CHANNELS; bDIOCh++)
+	{
+		if(psDioInfo->asPortInfo[bPort].sDir.abSlot[bDIOCh] < 2)
+		{
+			gsGlobalInfo_AA.sDioInfo.asPortInfo[bPort].sDir.abSlot[bDIOCh]	= psDioInfo->asPortInfo[bPort].sDir.abSlot[bDIOCh];
+		}
+	}
+}
+
+/****************************************************************************
+ *	SetDIODIT
+ *
+ *	Description:
+ *			Set digital io dit information.
+ *	Arguments:
+ *			psDioInfo	digital io information
+ *			bPort		port number
+ *	Return:
+ *			none
+ *
+ ****************************************************************************/
+static void	SetDIODIT
+(
+	const MCDRV_DIO_INFO*	psDioInfo,
+	UINT8	bPort
+)
+{
+	UINT8	bDIOCh;
+
+	gsGlobalInfo_AA.sDioInfo.asPortInfo[bPort].sDit.wSrcRate	= psDioInfo->asPortInfo[bPort].sDit.wSrcRate;
+	if(gsGlobalInfo_AA.sDioInfo.asPortInfo[bPort].sDioCommon.bInterface == MCDRV_DIO_DA)
+	{
+		if(psDioInfo->asPortInfo[bPort].sDit.sDaFormat.bBitSel == MCDRV_BITSEL_16
+		|| psDioInfo->asPortInfo[bPort].sDit.sDaFormat.bBitSel == MCDRV_BITSEL_20
+		|| psDioInfo->asPortInfo[bPort].sDit.sDaFormat.bBitSel == MCDRV_BITSEL_24)
+		{
+			gsGlobalInfo_AA.sDioInfo.asPortInfo[bPort].sDit.sDaFormat.bBitSel	= psDioInfo->asPortInfo[bPort].sDit.sDaFormat.bBitSel;
+		}
+		if(psDioInfo->asPortInfo[bPort].sDit.sDaFormat.bMode == MCDRV_DAMODE_HEADALIGN
+		|| psDioInfo->asPortInfo[bPort].sDit.sDaFormat.bMode == MCDRV_DAMODE_I2S
+		|| psDioInfo->asPortInfo[bPort].sDit.sDaFormat.bMode == MCDRV_DAMODE_TAILALIGN)
+		{
+			gsGlobalInfo_AA.sDioInfo.asPortInfo[bPort].sDit.sDaFormat.bMode	= psDioInfo->asPortInfo[bPort].sDit.sDaFormat.bMode;
+		}
+	}
+	else if(gsGlobalInfo_AA.sDioInfo.asPortInfo[bPort].sDioCommon.bInterface == MCDRV_DIO_PCM)
+	{
+		if(psDioInfo->asPortInfo[bPort].sDit.sPcmFormat.bMono == MCDRV_PCM_STEREO
+		|| psDioInfo->asPortInfo[bPort].sDit.sPcmFormat.bMono == MCDRV_PCM_MONO)
+		{
+			gsGlobalInfo_AA.sDioInfo.asPortInfo[bPort].sDit.sPcmFormat.bMono	= psDioInfo->asPortInfo[bPort].sDit.sPcmFormat.bMono;
+		}
+		if(psDioInfo->asPortInfo[bPort].sDit.sPcmFormat.bOrder == MCDRV_PCM_MSB_FIRST
+		|| psDioInfo->asPortInfo[bPort].sDit.sPcmFormat.bOrder == MCDRV_PCM_LSB_FIRST
+		|| psDioInfo->asPortInfo[bPort].sDit.sPcmFormat.bOrder == MCDRV_PCM_MSB_FIRST_SIGN
+		|| psDioInfo->asPortInfo[bPort].sDit.sPcmFormat.bOrder == MCDRV_PCM_LSB_FIRST_SIGN
+		|| psDioInfo->asPortInfo[bPort].sDit.sPcmFormat.bOrder == MCDRV_PCM_MSB_FIRST_ZERO
+		|| psDioInfo->asPortInfo[bPort].sDit.sPcmFormat.bOrder == MCDRV_PCM_LSB_FIRST_ZERO)
+		{
+			gsGlobalInfo_AA.sDioInfo.asPortInfo[bPort].sDit.sPcmFormat.bOrder	= psDioInfo->asPortInfo[bPort].sDit.sPcmFormat.bOrder;
+		}
+		if(psDioInfo->asPortInfo[bPort].sDit.sPcmFormat.bLaw == MCDRV_PCM_LINEAR
+		|| psDioInfo->asPortInfo[bPort].sDit.sPcmFormat.bLaw == MCDRV_PCM_ALAW
+		|| psDioInfo->asPortInfo[bPort].sDit.sPcmFormat.bLaw == MCDRV_PCM_MULAW)
+		{
+			gsGlobalInfo_AA.sDioInfo.asPortInfo[bPort].sDit.sPcmFormat.bLaw	= psDioInfo->asPortInfo[bPort].sDit.sPcmFormat.bLaw;
+		}
+		if(psDioInfo->asPortInfo[bPort].sDit.sPcmFormat.bBitSel == MCDRV_PCM_BITSEL_8
+		|| psDioInfo->asPortInfo[bPort].sDit.sPcmFormat.bBitSel == MCDRV_PCM_BITSEL_13
+		|| psDioInfo->asPortInfo[bPort].sDit.sPcmFormat.bBitSel == MCDRV_PCM_BITSEL_14
+		|| psDioInfo->asPortInfo[bPort].sDit.sPcmFormat.bBitSel == MCDRV_PCM_BITSEL_16)
+		{
+			gsGlobalInfo_AA.sDioInfo.asPortInfo[bPort].sDit.sPcmFormat.bBitSel	= psDioInfo->asPortInfo[bPort].sDit.sPcmFormat.bBitSel;
+		}
+	}
+	for(bDIOCh = 0; bDIOCh < DIO_CHANNELS; bDIOCh++)
+	{
+		if(psDioInfo->asPortInfo[bPort].sDit.abSlot[bDIOCh] < 2)
+		{
+			gsGlobalInfo_AA.sDioInfo.asPortInfo[bPort].sDit.abSlot[bDIOCh]	= psDioInfo->asPortInfo[bPort].sDit.abSlot[bDIOCh];
+		}
+	}
+}
+
+/****************************************************************************
+ *	McResCtrl_GetDioInfo_AA
+ *
+ *	Description:
+ *			Get digital io information.
+ *	Arguments:
+ *			psDioInfo	digital io information
+ *	Return:
+ *			none
+ *
+ ****************************************************************************/
+void	McResCtrl_GetDioInfo_AA
+(
+	MCDRV_DIO_INFO*	psDioInfo
+)
+{
+	*psDioInfo	= gsGlobalInfo_AA.sDioInfo;
+}
+
+/****************************************************************************
+ *	McResCtrl_SetVolInfo_AA
+ *
+ *	Description:
+ *			Update volume.
+ *	Arguments:
+ *			psVolInfo		volume setting
+ *	Return:
+ *			none
+ *
+ ****************************************************************************/
+void	McResCtrl_SetVolInfo_AA
+(
+	const MCDRV_VOL_INFO*	psVolInfo
+)
+{
+	UINT8	bCh;
+
+
+	for(bCh = 0; bCh < AD0_VOL_CHANNELS; bCh++)
+	{
+		if((psVolInfo->aswD_Ad0[bCh] & 0x01) != 0)
+		{
+			gsGlobalInfo_AA.sVolInfo.aswD_Ad0[bCh]	= (psVolInfo->aswD_Ad0[bCh] & 0xFFFE);
+		}
+		if((psVolInfo->aswD_Ad0Att[bCh] & 0x01) != 0)
+		{
+			gsGlobalInfo_AA.sVolInfo.aswD_Ad0Att[bCh]	= (psVolInfo->aswD_Ad0Att[bCh] & 0xFFFE);
+		}
+		if((psVolInfo->aswA_Ad0[bCh] & 0x01) != 0)
+		{
+			gsGlobalInfo_AA.sVolInfo.aswA_Ad0[bCh]	= (psVolInfo->aswA_Ad0[bCh] & 0xFFFE);
+		}
+	}
+	for(bCh = 0; bCh < AD1_VOL_CHANNELS; bCh++)
+	{
+		if((psVolInfo->aswD_Ad1[bCh] & 0x01) != 0)
+		{
+			gsGlobalInfo_AA.sVolInfo.aswD_Ad1[bCh]	= (psVolInfo->aswD_Ad1[bCh] & 0xFFFE);
+		}
+		if((psVolInfo->aswD_Ad1Att[bCh] & 0x01) != 0)
+		{
+			gsGlobalInfo_AA.sVolInfo.aswD_Ad1Att[bCh]	= (psVolInfo->aswD_Ad1Att[bCh] & 0xFFFE);
+		}
+		if((psVolInfo->aswA_Ad1[bCh] & 0x01) != 0)
+		{
+			gsGlobalInfo_AA.sVolInfo.aswA_Ad1[bCh]	= (psVolInfo->aswA_Ad1[bCh] & 0xFFFE);
+		}
+	}
+
+	for(bCh = 0; bCh < AENG6_VOL_CHANNELS; bCh++)
+	{
+		if((psVolInfo->aswD_Aeng6[bCh] & 0x01) != 0)
+		{
+			gsGlobalInfo_AA.sVolInfo.aswD_Aeng6[bCh]	= (psVolInfo->aswD_Aeng6[bCh] & 0xFFFE);
+		}
+	}
+
+	for(bCh = 0; bCh < PDM_VOL_CHANNELS; bCh++)
+	{
+		if((psVolInfo->aswD_Pdm[bCh] & 0x01) != 0)
+		{
+			gsGlobalInfo_AA.sVolInfo.aswD_Pdm[bCh]	= (psVolInfo->aswD_Pdm[bCh] & 0xFFFE);
+		}
+		if((psVolInfo->aswD_SideTone[bCh] & 0x01) != 0)
+		{
+			gsGlobalInfo_AA.sVolInfo.aswD_SideTone[bCh]	= (psVolInfo->aswD_SideTone[bCh] & 0xFFFE);
+		}
+	}
+
+	for(bCh = 0; bCh < DTMF_VOL_CHANNELS; bCh++)
+	{
+		if((psVolInfo->aswD_Dtmfb[bCh] & 0x01) != 0)
+		{
+			gsGlobalInfo_AA.sVolInfo.aswD_Dtmfb[bCh]	= (psVolInfo->aswD_Dtmfb[bCh] & 0xFFFE);
+		}
+		if((psVolInfo->aswD_DtmfAtt[bCh] & 0x01) != 0)
+		{
+			gsGlobalInfo_AA.sVolInfo.aswD_DtmfAtt[bCh]	= (psVolInfo->aswD_DtmfAtt[bCh] & 0xFFFE);
+		}
+	}
+
+	for(bCh = 0; bCh < DIO0_VOL_CHANNELS; bCh++)
+	{
+		if((psVolInfo->aswD_Dir0[bCh] & 0x01) != 0)
+		{
+			gsGlobalInfo_AA.sVolInfo.aswD_Dir0[bCh]	= (psVolInfo->aswD_Dir0[bCh] & 0xFFFE);
+		}
+		if((psVolInfo->aswD_Dir0Att[bCh] & 0x01) != 0)
+		{
+			gsGlobalInfo_AA.sVolInfo.aswD_Dir0Att[bCh]	= (psVolInfo->aswD_Dir0Att[bCh] & 0xFFFE);
+		}
+		if((psVolInfo->aswD_Dit0[bCh] & 0x01) != 0)
+		{
+			gsGlobalInfo_AA.sVolInfo.aswD_Dit0[bCh]	= (psVolInfo->aswD_Dit0[bCh] & 0xFFFE);
+		}
+	}
+
+	for(bCh = 0; bCh < DIO1_VOL_CHANNELS; bCh++)
+	{
+		if((psVolInfo->aswD_Dir1[bCh] & 0x01) != 0)
+		{
+			gsGlobalInfo_AA.sVolInfo.aswD_Dir1[bCh]	= (psVolInfo->aswD_Dir1[bCh] & 0xFFFE);
+		}
+		if((psVolInfo->aswD_Dir1Att[bCh] & 0x01) != 0)
+		{
+			gsGlobalInfo_AA.sVolInfo.aswD_Dir1Att[bCh]	= (psVolInfo->aswD_Dir1Att[bCh] & 0xFFFE);
+		}
+		if((psVolInfo->aswD_Dit1[bCh] & 0x01) != 0)
+		{
+			gsGlobalInfo_AA.sVolInfo.aswD_Dit1[bCh]	= (psVolInfo->aswD_Dit1[bCh] & 0xFFFE);
+		}
+	}
+
+	for(bCh = 0; bCh < DIO2_VOL_CHANNELS; bCh++)
+	{
+		if((psVolInfo->aswD_Dir2[bCh] & 0x01) != 0)
+		{
+			gsGlobalInfo_AA.sVolInfo.aswD_Dir2[bCh]	= (psVolInfo->aswD_Dir2[bCh] & 0xFFFE);
+		}
+		if((psVolInfo->aswD_Dir2Att[bCh] & 0x01) != 0)
+		{
+			gsGlobalInfo_AA.sVolInfo.aswD_Dir2Att[bCh]	= (psVolInfo->aswD_Dir2Att[bCh] & 0xFFFE);
+		}
+		if((psVolInfo->aswD_Dit2[bCh] & 0x01) != 0)
+		{
+			gsGlobalInfo_AA.sVolInfo.aswD_Dit2[bCh]	= (psVolInfo->aswD_Dit2[bCh] & 0xFFFE);
+		}
+	}
+
+	for(bCh = 0; bCh < DAC_VOL_CHANNELS; bCh++)
+	{
+		if((psVolInfo->aswD_DacMaster[bCh] & 0x01) != 0)
+		{
+			gsGlobalInfo_AA.sVolInfo.aswD_DacMaster[bCh]	= (psVolInfo->aswD_DacMaster[bCh] & 0xFFFE);
+		}
+		if((psVolInfo->aswD_DacVoice[bCh] & 0x01) != 0)
+		{
+			gsGlobalInfo_AA.sVolInfo.aswD_DacVoice[bCh]	= (psVolInfo->aswD_DacVoice[bCh] & 0xFFFE);
+		}
+		if((psVolInfo->aswD_DacAtt[bCh] & 0x01) != 0)
+		{
+			gsGlobalInfo_AA.sVolInfo.aswD_DacAtt[bCh]	= (psVolInfo->aswD_DacAtt[bCh] & 0xFFFE);
+		}
+	}
+
+	for(bCh = 0; bCh < LIN1_VOL_CHANNELS; bCh++)
+	{
+		if((psVolInfo->aswA_Lin1[bCh] & 0x01) != 0)
+		{
+			gsGlobalInfo_AA.sVolInfo.aswA_Lin1[bCh]	= (psVolInfo->aswA_Lin1[bCh] & 0xFFFE);
+		}
+	}
+
+	for(bCh = 0; bCh < LIN2_VOL_CHANNELS; bCh++)
+	{
+		if((psVolInfo->aswA_Lin2[bCh] & 0x01) != 0)
+		{
+			gsGlobalInfo_AA.sVolInfo.aswA_Lin2[bCh]	= (psVolInfo->aswA_Lin2[bCh] & 0xFFFE);
+		}
+	}
+
+	for(bCh = 0; bCh < MIC1_VOL_CHANNELS; bCh++)
+	{
+		if((psVolInfo->aswA_Mic1[bCh] & 0x01) != 0)
+		{
+			gsGlobalInfo_AA.sVolInfo.aswA_Mic1[bCh]	= (psVolInfo->aswA_Mic1[bCh] & 0xFFFE);
+		}
+	}
+
+	for(bCh = 0; bCh < MIC2_VOL_CHANNELS; bCh++)
+	{
+		if((psVolInfo->aswA_Mic2[bCh] & 0x01) != 0)
+		{
+			gsGlobalInfo_AA.sVolInfo.aswA_Mic2[bCh]	= (psVolInfo->aswA_Mic2[bCh] & 0xFFFE);
+		}
+	}
+
+	for(bCh = 0; bCh < MIC3_VOL_CHANNELS; bCh++)
+	{
+		if((psVolInfo->aswA_Mic3[bCh] & 0x01) != 0)
+		{
+			gsGlobalInfo_AA.sVolInfo.aswA_Mic3[bCh]	= (psVolInfo->aswA_Mic3[bCh] & 0xFFFE);
+		}
+	}
+
+	for(bCh = 0; bCh < HP_VOL_CHANNELS; bCh++)
+	{
+		if((psVolInfo->aswA_Hp[bCh] & 0x01) != 0)
+		{
+			gsGlobalInfo_AA.sVolInfo.aswA_Hp[bCh]	= (psVolInfo->aswA_Hp[bCh] & 0xFFFE);
+		}
+	}
+
+	for(bCh = 0; bCh < SP_VOL_CHANNELS; bCh++)
+	{
+		if((psVolInfo->aswA_Sp[bCh] & 0x01) != 0)
+		{
+			gsGlobalInfo_AA.sVolInfo.aswA_Sp[bCh]	= (psVolInfo->aswA_Sp[bCh] & 0xFFFE);
+		}
+	}
+
+	for(bCh = 0; bCh < RC_VOL_CHANNELS; bCh++)
+	{
+		if((psVolInfo->aswA_Rc[bCh] & 0x01) != 0)
+		{
+			gsGlobalInfo_AA.sVolInfo.aswA_Rc[bCh]	= (psVolInfo->aswA_Rc[bCh] & 0xFFFE);
+		}
+	}
+
+	for(bCh = 0; bCh < LOUT1_VOL_CHANNELS; bCh++)
+	{
+		if((psVolInfo->aswA_Lout1[bCh] & 0x01) != 0)
+		{
+			gsGlobalInfo_AA.sVolInfo.aswA_Lout1[bCh]	= (psVolInfo->aswA_Lout1[bCh] & 0xFFFE);
+		}
+	}
+
+	for(bCh = 0; bCh < LOUT2_VOL_CHANNELS; bCh++)
+	{
+		if((psVolInfo->aswA_Lout2[bCh] & 0x01) != 0)
+		{
+			gsGlobalInfo_AA.sVolInfo.aswA_Lout2[bCh]	= (psVolInfo->aswA_Lout2[bCh] & 0xFFFE);
+		}
+	}
+
+	for(bCh = 0; bCh < MIC1_VOL_CHANNELS; bCh++)
+	{
+		if((psVolInfo->aswA_Mic1Gain[bCh] & 0x01) != 0)
+		{
+			gsGlobalInfo_AA.sVolInfo.aswA_Mic1Gain[bCh]	= (psVolInfo->aswA_Mic1Gain[bCh] & 0xFFFE);
+		}
+	}
+
+	for(bCh = 0; bCh < MIC2_VOL_CHANNELS; bCh++)
+	{
+		if((psVolInfo->aswA_Mic2Gain[bCh] & 0x01) != 0)
+		{
+			gsGlobalInfo_AA.sVolInfo.aswA_Mic2Gain[bCh]	= (psVolInfo->aswA_Mic2Gain[bCh] & 0xFFFE);
+		}
+	}
+
+	for(bCh = 0; bCh < MIC3_VOL_CHANNELS; bCh++)
+	{
+		if((psVolInfo->aswA_Mic3Gain[bCh] & 0x01) != 0)
+		{
+			gsGlobalInfo_AA.sVolInfo.aswA_Mic3Gain[bCh]	= (psVolInfo->aswA_Mic3Gain[bCh] & 0xFFFE);
+		}
+	}
+
+	for(bCh = 0; bCh < HPGAIN_VOL_CHANNELS; bCh++)
+	{
+		if((psVolInfo->aswA_HpGain[bCh] & 0x01) != 0)
+		{
+			gsGlobalInfo_AA.sVolInfo.aswA_HpGain[bCh]	= (psVolInfo->aswA_HpGain[bCh] & 0xFFFE);
+		}
+	}
+}
+
+/****************************************************************************
+ *	McResCtrl_GetVolInfo_AA
+ *
+ *	Description:
+ *			Get volume setting.
+ *	Arguments:
+ *			psVolInfo		volume setting
+ *	Return:
+ *			none
+ *
+ ****************************************************************************/
+void	McResCtrl_GetVolInfo_AA
+(
+	MCDRV_VOL_INFO*	psVolInfo
+)
+{
+	*psVolInfo	= gsGlobalInfo_AA.sVolInfo;
+}
+
+/****************************************************************************
+ *	McResCtrl_SetDacInfo_AA
+ *
+ *	Description:
+ *			Set DAC information.
+ *	Arguments:
+ *			psDacInfo	DAC information
+ *			dUpdateInfo	update information
+ *	Return:
+ *			none
+ *
+ ****************************************************************************/
+void	McResCtrl_SetDacInfo_AA
+(
+	const MCDRV_DAC_INFO*	psDacInfo,
+	UINT32	dUpdateInfo
+)
+{
+
+	if((dUpdateInfo & MCDRV_DAC_MSWP_UPDATE_FLAG) != 0)
+	{
+		switch(psDacInfo->bMasterSwap)
+		{
+		case	MCDRV_DSWAP_OFF:
+		case	MCDRV_DSWAP_SWAP:
+		case	MCDRV_DSWAP_MUTE:
+		case	MCDRV_DSWAP_RMVCENTER:
+		case	MCDRV_DSWAP_MONO:
+		case	MCDRV_DSWAP_MONOHALF:
+		case	MCDRV_DSWAP_BOTHL:
+		case	MCDRV_DSWAP_BOTHR:
+			gsGlobalInfo_AA.sDacInfo.bMasterSwap	= psDacInfo->bMasterSwap;
+			break;
+		default:
+			break;
+		}
+	}
+	if((dUpdateInfo & MCDRV_DAC_VSWP_UPDATE_FLAG) != 0)
+	{
+		switch(psDacInfo->bVoiceSwap)
+		{
+		case	MCDRV_DSWAP_OFF:
+		case	MCDRV_DSWAP_SWAP:
+		case	MCDRV_DSWAP_MUTE:
+		case	MCDRV_DSWAP_RMVCENTER:
+		case	MCDRV_DSWAP_MONO:
+		case	MCDRV_DSWAP_MONOHALF:
+		case	MCDRV_DSWAP_BOTHL:
+		case	MCDRV_DSWAP_BOTHR:
+			gsGlobalInfo_AA.sDacInfo.bVoiceSwap	= psDacInfo->bVoiceSwap;
+			break;
+		default:
+			break;
+		}
+	}
+	if((dUpdateInfo & MCDRV_DAC_HPF_UPDATE_FLAG) != 0)
+	{
+		if(psDacInfo->bDcCut == MCDRV_DCCUT_ON || psDacInfo->bDcCut == MCDRV_DCCUT_OFF)
+		{
+			gsGlobalInfo_AA.sDacInfo.bDcCut	= psDacInfo->bDcCut;
+		}
+	}
+}
+
+/****************************************************************************
+ *	McResCtrl_GetDacInfo_AA
+ *
+ *	Description:
+ *			Get DAC information.
+ *	Arguments:
+ *			psDacInfo	DAC information
+ *	Return:
+ *			none
+ *
+ ****************************************************************************/
+void	McResCtrl_GetDacInfo_AA
+(
+	MCDRV_DAC_INFO*	psDacInfo
+)
+{
+	*psDacInfo	= gsGlobalInfo_AA.sDacInfo;
+}
+
+/****************************************************************************
+ *	McResCtrl_SetAdcInfo_AA
+ *
+ *	Description:
+ *			Set ADC information.
+ *	Arguments:
+ *			psAdcInfo	ADC information
+ *			dUpdateInfo	update information
+ *	Return:
+ *			none
+ *
+ ****************************************************************************/
+void	McResCtrl_SetAdcInfo_AA
+(
+	const MCDRV_ADC_INFO*	psAdcInfo,
+	UINT32	dUpdateInfo
+)
+{
+
+	if((dUpdateInfo & MCDRV_ADCADJ_UPDATE_FLAG) != 0)
+	{
+		switch(psAdcInfo->bAgcAdjust)
+		{
+		case	MCDRV_AGCADJ_24:
+		case	MCDRV_AGCADJ_18:
+		case	MCDRV_AGCADJ_12:
+		case	MCDRV_AGCADJ_0:
+			gsGlobalInfo_AA.sAdcInfo.bAgcAdjust	= psAdcInfo->bAgcAdjust;
+			break;
+		default:
+			break;
+		}
+	}
+	if((dUpdateInfo & MCDRV_ADCAGC_UPDATE_FLAG) != 0)
+	{
+		if(psAdcInfo->bAgcOn == MCDRV_AGC_OFF || psAdcInfo->bAgcOn == MCDRV_AGC_ON)
+		{
+			gsGlobalInfo_AA.sAdcInfo.bAgcOn	= psAdcInfo->bAgcOn;
+		}
+	}
+	if((dUpdateInfo & MCDRV_ADCMONO_UPDATE_FLAG) != 0)
+	{
+		if(psAdcInfo->bMono == MCDRV_ADC_STEREO || psAdcInfo->bMono == MCDRV_ADC_MONO)
+		{
+			gsGlobalInfo_AA.sAdcInfo.bMono	= psAdcInfo->bMono;
+		}
+	}
+}
+
+/****************************************************************************
+ *	McResCtrl_GetAdcInfo_AA
+ *
+ *	Description:
+ *			Get ADC information.
+ *	Arguments:
+ *			psAdcInfo	ADC information
+ *	Return:
+ *			none
+ *
+ ****************************************************************************/
+void	McResCtrl_GetAdcInfo_AA
+(
+	MCDRV_ADC_INFO*	psAdcInfo
+)
+{
+	*psAdcInfo	= gsGlobalInfo_AA.sAdcInfo;
+}
+
+/****************************************************************************
+ *	McResCtrl_SetSpInfo_AA
+ *
+ *	Description:
+ *			Set SP information.
+ *	Arguments:
+ *			psSpInfo	SP information
+ *	Return:
+ *			none
+ *
+ ****************************************************************************/
+void	McResCtrl_SetSpInfo_AA
+(
+	const MCDRV_SP_INFO*	psSpInfo
+)
+{
+
+	if(psSpInfo->bSwap == MCDRV_SPSWAP_OFF || psSpInfo->bSwap == MCDRV_SPSWAP_SWAP)
+	{
+		gsGlobalInfo_AA.sSpInfo.bSwap	= psSpInfo->bSwap;
+	}
+}
+
+/****************************************************************************
+ *	McResCtrl_GetSpInfo_AA
+ *
+ *	Description:
+ *			Get SP information.
+ *	Arguments:
+ *			psSpInfo	SP information
+ *	Return:
+ *			none
+ *
+ ****************************************************************************/
+void	McResCtrl_GetSpInfo_AA
+(
+	MCDRV_SP_INFO*	psSpInfo
+)
+{
+	*psSpInfo	= gsGlobalInfo_AA.sSpInfo;
+}
+
+/****************************************************************************
+ *	McResCtrl_SetDngInfo_AA
+ *
+ *	Description:
+ *			Set Digital Noise Gate information.
+ *	Arguments:
+ *			psDngInfo	DNG information
+ *			dUpdateInfo	update information
+ *	Return:
+ *			none
+ *
+ ****************************************************************************/
+void	McResCtrl_SetDngInfo_AA
+(
+	const MCDRV_DNG_INFO*	psDngInfo,
+	UINT32	dUpdateInfo
+)
+{
+
+	if((dUpdateInfo & MCDRV_DNGSW_HP_UPDATE_FLAG) != 0)
+	{
+		if(psDngInfo->abOnOff[0] == MCDRV_DNG_OFF || psDngInfo->abOnOff[0] == MCDRV_DNG_ON)
+		{
+			gsGlobalInfo_AA.sDngInfo.abOnOff[0]	= psDngInfo->abOnOff[0];
+		}
+	}
+	if((dUpdateInfo & MCDRV_DNGTHRES_HP_UPDATE_FLAG) != 0)
+	{
+		if(psDngInfo->abThreshold[0] <= MCDRV_DNG_THRES_72)
+		{
+			gsGlobalInfo_AA.sDngInfo.abThreshold[0]	= psDngInfo->abThreshold[0];
+		}
+	}
+	if((dUpdateInfo & MCDRV_DNGHOLD_HP_UPDATE_FLAG) != 0)
+	{
+		switch(psDngInfo->abHold[0])
+		{
+		case	MCDRV_DNG_HOLD_30:
+		case	MCDRV_DNG_HOLD_120:
+		case	MCDRV_DNG_HOLD_500:
+			gsGlobalInfo_AA.sDngInfo.abHold[0]	= psDngInfo->abHold[0];
+			break;
+		default:
+			break;
+		}
+	}
+	if((dUpdateInfo & MCDRV_DNGATK_HP_UPDATE_FLAG) != 0)
+	{
+		if(psDngInfo->abAttack[0] == MCDRV_DNG_ATTACK_25)
+		{
+			gsGlobalInfo_AA.sDngInfo.abAttack[0]	= psDngInfo->abAttack[0];
+		}
+		else if(psDngInfo->abAttack[0] == MCDRV_DNG_ATTACK_800)
+		{
+			gsGlobalInfo_AA.sDngInfo.abAttack[0]	= 1/*MCDRV_DNG_ATTACK_800*/;
+		}
+	}
+	if((dUpdateInfo & MCDRV_DNGREL_HP_UPDATE_FLAG) != 0)
+	{
+		switch(psDngInfo->abRelease[0])
+		{
+		case	MCDRV_DNG_RELEASE_7950:
+		case	MCDRV_DNG_RELEASE_470:
+		case	MCDRV_DNG_RELEASE_940:
+			gsGlobalInfo_AA.sDngInfo.abRelease[0]	= psDngInfo->abRelease[0];
+			break;
+		default:
+			break;
+		}
+	}
+}
+
+/****************************************************************************
+ *	McResCtrl_GetDngInfo_AA
+ *
+ *	Description:
+ *			Get Digital Noise Gate information.
+ *	Arguments:
+ *			psDngInfo	DNG information
+ *	Return:
+ *			none
+ *
+ ****************************************************************************/
+void	McResCtrl_GetDngInfo_AA
+(
+	MCDRV_DNG_INFO*	psDngInfo
+)
+{
+	*psDngInfo	= gsGlobalInfo_AA.sDngInfo;
+}
+
+/****************************************************************************
+ *	McResCtrl_SetAeInfo_AA
+ *
+ *	Description:
+ *			Set Audio Engine information.
+ *	Arguments:
+ *			psAeInfo	AE information
+ *			dUpdateInfo	update information
+ *	Return:
+ *			none
+ *
+ ****************************************************************************/
+void	McResCtrl_SetAeInfo_AA
+(
+	const MCDRV_AE_INFO*	psAeInfo,
+	UINT32	dUpdateInfo
+)
+{
+
+	if(McDevProf_IsValid(eMCDRV_FUNC_DBEX) == 1
+	&& (dUpdateInfo & MCDRV_AEUPDATE_FLAG_BEXWIDE_ONOFF) != 0)
+	{
+		if((psAeInfo->bOnOff & MCDRV_BEXWIDE_ON) != 0)
+		{
+			gsGlobalInfo_AA.sAeInfo.bOnOff	|= MCDRV_BEXWIDE_ON;
+		}
+		else
+		{
+			gsGlobalInfo_AA.sAeInfo.bOnOff &= (UINT8)~MCDRV_BEXWIDE_ON;
+		}
+	}
+	if((dUpdateInfo & MCDRV_AEUPDATE_FLAG_DRC_ONOFF) != 0)
+	{
+		if((psAeInfo->bOnOff & MCDRV_DRC_ON) != 0)
+		{
+			gsGlobalInfo_AA.sAeInfo.bOnOff	|= MCDRV_DRC_ON;
+		}
+		else
+		{
+			gsGlobalInfo_AA.sAeInfo.bOnOff &= (UINT8)~MCDRV_DRC_ON;
+		}
+	}
+	if((dUpdateInfo & MCDRV_AEUPDATE_FLAG_EQ5_ONOFF) != 0)
+	{
+		if((psAeInfo->bOnOff & MCDRV_EQ5_ON) != 0)
+		{
+			gsGlobalInfo_AA.sAeInfo.bOnOff	|= MCDRV_EQ5_ON;
+		}
+		else
+		{
+			gsGlobalInfo_AA.sAeInfo.bOnOff &= (UINT8)~MCDRV_EQ5_ON;
+		}
+	}
+	if((dUpdateInfo & MCDRV_AEUPDATE_FLAG_EQ3_ONOFF) != 0)
+	{
+		if((psAeInfo->bOnOff & MCDRV_EQ3_ON) != 0)
+		{
+			gsGlobalInfo_AA.sAeInfo.bOnOff	|= MCDRV_EQ3_ON;
+		}
+		else
+		{
+			gsGlobalInfo_AA.sAeInfo.bOnOff &= (UINT8)~MCDRV_EQ3_ON;
+		}
+	}
+
+	if((dUpdateInfo & MCDRV_AEUPDATE_FLAG_BEX) != 0)
+	{
+		McSrv_MemCopy(psAeInfo->abBex, gsGlobalInfo_AA.sAeInfo.abBex, BEX_PARAM_SIZE);
+	}
+
+	if((dUpdateInfo & MCDRV_AEUPDATE_FLAG_WIDE) != 0)
+	{
+		McSrv_MemCopy(psAeInfo->abWide, gsGlobalInfo_AA.sAeInfo.abWide, WIDE_PARAM_SIZE);
+	}
+
+	if((dUpdateInfo & MCDRV_AEUPDATE_FLAG_DRC) != 0)
+	{
+		McSrv_MemCopy(psAeInfo->abDrc, gsGlobalInfo_AA.sAeInfo.abDrc, DRC_PARAM_SIZE);
+	}
+
+	if((dUpdateInfo & MCDRV_AEUPDATE_FLAG_EQ5) != 0)
+	{
+		McSrv_MemCopy(psAeInfo->abEq5, gsGlobalInfo_AA.sAeInfo.abEq5, EQ5_PARAM_SIZE);
+	}
+
+	if((dUpdateInfo & MCDRV_AEUPDATE_FLAG_EQ3) != 0)
+	{
+		McSrv_MemCopy(psAeInfo->abEq3, gsGlobalInfo_AA.sAeInfo.abEq3, EQ3_PARAM_SIZE);
+	}
+
+	if(McDevProf_IsValid(eMCDRV_FUNC_HWADJ) == 1)
+	{
+		gsGlobalInfo_AA.sAeInfo.bOnOff |= MCDRV_EQ3_ON;
+	}
+}
+
+/****************************************************************************
+ *	McResCtrl_GetAeInfo_AA
+ *
+ *	Description:
+ *			Get Audio Engine information.
+ *	Arguments:
+ *			psAeInfo	AE information
+ *	Return:
+ *			none
+ *
+ ****************************************************************************/
+void	McResCtrl_GetAeInfo_AA
+(
+	MCDRV_AE_INFO*	psAeInfo
+)
+{
+	*psAeInfo	= gsGlobalInfo_AA.sAeInfo;
+}
+
+/****************************************************************************
+ *	McResCtrl_SetPdmInfo_AA
+ *
+ *	Description:
+ *			Set PDM information.
+ *	Arguments:
+ *			psPdmInfo	PDM information
+ *			dUpdateInfo	update information
+ *	Return:
+ *			none
+ *
+ ****************************************************************************/
+void	McResCtrl_SetPdmInfo_AA
+(
+	const MCDRV_PDM_INFO*	psPdmInfo,
+	UINT32	dUpdateInfo
+)
+{
+
+	if((dUpdateInfo & MCDRV_PDMCLK_UPDATE_FLAG) != 0)
+	{
+		switch(psPdmInfo->bClk)
+		{
+		case	MCDRV_PDM_CLK_128:
+		case	MCDRV_PDM_CLK_64:
+		case	MCDRV_PDM_CLK_32:
+			gsGlobalInfo_AA.sPdmInfo.bClk	= psPdmInfo->bClk;
+			break;
+		default:
+			break;
+		}
+	}
+	if((dUpdateInfo & MCDRV_PDMADJ_UPDATE_FLAG) != 0)
+	{
+		switch(psPdmInfo->bAgcAdjust)
+		{
+		case	MCDRV_AGCADJ_24:
+		case	MCDRV_AGCADJ_18:
+		case	MCDRV_AGCADJ_12:
+		case	MCDRV_AGCADJ_0:
+			gsGlobalInfo_AA.sPdmInfo.bAgcAdjust	= psPdmInfo->bAgcAdjust;
+			break;
+		default:
+			break;
+		}
+	}
+	if((dUpdateInfo & MCDRV_PDMAGC_UPDATE_FLAG) != 0)
+	{
+		switch(psPdmInfo->bAgcOn)
+		{
+		case	MCDRV_AGC_OFF:
+		case	MCDRV_AGC_ON:
+			gsGlobalInfo_AA.sPdmInfo.bAgcOn	= psPdmInfo->bAgcOn;
+			break;
+		default:
+			break;
+		}
+	}
+	if((dUpdateInfo & MCDRV_PDMEDGE_UPDATE_FLAG) != 0)
+	{
+		switch(psPdmInfo->bPdmEdge)
+		{
+		case	MCDRV_PDMEDGE_LH:
+		case	MCDRV_PDMEDGE_HL:
+			gsGlobalInfo_AA.sPdmInfo.bPdmEdge	= psPdmInfo->bPdmEdge;
+			break;
+		default:
+			break;
+		}
+	}
+	if((dUpdateInfo & MCDRV_PDMWAIT_UPDATE_FLAG) != 0)
+	{
+		switch(psPdmInfo->bPdmWait)
+		{
+		case	MCDRV_PDMWAIT_0:
+		case	MCDRV_PDMWAIT_1:
+		case	MCDRV_PDMWAIT_10:
+		case	MCDRV_PDMWAIT_20:
+			gsGlobalInfo_AA.sPdmInfo.bPdmWait	= psPdmInfo->bPdmWait;
+			break;
+		default:
+			break;
+		}
+	}
+	if((dUpdateInfo & MCDRV_PDMSEL_UPDATE_FLAG) != 0)
+	{
+		switch(psPdmInfo->bPdmSel)
+		{
+		case	MCDRV_PDMSEL_L1R2:
+		case	MCDRV_PDMSEL_L2R1:
+		case	MCDRV_PDMSEL_L1R1:
+		case	MCDRV_PDMSEL_L2R2:
+			gsGlobalInfo_AA.sPdmInfo.bPdmSel	= psPdmInfo->bPdmSel;
+			break;
+		default:
+			break;
+		}
+	}
+	if((dUpdateInfo & MCDRV_PDMMONO_UPDATE_FLAG) != 0)
+	{
+		switch(psPdmInfo->bMono)
+		{
+		case	MCDRV_PDM_STEREO:
+		case	MCDRV_PDM_MONO:
+			gsGlobalInfo_AA.sPdmInfo.bMono	= psPdmInfo->bMono;
+			break;
+		default:
+			break;
+		}
+	}
+}
+
+/****************************************************************************
+ *	McResCtrl_GetPdmInfo_AA
+ *
+ *	Description:
+ *			Get PDM information.
+ *	Arguments:
+ *			psPdmInfo	PDM information
+ *	Return:
+ *			none
+ *
+ ****************************************************************************/
+void	McResCtrl_GetPdmInfo_AA
+(
+	MCDRV_PDM_INFO*	psPdmInfo
+)
+{
+	*psPdmInfo	= gsGlobalInfo_AA.sPdmInfo;
+}
+
+/****************************************************************************
+ *	McResCtrl_SetGPMode_AA
+ *
+ *	Description:
+ *			Set GP mode.
+ *	Arguments:
+ *			psGpMode	GP mode
+ *	Return:
+ *			none
+ *
+ ****************************************************************************/
+void	McResCtrl_SetGPMode_AA
+(
+	const MCDRV_GP_MODE*	psGpMode
+)
+{
+	UINT8	bPad;
+
+
+	for(bPad = 0; bPad < GPIO_PAD_NUM; bPad++)
+	{
+		if(psGpMode->abGpDdr[bPad] == MCDRV_GPDDR_IN
+		|| psGpMode->abGpDdr[bPad] == MCDRV_GPDDR_OUT)
+		{
+			gsGlobalInfo_AA.sGpMode.abGpDdr[bPad]	= psGpMode->abGpDdr[bPad];
+		}
+		if(McDevProf_IsValid(eMCDRV_FUNC_GPMODE) == 1)
+		{
+			if(psGpMode->abGpMode[bPad] == MCDRV_GPMODE_RISING
+			|| psGpMode->abGpMode[bPad] == MCDRV_GPMODE_FALLING
+			|| psGpMode->abGpMode[bPad] == MCDRV_GPMODE_BOTH)
+			{
+				gsGlobalInfo_AA.sGpMode.abGpMode[bPad]	= psGpMode->abGpMode[bPad];
+			}
+			if(psGpMode->abGpHost[bPad] == MCDRV_GPHOST_SCU
+			|| psGpMode->abGpHost[bPad] == MCDRV_GPHOST_CDSP)
+			{
+				gsGlobalInfo_AA.sGpMode.abGpHost[bPad]	= psGpMode->abGpHost[bPad];
+			}
+			if(psGpMode->abGpInvert[bPad] == MCDRV_GPINV_NORMAL
+			|| psGpMode->abGpInvert[bPad] == MCDRV_GPINV_INVERT)
+			{
+				gsGlobalInfo_AA.sGpMode.abGpInvert[bPad]	= psGpMode->abGpInvert[bPad];
+			}
+		}
+	}
+}
+
+/****************************************************************************
+ *	McResCtrl_GetGPMode_AA
+ *
+ *	Description:
+ *			Get GP mode.
+ *	Arguments:
+ *			psGpMode	GP mode
+ *	Return:
+ *			none
+ *
+ ****************************************************************************/
+void	McResCtrl_GetGPMode_AA
+(
+	MCDRV_GP_MODE*	psGpMode
+)
+{
+	*psGpMode	= gsGlobalInfo_AA.sGpMode;
+}
+
+/****************************************************************************
+ *	McResCtrl_SetGPMask_AA
+ *
+ *	Description:
+ *			Set GP mask.
+ *	Arguments:
+ *			bMask	GP mask
+ *			dPadNo	PAD Number
+ *	Return:
+ *			none
+ *
+ ****************************************************************************/
+void	McResCtrl_SetGPMask_AA
+(
+	UINT8	bMask,
+	UINT32	dPadNo
+)
+{
+	if(dPadNo == MCDRV_GP_PAD0)
+	{
+		if(gsGlobalInfo_AA.sInitInfo.bPad0Func == MCDRV_PAD_GPIO
+		&& gsGlobalInfo_AA.sGpMode.abGpDdr[dPadNo] == MCDRV_GPDDR_IN)
+		{
+			if(bMask == MCDRV_GPMASK_ON || bMask == MCDRV_GPMASK_OFF)
+			{
+				gsGlobalInfo_AA.abGpMask[dPadNo]	= bMask;
+			}
+		}
+	}
+	else if(dPadNo == MCDRV_GP_PAD1)
+	{
+		if(gsGlobalInfo_AA.sInitInfo.bPad1Func == MCDRV_PAD_GPIO
+		&& gsGlobalInfo_AA.sGpMode.abGpDdr[dPadNo] == MCDRV_GPDDR_IN)
+		{
+			if(bMask == MCDRV_GPMASK_ON || bMask == MCDRV_GPMASK_OFF)
+			{
+				gsGlobalInfo_AA.abGpMask[dPadNo]	= bMask;
+			}
+		}
+	}
+/*
+	else if(dPadNo == MCDRV_GP_PAD2)
+	{
+		if(gsGlobalInfo_AA.sInitInfo.bPad2Func == MCDRV_PAD_GPIO
+		&& gsGlobalInfo_AA.sGpMode.abGpDdr[dPadNo] == MCDRV_GPDDR_IN)
+		{
+			if(bMask == MCDRV_GPMASK_ON || bMask == MCDRV_GPMASK_OFF)
+			{
+				gsGlobalInfo_AA.abGpMask[dPadNo]	= bMask;
+			}
+		}
+	}
+*/
+}
+
+/****************************************************************************
+ *	McResCtrl_GetGPMask_AA
+ *
+ *	Description:
+ *			Get GP mask.
+ *	Arguments:
+ *			pabMask	GP mask
+ *	Return:
+ *			none
+ *
+ ****************************************************************************/
+void	McResCtrl_GetGPMask_AA
+(
+	UINT8*	pabMask
+)
+{
+	UINT8	bPadNo;
+	for(bPadNo = 0; bPadNo < GPIO_PAD_NUM; bPadNo++)
+	{
+		pabMask[bPadNo]	= gsGlobalInfo_AA.abGpMask[bPadNo];
+	}
+}
+
+
+/****************************************************************************
+ *	McResCtrl_GetVolReg_AA
+ *
+ *	Description:
+ *			Get value of volume registers.
+ *	Arguments:
+ *			psVolInfo	volume information
+ *	Return:
+ *			none
+ *
+ ****************************************************************************/
+void	McResCtrl_GetVolReg_AA
+(
+	MCDRV_VOL_INFO*	psVolInfo
+)
+{
+	UINT8	bCh;
+	MCDRV_DST_CH	abDSTCh[]	= {eMCDRV_DST_CH0_AA, eMCDRV_DST_CH1_AA};
+	SINT16	swGainUp;
+
+
+	*psVolInfo	= gsGlobalInfo_AA.sVolInfo;
+
+	if(gsGlobalInfo_AA.sInitInfo.bDclGain == MCDRV_DCLGAIN_6)
+	{
+		swGainUp	= 6 * 256;
+	}
+	else if(gsGlobalInfo_AA.sInitInfo.bDclGain == MCDRV_DCLGAIN_12)
+	{
+		swGainUp	= 12 * 256;
+	}
+	else if(gsGlobalInfo_AA.sInitInfo.bDclGain == MCDRV_DCLGAIN_18)
+	{
+		swGainUp	= 18 * 256;
+	}
+	else
+	{
+		swGainUp	= 0;
+	}
+
+	psVolInfo->aswA_HpGain[0]	= MCDRV_REG_MUTE;
+	if(McResCtrl_IsDstUsed_AA(eMCDRV_DST_HP_AA, eMCDRV_DST_CH0_AA) == 0)
+	{
+		psVolInfo->aswA_Hp[0]	= MCDRV_REG_MUTE;
+	}
+	else
+	{
+		psVolInfo->aswA_Hp[0]		= GetHpVolReg(gsGlobalInfo_AA.sVolInfo.aswA_Hp[0]);
+		psVolInfo->aswA_HpGain[0]	= GetHpGainReg(gsGlobalInfo_AA.sVolInfo.aswA_HpGain[0]);
+	}
+	if(McResCtrl_IsDstUsed_AA(eMCDRV_DST_HP_AA, eMCDRV_DST_CH1_AA) == 0)
+	{
+		psVolInfo->aswA_Hp[1]	= MCDRV_REG_MUTE;
+	}
+	else
+	{
+		psVolInfo->aswA_Hp[1]	= GetHpVolReg(gsGlobalInfo_AA.sVolInfo.aswA_Hp[1]);
+		psVolInfo->aswA_HpGain[0]	= GetHpGainReg(gsGlobalInfo_AA.sVolInfo.aswA_HpGain[0]);
+	}
+
+	if(McResCtrl_IsDstUsed_AA(eMCDRV_DST_SP_AA, eMCDRV_DST_CH0_AA) == 0)
+	{
+		psVolInfo->aswA_Sp[0]	= MCDRV_REG_MUTE;
+	}
+	else
+	{
+		psVolInfo->aswA_Sp[0]	= GetSpVolReg(gsGlobalInfo_AA.sVolInfo.aswA_Sp[0]);
+	}
+	if(McResCtrl_IsDstUsed_AA(eMCDRV_DST_SP_AA, eMCDRV_DST_CH1_AA) == 0)
+	{
+		psVolInfo->aswA_Sp[1]	= MCDRV_REG_MUTE;
+	}
+	else
+	{
+		psVolInfo->aswA_Sp[1]	= GetSpVolReg(gsGlobalInfo_AA.sVolInfo.aswA_Sp[1]);
+	}
+
+	if(McResCtrl_IsDstUsed_AA(eMCDRV_DST_RCV_AA, eMCDRV_DST_CH0_AA) == 0)
+	{
+		psVolInfo->aswA_Rc[0]	= MCDRV_REG_MUTE;
+	}
+	else
+	{
+		psVolInfo->aswA_Rc[0]	= GetRcVolReg(gsGlobalInfo_AA.sVolInfo.aswA_Rc[0]);
+	}
+
+	if(McResCtrl_IsDstUsed_AA(eMCDRV_DST_LOUT1_AA, eMCDRV_DST_CH0_AA) == 0)
+	{
+		psVolInfo->aswA_Lout1[0]	= MCDRV_REG_MUTE;
+	}
+	else
+	{
+		psVolInfo->aswA_Lout1[0]	= GetLoVolReg(gsGlobalInfo_AA.sVolInfo.aswA_Lout1[0]);
+	}
+	if(McResCtrl_IsDstUsed_AA(eMCDRV_DST_LOUT1_AA, eMCDRV_DST_CH1_AA) == 0)
+	{
+		psVolInfo->aswA_Lout1[1]	= MCDRV_REG_MUTE;
+	}
+	else
+	{
+		psVolInfo->aswA_Lout1[1]	= GetLoVolReg(gsGlobalInfo_AA.sVolInfo.aswA_Lout1[1]);
+	}
+
+	if(McResCtrl_IsDstUsed_AA(eMCDRV_DST_LOUT2_AA, eMCDRV_DST_CH0_AA) == 0)
+	{
+		psVolInfo->aswA_Lout2[0]	= MCDRV_REG_MUTE;
+	}
+	else
+	{
+		psVolInfo->aswA_Lout2[0]	= GetLoVolReg(gsGlobalInfo_AA.sVolInfo.aswA_Lout2[0]);
+	}
+	if(McResCtrl_IsDstUsed_AA(eMCDRV_DST_LOUT2_AA, eMCDRV_DST_CH1_AA) == 0)
+	{
+		psVolInfo->aswA_Lout2[1]	= MCDRV_REG_MUTE;
+	}
+	else
+	{
+		psVolInfo->aswA_Lout2[1]	= GetLoVolReg(gsGlobalInfo_AA.sVolInfo.aswA_Lout2[1]);
+	}
+
+	for(bCh = 0; bCh < AD0_VOL_CHANNELS; bCh++)
+	{
+		if(McResCtrl_IsDstUsed_AA(eMCDRV_DST_ADC0_AA, abDSTCh[bCh]) == 0)
+		{/*	ADC0 source all off	*/
+			psVolInfo->aswA_Ad0[bCh]	= MCDRV_REG_MUTE;
+			psVolInfo->aswD_Ad0[bCh]	= MCDRV_REG_MUTE;
+		}
+		else
+		{
+			psVolInfo->aswA_Ad0[bCh]	= GetADVolReg(gsGlobalInfo_AA.sVolInfo.aswA_Ad0[bCh]);
+			psVolInfo->aswD_Ad0[bCh]	= GetDigitalVolReg(gsGlobalInfo_AA.sVolInfo.aswD_Ad0[bCh] - swGainUp);
+		}
+	}
+	if((gsGlobalInfo_AA.sPathInfo.asMix[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK] & MCDRV_SRC4_ADC0_ON) == MCDRV_SRC4_ADC0_ON
+	|| (gsGlobalInfo_AA.sPathInfo.asMix[0].abSrcOnOff[MCDRV_SRC_PDM_BLOCK] & MCDRV_SRC4_PDM_ON) == MCDRV_SRC4_PDM_ON
+	|| ((gsGlobalInfo_AA.sPathInfo.asMix[0].abSrcOnOff[MCDRV_SRC_AE_BLOCK] & MCDRV_SRC6_AE_ON) == MCDRV_SRC6_AE_ON
+		&& (McResCtrl_GetAESource_AA() == eMCDRV_SRC_PDM_AA || McResCtrl_GetAESource_AA() == eMCDRV_SRC_ADC0_AA)))
+	{
+		for(bCh = 0; bCh < AD0_VOL_CHANNELS; bCh++)
+		{
+			psVolInfo->aswD_Ad0Att[bCh]	= GetDigitalVolReg(gsGlobalInfo_AA.sVolInfo.aswD_Ad0Att[bCh]);
+		}
+	}
+	else
+	{
+		for(bCh = 0; bCh < AD0_VOL_CHANNELS; bCh++)
+		{
+			psVolInfo->aswD_Ad0Att[bCh]	= MCDRV_REG_MUTE;
+		}
+	}
+
+	if(McDevProf_IsValid(eMCDRV_FUNC_ADC1) == 1)
+	{
+		if(McResCtrl_IsDstUsed_AA(eMCDRV_DST_ADC1_AA, eMCDRV_DST_CH0_AA) == 0)
+		{/*	ADC1 source all off	*/
+			for(bCh = 0; bCh < AD1_VOL_CHANNELS; bCh++)
+			{
+				psVolInfo->aswA_Ad1[bCh]	= MCDRV_REG_MUTE;
+				psVolInfo->aswD_Ad1[bCh]	= MCDRV_REG_MUTE;
+			}
+		}
+		else
+		{
+			for(bCh = 0; bCh < AD1_VOL_CHANNELS; bCh++)
+			{
+				psVolInfo->aswA_Ad1[bCh]	= GetADVolReg(gsGlobalInfo_AA.sVolInfo.aswA_Ad1[bCh]);
+				psVolInfo->aswD_Ad1[bCh]	= GetDigitalVolReg(gsGlobalInfo_AA.sVolInfo.aswD_Ad1[bCh] - swGainUp);
+			}
+		}
+		if((gsGlobalInfo_AA.sPathInfo.asMix[0].abSrcOnOff[MCDRV_SRC_ADC1_BLOCK] & MCDRV_SRC4_ADC1_ON) == MCDRV_SRC4_ADC1_ON)
+		{
+			for(bCh = 0; bCh < AD1_VOL_CHANNELS; bCh++)
+			{
+				psVolInfo->aswD_Ad1Att[bCh]	= GetDigitalVolReg(gsGlobalInfo_AA.sVolInfo.aswD_Ad1Att[bCh]);
+			}
+		}
+		else
+		{
+			for(bCh = 0; bCh < AD1_VOL_CHANNELS; bCh++)
+			{
+				psVolInfo->aswD_Ad1Att[bCh]	= MCDRV_REG_MUTE;
+			}
+		}
+	}
+
+	if(((gsGlobalInfo_AA.sPathInfo.asHpOut[0].abSrcOnOff[MCDRV_SRC_LINE1_L_BLOCK] & MCDRV_SRC1_LINE1_L_ON) == MCDRV_SRC1_LINE1_L_ON)
+	|| ((gsGlobalInfo_AA.sPathInfo.asSpOut[0].abSrcOnOff[MCDRV_SRC_LINE1_L_BLOCK] & MCDRV_SRC1_LINE1_L_ON) == MCDRV_SRC1_LINE1_L_ON)
+	|| ((gsGlobalInfo_AA.sPathInfo.asLout1[0].abSrcOnOff[MCDRV_SRC_LINE1_L_BLOCK] & MCDRV_SRC1_LINE1_L_ON) == MCDRV_SRC1_LINE1_L_ON)
+	|| ((gsGlobalInfo_AA.sPathInfo.asLout1[0].abSrcOnOff[MCDRV_SRC_LINE1_L_BLOCK] & MCDRV_SRC1_LINE1_L_ON) == MCDRV_SRC1_LINE1_L_ON)
+	|| ((gsGlobalInfo_AA.sPathInfo.asLout2[0].abSrcOnOff[MCDRV_SRC_LINE1_L_BLOCK] & MCDRV_SRC1_LINE1_L_ON) == MCDRV_SRC1_LINE1_L_ON)
+	|| ((gsGlobalInfo_AA.sPathInfo.asHpOut[0].abSrcOnOff[MCDRV_SRC_LINE1_M_BLOCK] & MCDRV_SRC1_LINE1_M_ON) == MCDRV_SRC1_LINE1_M_ON)
+	|| ((gsGlobalInfo_AA.sPathInfo.asSpOut[0].abSrcOnOff[MCDRV_SRC_LINE1_M_BLOCK] & MCDRV_SRC1_LINE1_M_ON) == MCDRV_SRC1_LINE1_M_ON)
+	|| ((gsGlobalInfo_AA.sPathInfo.asSpOut[1].abSrcOnOff[MCDRV_SRC_LINE1_M_BLOCK] & MCDRV_SRC1_LINE1_M_ON) == MCDRV_SRC1_LINE1_M_ON)
+	|| ((gsGlobalInfo_AA.sPathInfo.asRcOut[0].abSrcOnOff[MCDRV_SRC_LINE1_M_BLOCK] & MCDRV_SRC1_LINE1_M_ON) == MCDRV_SRC1_LINE1_M_ON)
+	|| ((gsGlobalInfo_AA.sPathInfo.asLout1[0].abSrcOnOff[MCDRV_SRC_LINE1_M_BLOCK] & MCDRV_SRC1_LINE1_M_ON) == MCDRV_SRC1_LINE1_M_ON)
+	|| ((gsGlobalInfo_AA.sPathInfo.asLout1[0].abSrcOnOff[MCDRV_SRC_LINE1_M_BLOCK] & MCDRV_SRC1_LINE1_M_ON) == MCDRV_SRC1_LINE1_M_ON)
+	|| ((gsGlobalInfo_AA.sPathInfo.asLout2[0].abSrcOnOff[MCDRV_SRC_LINE1_M_BLOCK] & MCDRV_SRC1_LINE1_M_ON) == MCDRV_SRC1_LINE1_M_ON))
+	{
+		psVolInfo->aswA_Lin1[0]	= GetLIVolReg(gsGlobalInfo_AA.sVolInfo.aswA_Lin1[0]);
+	}
+	else
+	{
+		psVolInfo->aswA_Lin1[0]	= MCDRV_REG_MUTE;
+	}
+
+	if(((gsGlobalInfo_AA.sPathInfo.asHpOut[1].abSrcOnOff[MCDRV_SRC_LINE1_R_BLOCK] & MCDRV_SRC1_LINE1_R_ON) == MCDRV_SRC1_LINE1_R_ON)
+	|| ((gsGlobalInfo_AA.sPathInfo.asSpOut[1].abSrcOnOff[MCDRV_SRC_LINE1_R_BLOCK] & MCDRV_SRC1_LINE1_R_ON) == MCDRV_SRC1_LINE1_R_ON)
+	|| ((gsGlobalInfo_AA.sPathInfo.asLout1[1].abSrcOnOff[MCDRV_SRC_LINE1_R_BLOCK] & MCDRV_SRC1_LINE1_R_ON) == MCDRV_SRC1_LINE1_R_ON)
+	|| ((gsGlobalInfo_AA.sPathInfo.asLout2[1].abSrcOnOff[MCDRV_SRC_LINE1_R_BLOCK] & MCDRV_SRC1_LINE1_R_ON) == MCDRV_SRC1_LINE1_R_ON))
+	{
+		psVolInfo->aswA_Lin1[1]	= GetLIVolReg(gsGlobalInfo_AA.sVolInfo.aswA_Lin1[1]);
+	}
+	else
+	{
+		psVolInfo->aswA_Lin1[1]	= MCDRV_REG_MUTE;
+	}
+
+	if(McDevProf_IsValid(eMCDRV_FUNC_LI2) == 1)
+	{
+		psVolInfo->aswA_Lin2[0]	= MCDRV_REG_MUTE;
+		psVolInfo->aswA_Lin2[1]	= MCDRV_REG_MUTE;
+	}
+
+	if(McResCtrl_IsSrcUsed_AA(eMCDRV_SRC_MIC1_AA) == 0)
+	{/*	MIC1 is unused	*/
+		for(bCh = 0; bCh < MIC1_VOL_CHANNELS; bCh++)
+		{
+			psVolInfo->aswA_Mic1[bCh]		= MCDRV_REG_MUTE;
+			psVolInfo->aswA_Mic1Gain[bCh]	= (SINT16)(McResCtrl_GetRegVal_AA(MCDRV_PACKET_REGTYPE_B_ANA_AA, MCI_AA_MC_GAIN) & MCB_AA_MC1GAIN);
+		}
+	}
+	else
+	{
+		for(bCh = 0; bCh < MIC1_VOL_CHANNELS; bCh++)
+		{
+			if(((gsGlobalInfo_AA.sPathInfo.asHpOut[0].abSrcOnOff[MCDRV_SRC_MIC1_BLOCK] & MCDRV_SRC0_MIC1_ON) != MCDRV_SRC0_MIC1_ON)
+			&& ((gsGlobalInfo_AA.sPathInfo.asHpOut[1].abSrcOnOff[MCDRV_SRC_MIC1_BLOCK] & MCDRV_SRC0_MIC1_ON) != MCDRV_SRC0_MIC1_ON)
+			&& ((gsGlobalInfo_AA.sPathInfo.asRcOut[0].abSrcOnOff[MCDRV_SRC_MIC1_BLOCK] & MCDRV_SRC0_MIC1_ON) != MCDRV_SRC0_MIC1_ON)
+			&& ((gsGlobalInfo_AA.sPathInfo.asLout1[0].abSrcOnOff[MCDRV_SRC_MIC1_BLOCK] & MCDRV_SRC0_MIC1_ON) != MCDRV_SRC0_MIC1_ON)
+			&& ((gsGlobalInfo_AA.sPathInfo.asLout1[1].abSrcOnOff[MCDRV_SRC_MIC1_BLOCK] & MCDRV_SRC0_MIC1_ON) != MCDRV_SRC0_MIC1_ON)
+			&& ((gsGlobalInfo_AA.sPathInfo.asLout2[0].abSrcOnOff[MCDRV_SRC_MIC1_BLOCK] & MCDRV_SRC0_MIC1_ON) != MCDRV_SRC0_MIC1_ON)
+			&& ((gsGlobalInfo_AA.sPathInfo.asLout2[1].abSrcOnOff[MCDRV_SRC_MIC1_BLOCK] & MCDRV_SRC0_MIC1_ON) != MCDRV_SRC0_MIC1_ON))
+			{
+				psVolInfo->aswA_Mic1[bCh]	= MCDRV_REG_MUTE;
+			}
+			else
+			{
+				psVolInfo->aswA_Mic1[bCh]	= GetMcVolReg(gsGlobalInfo_AA.sVolInfo.aswA_Mic1[bCh]);
+			}
+			psVolInfo->aswA_Mic1Gain[bCh]	= GetMcGainReg(gsGlobalInfo_AA.sVolInfo.aswA_Mic1Gain[bCh]);
+		}
+	}
+	if(McResCtrl_IsSrcUsed_AA(eMCDRV_SRC_MIC2_AA) == 0)
+	{/*	MIC2 is unused	*/
+		for(bCh = 0; bCh < MIC2_VOL_CHANNELS; bCh++)
+		{
+			psVolInfo->aswA_Mic2[bCh]		= MCDRV_REG_MUTE;
+			psVolInfo->aswA_Mic2Gain[bCh]	= (SINT16)((McResCtrl_GetRegVal_AA(MCDRV_PACKET_REGTYPE_B_ANA_AA, MCI_AA_MC_GAIN) & MCB_AA_MC2GAIN) >> 4);
+		}
+	}
+	else
+	{
+		for(bCh = 0; bCh < MIC2_VOL_CHANNELS; bCh++)
+		{
+			if(((gsGlobalInfo_AA.sPathInfo.asHpOut[0].abSrcOnOff[MCDRV_SRC_MIC2_BLOCK] & MCDRV_SRC0_MIC2_ON) != MCDRV_SRC0_MIC2_ON)
+			&& ((gsGlobalInfo_AA.sPathInfo.asHpOut[1].abSrcOnOff[MCDRV_SRC_MIC2_BLOCK] & MCDRV_SRC0_MIC2_ON) != MCDRV_SRC0_MIC2_ON)
+			&& ((gsGlobalInfo_AA.sPathInfo.asRcOut[0].abSrcOnOff[MCDRV_SRC_MIC2_BLOCK] & MCDRV_SRC0_MIC2_ON) != MCDRV_SRC0_MIC2_ON)
+			&& ((gsGlobalInfo_AA.sPathInfo.asLout1[0].abSrcOnOff[MCDRV_SRC_MIC2_BLOCK] & MCDRV_SRC0_MIC2_ON) != MCDRV_SRC0_MIC2_ON)
+			&& ((gsGlobalInfo_AA.sPathInfo.asLout1[1].abSrcOnOff[MCDRV_SRC_MIC2_BLOCK] & MCDRV_SRC0_MIC2_ON) != MCDRV_SRC0_MIC2_ON)
+			&& ((gsGlobalInfo_AA.sPathInfo.asLout2[0].abSrcOnOff[MCDRV_SRC_MIC2_BLOCK] & MCDRV_SRC0_MIC2_ON) != MCDRV_SRC0_MIC2_ON)
+			&& ((gsGlobalInfo_AA.sPathInfo.asLout2[1].abSrcOnOff[MCDRV_SRC_MIC2_BLOCK] & MCDRV_SRC0_MIC2_ON) != MCDRV_SRC0_MIC2_ON))
+			{
+				psVolInfo->aswA_Mic2[bCh]	= MCDRV_REG_MUTE;
+			}
+			else
+			{
+				psVolInfo->aswA_Mic2[bCh]	= GetMcVolReg(gsGlobalInfo_AA.sVolInfo.aswA_Mic2[bCh]);
+			}
+			psVolInfo->aswA_Mic2Gain[bCh]	= GetMcGainReg(gsGlobalInfo_AA.sVolInfo.aswA_Mic2Gain[bCh]);
+		}
+	}
+	if(McResCtrl_IsSrcUsed_AA(eMCDRV_SRC_MIC3_AA) == 0)
+	{/*	MIC3 is unused	*/
+		for(bCh = 0; bCh < MIC3_VOL_CHANNELS; bCh++)
+		{
+			psVolInfo->aswA_Mic3[bCh]		= MCDRV_REG_MUTE;
+			psVolInfo->aswA_Mic3Gain[bCh]	= (SINT16)(McResCtrl_GetRegVal_AA(MCDRV_PACKET_REGTYPE_B_ANA_AA, MCI_AA_MC3_GAIN) & MCB_AA_MC3GAIN);
+		}
+	}
+	else
+	{
+		for(bCh = 0; bCh < MIC3_VOL_CHANNELS; bCh++)
+		{
+			if(((gsGlobalInfo_AA.sPathInfo.asHpOut[0].abSrcOnOff[MCDRV_SRC_MIC3_BLOCK] & MCDRV_SRC0_MIC3_ON) != MCDRV_SRC0_MIC3_ON)
+			&& ((gsGlobalInfo_AA.sPathInfo.asHpOut[1].abSrcOnOff[MCDRV_SRC_MIC3_BLOCK] & MCDRV_SRC0_MIC3_ON) != MCDRV_SRC0_MIC3_ON)
+			&& ((gsGlobalInfo_AA.sPathInfo.asRcOut[0].abSrcOnOff[MCDRV_SRC_MIC3_BLOCK] & MCDRV_SRC0_MIC3_ON) != MCDRV_SRC0_MIC3_ON)
+			&& ((gsGlobalInfo_AA.sPathInfo.asLout1[0].abSrcOnOff[MCDRV_SRC_MIC3_BLOCK] & MCDRV_SRC0_MIC3_ON) != MCDRV_SRC0_MIC3_ON)
+			&& ((gsGlobalInfo_AA.sPathInfo.asLout1[1].abSrcOnOff[MCDRV_SRC_MIC3_BLOCK] & MCDRV_SRC0_MIC3_ON) != MCDRV_SRC0_MIC3_ON)
+			&& ((gsGlobalInfo_AA.sPathInfo.asLout2[0].abSrcOnOff[MCDRV_SRC_MIC3_BLOCK] & MCDRV_SRC0_MIC3_ON) != MCDRV_SRC0_MIC3_ON)
+			&& ((gsGlobalInfo_AA.sPathInfo.asLout2[1].abSrcOnOff[MCDRV_SRC_MIC3_BLOCK] & MCDRV_SRC0_MIC3_ON) != MCDRV_SRC0_MIC3_ON))
+			{
+				psVolInfo->aswA_Mic3[bCh]	= MCDRV_REG_MUTE;
+			}
+			else
+			{
+				psVolInfo->aswA_Mic3[bCh]	= GetMcVolReg(gsGlobalInfo_AA.sVolInfo.aswA_Mic3[bCh]);
+			}
+			psVolInfo->aswA_Mic3Gain[bCh]	= GetMcGainReg(gsGlobalInfo_AA.sVolInfo.aswA_Mic3Gain[bCh]);
+		}
+	}
+
+	if(McResCtrl_IsSrcUsed_AA(eMCDRV_SRC_DIR0_AA) == 0)
+	{/*	DIR0 is unused	*/
+		for(bCh = 0; bCh < DIO0_VOL_CHANNELS; bCh++)
+		{
+			psVolInfo->aswD_Dir0[bCh]		= MCDRV_REG_MUTE;
+		}
+	}
+	else
+	{
+		for(bCh = 0; bCh < DIO0_VOL_CHANNELS; bCh++)
+		{
+			psVolInfo->aswD_Dir0[bCh]		= GetDigitalVolReg(gsGlobalInfo_AA.sVolInfo.aswD_Dir0[bCh] - swGainUp);
+		}
+	}
+	if((gsGlobalInfo_AA.sPathInfo.asMix[0].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK] & MCDRV_SRC3_DIR0_ON) == MCDRV_SRC3_DIR0_ON
+	|| ((gsGlobalInfo_AA.sPathInfo.asMix[0].abSrcOnOff[MCDRV_SRC_AE_BLOCK] & MCDRV_SRC6_AE_ON) == MCDRV_SRC6_AE_ON
+		&& McResCtrl_GetAESource_AA() == eMCDRV_SRC_DIR0_AA))
+	{
+		for(bCh = 0; bCh < DIO0_VOL_CHANNELS; bCh++)
+		{
+			psVolInfo->aswD_Dir0Att[bCh]	= GetDigitalVolReg(gsGlobalInfo_AA.sVolInfo.aswD_Dir0Att[bCh]);
+		}
+	}
+	else
+	{
+		for(bCh = 0; bCh < DIO0_VOL_CHANNELS; bCh++)
+		{
+			psVolInfo->aswD_Dir0Att[bCh]	= MCDRV_REG_MUTE;
+		}
+	}
+	if(McResCtrl_IsSrcUsed_AA(eMCDRV_SRC_DIR1_AA) == 0)
+	{/*	DIR1 is unused	*/
+		for(bCh = 0; bCh < DIO1_VOL_CHANNELS; bCh++)
+		{
+			psVolInfo->aswD_Dir1[bCh]		= MCDRV_REG_MUTE;
+		}
+	}
+	else
+	{
+		for(bCh = 0; bCh < DIO1_VOL_CHANNELS; bCh++)
+		{
+			psVolInfo->aswD_Dir1[bCh]		= GetDigitalVolReg(gsGlobalInfo_AA.sVolInfo.aswD_Dir1[bCh] - swGainUp);
+		}
+	}
+	if((gsGlobalInfo_AA.sPathInfo.asMix[0].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK] & MCDRV_SRC3_DIR1_ON) == MCDRV_SRC3_DIR1_ON
+	|| ((gsGlobalInfo_AA.sPathInfo.asMix[0].abSrcOnOff[MCDRV_SRC_AE_BLOCK] & MCDRV_SRC6_AE_ON) == MCDRV_SRC6_AE_ON
+		&& McResCtrl_GetAESource_AA() == eMCDRV_SRC_DIR1_AA))
+	{
+		for(bCh = 0; bCh < DIO1_VOL_CHANNELS; bCh++)
+		{
+			psVolInfo->aswD_Dir1Att[bCh]	= GetDigitalVolReg(gsGlobalInfo_AA.sVolInfo.aswD_Dir1Att[bCh]);
+		}
+	}
+	else
+	{
+		for(bCh = 0; bCh < DIO1_VOL_CHANNELS; bCh++)
+		{
+			psVolInfo->aswD_Dir1Att[bCh]	= MCDRV_REG_MUTE;
+		}
+	}
+	if(McResCtrl_IsSrcUsed_AA(eMCDRV_SRC_DIR2_AA) == 0)
+	{/*	DIR2 is unused	*/
+		for(bCh = 0; bCh < DIO2_VOL_CHANNELS; bCh++)
+		{
+			psVolInfo->aswD_Dir2[bCh]		= MCDRV_REG_MUTE;
+		}
+	}
+	else
+	{
+		for(bCh = 0; bCh < DIO2_VOL_CHANNELS; bCh++)
+		{
+			psVolInfo->aswD_Dir2[bCh]		= GetDigitalVolReg(gsGlobalInfo_AA.sVolInfo.aswD_Dir2[bCh] - swGainUp);
+		}
+	}
+	if((gsGlobalInfo_AA.sPathInfo.asMix[0].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK] & MCDRV_SRC3_DIR2_ON) == MCDRV_SRC3_DIR2_ON
+	|| ((gsGlobalInfo_AA.sPathInfo.asMix[0].abSrcOnOff[MCDRV_SRC_AE_BLOCK] & MCDRV_SRC6_AE_ON) == MCDRV_SRC6_AE_ON
+		&& McResCtrl_GetAESource_AA() == eMCDRV_SRC_DIR2_AA))
+	{
+		for(bCh = 0; bCh < DIO2_VOL_CHANNELS; bCh++)
+		{
+			psVolInfo->aswD_Dir2Att[bCh]	= GetDigitalVolReg(gsGlobalInfo_AA.sVolInfo.aswD_Dir2Att[bCh]);
+		}
+	}
+	else
+	{
+		for(bCh = 0; bCh < DIO2_VOL_CHANNELS; bCh++)
+		{
+			psVolInfo->aswD_Dir2Att[bCh]	= MCDRV_REG_MUTE;
+		}
+	}
+
+	if(McResCtrl_GetDITSource_AA(eMCDRV_DIO_0_AA) == eMCDRV_SRC_NONE_AA)
+	{/*	DIT0 source all off	*/
+		for(bCh = 0; bCh < DIO0_VOL_CHANNELS; bCh++)
+		{
+			psVolInfo->aswD_Dit0[bCh]	= MCDRV_REG_MUTE;
+		}
+	}
+	else
+	{
+		for(bCh = 0; bCh < DIO0_VOL_CHANNELS; bCh++)
+		{
+			psVolInfo->aswD_Dit0[bCh]	= GetDigitalVolReg(gsGlobalInfo_AA.sVolInfo.aswD_Dit0[bCh] + swGainUp);
+		}
+	}
+	if(McResCtrl_GetDITSource_AA(eMCDRV_DIO_1_AA) == eMCDRV_SRC_NONE_AA)
+	{/*	DIT1 source all off	*/
+		for(bCh = 0; bCh < DIO1_VOL_CHANNELS; bCh++)
+		{
+			psVolInfo->aswD_Dit1[bCh]	= MCDRV_REG_MUTE;
+		}
+	}
+	else
+	{
+		for(bCh = 0; bCh < DIO1_VOL_CHANNELS; bCh++)
+		{
+			psVolInfo->aswD_Dit1[bCh]	= GetDigitalVolReg(gsGlobalInfo_AA.sVolInfo.aswD_Dit1[bCh] + swGainUp);
+		}
+	}
+	if(McResCtrl_GetDITSource_AA(eMCDRV_DIO_2_AA) == eMCDRV_SRC_NONE_AA)
+	{/*	DIT2 source all off	*/
+		for(bCh = 0; bCh < DIO2_VOL_CHANNELS; bCh++)
+		{
+			psVolInfo->aswD_Dit2[bCh]	= MCDRV_REG_MUTE;
+		}
+	}
+	else
+	{
+		for(bCh = 0; bCh < DIO2_VOL_CHANNELS; bCh++)
+		{
+			psVolInfo->aswD_Dit2[bCh]	= GetDigitalVolReg(gsGlobalInfo_AA.sVolInfo.aswD_Dit2[bCh] + swGainUp);
+		}
+	}
+
+	if(McResCtrl_GetDACSource_AA(eMCDRV_DAC_MASTER_AA) == eMCDRV_SRC_NONE_AA
+	&& McResCtrl_GetDACSource_AA(eMCDRV_DAC_VOICE_AA) == eMCDRV_SRC_NONE_AA)
+	{
+		for(bCh = 0; bCh < DAC_VOL_CHANNELS; bCh++)
+		{
+			psVolInfo->aswD_DacAtt[bCh]		= MCDRV_REG_MUTE;
+			psVolInfo->aswD_DacMaster[bCh]	= MCDRV_REG_MUTE;
+			psVolInfo->aswD_DacVoice[bCh]	= MCDRV_REG_MUTE;
+		}
+	}
+	else
+	{
+		if(McResCtrl_GetDACSource_AA(eMCDRV_DAC_MASTER_AA) == eMCDRV_SRC_NONE_AA)
+		{
+			for(bCh = 0; bCh < DAC_VOL_CHANNELS; bCh++)
+			{
+				psVolInfo->aswD_DacMaster[bCh]	= MCDRV_REG_MUTE;
+			}
+		}
+		else
+		{
+			for(bCh = 0; bCh < DAC_VOL_CHANNELS; bCh++)
+			{
+				psVolInfo->aswD_DacMaster[bCh]	= GetDigitalVolReg(gsGlobalInfo_AA.sVolInfo.aswD_DacMaster[bCh]);
+			}
+		}
+		if(McResCtrl_GetDACSource_AA(eMCDRV_DAC_VOICE_AA) == eMCDRV_SRC_NONE_AA)
+		{
+			for(bCh = 0; bCh < DAC_VOL_CHANNELS; bCh++)
+			{
+				psVolInfo->aswD_DacVoice[bCh]	= MCDRV_REG_MUTE;
+			}
+		}
+		else
+		{
+			for(bCh = 0; bCh < DAC_VOL_CHANNELS; bCh++)
+			{
+				psVolInfo->aswD_DacVoice[bCh]	= GetDigitalVolReg(gsGlobalInfo_AA.sVolInfo.aswD_DacVoice[bCh]);
+			}
+		}
+		for(bCh = 0; bCh < DAC_VOL_CHANNELS; bCh++)
+		{
+			psVolInfo->aswD_DacAtt[bCh]	= GetDigitalVolReg(gsGlobalInfo_AA.sVolInfo.aswD_DacAtt[bCh]);
+		}
+	}
+
+	if(McResCtrl_IsSrcUsed_AA(eMCDRV_SRC_PDM_AA) == 0
+	&& McResCtrl_IsSrcUsed_AA(eMCDRV_SRC_ADC0_AA) == 0)
+	{/*	PDM&ADC0 is unused	*/
+		for(bCh = 0; bCh < AENG6_VOL_CHANNELS; bCh++)
+		{
+			psVolInfo->aswD_Aeng6[bCh]	= MCDRV_REG_MUTE;
+		}
+	}
+	else
+	{
+		for(bCh = 0; bCh < AENG6_VOL_CHANNELS; bCh++)
+		{
+			psVolInfo->aswD_Aeng6[bCh]	= GetDigitalVolReg(gsGlobalInfo_AA.sVolInfo.aswD_Aeng6[bCh]);
+		}
+	}
+
+	if(McResCtrl_IsSrcUsed_AA(eMCDRV_SRC_PDM_AA) == 0)
+	{/*	PDM is unused	*/
+		for(bCh = 0; bCh < PDM_VOL_CHANNELS; bCh++)
+		{
+			psVolInfo->aswD_Pdm[bCh]		= MCDRV_REG_MUTE;
+			psVolInfo->aswD_SideTone[bCh]	= MCDRV_REG_MUTE;
+		}
+	}
+	else
+	{
+		for(bCh = 0; bCh < PDM_VOL_CHANNELS; bCh++)
+		{
+			psVolInfo->aswD_Pdm[bCh]		= GetDigitalVolReg(gsGlobalInfo_AA.sVolInfo.aswD_Pdm[bCh] - swGainUp);
+			psVolInfo->aswD_SideTone[bCh]	= GetDigitalVolReg(gsGlobalInfo_AA.sVolInfo.aswD_SideTone[bCh] - swGainUp);
+		}
+	}
+
+	if(McDevProf_IsValid(eMCDRV_FUNC_DTMF) == 1)
+	{
+		/*	DTMF	*/
+		for(bCh = 0; bCh < DTMF_VOL_CHANNELS; bCh++)
+		{
+			psVolInfo->aswD_Dtmfb[bCh]		= GetDigitalVolReg(gsGlobalInfo_AA.sVolInfo.aswD_Dtmfb[bCh] - swGainUp);
+			psVolInfo->aswD_DtmfAtt[bCh]	= GetDigitalVolReg(gsGlobalInfo_AA.sVolInfo.aswD_DtmfAtt[bCh] - swGainUp);
+		}
+	}
+}
+
+/****************************************************************************
+ *	GetDigitalVolReg
+ *
+ *	Description:
+ *			Get value of digital volume registers.
+ *	Arguments:
+ *			swVol	volume(dB value*256)
+ *	Return:
+ *			value of registers
+ *
+ ****************************************************************************/
+static SINT16	GetDigitalVolReg
+(
+	SINT16	swVol
+)
+{
+	SINT16	swRet;
+
+	if(swVol < (-74*256))
+	{
+		swRet	= 0;
+	}
+	else if(swVol < 0)
+	{
+		swRet	= 96 + (swVol-128)/256;
+	}
+	else
+	{
+		swRet	= 96 + (swVol+128)/256;
+	}
+
+	if(swRet < 22)
+	{
+		swRet	= 0;
+	}
+
+	if(swRet > 114)
+	{
+		swRet	= 114;
+	}
+
+	return swRet;
+}
+
+/****************************************************************************
+ *	GetADVolReg
+ *
+ *	Description:
+ *			Get update value of analog AD volume registers.
+ *	Arguments:
+ *			swVol	volume(dB value*256)
+ *	Return:
+ *			value of registers
+ *
+ ****************************************************************************/
+static SINT16	GetADVolReg
+(
+	SINT16	swVol
+)
+{
+	SINT16	swRet;
+
+	if(swVol < (-27*256))
+	{
+		swRet	= 0;
+	}
+	else if(swVol < 0)
+	{
+		swRet	= 19 + (swVol-192) * 2 / (256*3);
+	}
+	else
+	{
+		swRet	= 19 + (swVol+192) * 2 / (256*3);
+	}
+
+	if(swRet < 0)
+	{
+		swRet	= 0;
+	}
+
+	if(swRet > 31)
+	{
+		swRet	= 31;
+	}
+
+	return swRet;
+}
+
+/****************************************************************************
+ *	GetLIVolReg
+ *
+ *	Description:
+ *			Get update value of analog LIN volume registers.
+ *	Arguments:
+ *			swVol	volume(dB value*256)
+ *	Return:
+ *			value of registers
+ *
+ ****************************************************************************/
+static SINT16	GetLIVolReg
+(
+	SINT16	swVol
+)
+{
+	SINT16	swRet;
+
+	if(swVol < (-30*256))
+	{
+		swRet	= 0;
+	}
+	else if(swVol < 0)
+	{
+		swRet	= 21 + (swVol-192) * 2 / (256*3);
+	}
+	else
+	{
+		swRet	= 21 + (swVol+192) * 2 / (256*3);
+	}
+
+	if(swRet < 0)
+	{
+		swRet	= 0;
+	}
+	if(swRet > 31)
+	{
+		swRet	= 31;
+	}
+	return swRet;
+}
+
+/****************************************************************************
+ *	GetMcVolReg
+ *
+ *	Description:
+ *			Get update value of analog Mic volume registers.
+ *	Arguments:
+ *			swVol	volume(dB value*256)
+ *	Return:
+ *			value of registers
+ *
+ ****************************************************************************/
+static SINT16	GetMcVolReg
+(
+	SINT16	swVol
+)
+{
+	SINT16	swRet;
+
+	if(swVol < (-30*256))
+	{
+		swRet	= 0;
+	}
+	else if(swVol < 0)
+	{
+		swRet	= 21 + (swVol-192) * 2 / (256*3);
+	}
+	else
+	{
+		swRet	= 21 + (swVol+192) * 2 / (256*3);
+	}
+
+	if(swRet < 0)
+	{
+		swRet	= 0;
+	}
+	if(swRet > 31)
+	{
+		swRet	= 31;
+	}
+	return swRet;
+}
+
+/****************************************************************************
+ *	GetMcGainReg
+ *
+ *	Description:
+ *			Get update value of analog Mic gain registers.
+ *	Arguments:
+ *			swVol	volume(dB value*256)
+ *	Return:
+ *			value of registers
+ *
+ ****************************************************************************/
+static SINT16	GetMcGainReg
+(
+	SINT16	swVol
+)
+{
+	SINT16	swGain	= (swVol+128)/256;
+
+	if(swGain < 18)
+	{
+		return 0;
+	}
+	if(swGain < 23)
+	{
+		return 1;
+	}
+	if(swGain < 28)
+	{
+		return 2;
+	}
+
+	return 3;
+}
+
+/****************************************************************************
+ *	GetHpVolReg
+ *
+ *	Description:
+ *			Get update value of analog Hp volume registers.
+ *	Arguments:
+ *			swVol	volume(dB value*256)
+ *	Return:
+ *			value of registers
+ *
+ ****************************************************************************/
+static SINT16	GetHpVolReg
+(
+	SINT16	swVol
+)
+{
+	SINT16	swDB	= swVol/256;
+
+	if(swVol >= 0)
+	{
+		return 31;
+	}
+
+	if(swDB <= -8)
+	{
+		if(swVol < (-36*256))
+		{
+			return 0;
+		}
+		if(swDB <= -32)
+		{
+			return 1;
+		}
+		if(swDB <= -26)
+		{
+			return 2;
+		}
+		if(swDB <= -23)
+		{
+			return 3;
+		}
+		if(swDB <= -21)
+		{
+			return 4;
+		}
+		if(swDB <= -19)
+		{
+			return 5;
+		}
+		if(swDB <= -17)
+		{
+			return 6;
+		}
+		return 23+(swVol-128)/256;
+	}
+
+	return 31 + (swVol-64)*2/256;
+}
+
+/****************************************************************************
+ *	GetHpGainReg
+ *
+ *	Description:
+ *			Get update value of analog Hp gain registers.
+ *	Arguments:
+ *			swVol	volume(dB value*256)
+ *	Return:
+ *			value of registers
+ *
+ ****************************************************************************/
+static SINT16	GetHpGainReg
+(
+	SINT16	swVol
+)
+{
+	SINT16	swDB	= swVol/(256/4);
+
+	if(swDB < 3)
+	{
+		return 0;
+	}
+	if(swDB < 9)
+	{
+		return 1;
+	}
+	if(swDB < 18)
+	{
+		return 2;
+	}
+
+	return 3;
+}
+
+/****************************************************************************
+ *	GetSpVolReg
+ *
+ *	Description:
+ *			Get update value of analog Sp volume registers.
+ *	Arguments:
+ *			swVol	volume(dB value*256)
+ *	Return:
+ *			value of registers
+ *
+ ****************************************************************************/
+static SINT16	GetSpVolReg
+(
+	SINT16	swVol
+)
+{
+	SINT16	swDB	= swVol/256;
+
+	if(swVol >= 0)
+	{
+		return 31;
+	}
+
+	if(swDB <= -8)
+	{
+		if(swVol < (-36*256))
+		{
+			return 0;
+		}
+		if(swDB <= -32)
+		{
+			return 1;
+		}
+		if(swDB <= -26)
+		{
+			return 2;
+		}
+		if(swDB <= -23)
+		{
+			return 3;
+		}
+		if(swDB <= -21)
+		{
+			return 4;
+		}
+		if(swDB <= -19)
+		{
+			return 5;
+		}
+		if(swDB <= -17)
+		{
+			return 6;
+		}
+		return 23+(swVol-128)/256;
+	}
+
+	return 31 + (swVol-64)*2/256;
+}
+
+/****************************************************************************
+ *	GetRcVolReg
+ *
+ *	Description:
+ *			Get update value of analog Rcv volume registers.
+ *	Arguments:
+ *			swVol	volume(dB value*256)
+ *	Return:
+ *			value of registers
+ *
+ ****************************************************************************/
+static SINT16	GetRcVolReg
+(
+	SINT16	swVol
+)
+{
+	SINT16	swRet	= 31 + (swVol-128)/256;
+	if(swVol < (-30*256))
+	{
+		swRet	= 0;
+	}
+	if(swRet < 0)
+	{
+		swRet	= 0;
+	}
+	if(swRet > 31)
+	{
+		swRet	= 31;
+	}
+	return swRet;
+}
+
+/****************************************************************************
+ *	GetLoVolReg
+ *
+ *	Description:
+ *			Get update value of analog Lout volume registers.
+ *	Arguments:
+ *			swVol	volume(dB value*256)
+ *	Return:
+ *			value of registers
+ *
+ ****************************************************************************/
+static SINT16	GetLoVolReg
+(
+	SINT16	swVol
+)
+{
+	SINT16	swRet	= 31 + (swVol-128)/256;
+	if(swVol < (-30*256))
+	{
+		swRet	= 0;
+	}
+	if(swRet < 0)
+	{
+		swRet	= 0;
+	}
+	if(swRet > 31)
+	{
+		swRet	= 31;
+	}
+	return swRet;
+}
+
+/****************************************************************************
+ *	McResCtrl_GetPowerInfo_AA
+ *
+ *	Description:
+ *			Get power information.
+ *	Arguments:
+ *			psPowerInfo	power information
+ *	Return:
+ *			none
+ *
+ ****************************************************************************/
+void	McResCtrl_GetPowerInfo_AA
+(
+	MCDRV_POWER_INFO_AA*	psPowerInfo
+)
+{
+	UINT8	i;
+	UINT8	bAnalogOn	= 0;
+	UINT8	bPowerMode	= gsGlobalInfo_AA.sInitInfo.bPowerMode;
+
+	/*	Digital power	*/
+	psPowerInfo->dDigital	= 0;
+	if((bPowerMode & MCDRV_POWMODE_CLKON) == 0)
+	{
+		psPowerInfo->dDigital |= (MCDRV_POWINFO_DIGITAL_DP0_AA | MCDRV_POWINFO_DIGITAL_DP1_AA | MCDRV_POWINFO_DIGITAL_DP2_AA | MCDRV_POWINFO_DIGITAL_PLLRST0_AA);
+	}
+	if(McResCtrl_GetDITSource_AA(eMCDRV_DIO_0_AA)		!= eMCDRV_SRC_NONE_AA
+	|| McResCtrl_GetDITSource_AA(eMCDRV_DIO_1_AA)		!= eMCDRV_SRC_NONE_AA
+	|| McResCtrl_GetDITSource_AA(eMCDRV_DIO_2_AA)		!= eMCDRV_SRC_NONE_AA
+	|| McResCtrl_IsSrcUsed_AA(eMCDRV_SRC_DAC_L_AA)	!= 0
+	|| McResCtrl_IsSrcUsed_AA(eMCDRV_SRC_DAC_M_AA)	!= 0
+	|| McResCtrl_IsSrcUsed_AA(eMCDRV_SRC_DAC_R_AA)	!= 0
+	|| McResCtrl_IsSrcUsed_AA(eMCDRV_SRC_ADC0_AA)		!= 0
+	|| McResCtrl_IsSrcUsed_AA(eMCDRV_SRC_AE_AA)		!= 0
+	|| McResCtrl_IsSrcUsed_AA(eMCDRV_SRC_MIX_AA)		!= 0)
+	{
+		/*	DP0-2, PLLRST0 on	*/
+		psPowerInfo->dDigital &= ~(MCDRV_POWINFO_DIGITAL_DP0_AA | MCDRV_POWINFO_DIGITAL_DP1_AA | MCDRV_POWINFO_DIGITAL_DP2_AA | MCDRV_POWINFO_DIGITAL_PLLRST0_AA);
+	}
+	else
+	{
+		psPowerInfo->dDigital |= MCDRV_POWINFO_DIGITAL_DPB_AA;
+	}
+
+	/*	DPBDSP	*/
+	if(McResCtrl_IsSrcUsed_AA(eMCDRV_SRC_AE_AA) == 0
+	|| (gsGlobalInfo_AA.sAeInfo.bOnOff&(MCDRV_BEXWIDE_ON|MCDRV_DRC_ON)) == 0)
+	{
+		psPowerInfo->dDigital |= MCDRV_POWINFO_DIGITAL_DPBDSP_AA;
+	}
+
+	/*	DPADIF	*/
+	if(McResCtrl_IsSrcUsed_AA(eMCDRV_SRC_ADC0_AA) == 0)
+	{
+		psPowerInfo->dDigital |= MCDRV_POWINFO_DIGITAL_DPADIF_AA;
+	}
+
+	/*	DPPDM	*/
+	if(gsGlobalInfo_AA.sInitInfo.bPad0Func != MCDRV_PAD_PDMCK || McResCtrl_IsSrcUsed_AA(eMCDRV_SRC_PDM_AA) == 0)
+	{
+		psPowerInfo->dDigital |= MCDRV_POWINFO_DIGITAL_DPPDM_AA;
+	}
+
+	/*	DPDI*	*/
+	if(gsGlobalInfo_AA.sDioInfo.asPortInfo[0].sDioCommon.bMasterSlave == MCDRV_DIO_SLAVE
+	|| (McResCtrl_IsSrcUsed_AA(eMCDRV_SRC_DIR0_AA) == 0 && McResCtrl_GetDITSource_AA(eMCDRV_DIO_0_AA) == eMCDRV_SRC_NONE_AA))
+	{
+		psPowerInfo->dDigital |= MCDRV_POWINFO_DIGITAL_DPDI0_AA;
+	}
+	if(gsGlobalInfo_AA.sDioInfo.asPortInfo[1].sDioCommon.bMasterSlave == MCDRV_DIO_SLAVE
+	|| (McResCtrl_IsSrcUsed_AA(eMCDRV_SRC_DIR1_AA) == 0 && McResCtrl_GetDITSource_AA(eMCDRV_DIO_1_AA) == eMCDRV_SRC_NONE_AA))
+	{
+		psPowerInfo->dDigital |= MCDRV_POWINFO_DIGITAL_DPDI1_AA;
+	}
+	if(gsGlobalInfo_AA.sDioInfo.asPortInfo[2].sDioCommon.bMasterSlave == MCDRV_DIO_SLAVE
+	|| (McResCtrl_IsSrcUsed_AA(eMCDRV_SRC_DIR2_AA) == 0 && McResCtrl_GetDITSource_AA(eMCDRV_DIO_2_AA) == eMCDRV_SRC_NONE_AA))
+	{
+		psPowerInfo->dDigital |= MCDRV_POWINFO_DIGITAL_DPDI2_AA;
+	}
+
+	/*	Analog power	*/
+	for(i = 0; i < 5; i++)
+	{
+		psPowerInfo->abAnalog[i]	= 0;
+	}
+
+	/*	SPL*	*/
+	if(McResCtrl_IsDstUsed_AA(eMCDRV_DST_SP_AA, eMCDRV_DST_CH0_AA) == 0)
+	{
+		psPowerInfo->abAnalog[1] |= MCB_AA_PWM_SPL1;
+		psPowerInfo->abAnalog[1] |= MCB_AA_PWM_SPL2;
+	}
+	else
+	{
+		bAnalogOn	= 1;
+	}
+	/*	SPR*	*/
+	if(McResCtrl_IsDstUsed_AA(eMCDRV_DST_SP_AA, eMCDRV_DST_CH1_AA) == 0)
+	{
+		psPowerInfo->abAnalog[1] |= MCB_AA_PWM_SPR1;
+		psPowerInfo->abAnalog[1] |= MCB_AA_PWM_SPR2;
+	}
+	else
+	{
+		bAnalogOn	= 1;
+	}
+
+	/*	HPL	*/
+	if(McResCtrl_IsDstUsed_AA(eMCDRV_DST_HP_AA, eMCDRV_DST_CH0_AA) == 0)
+	{
+		psPowerInfo->abAnalog[1] |= MCB_AA_PWM_HPL;
+	}
+	else
+	{
+		bAnalogOn	= 1;
+	}
+	/*	HPR	*/
+	if(McResCtrl_IsDstUsed_AA(eMCDRV_DST_HP_AA, eMCDRV_DST_CH1_AA) == 0)
+	{
+		psPowerInfo->abAnalog[1] |= MCB_AA_PWM_HPR;
+	}
+	else
+	{
+		bAnalogOn	= 1;
+	}
+	/*	CP	*/
+	if((psPowerInfo->abAnalog[1] & MCB_AA_PWM_HPL) != 0 && (psPowerInfo->abAnalog[1] & MCB_AA_PWM_HPR) != 0)
+	{
+		psPowerInfo->abAnalog[0] |= MCB_AA_PWM_CP;
+	}
+
+	/*	LOUT1L	*/
+	if(McResCtrl_IsDstUsed_AA(eMCDRV_DST_LOUT1_AA, eMCDRV_DST_CH0_AA) == 0)
+	{
+		psPowerInfo->abAnalog[2] |= MCB_AA_PWM_LO1L;
+	}
+	else
+	{
+		bAnalogOn	= 1;
+	}
+	/*	LOUT1R	*/
+	if(McResCtrl_IsDstUsed_AA(eMCDRV_DST_LOUT1_AA, eMCDRV_DST_CH1_AA) == 0)
+	{
+		psPowerInfo->abAnalog[2] |= MCB_AA_PWM_LO1R;
+	}
+	else
+	{
+		bAnalogOn	= 1;
+	}
+	/*	LOUT2L	*/
+	if(McResCtrl_IsDstUsed_AA(eMCDRV_DST_LOUT2_AA, eMCDRV_DST_CH0_AA) == 0)
+	{
+		psPowerInfo->abAnalog[2] |= MCB_AA_PWM_LO2L;
+	}
+	else
+	{
+		bAnalogOn	= 1;
+	}
+	/*	LOUT2R	*/
+	if(McResCtrl_IsDstUsed_AA(eMCDRV_DST_LOUT2_AA, eMCDRV_DST_CH1_AA) == 0)
+	{
+		psPowerInfo->abAnalog[2] |= MCB_AA_PWM_LO2R;
+	}
+	else
+	{
+		bAnalogOn	= 1;
+	}
+	/*	RCV	*/
+	if(McResCtrl_IsDstUsed_AA(eMCDRV_DST_RCV_AA, eMCDRV_DST_CH0_AA) == 0)
+	{
+		psPowerInfo->abAnalog[2] |= MCB_AA_PWM_RC1;
+		psPowerInfo->abAnalog[2] |= MCB_AA_PWM_RC2;
+	}
+	else
+	{
+		bAnalogOn	= 1;
+	}
+	/*	DA	*/
+	if(McResCtrl_IsDstUsed_AA(eMCDRV_DST_DAC_AA, eMCDRV_DST_CH0_AA) == 0
+	&& McResCtrl_IsDstUsed_AA(eMCDRV_DST_DAC_AA, eMCDRV_DST_CH1_AA) == 0)
+	{
+		psPowerInfo->abAnalog[3] |= MCB_AA_PWM_DA;
+	}
+	else
+	{
+		bAnalogOn	= 1;
+	}
+	/*	ADC0L	*/
+	if(McResCtrl_IsDstUsed_AA(eMCDRV_DST_ADC0_AA, eMCDRV_DST_CH0_AA) == 1)
+	{
+		bAnalogOn	= 1;
+	}
+	else
+	{
+		if(McDevProf_IsValid(eMCDRV_FUNC_LI2) == 1
+		&& ((gsGlobalInfo_AA.sPathInfo.asAdc0[0].abSrcOnOff[MCDRV_SRC_LINE2_L_BLOCK] & MCDRV_SRC2_LINE2_L_ON) == MCDRV_SRC2_LINE2_L_ON
+			|| (gsGlobalInfo_AA.sPathInfo.asAdc0[0].abSrcOnOff[MCDRV_SRC_LINE2_M_BLOCK] & MCDRV_SRC2_LINE2_M_ON) == MCDRV_SRC2_LINE2_M_ON))
+		{
+			bAnalogOn	= 1;
+		}
+		else
+		{
+			psPowerInfo->abAnalog[1] |= MCB_AA_PWM_ADL;
+		}
+	}
+	/*	ADC0R	*/
+	if(McResCtrl_IsDstUsed_AA(eMCDRV_DST_ADC0_AA, eMCDRV_DST_CH1_AA) == 1)
+	{
+		bAnalogOn	= 1;
+	}
+	else
+	{
+		if(McDevProf_IsValid(eMCDRV_FUNC_LI2) == 1
+		&& ((gsGlobalInfo_AA.sPathInfo.asAdc0[1].abSrcOnOff[MCDRV_SRC_LINE2_R_BLOCK] & MCDRV_SRC2_LINE2_R_ON) == MCDRV_SRC2_LINE2_R_ON
+			|| (gsGlobalInfo_AA.sPathInfo.asAdc0[1].abSrcOnOff[MCDRV_SRC_LINE2_M_BLOCK] & MCDRV_SRC2_LINE2_M_ON) == MCDRV_SRC2_LINE2_M_ON))
+		{
+			bAnalogOn	= 1;
+		}
+		else
+		{
+			psPowerInfo->abAnalog[1] |= MCB_AA_PWM_ADR;
+		}
+	}
+	if(McDevProf_IsValid(eMCDRV_FUNC_ADC1) == 1)
+	{
+	}
+	/*	LI	*/
+	if(McResCtrl_IsSrcUsed_AA(eMCDRV_SRC_LINE1_L_AA) == 0
+	&& McResCtrl_IsSrcUsed_AA(eMCDRV_SRC_LINE1_M_AA) == 0
+	&& McResCtrl_IsSrcUsed_AA(eMCDRV_SRC_LINE1_R_AA) == 0)
+	{
+		psPowerInfo->abAnalog[4] |= MCB_AA_PWM_LI;
+	}
+	else
+	{
+		bAnalogOn	= 1;
+	}
+	if(McDevProf_IsValid(eMCDRV_FUNC_LI2) == 1)
+	{
+		if(McResCtrl_IsSrcUsed_AA(eMCDRV_SRC_LINE2_L_AA) == 0
+		&& McResCtrl_IsSrcUsed_AA(eMCDRV_SRC_LINE2_M_AA) == 0
+		&& McResCtrl_IsSrcUsed_AA(eMCDRV_SRC_LINE2_R_AA) == 0)
+		{
+			/*psPowerInfo->abAnalog[4] |= MCB_AA_PWM_LI2;*/
+		}
+		else
+		{
+			bAnalogOn	= 1;
+		}
+	}
+	/*	MC1	*/
+	if(McResCtrl_IsSrcUsed_AA(eMCDRV_SRC_MIC1_AA) == 0)
+	{
+		psPowerInfo->abAnalog[4] |= MCB_AA_PWM_MC1;
+	}
+	else
+	{
+		bAnalogOn	= 1;
+	}
+	/*	MC2	*/
+	if(McResCtrl_IsSrcUsed_AA(eMCDRV_SRC_MIC2_AA) == 0)
+	{
+		psPowerInfo->abAnalog[4] |= MCB_AA_PWM_MC2;
+	}
+	else
+	{
+		bAnalogOn	= 1;
+	}
+	/*	MC3	*/
+	if(McResCtrl_IsSrcUsed_AA(eMCDRV_SRC_MIC3_AA) == 0)
+	{
+		psPowerInfo->abAnalog[4] |= MCB_AA_PWM_MC3;
+	}
+	else
+	{
+		bAnalogOn	= 1;
+	}
+	if((gsGlobalInfo_AA.sPathInfo.asBias[0].abSrcOnOff[MCDRV_SRC_MIC1_BLOCK] & MCDRV_SRC0_MIC1_ON) != MCDRV_SRC0_MIC1_ON)
+	{
+		psPowerInfo->abAnalog[3] |= MCB_AA_PWM_MB1;
+	}
+	else
+	{
+		bAnalogOn	= 1;
+	}
+	if((gsGlobalInfo_AA.sPathInfo.asBias[0].abSrcOnOff[MCDRV_SRC_MIC2_BLOCK] & MCDRV_SRC0_MIC2_ON) != MCDRV_SRC0_MIC2_ON)
+	{
+		psPowerInfo->abAnalog[3] |= MCB_AA_PWM_MB2;
+	}
+	else
+	{
+		bAnalogOn	= 1;
+	}
+	if((gsGlobalInfo_AA.sPathInfo.asBias[0].abSrcOnOff[MCDRV_SRC_MIC3_BLOCK] & MCDRV_SRC0_MIC3_ON) != MCDRV_SRC0_MIC3_ON)
+	{
+		psPowerInfo->abAnalog[3] |= MCB_AA_PWM_MB3;
+	}
+	else
+	{
+		bAnalogOn	= 1;
+	}
+
+	/*	VR/LDOA/REFA	*/
+	if ((0 == bAnalogOn) && ((bPowerMode & MCDRV_POWMODE_VREFON) == 0))
+	{
+		psPowerInfo->abAnalog[0] |= MCB_AA_PWM_VR;
+		psPowerInfo->abAnalog[0] |= MCB_AA_PWM_REFA;
+		psPowerInfo->abAnalog[0] |= MCB_AA_PWM_LDOA;
+	}
+	else
+	{
+		if (MCDRV_LDO_OFF == gsGlobalInfo_AA.sInitInfo.bLdo)
+		{
+			psPowerInfo->abAnalog[0] |= MCB_AA_PWM_LDOA;
+		}
+		else
+		{
+			psPowerInfo->abAnalog[0] |= MCB_AA_PWM_REFA;
+		}
+	}
+}
+
+/****************************************************************************
+ *	McResCtrl_GetPowerInfoRegAccess_AA
+ *
+ *	Description:
+ *			Get power information to access register.
+ *	Arguments:
+ *			psRegInfo	register information
+ *			psPowerInfo	power information
+ *	Return:
+ *			none
+ *
+ ****************************************************************************/
+void	McResCtrl_GetPowerInfoRegAccess_AA
+(
+	const MCDRV_REG_INFO*	psRegInfo,
+	MCDRV_POWER_INFO_AA*		psPowerInfo
+)
+{
+
+	McResCtrl_GetPowerInfo_AA(psPowerInfo);
+
+	switch(psRegInfo->bRegType)
+	{
+	default:
+	case	MCDRV_REGTYPE_A:
+	case	MCDRV_REGTYPE_B_BASE:
+	case	MCDRV_REGTYPE_B_AE:
+		break;
+	case	MCDRV_REGTYPE_B_ANALOG:
+		switch(psRegInfo->bAddress)
+		{
+		case	MCI_AA_AMP:
+		case	MCI_AA_DNGATRT:
+		case	MCI_AA_HPVOL_L:
+		case	MCI_AA_HPVOL_R:
+		case	MCI_AA_SPVOL_L:
+		case	MCI_AA_SPVOL_R:
+		case	MCI_AA_RCVOL:
+		case	MCI_AA_ADL_MIX:
+		case	MCI_AA_ADL_MONO:
+		case	MCI_AA_ADR_MIX:
+		case	MCI_AA_ADR_MONO:
+		case	MCI_AA_LO1L_MIX:
+		case	MCI_AA_LO1L_MONO:
+		case	MCI_AA_LO1R_MIX:
+		case	MCI_AA_LO2L_MIX:
+		case	MCI_AA_LO2L_MONO:
+		case	MCI_AA_LO2R_MIX:
+		case	MCI_AA_HPL_MIX:
+		case	MCI_AA_HPL_MONO:
+		case	MCI_AA_HPR_MIX:
+		case	MCI_AA_SPL_MIX:
+		case	MCI_AA_SPL_MONO:
+		case	MCI_AA_SPR_MIX:
+		case	MCI_AA_SPR_MONO:
+		case	MCI_AA_RC_MIX:
+			psPowerInfo->abAnalog[0]	&= (UINT8)~MCB_AA_PWM_VR;
+			break;
+		case	MCI_AA_DNGON:
+			psPowerInfo->dDigital	&= ~(MCDRV_POWINFO_DIGITAL_DP0_AA | MCDRV_POWINFO_DIGITAL_DP1_AA
+												| MCDRV_POWINFO_DIGITAL_DP2_AA | MCDRV_POWINFO_DIGITAL_PLLRST0_AA);
+			break;
+		default:
+			break;
+		}
+		break;
+
+	case	MCDRV_REGTYPE_B_CODEC:
+		if(psRegInfo->bAddress == MCI_AA_DPADIF || psRegInfo->bAddress == MCI_AA_CD_HW_ID)
+		{
+			break;
+		}
+		psPowerInfo->dDigital	&= ~(MCDRV_POWINFO_DIGITAL_DP0_AA | MCDRV_POWINFO_DIGITAL_DP1_AA
+											| MCDRV_POWINFO_DIGITAL_DP2_AA | MCDRV_POWINFO_DIGITAL_PLLRST0_AA | MCDRV_POWINFO_DIGITAL_DPB_AA);
+		break;
+
+	case	MCDRV_REGTYPE_B_MIXER:
+		psPowerInfo->dDigital	&= ~(MCDRV_POWINFO_DIGITAL_DP0_AA | MCDRV_POWINFO_DIGITAL_DP1_AA
+											| MCDRV_POWINFO_DIGITAL_DP2_AA | MCDRV_POWINFO_DIGITAL_PLLRST0_AA | MCDRV_POWINFO_DIGITAL_DPB_AA);
+		break;
+
+	case	MCDRV_REGTYPE_B_CDSP:
+		break;
+	}
+}
+
+/****************************************************************************
+ *	McResCtrl_GetCurPowerInfo_AA
+ *
+ *	Description:
+ *			Get current power setting.
+ *	Arguments:
+ *			psPowerInfo	power information
+ *	Return:
+ *			none
+ *
+ ****************************************************************************/
+void	McResCtrl_GetCurPowerInfo_AA
+(
+	MCDRV_POWER_INFO_AA*	psPowerInfo
+)
+{
+	UINT8	bReg;
+
+
+	psPowerInfo->abAnalog[0]	= gsGlobalInfo_AA.abRegValB_ANA[MCI_AA_PWM_ANALOG_0];
+	psPowerInfo->abAnalog[1]	= gsGlobalInfo_AA.abRegValB_ANA[MCI_AA_PWM_ANALOG_1];
+	psPowerInfo->abAnalog[2]	= gsGlobalInfo_AA.abRegValB_ANA[MCI_AA_PWM_ANALOG_2];
+	psPowerInfo->abAnalog[3]	= gsGlobalInfo_AA.abRegValB_ANA[MCI_AA_PWM_ANALOG_3];
+	psPowerInfo->abAnalog[4]	= gsGlobalInfo_AA.abRegValB_ANA[MCI_AA_PWM_ANALOG_4];
+
+	psPowerInfo->dDigital	= 0;
+	bReg	= gsGlobalInfo_AA.abRegValB_BASE[MCI_AA_PWM_DIGITAL];
+	if((bReg & MCB_AA_PWM_DP0) == MCB_AA_PWM_DP0)
+	{
+		psPowerInfo->dDigital	|= MCDRV_POWINFO_DIGITAL_DP0_AA;
+	}
+	if((bReg & MCB_AA_PWM_DP1) == MCB_AA_PWM_DP1)
+	{
+		psPowerInfo->dDigital	|= MCDRV_POWINFO_DIGITAL_DP1_AA;
+	}
+	if((bReg & MCB_AA_PWM_DP2) == MCB_AA_PWM_DP2)
+	{
+		psPowerInfo->dDigital	|= MCDRV_POWINFO_DIGITAL_DP2_AA;
+	}
+
+	bReg	= gsGlobalInfo_AA.abRegValB_BASE[MCI_AA_PWM_DIGITAL_1];
+	if((bReg & MCB_AA_PWM_DPB) == MCB_AA_PWM_DPB)
+	{
+		psPowerInfo->dDigital	|= MCDRV_POWINFO_DIGITAL_DPB_AA;
+	}
+	if((bReg & MCB_AA_PWM_DPDI0) == MCB_AA_PWM_DPDI0)
+	{
+		psPowerInfo->dDigital	|= MCDRV_POWINFO_DIGITAL_DPDI0_AA;
+	}
+	if((bReg & MCB_AA_PWM_DPDI1) == MCB_AA_PWM_DPDI1)
+	{
+		psPowerInfo->dDigital	|= MCDRV_POWINFO_DIGITAL_DPDI1_AA;
+	}
+	if((bReg & MCB_AA_PWM_DPDI2) == MCB_AA_PWM_DPDI2)
+	{
+		psPowerInfo->dDigital	|= MCDRV_POWINFO_DIGITAL_DPDI2_AA;
+	}
+	if((bReg & MCB_AA_PWM_DPPDM) == MCB_AA_PWM_DPPDM)
+	{
+		psPowerInfo->dDigital	|= MCDRV_POWINFO_DIGITAL_DPPDM_AA;
+	}
+
+	bReg	= gsGlobalInfo_AA.abRegValB_BASE[MCI_AA_PWM_DIGITAL_BDSP];
+	if((bReg & MCB_AA_PWM_DPBDSP) == MCB_AA_PWM_DPBDSP)
+	{
+		psPowerInfo->dDigital	|= MCDRV_POWINFO_DIGITAL_DPBDSP_AA;
+	}
+
+	bReg	= gsGlobalInfo_AA.abRegValB_BASE[MCI_AA_PLL_RST];
+	if((bReg & MCB_AA_PLLRST0) == MCB_AA_PLLRST0)
+	{
+		psPowerInfo->dDigital	|= MCDRV_POWINFO_DIGITAL_PLLRST0_AA;
+	}
+
+	bReg	= gsGlobalInfo_AA.abRegValB_CODEC[MCI_AA_DPADIF];
+	if((bReg & MCB_AA_DPADIF) == MCB_AA_DPADIF)
+	{
+		psPowerInfo->dDigital	|= MCDRV_POWINFO_DIGITAL_DPADIF_AA;
+	}
+}
+
+/****************************************************************************
+ *	McResCtrl_GetDACSource_AA
+ *
+ *	Description:
+ *			Get DAC source information.
+ *	Arguments:
+ *			eCh	0:Master/1:Voice
+ *	Return:
+ *			path source(MCDRV_SRC_TYPE_AA)
+ *
+ ****************************************************************************/
+MCDRV_SRC_TYPE_AA	McResCtrl_GetDACSource_AA
+(
+	MCDRV_DAC_CH_AA	eCh
+)
+{
+
+	if((gsGlobalInfo_AA.sPathInfo.asDac[eCh].abSrcOnOff[MCDRV_SRC_PDM_BLOCK] & MCDRV_SRC4_PDM_ON) == MCDRV_SRC4_PDM_ON)
+	{
+		return eMCDRV_SRC_PDM_AA;
+	}
+	else if((gsGlobalInfo_AA.sPathInfo.asDac[eCh].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK] & MCDRV_SRC4_ADC0_ON) == MCDRV_SRC4_ADC0_ON)
+	{
+		return eMCDRV_SRC_ADC0_AA;
+	}
+	else if((gsGlobalInfo_AA.sPathInfo.asDac[eCh].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK] & MCDRV_SRC3_DIR0_ON) == MCDRV_SRC3_DIR0_ON)
+	{
+		return eMCDRV_SRC_DIR0_AA;
+	}
+	else if((gsGlobalInfo_AA.sPathInfo.asDac[eCh].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK] & MCDRV_SRC3_DIR1_ON) == MCDRV_SRC3_DIR1_ON)
+	{
+		return eMCDRV_SRC_DIR1_AA;
+	}
+	else if((gsGlobalInfo_AA.sPathInfo.asDac[eCh].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK] & MCDRV_SRC3_DIR2_ON) == MCDRV_SRC3_DIR2_ON)
+	{
+		return eMCDRV_SRC_DIR2_AA;
+	}
+	else if((gsGlobalInfo_AA.sPathInfo.asDac[eCh].abSrcOnOff[MCDRV_SRC_MIX_BLOCK] & MCDRV_SRC6_MIX_ON) == MCDRV_SRC6_MIX_ON)
+	{
+		return eMCDRV_SRC_MIX_AA;
+	}
+	else if((gsGlobalInfo_AA.sPathInfo.asDac[eCh].abSrcOnOff[MCDRV_SRC_AE_BLOCK] & MCDRV_SRC6_AE_ON) == MCDRV_SRC6_AE_ON)
+	{
+		return McResCtrl_GetAESource_AA();
+	}
+	return eMCDRV_SRC_NONE_AA;
+}
+
+/****************************************************************************
+ *	McResCtrl_GetDITSource_AA
+ *
+ *	Description:
+ *			Get DIT source information.
+ *	Arguments:
+ *			ePort	port number
+ *	Return:
+ *			path source(MCDRV_SRC_TYPE_AA)
+ *
+ ****************************************************************************/
+MCDRV_SRC_TYPE_AA	McResCtrl_GetDITSource_AA
+(
+	MCDRV_DIO_PORT_NO_AA	ePort
+)
+{
+	MCDRV_CHANNEL*	pasDit;
+
+	if(ePort == 0)
+	{
+		pasDit	= &gsGlobalInfo_AA.sPathInfo.asDit0[0];
+	}
+	else if(ePort == 1)
+	{
+		pasDit	= &gsGlobalInfo_AA.sPathInfo.asDit1[0];
+	}
+	else if(ePort == 2)
+	{
+		pasDit	= &gsGlobalInfo_AA.sPathInfo.asDit2[0];
+	}
+	else
+	{
+		return eMCDRV_SRC_NONE_AA;
+	}
+
+	if((pasDit->abSrcOnOff[MCDRV_SRC_PDM_BLOCK] & MCDRV_SRC4_PDM_ON) == MCDRV_SRC4_PDM_ON)
+	{
+		return eMCDRV_SRC_PDM_AA;
+	}
+	else if((pasDit->abSrcOnOff[MCDRV_SRC_ADC0_BLOCK] & MCDRV_SRC4_ADC0_ON) == MCDRV_SRC4_ADC0_ON)
+	{
+		return eMCDRV_SRC_ADC0_AA;
+	}
+	else if((pasDit->abSrcOnOff[MCDRV_SRC_DIR0_BLOCK] & MCDRV_SRC3_DIR0_ON) == MCDRV_SRC3_DIR0_ON)
+	{
+		return eMCDRV_SRC_DIR0_AA;
+	}
+	else if((pasDit->abSrcOnOff[MCDRV_SRC_DIR1_BLOCK] & MCDRV_SRC3_DIR1_ON) == MCDRV_SRC3_DIR1_ON)
+	{
+		return eMCDRV_SRC_DIR1_AA;
+	}
+	else if((pasDit->abSrcOnOff[MCDRV_SRC_DIR2_BLOCK] & MCDRV_SRC3_DIR2_ON) == MCDRV_SRC3_DIR2_ON)
+	{
+		return eMCDRV_SRC_DIR2_AA;
+	}
+	else if((pasDit->abSrcOnOff[MCDRV_SRC_MIX_BLOCK] & MCDRV_SRC6_MIX_ON) == MCDRV_SRC6_MIX_ON)
+	{
+		return eMCDRV_SRC_MIX_AA;
+	}
+	else if((pasDit->abSrcOnOff[MCDRV_SRC_AE_BLOCK] & MCDRV_SRC6_AE_ON) == MCDRV_SRC6_AE_ON)
+	{
+		return McResCtrl_GetAESource_AA();
+	}
+	return eMCDRV_SRC_NONE_AA;
+}
+
+/****************************************************************************
+ *	McResCtrl_GetAESource_AA
+ *
+ *	Description:
+ *			Get AE source information.
+ *	Arguments:
+ *			none
+ *	Return:
+ *			path source(MCDRV_SRC_TYPE_AA)
+ *
+ ****************************************************************************/
+MCDRV_SRC_TYPE_AA	McResCtrl_GetAESource_AA
+(
+void
+)
+{
+	if((gsGlobalInfo_AA.sPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_PDM_BLOCK] & MCDRV_SRC4_PDM_ON) == MCDRV_SRC4_PDM_ON)
+	{
+		return eMCDRV_SRC_PDM_AA;
+	}
+	else if((gsGlobalInfo_AA.sPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK] & MCDRV_SRC4_ADC0_ON) == MCDRV_SRC4_ADC0_ON)
+	{
+		return eMCDRV_SRC_ADC0_AA;
+	}
+	else if((gsGlobalInfo_AA.sPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK] & MCDRV_SRC3_DIR0_ON) == MCDRV_SRC3_DIR0_ON)
+	{
+		return eMCDRV_SRC_DIR0_AA;
+	}
+	else if((gsGlobalInfo_AA.sPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK] & MCDRV_SRC3_DIR1_ON) == MCDRV_SRC3_DIR1_ON)
+	{
+		return eMCDRV_SRC_DIR1_AA;
+	}
+	else if((gsGlobalInfo_AA.sPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK] & MCDRV_SRC3_DIR2_ON) == MCDRV_SRC3_DIR2_ON)
+	{
+		return eMCDRV_SRC_DIR2_AA;
+	}
+	else if((gsGlobalInfo_AA.sPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_MIX_BLOCK] & MCDRV_SRC6_MIX_ON) == MCDRV_SRC6_MIX_ON)
+	{
+		return eMCDRV_SRC_MIX_AA;
+	}
+	return eMCDRV_SRC_NONE_AA;
+}
+
+/****************************************************************************
+ *	McResCtrl_IsSrcUsed_AA
+ *
+ *	Description:
+ *			Is Src used
+ *	Arguments:
+ *			ePathSrc	path src type
+ *	Return:
+ *			0:unused/1:used
+ *
+ ****************************************************************************/
+UINT8	McResCtrl_IsSrcUsed_AA
+(
+	MCDRV_SRC_TYPE_AA	ePathSrc
+)
+{
+	UINT8	bUsed	= 0;
+
+	switch(ePathSrc)
+	{
+	case	eMCDRV_SRC_MIC1_AA:
+		if((gsGlobalInfo_AA.sPathInfo.asHpOut[0].abSrcOnOff[MCDRV_SRC_MIC1_BLOCK] & MCDRV_SRC0_MIC1_ON) == MCDRV_SRC0_MIC1_ON
+		|| (gsGlobalInfo_AA.sPathInfo.asHpOut[1].abSrcOnOff[MCDRV_SRC_MIC1_BLOCK] & MCDRV_SRC0_MIC1_ON) == MCDRV_SRC0_MIC1_ON
+		|| (gsGlobalInfo_AA.sPathInfo.asRcOut[0].abSrcOnOff[MCDRV_SRC_MIC1_BLOCK] & MCDRV_SRC0_MIC1_ON) == MCDRV_SRC0_MIC1_ON
+		|| (gsGlobalInfo_AA.sPathInfo.asLout1[0].abSrcOnOff[MCDRV_SRC_MIC1_BLOCK] & MCDRV_SRC0_MIC1_ON) == MCDRV_SRC0_MIC1_ON
+		|| (gsGlobalInfo_AA.sPathInfo.asLout1[1].abSrcOnOff[MCDRV_SRC_MIC1_BLOCK] & MCDRV_SRC0_MIC1_ON) == MCDRV_SRC0_MIC1_ON
+		|| (gsGlobalInfo_AA.sPathInfo.asLout2[0].abSrcOnOff[MCDRV_SRC_MIC1_BLOCK] & MCDRV_SRC0_MIC1_ON) == MCDRV_SRC0_MIC1_ON
+		|| (gsGlobalInfo_AA.sPathInfo.asLout2[1].abSrcOnOff[MCDRV_SRC_MIC1_BLOCK] & MCDRV_SRC0_MIC1_ON) == MCDRV_SRC0_MIC1_ON
+		|| (gsGlobalInfo_AA.sPathInfo.asAdc0[0].abSrcOnOff[MCDRV_SRC_MIC1_BLOCK] & MCDRV_SRC0_MIC1_ON) == MCDRV_SRC0_MIC1_ON
+		|| (gsGlobalInfo_AA.sPathInfo.asAdc0[1].abSrcOnOff[MCDRV_SRC_MIC1_BLOCK] & MCDRV_SRC0_MIC1_ON) == MCDRV_SRC0_MIC1_ON)
+		{
+			bUsed	= 1;
+		}
+		break;
+
+	case	eMCDRV_SRC_MIC2_AA:
+		if((gsGlobalInfo_AA.sPathInfo.asHpOut[0].abSrcOnOff[MCDRV_SRC_MIC2_BLOCK] & MCDRV_SRC0_MIC2_ON) == MCDRV_SRC0_MIC2_ON
+		|| (gsGlobalInfo_AA.sPathInfo.asHpOut[1].abSrcOnOff[MCDRV_SRC_MIC2_BLOCK] & MCDRV_SRC0_MIC2_ON) == MCDRV_SRC0_MIC2_ON
+		|| (gsGlobalInfo_AA.sPathInfo.asRcOut[0].abSrcOnOff[MCDRV_SRC_MIC2_BLOCK] & MCDRV_SRC0_MIC2_ON) == MCDRV_SRC0_MIC2_ON
+		|| (gsGlobalInfo_AA.sPathInfo.asLout1[0].abSrcOnOff[MCDRV_SRC_MIC2_BLOCK] & MCDRV_SRC0_MIC2_ON) == MCDRV_SRC0_MIC2_ON
+		|| (gsGlobalInfo_AA.sPathInfo.asLout1[1].abSrcOnOff[MCDRV_SRC_MIC2_BLOCK] & MCDRV_SRC0_MIC2_ON) == MCDRV_SRC0_MIC2_ON
+		|| (gsGlobalInfo_AA.sPathInfo.asLout2[0].abSrcOnOff[MCDRV_SRC_MIC2_BLOCK] & MCDRV_SRC0_MIC2_ON) == MCDRV_SRC0_MIC2_ON
+		|| (gsGlobalInfo_AA.sPathInfo.asLout2[1].abSrcOnOff[MCDRV_SRC_MIC2_BLOCK] & MCDRV_SRC0_MIC2_ON) == MCDRV_SRC0_MIC2_ON
+		|| (gsGlobalInfo_AA.sPathInfo.asAdc0[0].abSrcOnOff[MCDRV_SRC_MIC2_BLOCK] & MCDRV_SRC0_MIC2_ON) == MCDRV_SRC0_MIC2_ON
+		|| (gsGlobalInfo_AA.sPathInfo.asAdc0[1].abSrcOnOff[MCDRV_SRC_MIC2_BLOCK] & MCDRV_SRC0_MIC2_ON) == MCDRV_SRC0_MIC2_ON)
+		{
+			bUsed	= 1;
+		}
+		break;
+
+	case	eMCDRV_SRC_MIC3_AA:
+		if((gsGlobalInfo_AA.sPathInfo.asHpOut[0].abSrcOnOff[MCDRV_SRC_MIC3_BLOCK] & MCDRV_SRC0_MIC3_ON) == MCDRV_SRC0_MIC3_ON
+		|| (gsGlobalInfo_AA.sPathInfo.asHpOut[1].abSrcOnOff[MCDRV_SRC_MIC3_BLOCK] & MCDRV_SRC0_MIC3_ON) == MCDRV_SRC0_MIC3_ON
+		|| (gsGlobalInfo_AA.sPathInfo.asRcOut[0].abSrcOnOff[MCDRV_SRC_MIC3_BLOCK] & MCDRV_SRC0_MIC3_ON) == MCDRV_SRC0_MIC3_ON
+		|| (gsGlobalInfo_AA.sPathInfo.asLout1[0].abSrcOnOff[MCDRV_SRC_MIC3_BLOCK] & MCDRV_SRC0_MIC3_ON) == MCDRV_SRC0_MIC3_ON
+		|| (gsGlobalInfo_AA.sPathInfo.asLout1[1].abSrcOnOff[MCDRV_SRC_MIC3_BLOCK] & MCDRV_SRC0_MIC3_ON) == MCDRV_SRC0_MIC3_ON
+		|| (gsGlobalInfo_AA.sPathInfo.asLout2[0].abSrcOnOff[MCDRV_SRC_MIC3_BLOCK] & MCDRV_SRC0_MIC3_ON) == MCDRV_SRC0_MIC3_ON
+		|| (gsGlobalInfo_AA.sPathInfo.asLout2[1].abSrcOnOff[MCDRV_SRC_MIC3_BLOCK] & MCDRV_SRC0_MIC3_ON) == MCDRV_SRC0_MIC3_ON
+		|| (gsGlobalInfo_AA.sPathInfo.asAdc0[0].abSrcOnOff[MCDRV_SRC_MIC3_BLOCK] & MCDRV_SRC0_MIC3_ON) == MCDRV_SRC0_MIC3_ON
+		|| (gsGlobalInfo_AA.sPathInfo.asAdc0[1].abSrcOnOff[MCDRV_SRC_MIC3_BLOCK] & MCDRV_SRC0_MIC3_ON) == MCDRV_SRC0_MIC3_ON)
+		{
+			bUsed	= 1;
+		}
+		break;
+
+	case	eMCDRV_SRC_LINE1_L_AA:
+		if((gsGlobalInfo_AA.sPathInfo.asHpOut[0].abSrcOnOff[MCDRV_SRC_LINE1_L_BLOCK] & MCDRV_SRC1_LINE1_L_ON) == MCDRV_SRC1_LINE1_L_ON
+		|| (gsGlobalInfo_AA.sPathInfo.asSpOut[0].abSrcOnOff[MCDRV_SRC_LINE1_L_BLOCK] & MCDRV_SRC1_LINE1_L_ON) == MCDRV_SRC1_LINE1_L_ON
+		|| (gsGlobalInfo_AA.sPathInfo.asLout1[0].abSrcOnOff[MCDRV_SRC_LINE1_L_BLOCK] & MCDRV_SRC1_LINE1_L_ON) == MCDRV_SRC1_LINE1_L_ON
+		|| (gsGlobalInfo_AA.sPathInfo.asLout1[0].abSrcOnOff[MCDRV_SRC_LINE1_L_BLOCK] & MCDRV_SRC1_LINE1_L_ON) == MCDRV_SRC1_LINE1_L_ON
+		|| (gsGlobalInfo_AA.sPathInfo.asLout2[0].abSrcOnOff[MCDRV_SRC_LINE1_L_BLOCK] & MCDRV_SRC1_LINE1_L_ON) == MCDRV_SRC1_LINE1_L_ON
+		|| (gsGlobalInfo_AA.sPathInfo.asAdc0[0].abSrcOnOff[MCDRV_SRC_LINE1_L_BLOCK] & MCDRV_SRC1_LINE1_L_ON) == MCDRV_SRC1_LINE1_L_ON)
+		{
+			bUsed	= 1;
+		}
+		break;
+
+	case	eMCDRV_SRC_LINE1_R_AA:
+		if((gsGlobalInfo_AA.sPathInfo.asHpOut[1].abSrcOnOff[MCDRV_SRC_LINE1_R_BLOCK] & MCDRV_SRC1_LINE1_R_ON) == MCDRV_SRC1_LINE1_R_ON
+		|| (gsGlobalInfo_AA.sPathInfo.asSpOut[1].abSrcOnOff[MCDRV_SRC_LINE1_R_BLOCK] & MCDRV_SRC1_LINE1_R_ON) == MCDRV_SRC1_LINE1_R_ON
+		|| (gsGlobalInfo_AA.sPathInfo.asLout1[1].abSrcOnOff[MCDRV_SRC_LINE1_R_BLOCK] & MCDRV_SRC1_LINE1_R_ON) == MCDRV_SRC1_LINE1_R_ON
+		|| (gsGlobalInfo_AA.sPathInfo.asLout2[1].abSrcOnOff[MCDRV_SRC_LINE1_R_BLOCK] & MCDRV_SRC1_LINE1_R_ON) == MCDRV_SRC1_LINE1_R_ON
+		|| (gsGlobalInfo_AA.sPathInfo.asAdc0[1].abSrcOnOff[MCDRV_SRC_LINE1_R_BLOCK] & MCDRV_SRC1_LINE1_R_ON) == MCDRV_SRC1_LINE1_R_ON)
+		{
+			bUsed	= 1;
+		}
+		break;
+
+	case	eMCDRV_SRC_LINE1_M_AA:
+		if((gsGlobalInfo_AA.sPathInfo.asHpOut[0].abSrcOnOff[MCDRV_SRC_LINE1_M_BLOCK] & MCDRV_SRC1_LINE1_M_ON) == MCDRV_SRC1_LINE1_M_ON
+		|| (gsGlobalInfo_AA.sPathInfo.asSpOut[0].abSrcOnOff[MCDRV_SRC_LINE1_M_BLOCK] & MCDRV_SRC1_LINE1_M_ON) == MCDRV_SRC1_LINE1_M_ON
+		|| (gsGlobalInfo_AA.sPathInfo.asSpOut[1].abSrcOnOff[MCDRV_SRC_LINE1_M_BLOCK] & MCDRV_SRC1_LINE1_M_ON) == MCDRV_SRC1_LINE1_M_ON
+		|| (gsGlobalInfo_AA.sPathInfo.asRcOut[0].abSrcOnOff[MCDRV_SRC_LINE1_M_BLOCK] & MCDRV_SRC1_LINE1_M_ON) == MCDRV_SRC1_LINE1_M_ON
+		|| (gsGlobalInfo_AA.sPathInfo.asLout1[0].abSrcOnOff[MCDRV_SRC_LINE1_M_BLOCK] & MCDRV_SRC1_LINE1_M_ON) == MCDRV_SRC1_LINE1_M_ON
+		|| (gsGlobalInfo_AA.sPathInfo.asLout1[0].abSrcOnOff[MCDRV_SRC_LINE1_M_BLOCK] & MCDRV_SRC1_LINE1_M_ON) == MCDRV_SRC1_LINE1_M_ON
+		|| (gsGlobalInfo_AA.sPathInfo.asLout2[0].abSrcOnOff[MCDRV_SRC_LINE1_M_BLOCK] & MCDRV_SRC1_LINE1_M_ON) == MCDRV_SRC1_LINE1_M_ON
+		|| (gsGlobalInfo_AA.sPathInfo.asAdc0[0].abSrcOnOff[MCDRV_SRC_LINE1_M_BLOCK] & MCDRV_SRC1_LINE1_M_ON) == MCDRV_SRC1_LINE1_M_ON
+		|| (gsGlobalInfo_AA.sPathInfo.asAdc0[1].abSrcOnOff[MCDRV_SRC_LINE1_M_BLOCK] & MCDRV_SRC1_LINE1_M_ON) == MCDRV_SRC1_LINE1_M_ON)
+		{
+			bUsed	= 1;
+		}
+		break;
+
+	case	eMCDRV_SRC_LINE2_L_AA:
+		if((gsGlobalInfo_AA.sPathInfo.asHpOut[0].abSrcOnOff[MCDRV_SRC_LINE2_L_BLOCK] & MCDRV_SRC2_LINE2_L_ON) == MCDRV_SRC2_LINE2_L_ON
+		|| (gsGlobalInfo_AA.sPathInfo.asSpOut[0].abSrcOnOff[MCDRV_SRC_LINE2_L_BLOCK] & MCDRV_SRC2_LINE2_L_ON) == MCDRV_SRC2_LINE2_L_ON
+		|| (gsGlobalInfo_AA.sPathInfo.asLout1[0].abSrcOnOff[MCDRV_SRC_LINE2_L_BLOCK] & MCDRV_SRC2_LINE2_L_ON) == MCDRV_SRC2_LINE2_L_ON
+		|| (gsGlobalInfo_AA.sPathInfo.asLout1[0].abSrcOnOff[MCDRV_SRC_LINE2_L_BLOCK] & MCDRV_SRC2_LINE2_L_ON) == MCDRV_SRC2_LINE2_L_ON
+		|| (gsGlobalInfo_AA.sPathInfo.asLout2[0].abSrcOnOff[MCDRV_SRC_LINE2_L_BLOCK] & MCDRV_SRC2_LINE2_L_ON) == MCDRV_SRC2_LINE2_L_ON
+		|| (gsGlobalInfo_AA.sPathInfo.asAdc0[0].abSrcOnOff[MCDRV_SRC_LINE2_L_BLOCK] & MCDRV_SRC2_LINE2_L_ON) == MCDRV_SRC2_LINE2_L_ON)
+		{
+			bUsed	= 1;
+		}
+		break;
+
+	case	eMCDRV_SRC_LINE2_R_AA:
+		if((gsGlobalInfo_AA.sPathInfo.asHpOut[1].abSrcOnOff[MCDRV_SRC_LINE2_R_BLOCK] & MCDRV_SRC2_LINE2_R_ON) == MCDRV_SRC2_LINE2_R_ON
+		|| (gsGlobalInfo_AA.sPathInfo.asSpOut[1].abSrcOnOff[MCDRV_SRC_LINE2_R_BLOCK] & MCDRV_SRC2_LINE2_R_ON) == MCDRV_SRC2_LINE2_R_ON
+		|| (gsGlobalInfo_AA.sPathInfo.asLout1[1].abSrcOnOff[MCDRV_SRC_LINE2_R_BLOCK] & MCDRV_SRC2_LINE2_R_ON) == MCDRV_SRC2_LINE2_R_ON
+		|| (gsGlobalInfo_AA.sPathInfo.asLout2[1].abSrcOnOff[MCDRV_SRC_LINE2_R_BLOCK] & MCDRV_SRC2_LINE2_R_ON) == MCDRV_SRC2_LINE2_R_ON
+		|| (gsGlobalInfo_AA.sPathInfo.asAdc0[1].abSrcOnOff[MCDRV_SRC_LINE2_R_BLOCK] & MCDRV_SRC2_LINE2_R_ON) == MCDRV_SRC2_LINE2_R_ON)
+		{
+			bUsed	= 1;
+		}
+		break;
+
+	case	eMCDRV_SRC_LINE2_M_AA:
+		if((gsGlobalInfo_AA.sPathInfo.asHpOut[0].abSrcOnOff[MCDRV_SRC_LINE2_M_BLOCK] & MCDRV_SRC2_LINE2_M_ON) == MCDRV_SRC2_LINE2_M_ON
+		|| (gsGlobalInfo_AA.sPathInfo.asSpOut[0].abSrcOnOff[MCDRV_SRC_LINE2_M_BLOCK] & MCDRV_SRC2_LINE2_M_ON) == MCDRV_SRC2_LINE2_M_ON
+		|| (gsGlobalInfo_AA.sPathInfo.asSpOut[1].abSrcOnOff[MCDRV_SRC_LINE2_M_BLOCK] & MCDRV_SRC2_LINE2_M_ON) == MCDRV_SRC2_LINE2_M_ON
+		|| (gsGlobalInfo_AA.sPathInfo.asRcOut[0].abSrcOnOff[MCDRV_SRC_LINE2_M_BLOCK] & MCDRV_SRC2_LINE2_M_ON) == MCDRV_SRC2_LINE2_M_ON
+		|| (gsGlobalInfo_AA.sPathInfo.asLout1[0].abSrcOnOff[MCDRV_SRC_LINE2_M_BLOCK] & MCDRV_SRC2_LINE2_M_ON) == MCDRV_SRC2_LINE2_M_ON
+		|| (gsGlobalInfo_AA.sPathInfo.asLout1[0].abSrcOnOff[MCDRV_SRC_LINE2_M_BLOCK] & MCDRV_SRC2_LINE2_M_ON) == MCDRV_SRC2_LINE2_M_ON
+		|| (gsGlobalInfo_AA.sPathInfo.asLout2[0].abSrcOnOff[MCDRV_SRC_LINE2_M_BLOCK] & MCDRV_SRC2_LINE2_M_ON) == MCDRV_SRC2_LINE2_M_ON
+		|| (gsGlobalInfo_AA.sPathInfo.asAdc0[0].abSrcOnOff[MCDRV_SRC_LINE2_M_BLOCK] & MCDRV_SRC2_LINE2_M_ON) == MCDRV_SRC2_LINE2_M_ON
+		|| (gsGlobalInfo_AA.sPathInfo.asAdc0[1].abSrcOnOff[MCDRV_SRC_LINE2_M_BLOCK] & MCDRV_SRC2_LINE2_M_ON) == MCDRV_SRC2_LINE2_M_ON)
+		{
+			bUsed	= 1;
+		}
+		break;
+
+	case	eMCDRV_SRC_DIR0_AA:
+		if((gsGlobalInfo_AA.sPathInfo.asDit0[0].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK] & MCDRV_SRC3_DIR0_ON) == MCDRV_SRC3_DIR0_ON
+		|| (gsGlobalInfo_AA.sPathInfo.asDit1[0].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK] & MCDRV_SRC3_DIR0_ON) == MCDRV_SRC3_DIR0_ON
+		|| (gsGlobalInfo_AA.sPathInfo.asDit2[0].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK] & MCDRV_SRC3_DIR0_ON) == MCDRV_SRC3_DIR0_ON
+		|| (gsGlobalInfo_AA.sPathInfo.asDac[0].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK] & MCDRV_SRC3_DIR0_ON) == MCDRV_SRC3_DIR0_ON
+		|| (gsGlobalInfo_AA.sPathInfo.asDac[1].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK] & MCDRV_SRC3_DIR0_ON) == MCDRV_SRC3_DIR0_ON
+		|| (gsGlobalInfo_AA.sPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK] & MCDRV_SRC3_DIR0_ON) == MCDRV_SRC3_DIR0_ON
+		|| (gsGlobalInfo_AA.sPathInfo.asMix[0].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK] & MCDRV_SRC3_DIR0_ON) == MCDRV_SRC3_DIR0_ON)
+		{
+			bUsed	= 1;
+		}
+		break;
+
+	case	eMCDRV_SRC_DIR1_AA:
+		if((gsGlobalInfo_AA.sPathInfo.asDit0[0].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK] & MCDRV_SRC3_DIR1_ON) == MCDRV_SRC3_DIR1_ON
+		|| (gsGlobalInfo_AA.sPathInfo.asDit1[0].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK] & MCDRV_SRC3_DIR1_ON) == MCDRV_SRC3_DIR1_ON
+		|| (gsGlobalInfo_AA.sPathInfo.asDit2[0].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK] & MCDRV_SRC3_DIR1_ON) == MCDRV_SRC3_DIR1_ON
+		|| (gsGlobalInfo_AA.sPathInfo.asDac[0].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK] & MCDRV_SRC3_DIR1_ON) == MCDRV_SRC3_DIR1_ON
+		|| (gsGlobalInfo_AA.sPathInfo.asDac[1].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK] & MCDRV_SRC3_DIR1_ON) == MCDRV_SRC3_DIR1_ON
+		|| (gsGlobalInfo_AA.sPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK] & MCDRV_SRC3_DIR1_ON) == MCDRV_SRC3_DIR1_ON
+		|| (gsGlobalInfo_AA.sPathInfo.asMix[0].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK] & MCDRV_SRC3_DIR1_ON) == MCDRV_SRC3_DIR1_ON)
+		{
+			bUsed	= 1;
+		}
+		break;
+
+	case	eMCDRV_SRC_DIR2_AA:
+		if((gsGlobalInfo_AA.sPathInfo.asDit0[0].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK] & MCDRV_SRC3_DIR2_ON) == MCDRV_SRC3_DIR2_ON
+		|| (gsGlobalInfo_AA.sPathInfo.asDit1[0].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK] & MCDRV_SRC3_DIR2_ON) == MCDRV_SRC3_DIR2_ON
+		|| (gsGlobalInfo_AA.sPathInfo.asDit2[0].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK] & MCDRV_SRC3_DIR2_ON) == MCDRV_SRC3_DIR2_ON
+		|| (gsGlobalInfo_AA.sPathInfo.asDac[0].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK] & MCDRV_SRC3_DIR2_ON) == MCDRV_SRC3_DIR2_ON
+		|| (gsGlobalInfo_AA.sPathInfo.asDac[1].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK] & MCDRV_SRC3_DIR2_ON) == MCDRV_SRC3_DIR2_ON
+		|| (gsGlobalInfo_AA.sPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK] & MCDRV_SRC3_DIR2_ON) == MCDRV_SRC3_DIR2_ON
+		|| (gsGlobalInfo_AA.sPathInfo.asMix[0].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK] & MCDRV_SRC3_DIR2_ON) == MCDRV_SRC3_DIR2_ON)
+		{
+			bUsed	= 1;
+		}
+		break;
+
+	case	eMCDRV_SRC_DTMF_AA:
+		break;
+
+	case	eMCDRV_SRC_PDM_AA:
+		if((gsGlobalInfo_AA.sPathInfo.asDit0[0].abSrcOnOff[MCDRV_SRC_PDM_BLOCK] & MCDRV_SRC4_PDM_ON) == MCDRV_SRC4_PDM_ON
+		|| (gsGlobalInfo_AA.sPathInfo.asDit1[0].abSrcOnOff[MCDRV_SRC_PDM_BLOCK] & MCDRV_SRC4_PDM_ON) == MCDRV_SRC4_PDM_ON
+		|| (gsGlobalInfo_AA.sPathInfo.asDit2[0].abSrcOnOff[MCDRV_SRC_PDM_BLOCK] & MCDRV_SRC4_PDM_ON) == MCDRV_SRC4_PDM_ON
+		|| (gsGlobalInfo_AA.sPathInfo.asDac[0].abSrcOnOff[MCDRV_SRC_PDM_BLOCK] & MCDRV_SRC4_PDM_ON) == MCDRV_SRC4_PDM_ON
+		|| (gsGlobalInfo_AA.sPathInfo.asDac[1].abSrcOnOff[MCDRV_SRC_PDM_BLOCK] & MCDRV_SRC4_PDM_ON) == MCDRV_SRC4_PDM_ON
+		|| (gsGlobalInfo_AA.sPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_PDM_BLOCK] & MCDRV_SRC4_PDM_ON) == MCDRV_SRC4_PDM_ON
+		|| (gsGlobalInfo_AA.sPathInfo.asMix[0].abSrcOnOff[MCDRV_SRC_PDM_BLOCK] & MCDRV_SRC4_PDM_ON) == MCDRV_SRC4_PDM_ON)
+		{
+			bUsed	= 1;
+		}
+		break;
+
+	case	eMCDRV_SRC_ADC0_AA:
+		if((gsGlobalInfo_AA.sPathInfo.asDit0[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK] & MCDRV_SRC4_ADC0_ON) == MCDRV_SRC4_ADC0_ON
+		|| (gsGlobalInfo_AA.sPathInfo.asDit1[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK] & MCDRV_SRC4_ADC0_ON) == MCDRV_SRC4_ADC0_ON
+		|| (gsGlobalInfo_AA.sPathInfo.asDit2[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK] & MCDRV_SRC4_ADC0_ON) == MCDRV_SRC4_ADC0_ON
+		|| (gsGlobalInfo_AA.sPathInfo.asDac[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK] & MCDRV_SRC4_ADC0_ON) == MCDRV_SRC4_ADC0_ON
+		|| (gsGlobalInfo_AA.sPathInfo.asDac[1].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK] & MCDRV_SRC4_ADC0_ON) == MCDRV_SRC4_ADC0_ON
+		|| (gsGlobalInfo_AA.sPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK] & MCDRV_SRC4_ADC0_ON) == MCDRV_SRC4_ADC0_ON
+		|| (gsGlobalInfo_AA.sPathInfo.asMix[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK] & MCDRV_SRC4_ADC0_ON) == MCDRV_SRC4_ADC0_ON)
+		{
+			bUsed	= 1;
+		}
+		break;
+
+	case	eMCDRV_SRC_ADC1_AA:
+		break;
+
+	case	eMCDRV_SRC_DAC_L_AA:
+		if((gsGlobalInfo_AA.sPathInfo.asHpOut[0].abSrcOnOff[MCDRV_SRC_DAC_L_BLOCK] & MCDRV_SRC5_DAC_L_ON) == MCDRV_SRC5_DAC_L_ON
+		|| (gsGlobalInfo_AA.sPathInfo.asSpOut[0].abSrcOnOff[MCDRV_SRC_DAC_L_BLOCK] & MCDRV_SRC5_DAC_L_ON) == MCDRV_SRC5_DAC_L_ON
+		|| (gsGlobalInfo_AA.sPathInfo.asRcOut[0].abSrcOnOff[MCDRV_SRC_DAC_L_BLOCK] & MCDRV_SRC5_DAC_L_ON) == MCDRV_SRC5_DAC_L_ON
+		|| (gsGlobalInfo_AA.sPathInfo.asLout1[0].abSrcOnOff[MCDRV_SRC_DAC_L_BLOCK] & MCDRV_SRC5_DAC_L_ON) == MCDRV_SRC5_DAC_L_ON
+		|| (gsGlobalInfo_AA.sPathInfo.asLout2[0].abSrcOnOff[MCDRV_SRC_DAC_L_BLOCK] & MCDRV_SRC5_DAC_L_ON) == MCDRV_SRC5_DAC_L_ON)
+		{
+			bUsed	= 1;
+		}
+		break;
+
+	case	eMCDRV_SRC_DAC_R_AA:
+		if((gsGlobalInfo_AA.sPathInfo.asHpOut[1].abSrcOnOff[MCDRV_SRC_DAC_R_BLOCK] & MCDRV_SRC5_DAC_R_ON) == MCDRV_SRC5_DAC_R_ON
+		|| (gsGlobalInfo_AA.sPathInfo.asSpOut[1].abSrcOnOff[MCDRV_SRC_DAC_R_BLOCK] & MCDRV_SRC5_DAC_R_ON) == MCDRV_SRC5_DAC_R_ON
+		|| (gsGlobalInfo_AA.sPathInfo.asRcOut[0].abSrcOnOff[MCDRV_SRC_DAC_R_BLOCK] & MCDRV_SRC5_DAC_R_ON) == MCDRV_SRC5_DAC_R_ON
+		|| (gsGlobalInfo_AA.sPathInfo.asLout1[1].abSrcOnOff[MCDRV_SRC_DAC_R_BLOCK] & MCDRV_SRC5_DAC_R_ON) == MCDRV_SRC5_DAC_R_ON
+		|| (gsGlobalInfo_AA.sPathInfo.asLout2[1].abSrcOnOff[MCDRV_SRC_DAC_R_BLOCK] & MCDRV_SRC5_DAC_R_ON) == MCDRV_SRC5_DAC_R_ON)
+		{
+			bUsed	= 1;
+		}
+		break;
+
+	case	eMCDRV_SRC_DAC_M_AA:
+		if((gsGlobalInfo_AA.sPathInfo.asHpOut[0].abSrcOnOff[MCDRV_SRC_DAC_M_BLOCK] & MCDRV_SRC5_DAC_M_ON) == MCDRV_SRC5_DAC_M_ON
+		|| (gsGlobalInfo_AA.sPathInfo.asSpOut[0].abSrcOnOff[MCDRV_SRC_DAC_M_BLOCK] & MCDRV_SRC5_DAC_M_ON) == MCDRV_SRC5_DAC_M_ON
+		|| (gsGlobalInfo_AA.sPathInfo.asSpOut[1].abSrcOnOff[MCDRV_SRC_DAC_M_BLOCK] & MCDRV_SRC5_DAC_M_ON) == MCDRV_SRC5_DAC_M_ON
+		|| (gsGlobalInfo_AA.sPathInfo.asLout1[0].abSrcOnOff[MCDRV_SRC_DAC_M_BLOCK] & MCDRV_SRC5_DAC_M_ON) == MCDRV_SRC5_DAC_M_ON
+		|| (gsGlobalInfo_AA.sPathInfo.asLout2[0].abSrcOnOff[MCDRV_SRC_DAC_M_BLOCK] & MCDRV_SRC5_DAC_M_ON) == MCDRV_SRC5_DAC_M_ON)
+		{
+			bUsed	= 1;
+		}
+		break;
+
+	case	eMCDRV_SRC_AE_AA:
+		if((gsGlobalInfo_AA.sPathInfo.asDit0[0].abSrcOnOff[MCDRV_SRC_AE_BLOCK] & MCDRV_SRC6_AE_ON) == MCDRV_SRC6_AE_ON
+		|| (gsGlobalInfo_AA.sPathInfo.asDit1[0].abSrcOnOff[MCDRV_SRC_AE_BLOCK] & MCDRV_SRC6_AE_ON) == MCDRV_SRC6_AE_ON
+		|| (gsGlobalInfo_AA.sPathInfo.asDit2[0].abSrcOnOff[MCDRV_SRC_AE_BLOCK] & MCDRV_SRC6_AE_ON) == MCDRV_SRC6_AE_ON
+		|| (gsGlobalInfo_AA.sPathInfo.asDac[0].abSrcOnOff[MCDRV_SRC_AE_BLOCK] & MCDRV_SRC6_AE_ON) == MCDRV_SRC6_AE_ON
+		|| (gsGlobalInfo_AA.sPathInfo.asDac[1].abSrcOnOff[MCDRV_SRC_AE_BLOCK] & MCDRV_SRC6_AE_ON) == MCDRV_SRC6_AE_ON
+		|| (gsGlobalInfo_AA.sPathInfo.asMix[0].abSrcOnOff[MCDRV_SRC_AE_BLOCK] & MCDRV_SRC6_AE_ON) == MCDRV_SRC6_AE_ON)
+		{
+			bUsed	= 1;
+		}
+		break;
+
+	case	eMCDRV_SRC_CDSP_AA:
+		break;
+
+	case	eMCDRV_SRC_MIX_AA:
+		if((gsGlobalInfo_AA.sPathInfo.asDit0[0].abSrcOnOff[MCDRV_SRC_MIX_BLOCK] & MCDRV_SRC6_MIX_ON) == MCDRV_SRC6_MIX_ON
+		|| (gsGlobalInfo_AA.sPathInfo.asDit1[0].abSrcOnOff[MCDRV_SRC_MIX_BLOCK] & MCDRV_SRC6_MIX_ON) == MCDRV_SRC6_MIX_ON
+		|| (gsGlobalInfo_AA.sPathInfo.asDit2[0].abSrcOnOff[MCDRV_SRC_MIX_BLOCK] & MCDRV_SRC6_MIX_ON) == MCDRV_SRC6_MIX_ON
+		|| (gsGlobalInfo_AA.sPathInfo.asDac[0].abSrcOnOff[MCDRV_SRC_MIX_BLOCK] & MCDRV_SRC6_MIX_ON) == MCDRV_SRC6_MIX_ON
+		|| (gsGlobalInfo_AA.sPathInfo.asDac[1].abSrcOnOff[MCDRV_SRC_MIX_BLOCK] & MCDRV_SRC6_MIX_ON) == MCDRV_SRC6_MIX_ON
+		|| (gsGlobalInfo_AA.sPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_MIX_BLOCK] & MCDRV_SRC6_MIX_ON) == MCDRV_SRC6_MIX_ON)
+		{
+			bUsed	= 1;
+		}
+		break;
+
+	case	eMCDRV_SRC_DIR2_DIRECT_AA:
+		break;
+
+	case	eMCDRV_SRC_CDSP_DIRECT_AA:
+		break;
+
+	default:
+		break;
+	}
+
+	return bUsed;
+}
+
+/****************************************************************************
+ *	McResCtrl_IsDstUsed_AA
+ *
+ *	Description:
+ *			Is Destination used
+ *	Arguments:
+ *			eType	path destination
+ *			eCh		channel
+ *	Return:
+ *			0:unused/1:used
+ *
+ ****************************************************************************/
+UINT8	McResCtrl_IsDstUsed_AA
+(
+	MCDRV_DST_TYPE_AA	eType,
+	MCDRV_DST_CH	eCh
+)
+{
+	UINT8	bUsed	= 0;
+
+	switch(eType)
+	{
+	case	eMCDRV_DST_HP_AA:
+		if(eCh == eMCDRV_DST_CH0_AA)
+		{
+			if((gsGlobalInfo_AA.sPathInfo.asHpOut[0].abSrcOnOff[MCDRV_SRC_MIC1_BLOCK] & MCDRV_SRC0_MIC1_ON) == MCDRV_SRC0_MIC1_ON
+			|| (gsGlobalInfo_AA.sPathInfo.asHpOut[0].abSrcOnOff[MCDRV_SRC_MIC2_BLOCK] & MCDRV_SRC0_MIC2_ON) == MCDRV_SRC0_MIC2_ON
+			|| (gsGlobalInfo_AA.sPathInfo.asHpOut[0].abSrcOnOff[MCDRV_SRC_MIC3_BLOCK] & MCDRV_SRC0_MIC3_ON) == MCDRV_SRC0_MIC3_ON
+			|| (gsGlobalInfo_AA.sPathInfo.asHpOut[0].abSrcOnOff[MCDRV_SRC_LINE1_L_BLOCK] & MCDRV_SRC1_LINE1_L_ON) == MCDRV_SRC1_LINE1_L_ON
+			|| (gsGlobalInfo_AA.sPathInfo.asHpOut[0].abSrcOnOff[MCDRV_SRC_LINE1_M_BLOCK] & MCDRV_SRC1_LINE1_M_ON) == MCDRV_SRC1_LINE1_M_ON
+			|| (gsGlobalInfo_AA.sPathInfo.asHpOut[0].abSrcOnOff[MCDRV_SRC_DAC_L_BLOCK] & MCDRV_SRC5_DAC_L_ON) == MCDRV_SRC5_DAC_L_ON
+			|| (gsGlobalInfo_AA.sPathInfo.asHpOut[0].abSrcOnOff[MCDRV_SRC_DAC_M_BLOCK] & MCDRV_SRC5_DAC_M_ON) == MCDRV_SRC5_DAC_M_ON)
+			{
+				bUsed	= 1;
+			}
+		}
+		else if(eCh == eMCDRV_DST_CH1_AA)
+		{
+			if((gsGlobalInfo_AA.sPathInfo.asHpOut[1].abSrcOnOff[MCDRV_SRC_MIC1_BLOCK] & MCDRV_SRC0_MIC1_ON) == MCDRV_SRC0_MIC1_ON
+			|| (gsGlobalInfo_AA.sPathInfo.asHpOut[1].abSrcOnOff[MCDRV_SRC_MIC2_BLOCK] & MCDRV_SRC0_MIC2_ON) == MCDRV_SRC0_MIC2_ON
+			|| (gsGlobalInfo_AA.sPathInfo.asHpOut[1].abSrcOnOff[MCDRV_SRC_MIC3_BLOCK] & MCDRV_SRC0_MIC3_ON) == MCDRV_SRC0_MIC3_ON
+			|| (gsGlobalInfo_AA.sPathInfo.asHpOut[1].abSrcOnOff[MCDRV_SRC_LINE1_R_BLOCK] & MCDRV_SRC1_LINE1_R_ON) == MCDRV_SRC1_LINE1_R_ON
+			|| (gsGlobalInfo_AA.sPathInfo.asHpOut[1].abSrcOnOff[MCDRV_SRC_DAC_R_BLOCK] & MCDRV_SRC5_DAC_R_ON) == MCDRV_SRC5_DAC_R_ON)
+			{
+				bUsed	= 1;
+			}
+		}
+		else
+		{
+		}
+		break;
+
+	case	eMCDRV_DST_SP_AA:
+		if(eCh == eMCDRV_DST_CH0_AA)
+		{
+			if((gsGlobalInfo_AA.sPathInfo.asSpOut[0].abSrcOnOff[MCDRV_SRC_LINE1_L_BLOCK] & MCDRV_SRC1_LINE1_L_ON) == MCDRV_SRC1_LINE1_L_ON
+			|| (gsGlobalInfo_AA.sPathInfo.asSpOut[0].abSrcOnOff[MCDRV_SRC_LINE1_M_BLOCK] & MCDRV_SRC1_LINE1_M_ON) == MCDRV_SRC1_LINE1_M_ON
+			|| (gsGlobalInfo_AA.sPathInfo.asSpOut[0].abSrcOnOff[MCDRV_SRC_DAC_L_BLOCK] & MCDRV_SRC5_DAC_L_ON) == MCDRV_SRC5_DAC_L_ON
+			|| (gsGlobalInfo_AA.sPathInfo.asSpOut[0].abSrcOnOff[MCDRV_SRC_DAC_M_BLOCK] & MCDRV_SRC5_DAC_M_ON) == MCDRV_SRC5_DAC_M_ON)
+			{
+				bUsed	= 1;
+			}
+		}
+		else if(eCh == eMCDRV_DST_CH1_AA)
+		{
+			if((gsGlobalInfo_AA.sPathInfo.asSpOut[1].abSrcOnOff[MCDRV_SRC_LINE1_R_BLOCK] & MCDRV_SRC1_LINE1_R_ON) == MCDRV_SRC1_LINE1_R_ON
+			|| (gsGlobalInfo_AA.sPathInfo.asSpOut[1].abSrcOnOff[MCDRV_SRC_LINE1_M_BLOCK] & MCDRV_SRC1_LINE1_M_ON) == MCDRV_SRC1_LINE1_M_ON
+			|| (gsGlobalInfo_AA.sPathInfo.asSpOut[1].abSrcOnOff[MCDRV_SRC_DAC_R_BLOCK] & MCDRV_SRC5_DAC_R_ON) == MCDRV_SRC5_DAC_R_ON
+			|| (gsGlobalInfo_AA.sPathInfo.asSpOut[1].abSrcOnOff[MCDRV_SRC_DAC_M_BLOCK] & MCDRV_SRC5_DAC_M_ON) == MCDRV_SRC5_DAC_M_ON)
+			{
+				bUsed	= 1;
+			}
+		}
+		else
+		{
+		}
+		break;
+
+	case	eMCDRV_DST_RCV_AA:
+		if(eCh == eMCDRV_DST_CH0_AA)
+		{
+			if((gsGlobalInfo_AA.sPathInfo.asRcOut[0].abSrcOnOff[MCDRV_SRC_MIC1_BLOCK] & MCDRV_SRC0_MIC1_ON) == MCDRV_SRC0_MIC1_ON
+			|| (gsGlobalInfo_AA.sPathInfo.asRcOut[0].abSrcOnOff[MCDRV_SRC_MIC2_BLOCK] & MCDRV_SRC0_MIC2_ON) == MCDRV_SRC0_MIC2_ON
+			|| (gsGlobalInfo_AA.sPathInfo.asRcOut[0].abSrcOnOff[MCDRV_SRC_MIC3_BLOCK] & MCDRV_SRC0_MIC3_ON) == MCDRV_SRC0_MIC3_ON
+			|| (gsGlobalInfo_AA.sPathInfo.asRcOut[0].abSrcOnOff[MCDRV_SRC_LINE1_M_BLOCK] & MCDRV_SRC1_LINE1_M_ON) == MCDRV_SRC1_LINE1_M_ON
+			|| (gsGlobalInfo_AA.sPathInfo.asRcOut[0].abSrcOnOff[MCDRV_SRC_DAC_L_BLOCK] & MCDRV_SRC5_DAC_L_ON) == MCDRV_SRC5_DAC_L_ON
+			|| (gsGlobalInfo_AA.sPathInfo.asRcOut[0].abSrcOnOff[MCDRV_SRC_DAC_R_BLOCK] & MCDRV_SRC5_DAC_R_ON) ==MCDRV_SRC5_DAC_R_ON)
+			{
+				bUsed	= 1;
+			}
+		}
+		else
+		{
+		}
+		break;
+
+	case	eMCDRV_DST_LOUT1_AA:
+		if(eCh == eMCDRV_DST_CH0_AA)
+		{
+			if((gsGlobalInfo_AA.sPathInfo.asLout1[0].abSrcOnOff[MCDRV_SRC_MIC1_BLOCK] & MCDRV_SRC0_MIC1_ON) == MCDRV_SRC0_MIC1_ON
+			|| (gsGlobalInfo_AA.sPathInfo.asLout1[0].abSrcOnOff[MCDRV_SRC_MIC2_BLOCK] & MCDRV_SRC0_MIC2_ON) == MCDRV_SRC0_MIC2_ON
+			|| (gsGlobalInfo_AA.sPathInfo.asLout1[0].abSrcOnOff[MCDRV_SRC_MIC3_BLOCK] & MCDRV_SRC0_MIC3_ON) == MCDRV_SRC0_MIC3_ON
+			|| (gsGlobalInfo_AA.sPathInfo.asLout1[0].abSrcOnOff[MCDRV_SRC_LINE1_L_BLOCK] & MCDRV_SRC1_LINE1_L_ON) == MCDRV_SRC1_LINE1_L_ON
+			|| (gsGlobalInfo_AA.sPathInfo.asLout1[0].abSrcOnOff[MCDRV_SRC_LINE1_M_BLOCK] & MCDRV_SRC1_LINE1_M_ON) == MCDRV_SRC1_LINE1_M_ON
+			|| (gsGlobalInfo_AA.sPathInfo.asLout1[0].abSrcOnOff[MCDRV_SRC_DAC_L_BLOCK] & MCDRV_SRC5_DAC_L_ON) == MCDRV_SRC5_DAC_L_ON
+			|| (gsGlobalInfo_AA.sPathInfo.asLout1[0].abSrcOnOff[MCDRV_SRC_DAC_M_BLOCK] & MCDRV_SRC5_DAC_M_ON) == MCDRV_SRC5_DAC_M_ON)
+			{
+				bUsed	= 1;
+			}
+		}
+		else if(eCh == eMCDRV_DST_CH1_AA)
+		{
+			if((gsGlobalInfo_AA.sPathInfo.asLout1[1].abSrcOnOff[MCDRV_SRC_MIC1_BLOCK] & MCDRV_SRC0_MIC1_ON) == MCDRV_SRC0_MIC1_ON
+			|| (gsGlobalInfo_AA.sPathInfo.asLout1[1].abSrcOnOff[MCDRV_SRC_MIC2_BLOCK] & MCDRV_SRC0_MIC2_ON) == MCDRV_SRC0_MIC2_ON
+			|| (gsGlobalInfo_AA.sPathInfo.asLout1[1].abSrcOnOff[MCDRV_SRC_MIC3_BLOCK] & MCDRV_SRC0_MIC3_ON) == MCDRV_SRC0_MIC3_ON
+			|| (gsGlobalInfo_AA.sPathInfo.asLout1[1].abSrcOnOff[MCDRV_SRC_LINE1_R_BLOCK] & MCDRV_SRC1_LINE1_R_ON) == MCDRV_SRC1_LINE1_R_ON
+			|| (gsGlobalInfo_AA.sPathInfo.asLout1[1].abSrcOnOff[MCDRV_SRC_DAC_R_BLOCK] & MCDRV_SRC5_DAC_R_ON) == MCDRV_SRC5_DAC_R_ON)
+			{
+				bUsed	= 1;
+			}
+		}
+		else
+		{
+		}
+		break;
+
+	case	eMCDRV_DST_LOUT2_AA:
+		if(eCh == eMCDRV_DST_CH0_AA)
+		{
+			if((gsGlobalInfo_AA.sPathInfo.asLout2[0].abSrcOnOff[MCDRV_SRC_MIC1_BLOCK] & MCDRV_SRC0_MIC1_ON) == MCDRV_SRC0_MIC1_ON
+			|| (gsGlobalInfo_AA.sPathInfo.asLout2[0].abSrcOnOff[MCDRV_SRC_MIC2_BLOCK] & MCDRV_SRC0_MIC2_ON) == MCDRV_SRC0_MIC2_ON
+			|| (gsGlobalInfo_AA.sPathInfo.asLout2[0].abSrcOnOff[MCDRV_SRC_MIC3_BLOCK] & MCDRV_SRC0_MIC3_ON) == MCDRV_SRC0_MIC3_ON
+			|| (gsGlobalInfo_AA.sPathInfo.asLout2[0].abSrcOnOff[MCDRV_SRC_LINE1_L_BLOCK] & MCDRV_SRC1_LINE1_L_ON) == MCDRV_SRC1_LINE1_L_ON
+			|| (gsGlobalInfo_AA.sPathInfo.asLout2[0].abSrcOnOff[MCDRV_SRC_LINE1_M_BLOCK] & MCDRV_SRC1_LINE1_M_ON) == MCDRV_SRC1_LINE1_M_ON
+			|| (gsGlobalInfo_AA.sPathInfo.asLout2[0].abSrcOnOff[MCDRV_SRC_DAC_L_BLOCK] & MCDRV_SRC5_DAC_L_ON) == MCDRV_SRC5_DAC_L_ON
+			|| (gsGlobalInfo_AA.sPathInfo.asLout2[0].abSrcOnOff[MCDRV_SRC_DAC_M_BLOCK] & MCDRV_SRC5_DAC_M_ON) == MCDRV_SRC5_DAC_M_ON)
+			{
+				bUsed	= 1;
+			}
+		}
+		else if(eCh == eMCDRV_DST_CH1_AA)
+		{
+			if((gsGlobalInfo_AA.sPathInfo.asLout2[1].abSrcOnOff[MCDRV_SRC_MIC1_BLOCK] & MCDRV_SRC0_MIC1_ON) == MCDRV_SRC0_MIC1_ON
+			|| (gsGlobalInfo_AA.sPathInfo.asLout2[1].abSrcOnOff[MCDRV_SRC_MIC2_BLOCK] & MCDRV_SRC0_MIC2_ON) == MCDRV_SRC0_MIC2_ON
+			|| (gsGlobalInfo_AA.sPathInfo.asLout2[1].abSrcOnOff[MCDRV_SRC_MIC3_BLOCK] & MCDRV_SRC0_MIC3_ON) == MCDRV_SRC0_MIC3_ON
+			|| (gsGlobalInfo_AA.sPathInfo.asLout2[1].abSrcOnOff[MCDRV_SRC_LINE1_R_BLOCK] & MCDRV_SRC1_LINE1_R_ON) == MCDRV_SRC1_LINE1_R_ON
+			|| (gsGlobalInfo_AA.sPathInfo.asLout2[1].abSrcOnOff[MCDRV_SRC_DAC_R_BLOCK] & MCDRV_SRC5_DAC_R_ON) == MCDRV_SRC5_DAC_R_ON)
+			{
+				bUsed	= 1;
+			}
+		}
+		else
+		{
+		}
+		break;
+
+	case	eMCDRV_DST_PEAK_AA:
+		break;
+
+	case	eMCDRV_DST_DIT0_AA:
+		if(eCh == eMCDRV_DST_CH0_AA)
+		{
+			if(McResCtrl_GetDITSource_AA(eMCDRV_DIO_0_AA) != eMCDRV_SRC_NONE_AA)
+			{
+				bUsed	= 1;
+			}
+		}
+		else
+		{
+		}
+		break;
+
+	case	eMCDRV_DST_DIT1_AA:
+		if(eCh == eMCDRV_DST_CH0_AA)
+		{
+			if(McResCtrl_GetDITSource_AA(eMCDRV_DIO_1_AA) != eMCDRV_SRC_NONE_AA)
+			{
+				bUsed	= 1;
+			}
+		}
+		else
+		{
+		}
+		break;
+
+	case	eMCDRV_DST_DIT2_AA:
+		if(eCh == eMCDRV_DST_CH0_AA)
+		{
+			if(McResCtrl_GetDITSource_AA(eMCDRV_DIO_2_AA) != eMCDRV_SRC_NONE_AA)
+			{
+				bUsed	= 1;
+			}
+		}
+		else
+		{
+		}
+		break;
+
+	case	eMCDRV_DST_DAC_AA:
+		if(eCh == eMCDRV_DST_CH0_AA)
+		{
+			if(McResCtrl_GetDACSource_AA(eMCDRV_DAC_MASTER_AA) != eMCDRV_SRC_NONE_AA)
+			{
+				bUsed	= 1;
+			}
+		}
+		else if(eCh == eMCDRV_DST_CH1_AA)
+		{
+			if(McResCtrl_GetDACSource_AA(eMCDRV_DAC_VOICE_AA) != eMCDRV_SRC_NONE_AA)
+			{
+				bUsed	= 1;
+			}
+		}
+		else
+		{
+		}
+		break;
+
+	case	eMCDRV_DST_AE_AA:
+		if(eCh == eMCDRV_DST_CH0_AA)
+		{
+			if(McResCtrl_GetAESource_AA() != eMCDRV_SRC_NONE_AA)
+			{
+				bUsed	= 1;
+			}
+		}
+		else
+		{
+		}
+		break;
+
+	case	eMCDRV_DST_CDSP_AA:
+		break;
+
+	case	eMCDRV_DST_ADC0_AA:
+		if(eCh == eMCDRV_DST_CH0_AA)
+		{
+			if((gsGlobalInfo_AA.sPathInfo.asAdc0[0].abSrcOnOff[MCDRV_SRC_MIC1_BLOCK] & MCDRV_SRC0_MIC1_ON) == MCDRV_SRC0_MIC1_ON
+			|| (gsGlobalInfo_AA.sPathInfo.asAdc0[0].abSrcOnOff[MCDRV_SRC_MIC2_BLOCK] & MCDRV_SRC0_MIC2_ON) == MCDRV_SRC0_MIC2_ON
+			|| (gsGlobalInfo_AA.sPathInfo.asAdc0[0].abSrcOnOff[MCDRV_SRC_MIC3_BLOCK] & MCDRV_SRC0_MIC3_ON) == MCDRV_SRC0_MIC3_ON
+			|| (gsGlobalInfo_AA.sPathInfo.asAdc0[0].abSrcOnOff[MCDRV_SRC_LINE1_L_BLOCK] & MCDRV_SRC1_LINE1_L_ON) == MCDRV_SRC1_LINE1_L_ON
+			|| (gsGlobalInfo_AA.sPathInfo.asAdc0[0].abSrcOnOff[MCDRV_SRC_LINE1_M_BLOCK] & MCDRV_SRC1_LINE1_M_ON) == MCDRV_SRC1_LINE1_M_ON)
+			{
+				bUsed	= 1;
+			}
+		}
+		else if(eCh == eMCDRV_DST_CH1_AA)
+		{
+			if((gsGlobalInfo_AA.sPathInfo.asAdc0[1].abSrcOnOff[MCDRV_SRC_MIC1_BLOCK] & MCDRV_SRC0_MIC1_ON) == MCDRV_SRC0_MIC1_ON
+			|| (gsGlobalInfo_AA.sPathInfo.asAdc0[1].abSrcOnOff[MCDRV_SRC_MIC2_BLOCK] & MCDRV_SRC0_MIC2_ON) == MCDRV_SRC0_MIC2_ON
+			|| (gsGlobalInfo_AA.sPathInfo.asAdc0[1].abSrcOnOff[MCDRV_SRC_MIC3_BLOCK] & MCDRV_SRC0_MIC3_ON) == MCDRV_SRC0_MIC3_ON
+			|| (gsGlobalInfo_AA.sPathInfo.asAdc0[1].abSrcOnOff[MCDRV_SRC_LINE1_R_BLOCK] & MCDRV_SRC1_LINE1_R_ON) == MCDRV_SRC1_LINE1_R_ON
+			|| (gsGlobalInfo_AA.sPathInfo.asAdc0[1].abSrcOnOff[MCDRV_SRC_LINE1_M_BLOCK] & MCDRV_SRC1_LINE1_M_ON) == MCDRV_SRC1_LINE1_M_ON)
+			{
+				bUsed	= 1;
+			}
+		}
+		else
+		{
+		}
+		break;
+
+	case	eMCDRV_DST_ADC1_AA:
+		if(McDevProf_IsValid(eMCDRV_FUNC_ADC1) == 1)
+		{
+			if(eCh == eMCDRV_DST_CH0_AA)
+			{
+				if((gsGlobalInfo_AA.sPathInfo.asAdc1[0].abSrcOnOff[MCDRV_SRC_MIC1_BLOCK] & MCDRV_SRC0_MIC1_ON) == MCDRV_SRC0_MIC1_ON
+				|| (gsGlobalInfo_AA.sPathInfo.asAdc1[0].abSrcOnOff[MCDRV_SRC_MIC2_BLOCK] & MCDRV_SRC0_MIC2_ON) == MCDRV_SRC0_MIC2_ON
+				|| (gsGlobalInfo_AA.sPathInfo.asAdc1[0].abSrcOnOff[MCDRV_SRC_MIC3_BLOCK] & MCDRV_SRC0_MIC3_ON) == MCDRV_SRC0_MIC3_ON
+				|| (gsGlobalInfo_AA.sPathInfo.asAdc1[0].abSrcOnOff[MCDRV_SRC_LINE1_L_BLOCK] & MCDRV_SRC1_LINE1_L_ON) == MCDRV_SRC1_LINE1_L_ON
+				|| (gsGlobalInfo_AA.sPathInfo.asAdc1[0].abSrcOnOff[MCDRV_SRC_LINE1_M_BLOCK] & MCDRV_SRC1_LINE1_M_ON) == MCDRV_SRC1_LINE1_M_ON)
+				{
+					bUsed	= 1;
+				}
+			}
+			else
+			{
+			}
+		}
+		break;
+
+	case	eMCDRV_DST_MIX_AA:
+		if(eCh != 0)
+		{
+			break;
+		}
+		if((gsGlobalInfo_AA.sPathInfo.asMix[0].abSrcOnOff[MCDRV_SRC_PDM_BLOCK] & MCDRV_SRC4_PDM_ON) == MCDRV_SRC4_PDM_ON
+		|| (gsGlobalInfo_AA.sPathInfo.asMix[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK] & MCDRV_SRC4_ADC0_ON) == MCDRV_SRC4_ADC0_ON
+		|| (gsGlobalInfo_AA.sPathInfo.asMix[0].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK] & MCDRV_SRC3_DIR0_ON) == MCDRV_SRC3_DIR0_ON
+		|| (gsGlobalInfo_AA.sPathInfo.asMix[0].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK] & MCDRV_SRC3_DIR1_ON) == MCDRV_SRC3_DIR1_ON
+		|| (gsGlobalInfo_AA.sPathInfo.asMix[0].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK] & MCDRV_SRC3_DIR2_ON) == MCDRV_SRC3_DIR2_ON
+		|| (gsGlobalInfo_AA.sPathInfo.asMix[0].abSrcOnOff[MCDRV_SRC_AE_BLOCK] & MCDRV_SRC6_AE_ON) == MCDRV_SRC6_AE_ON)
+		{
+			bUsed	= 1;
+		}
+		break;
+
+	case	eMCDRV_DST_BIAS_AA:
+		if(eCh == eMCDRV_DST_CH0_AA)
+		{
+			if((gsGlobalInfo_AA.sPathInfo.asBias[0].abSrcOnOff[MCDRV_SRC_MIC1_BLOCK] & MCDRV_SRC0_MIC1_ON) == MCDRV_SRC0_MIC1_ON
+			|| (gsGlobalInfo_AA.sPathInfo.asBias[0].abSrcOnOff[MCDRV_SRC_MIC2_BLOCK] & MCDRV_SRC0_MIC2_ON) == MCDRV_SRC0_MIC2_ON
+			|| (gsGlobalInfo_AA.sPathInfo.asBias[0].abSrcOnOff[MCDRV_SRC_MIC3_BLOCK] & MCDRV_SRC0_MIC3_ON) == MCDRV_SRC0_MIC3_ON)
+			{
+				bUsed	= 1;
+			}
+		}
+		else
+		{
+		}
+		break;
+
+	default:
+		break;
+	}
+
+	return bUsed;
+}
+
+/****************************************************************************
+ *	McResCtrl_GetRegAccess_AA
+ *
+ *	Description:
+ *			Get register access availability
+ *	Arguments:
+ *			psRegInfo	register information
+ *	Return:
+ *			MCDRV_REG_ACCSESS_AA
+ *
+ ****************************************************************************/
+MCDRV_REG_ACCSESS_AA	McResCtrl_GetRegAccess_AA
+(
+	const MCDRV_REG_INFO*	psRegInfo
+)
+{
+	switch(psRegInfo->bRegType)
+	{
+	case	MCDRV_REGTYPE_A:
+		return gawRegAccessAvailableA[psRegInfo->bAddress];
+
+	case	MCDRV_REGTYPE_B_BASE:
+		return gawRegAccessAvailableB_BASE[psRegInfo->bAddress];
+
+	case	MCDRV_REGTYPE_B_ANALOG:
+		return gawRegAccessAvailableB_ANA[psRegInfo->bAddress];
+
+	case	MCDRV_REGTYPE_B_CODEC:
+		return gawRegAccessAvailableB_CODEC[psRegInfo->bAddress];
+
+	case	MCDRV_REGTYPE_B_MIXER:
+		return gawRegAccessAvailableB_MIX[psRegInfo->bAddress];
+
+	case	MCDRV_REGTYPE_B_AE:
+		return gawRegAccessAvailableB_AE[psRegInfo->bAddress];
+
+	default:
+		break;
+	}
+	return eMCDRV_ACCESS_DENY_AA;
+}
+
+/****************************************************************************
+ *	McResCtrl_GetAPMode_AA
+ *
+ *	Description:
+ *			get auto power management mode.
+ *	Arguments:
+ *			none
+ *	Return:
+ *			eMCDRV_APM_ON_AA
+ *			eMCDRV_APM_OFF
+ *
+ ****************************************************************************/
+MCDRV_PMODE_AA	McResCtrl_GetAPMode_AA
+(
+	void
+)
+{
+	return gsGlobalInfo_AA.eAPMode;
+}
+
+
+/****************************************************************************
+ *	McResCtrl_AllocPacketBuf_AA
+ *
+ *	Description:
+ *			allocate the buffer for register setting packets.
+ *	Arguments:
+ *			none
+ *	Return:
+ *			pointer to the area to store packets
+ *
+ ****************************************************************************/
+MCDRV_PACKET_AA*	McResCtrl_AllocPacketBuf_AA
+(
+	void
+)
+{
+	if(eMCDRV_PACKETBUF_ALLOCATED_AA == gsGlobalInfo_AA.ePacketBufAlloc)
+	{
+		return NULL;
+	}
+
+	gsGlobalInfo_AA.ePacketBufAlloc = eMCDRV_PACKETBUF_ALLOCATED_AA;
+	return gasPacket;
+}
+
+/****************************************************************************
+ *	McResCtrl_ReleasePacketBuf_AA
+ *
+ *	Description:
+ *			Release the buffer for register setting packets.
+ *	Arguments:
+ *			none
+ *	Return:
+ *			none
+ *
+ ****************************************************************************/
+void	McResCtrl_ReleasePacketBuf_AA
+(
+	void
+)
+{
+	gsGlobalInfo_AA.ePacketBufAlloc = eMCDRV_PACKETBUF_FREE_AA;
+}
+
+/****************************************************************************
+ *	McResCtrl_InitRegUpdate_AA
+ *
+ *	Description:
+ *			Initialize the process of register update.
+ *	Arguments:
+ *			none
+ *	Return:
+ *			none
+ *
+ ****************************************************************************/
+void	McResCtrl_InitRegUpdate_AA
+(
+	void
+)
+{
+	gsGlobalInfo_AA.sCtrlPacket.wDataNum	= 0;
+	gsGlobalInfo_AA.wCurSlaveAddress		= 0xFFFF;
+	gsGlobalInfo_AA.wCurRegType			= 0xFFFF;
+	gsGlobalInfo_AA.wCurRegAddress			= 0xFFFF;
+	gsGlobalInfo_AA.wDataContinueCount		= 0;
+	gsGlobalInfo_AA.wPrevAddressIndex		= 0;
+}
+
+/****************************************************************************
+ *	McResCtrl_AddRegUpdate_AA
+ *
+ *	Description:
+ *			Add register update packet and save register value.
+ *	Arguments:
+ *			wRegType	register type
+ *			wAddress	address
+ *			bData		write data
+ *			eUpdateMode	updete mode
+ *	Return:
+ *			none
+ *
+ ****************************************************************************/
+void	McResCtrl_AddRegUpdate_AA
+(
+	UINT16	wRegType,
+	UINT16	wAddress,
+	UINT8	bData,
+	MCDRV_UPDATE_MODE_AA	eUpdateMode
+)
+{
+	UINT8			*pbRegVal;
+	UINT8			bAddressADR;
+	UINT8			bAddressWINDOW;
+	UINT8			*pbCtrlData;
+	UINT16			*pwCtrlDataNum;
+	const UINT16	*pwNextAddress;
+	UINT16			wNextAddress;
+	UINT16			wSlaveAddress;
+
+	switch (wRegType)
+	{
+	case MCDRV_PACKET_REGTYPE_A_AA:
+		wSlaveAddress	= McDevProf_GetSlaveAddr(eMCDRV_SLAVE_ADDR_DIG);
+		pbRegVal		= gsGlobalInfo_AA.abRegValA;
+		pwNextAddress	= gawNextAddressA;
+		bAddressADR		= (UINT8)wAddress;
+		bAddressWINDOW	= bAddressADR;
+		if(MCDRV_A_REG_NUM_AA <= wAddress)
+		{
+			return;
+		}
+		break;
+
+	case MCDRV_PACKET_REGTYPE_B_BASE_AA:
+		wSlaveAddress	= McDevProf_GetSlaveAddr(eMCDRV_SLAVE_ADDR_DIG);
+		pbRegVal		= gsGlobalInfo_AA.abRegValB_BASE;
+		pwNextAddress	= gawNextAddressB_BASE;
+		bAddressADR		= MCI_AA_BASE_ADR;
+		bAddressWINDOW	= MCI_AA_BASE_WINDOW;
+		if(MCDRV_B_BASE_REG_NUM_AA <= wAddress)
+		{
+			return;
+		}
+		break;
+
+	case MCDRV_PACKET_REGTYPE_B_CODEC_AA:
+		wSlaveAddress	= McDevProf_GetSlaveAddr(eMCDRV_SLAVE_ADDR_DIG);
+		pbRegVal		= gsGlobalInfo_AA.abRegValB_CODEC;
+		pwNextAddress	= gawNextAddressB_CODEC;
+		bAddressADR		= MCI_AA_CD_ADR;
+		bAddressWINDOW	= MCI_AA_CD_WINDOW;
+		if(MCDRV_B_CODEC_REG_NUM_AA <= wAddress)
+		{
+			return;
+		}
+		break;
+
+	case MCDRV_PACKET_REGTYPE_B_ANA_AA:
+		wSlaveAddress	= McDevProf_GetSlaveAddr(eMCDRV_SLAVE_ADDR_ANA);
+		pbRegVal		= gsGlobalInfo_AA.abRegValB_ANA;
+		pwNextAddress	= gawNextAddressB_Ana;
+		bAddressADR		= MCI_AA_ANA_ADR;
+		bAddressWINDOW	= MCI_AA_ANA_WINDOW;
+		if(MCDRV_B_ANA_REG_NUM_AA <= wAddress)
+		{
+			return;
+		}
+		break;
+
+	case MCDRV_PACKET_REGTYPE_B_MIXER_AA:
+		wSlaveAddress	= McDevProf_GetSlaveAddr(eMCDRV_SLAVE_ADDR_DIG);
+		pbRegVal		= gsGlobalInfo_AA.abRegValB_MIXER;
+		pwNextAddress	= gawNextAddressB_MIXER;
+		bAddressADR		= MCI_AA_MIX_ADR;
+		bAddressWINDOW	= MCI_AA_MIX_WINDOW;
+		if(MCDRV_B_MIXER_REG_NUM_AA <= wAddress)
+		{
+			return;
+		}
+		break;
+
+	case MCDRV_PACKET_REGTYPE_B_AE_AA:
+		wSlaveAddress	= McDevProf_GetSlaveAddr(eMCDRV_SLAVE_ADDR_DIG);
+		pbRegVal		= gsGlobalInfo_AA.abRegValB_AE;
+		pwNextAddress	= gawNextAddressB_AE;
+		bAddressADR		= MCI_AA_AE_ADR;
+		bAddressWINDOW	= MCI_AA_AE_WINDOW;
+		if(MCDRV_B_AE_REG_NUM_AA <= wAddress)
+		{
+			return;
+		}
+		break;
+
+	case MCDRV_PACKET_REGTYPE_B_CDSP_AA:
+		wSlaveAddress	= McDevProf_GetSlaveAddr(eMCDRV_SLAVE_ADDR_DIG);
+		pbRegVal		= gsGlobalInfo_AA.abRegValB_CDSP;
+		pwNextAddress	= gawNextAddressB_CDSP;
+		bAddressADR		= MCI_AA_CDSP_ADR;
+		bAddressWINDOW	= MCI_AA_CDSP_WINDOW;
+		if(MCDRV_B_CDSP_REG_NUM_AA <= wAddress)
+		{
+			return;
+		}
+		break;
+
+	default:
+		return;
+	}
+
+	if(gsGlobalInfo_AA.wCurSlaveAddress != 0xFFFF && gsGlobalInfo_AA.wCurSlaveAddress != wSlaveAddress)
+	{
+		McResCtrl_ExecuteRegUpdate_AA();
+		McResCtrl_InitRegUpdate_AA();
+	}
+
+	if(gsGlobalInfo_AA.wCurRegType != 0xFFFF && gsGlobalInfo_AA.wCurRegType != wRegType)
+	{
+		McResCtrl_ExecuteRegUpdate_AA();
+		McResCtrl_InitRegUpdate_AA();
+	}
+
+	if ((eMCDRV_UPDATE_FORCE_AA != eUpdateMode) && (bData == pbRegVal[wAddress]))
+	{
+		return;
+	}
+
+	if(gsGlobalInfo_AA.wCurRegAddress == 0xFFFF)
+	{
+		gsGlobalInfo_AA.wCurRegAddress	= wAddress;
+	}
+
+	if (eMCDRV_UPDATE_DUMMY_AA != eUpdateMode)
+	{
+		pbCtrlData		= gsGlobalInfo_AA.sCtrlPacket.abData;
+		pwCtrlDataNum	= &(gsGlobalInfo_AA.sCtrlPacket.wDataNum);
+		wNextAddress	= pwNextAddress[gsGlobalInfo_AA.wCurRegAddress];
+
+		if ((wSlaveAddress == gsGlobalInfo_AA.wCurSlaveAddress)
+		&& (wRegType == gsGlobalInfo_AA.wCurRegType)
+		&& (0xFFFF != wNextAddress)
+		&& (wAddress != wNextAddress))
+		{
+			if (pwNextAddress[wNextAddress] == wAddress)
+			{
+				if (0 == gsGlobalInfo_AA.wDataContinueCount)
+				{
+					pbCtrlData[gsGlobalInfo_AA.wPrevAddressIndex] |= MCDRV_BURST_WRITE_ENABLE;
+				}
+				pbCtrlData[*pwCtrlDataNum]	= pbRegVal[wNextAddress];
+				(*pwCtrlDataNum)++;
+				gsGlobalInfo_AA.wDataContinueCount++;
+				wNextAddress				= pwNextAddress[wNextAddress];
+			}
+			else if ((0xFFFF != pwNextAddress[wNextAddress])
+					&& pwNextAddress[pwNextAddress[wNextAddress]] == wAddress)
+			{
+				if (0 == gsGlobalInfo_AA.wDataContinueCount)
+				{
+					pbCtrlData[gsGlobalInfo_AA.wPrevAddressIndex] |= MCDRV_BURST_WRITE_ENABLE;
+				}
+				pbCtrlData[*pwCtrlDataNum]	= pbRegVal[wNextAddress];
+				(*pwCtrlDataNum)++;
+				pbCtrlData[*pwCtrlDataNum]	= pbRegVal[pwNextAddress[wNextAddress]];
+				(*pwCtrlDataNum)++;
+				gsGlobalInfo_AA.wDataContinueCount += 2;
+				wNextAddress				= pwNextAddress[pwNextAddress[wNextAddress]];
+			}
+		}
+
+		if ((0 == *pwCtrlDataNum) || (wAddress != wNextAddress))
+		{
+			if (0 != gsGlobalInfo_AA.wDataContinueCount)
+			{
+				McResCtrl_ExecuteRegUpdate_AA();
+				McResCtrl_InitRegUpdate_AA();
+			}
+
+			if (MCDRV_PACKET_REGTYPE_A_AA == wRegType)
+			{
+				pbCtrlData[*pwCtrlDataNum]		= (bAddressADR << 1);
+				gsGlobalInfo_AA.wPrevAddressIndex	= *pwCtrlDataNum;
+				(*pwCtrlDataNum)++;
+			}
+			else
+			{
+				pbCtrlData[(*pwCtrlDataNum)++]	= (bAddressADR << 1);
+				pbCtrlData[(*pwCtrlDataNum)++]	= (UINT8)wAddress;
+				pbCtrlData[*pwCtrlDataNum]		= (bAddressWINDOW << 1);
+				gsGlobalInfo_AA.wPrevAddressIndex	= (*pwCtrlDataNum)++;
+			}
+		}
+		else
+		{
+			if (0 == gsGlobalInfo_AA.wDataContinueCount)
+			{
+				pbCtrlData[gsGlobalInfo_AA.wPrevAddressIndex] |= MCDRV_BURST_WRITE_ENABLE;
+			}
+			gsGlobalInfo_AA.wDataContinueCount++;
+		}
+
+		pbCtrlData[(*pwCtrlDataNum)++]	= bData;
+	}
+
+	gsGlobalInfo_AA.wCurSlaveAddress	= wSlaveAddress;
+	gsGlobalInfo_AA.wCurRegType		= wRegType;
+	gsGlobalInfo_AA.wCurRegAddress		= wAddress;
+
+	/* save register value */
+	pbRegVal[wAddress] = bData;
+}
+
+/****************************************************************************
+ *	McResCtrl_ExecuteRegUpdate_AA
+ *
+ *	Description:
+ *			Add register update packet and save register value.
+ *	Arguments:
+ *			none
+ *	Return:
+ *			none
+ *
+ ****************************************************************************/
+void	McResCtrl_ExecuteRegUpdate_AA
+(
+	void
+)
+{
+	if (0 != gsGlobalInfo_AA.sCtrlPacket.wDataNum)
+	{
+		McSrv_WriteI2C((UINT8)gsGlobalInfo_AA.wCurSlaveAddress, gsGlobalInfo_AA.sCtrlPacket.abData, gsGlobalInfo_AA.sCtrlPacket.wDataNum);
+	}
+}
+
+/****************************************************************************
+ *	McResCtrl_WaitEvent_AA
+ *
+ *	Description:
+ *			Wait event.
+ *	Arguments:
+ *			dEvent	event to wait
+ *			dParam	event parameter
+ *	Return:
+ *			MCDRV_SUCCESS
+ *			MCDRV_ERROR_TIMEOUT
+ *
+ ****************************************************************************/
+SINT32	McResCtrl_WaitEvent_AA
+(
+	UINT32	dEvent,
+	UINT32	dParam
+)
+{
+	SINT32	sdRet	= MCDRV_SUCCESS;
+	UINT32	dInterval;
+	UINT32	dTimeOut;
+	UINT8	bSlaveAddr;
+	UINT8	abWriteData[2];
+
+
+	switch(dEvent)
+	{
+	case	MCDRV_EVT_INSFLG_AA:
+		dInterval	= gsGlobalInfo_AA.sInitInfo.sWaitTime.dSvolInterval;
+		dTimeOut	= gsGlobalInfo_AA.sInitInfo.sWaitTime.dSvolTimeOut;
+		bSlaveAddr	= McDevProf_GetSlaveAddr(eMCDRV_SLAVE_ADDR_DIG);
+		if((dParam>>8) != (UINT32)0)
+		{
+			abWriteData[0]	= MCI_AA_MIX_ADR<<1;
+			abWriteData[1]	= MCI_AA_DAC_INS_FLAG;
+			McSrv_WriteI2C(bSlaveAddr, abWriteData, 2);
+			sdRet	= WaitBitRelease(bSlaveAddr, MCI_AA_MIX_WINDOW, (UINT8)(dParam>>8), dInterval, dTimeOut);
+			if(MCDRV_SUCCESS != sdRet)
+			{
+				break;
+			}
+		}
+		else if((dParam&(UINT32)0xFF) != (UINT32)0)
+		{
+			abWriteData[0]	= MCI_AA_MIX_ADR<<1;
+			abWriteData[1]	= MCI_AA_INS_FLAG;
+			McSrv_WriteI2C(bSlaveAddr, abWriteData, 2);
+			sdRet	= WaitBitRelease(bSlaveAddr, (UINT16)MCI_AA_MIX_WINDOW, (UINT8)(dParam&(UINT32)0xFF), dInterval, dTimeOut);
+		}
+		break;
+
+	case	MCDRV_EVT_ALLMUTE_AA:
+		dInterval	= gsGlobalInfo_AA.sInitInfo.sWaitTime.dSvolInterval;
+		dTimeOut	= gsGlobalInfo_AA.sInitInfo.sWaitTime.dSvolTimeOut;
+		bSlaveAddr	= McDevProf_GetSlaveAddr(eMCDRV_SLAVE_ADDR_DIG);
+		abWriteData[0]	= MCI_AA_MIX_ADR<<1;
+		abWriteData[1]	= MCI_AA_DIT_INVFLAGL;
+		McSrv_WriteI2C(bSlaveAddr, abWriteData, 2);
+		sdRet	= WaitBitRelease(bSlaveAddr, (UINT16)MCI_AA_MIX_WINDOW, (MCB_AA_DIT0_INVFLAGL|MCB_AA_DIT1_INVFLAGL|MCB_AA_DIT2_INVFLAGL), dInterval, dTimeOut);
+		if(MCDRV_SUCCESS != sdRet)
+		{
+			break;
+		}
+		abWriteData[0]	= MCI_AA_MIX_ADR<<1;
+		abWriteData[1]	= MCI_AA_DIT_INVFLAGR;
+		McSrv_WriteI2C(McDevProf_GetSlaveAddr(eMCDRV_SLAVE_ADDR_DIG), abWriteData, 2);
+		sdRet	= WaitBitRelease(bSlaveAddr, (UINT16)MCI_AA_MIX_WINDOW, (MCB_AA_DIT0_INVFLAGR|MCB_AA_DIT1_INVFLAGR|MCB_AA_DIT2_INVFLAGR), dInterval, dTimeOut);
+		if(MCDRV_SUCCESS != sdRet)
+		{
+			break;
+		}
+		abWriteData[0]	= MCI_AA_MIX_ADR<<1;
+		abWriteData[1]	= MCI_AA_DIR_VFLAGL;
+		McSrv_WriteI2C(bSlaveAddr, abWriteData, 2);
+		sdRet	= WaitBitRelease(bSlaveAddr, (UINT16)MCI_AA_MIX_WINDOW, (MCB_AA_PDM0_VFLAGL|MCB_AA_DIR0_VFLAGL|MCB_AA_DIR1_VFLAGL|MCB_AA_DIR2_VFLAGL), dInterval, dTimeOut);
+		if(MCDRV_SUCCESS != sdRet)
+		{
+			break;
+		}
+		abWriteData[0]	= MCI_AA_MIX_ADR<<1;
+		abWriteData[1]	= MCI_AA_DIR_VFLAGR;
+		McSrv_WriteI2C(bSlaveAddr, abWriteData, 2);
+		sdRet	= WaitBitRelease(bSlaveAddr, (UINT16)MCI_AA_MIX_WINDOW, (MCB_AA_PDM0_VFLAGR|MCB_AA_DIR0_VFLAGR|MCB_AA_DIR1_VFLAGR|MCB_AA_DIR2_VFLAGR), dInterval, dTimeOut);
+		if(MCDRV_SUCCESS != sdRet)
+		{
+			break;
+		}
+		abWriteData[0]	= MCI_AA_MIX_ADR<<1;
+		abWriteData[1]	= MCI_AA_AD_VFLAGL;
+		McSrv_WriteI2C(bSlaveAddr, abWriteData, 2);
+		sdRet	= WaitBitRelease(bSlaveAddr, (UINT16)MCI_AA_MIX_WINDOW, (MCB_AA_ADC_VFLAGL|MCB_AA_AENG6_VFLAGL), dInterval, dTimeOut);
+		if(MCDRV_SUCCESS != sdRet)
+		{
+			break;
+		}
+		abWriteData[0]	= MCI_AA_MIX_ADR<<1;
+		abWriteData[1]	= MCI_AA_AD_VFLAGR;
+		McSrv_WriteI2C(bSlaveAddr, abWriteData, 2);
+		sdRet	= WaitBitRelease(bSlaveAddr, (UINT16)MCI_AA_MIX_WINDOW, (MCB_AA_ADC_VFLAGR|MCB_AA_AENG6_VFLAGR), dInterval, dTimeOut);
+		if(MCDRV_SUCCESS != sdRet)
+		{
+			break;
+		}
+		abWriteData[0]	= MCI_AA_MIX_ADR<<1;
+		abWriteData[1]	= MCI_AA_AFLAGL;
+		McSrv_WriteI2C(bSlaveAddr, abWriteData, 2);
+		sdRet	= WaitBitRelease(bSlaveAddr, (UINT16)MCI_AA_MIX_WINDOW, (MCB_AA_ADC_AFLAGL|MCB_AA_DIR0_AFLAGL|MCB_AA_DIR1_AFLAGL|MCB_AA_DIR2_AFLAGL), dInterval, dTimeOut);
+		if(MCDRV_SUCCESS != sdRet)
+		{
+			break;
+		}
+		abWriteData[0]	= MCI_AA_MIX_ADR<<1;
+		abWriteData[1]	= MCI_AA_AFLAGR;
+		McSrv_WriteI2C(bSlaveAddr, abWriteData, 2);
+		sdRet	= WaitBitRelease(bSlaveAddr, (UINT16)MCI_AA_MIX_WINDOW, (MCB_AA_ADC_AFLAGR|MCB_AA_DIR0_AFLAGR|MCB_AA_DIR1_AFLAGR|MCB_AA_DIR2_AFLAGR), dInterval, dTimeOut);
+		if(MCDRV_SUCCESS != sdRet)
+		{
+			break;
+		}
+		abWriteData[0]	= MCI_AA_MIX_ADR<<1;
+		abWriteData[1]	= MCI_AA_DAC_FLAGL;
+		McSrv_WriteI2C(bSlaveAddr, abWriteData, 2);
+		sdRet	= WaitBitRelease(bSlaveAddr, (UINT16)MCI_AA_MIX_WINDOW, (MCB_AA_ST_FLAGL|MCB_AA_MASTER_OFLAGL|MCB_AA_VOICE_FLAGL|MCB_AA_DAC_FLAGL), dInterval, dTimeOut);
+		if(MCDRV_SUCCESS != sdRet)
+		{
+			break;
+		}
+		abWriteData[0]	= MCI_AA_MIX_ADR<<1;
+		abWriteData[1]	= MCI_AA_DAC_FLAGR;
+		McSrv_WriteI2C(bSlaveAddr, abWriteData, 2);
+		sdRet	= WaitBitRelease(bSlaveAddr, (UINT16)MCI_AA_MIX_WINDOW, (MCB_AA_ST_FLAGR|MCB_AA_MASTER_OFLAGR|MCB_AA_VOICE_FLAGR|MCB_AA_DAC_FLAGR), dInterval, dTimeOut);
+		break;
+
+	case	MCDRV_EVT_DITMUTE_AA:
+		dInterval	= gsGlobalInfo_AA.sInitInfo.sWaitTime.dSvolInterval;
+		dTimeOut	= gsGlobalInfo_AA.sInitInfo.sWaitTime.dSvolTimeOut;
+		bSlaveAddr	= McDevProf_GetSlaveAddr(eMCDRV_SLAVE_ADDR_DIG);
+		if((dParam>>8) != (UINT32)0)
+		{
+			abWriteData[0]	= MCI_AA_MIX_ADR<<1;
+			abWriteData[1]	= MCI_AA_DIT_INVFLAGL;
+			McSrv_WriteI2C(bSlaveAddr, abWriteData, 2);
+			sdRet	= WaitBitRelease(bSlaveAddr, (UINT16)MCI_AA_MIX_WINDOW, (UINT8)(dParam>>8), dInterval, dTimeOut);
+			if(MCDRV_SUCCESS != sdRet)
+			{
+				break;
+			}
+		}
+		if((dParam&(UINT32)0xFF) != (UINT32)0)
+		{
+			abWriteData[0]	= MCI_AA_MIX_ADR<<1;
+			abWriteData[1]	= MCI_AA_DIT_INVFLAGR;
+			McSrv_WriteI2C(bSlaveAddr, abWriteData, 2);
+			sdRet	= WaitBitRelease(bSlaveAddr, (UINT16)MCI_AA_MIX_WINDOW, (UINT8)(dParam&(UINT32)0xFF), dInterval, dTimeOut);
+		}
+		break;
+
+	case	MCDRV_EVT_DACMUTE_AA:
+		dInterval	= gsGlobalInfo_AA.sInitInfo.sWaitTime.dSvolInterval;
+		dTimeOut	= gsGlobalInfo_AA.sInitInfo.sWaitTime.dSvolTimeOut;
+		bSlaveAddr	= McDevProf_GetSlaveAddr(eMCDRV_SLAVE_ADDR_DIG);
+		if((dParam>>8) != (UINT32)0)
+		{
+			abWriteData[0]	= MCI_AA_MIX_ADR<<1;
+			abWriteData[1]	= MCI_AA_DAC_FLAGL;
+			McSrv_WriteI2C(bSlaveAddr, abWriteData, 2);
+			sdRet	= WaitBitRelease(bSlaveAddr, (UINT16)MCI_AA_MIX_WINDOW, (UINT8)(dParam>>8), dInterval, dTimeOut);
+			if(MCDRV_SUCCESS != sdRet)
+			{
+				break;
+			}
+		}
+		if((dParam&(UINT32)0xFF) != (UINT32)0)
+		{
+			abWriteData[0]	= MCI_AA_MIX_ADR<<1;
+			abWriteData[1]	= MCI_AA_DAC_FLAGR;
+			McSrv_WriteI2C(bSlaveAddr, abWriteData, 2);
+			sdRet	= WaitBitRelease(bSlaveAddr, (UINT16)MCI_AA_MIX_WINDOW, (UINT8)(dParam&(UINT32)0xFF), dInterval, dTimeOut);
+		}
+		break;
+
+	case	MCDRV_EVT_SVOL_DONE_AA:
+		dInterval	= gsGlobalInfo_AA.sInitInfo.sWaitTime.dSvolInterval;
+		dTimeOut	= gsGlobalInfo_AA.sInitInfo.sWaitTime.dSvolTimeOut;
+		bSlaveAddr	= McDevProf_GetSlaveAddr(eMCDRV_SLAVE_ADDR_ANA);
+		if((dParam>>8) != (UINT32)0)
+		{
+			abWriteData[0]	= MCI_AA_ANA_ADR<<1;
+			abWriteData[1]	= MCI_AA_BUSY1;
+			McSrv_WriteI2C(bSlaveAddr, abWriteData, 2);
+			sdRet	= WaitBitRelease(bSlaveAddr, (UINT16)MCI_AA_ANA_WINDOW, (UINT8)(dParam>>8), dInterval, dTimeOut);
+			if(MCDRV_SUCCESS != sdRet)
+			{
+				break;
+			}
+		}
+		if((dParam&(UINT32)0xFF) != (UINT32)0)
+		{
+			abWriteData[0]	= MCI_AA_ANA_ADR<<1;
+			abWriteData[1]	= MCI_AA_BUSY2;
+			McSrv_WriteI2C(bSlaveAddr, abWriteData, 2);
+			return WaitBitRelease(bSlaveAddr, (UINT16)MCI_AA_ANA_WINDOW, (UINT8)(dParam&(UINT8)0xFF), dInterval, dTimeOut);
+		}
+		break;
+
+	case	MCDRV_EVT_APM_DONE_AA:
+		dInterval	= gsGlobalInfo_AA.sInitInfo.sWaitTime.dSvolInterval;
+		dTimeOut	= gsGlobalInfo_AA.sInitInfo.sWaitTime.dSvolTimeOut;
+		bSlaveAddr	= McDevProf_GetSlaveAddr(eMCDRV_SLAVE_ADDR_ANA);
+		abWriteData[0]	= MCI_AA_ANA_ADR<<1;
+		abWriteData[1]	= MCI_AA_AP_A1;
+		McSrv_WriteI2C(bSlaveAddr, abWriteData, 2);
+		sdRet	= WaitBitSet(bSlaveAddr, (UINT16)MCI_AA_ANA_WINDOW, (UINT8)(dParam>>8), dInterval, dTimeOut);
+		if(MCDRV_SUCCESS != sdRet)
+		{
+			break;
+		}
+		abWriteData[0]	= MCI_AA_ANA_ADR<<1;
+		abWriteData[1]	= MCI_AA_AP_A2;
+		McSrv_WriteI2C(bSlaveAddr, abWriteData, 2);
+		sdRet	= WaitBitSet(bSlaveAddr, (UINT16)MCI_AA_ANA_WINDOW, (UINT8)(dParam&(UINT8)0xFF), dInterval, dTimeOut);
+		break;
+
+	case	MCDRV_EVT_ANA_RDY_AA:
+		dInterval	= gsGlobalInfo_AA.sInitInfo.sWaitTime.dAnaRdyInterval;
+		dTimeOut	= gsGlobalInfo_AA.sInitInfo.sWaitTime.dAnaRdyTimeOut;
+		bSlaveAddr	= McDevProf_GetSlaveAddr(eMCDRV_SLAVE_ADDR_ANA);
+		abWriteData[0]	= MCI_AA_ANA_ADR<<1;
+		abWriteData[1]	= MCI_AA_RDY_FLAG;
+		McSrv_WriteI2C(bSlaveAddr, abWriteData, 2);
+		sdRet	= WaitBitSet(bSlaveAddr, (UINT16)MCI_AA_ANA_WINDOW, (UINT8)dParam, dInterval, dTimeOut);
+		break;
+
+	default:
+		sdRet	= MCDRV_ERROR_ARGUMENT;
+	}
+
+	return sdRet;
+}
+
+/****************************************************************************
+ *	WaitBitSet
+ *
+ *	Description:
+ *			Wait register bit to set.
+ *	Arguments:
+ *			bSlaveAddr	slave address
+ *			wRegAddr	register address
+ *			bBit		bit
+ *			dCycleTime	cycle time to poll [us]
+ *			dTimeOut	number of read cycles for time out
+ *	Return:
+ *			MCDRV_SUCCESS
+ *			MCDRV_ERROR_TIMEOUT
+ *
+ ****************************************************************************/
+static SINT32	WaitBitSet
+(
+	UINT8	bSlaveAddr,
+	UINT16	wRegAddr,
+	UINT8	bBit,
+	UINT32	dCycleTime,
+	UINT32	dTimeOut
+)
+{
+	UINT8	bData;
+	UINT32	dCycles;
+	SINT32	sdRet;
+
+
+	dCycles	= 0;
+	sdRet	= MCDRV_ERROR_TIMEOUT;
+
+	while(dCycles < dTimeOut)
+	{
+		bData	= McSrv_ReadI2C(bSlaveAddr, wRegAddr);
+		if((bData & bBit) == bBit)
+		{
+			sdRet	= MCDRV_SUCCESS;
+			break;
+		}
+
+		McSrv_Sleep(dCycleTime);
+		dCycles++;
+	}
+
+	return sdRet;
+}
+
+/****************************************************************************
+ *	WaitBitRelease
+ *
+ *	Description:
+ *			Wait register bit to release.
+ *	Arguments:
+ *			bSlaveAddr	slave address
+ *			wRegAddr	register address
+ *			bBit		bit
+ *			dCycleTime	cycle time to poll [us]
+ *			dTimeOut	number of read cycles for time out
+ *	Return:
+ *			MCDRV_SUCCESS
+ *			MCDRV_ERROR_TIMEOUT
+ *
+ ****************************************************************************/
+static SINT32	WaitBitRelease
+(
+	UINT8	bSlaveAddr,
+	UINT16	wRegAddr,
+	UINT8	bBit,
+	UINT32	dCycleTime,
+	UINT32	dTimeOut
+)
+{
+	UINT8	bData;
+	UINT32	dCycles;
+	SINT32	sdRet;
+
+
+	dCycles	= 0;
+	sdRet	= MCDRV_ERROR_TIMEOUT;
+
+	while(dCycles < dTimeOut)
+	{
+		bData	= McSrv_ReadI2C(bSlaveAddr, wRegAddr);
+		if(0 == (bData & bBit))
+		{
+			sdRet	= MCDRV_SUCCESS;
+			break;
+		}
+
+		McSrv_Sleep(dCycleTime);
+		dCycles++;
+	}
+
+	return sdRet;
+}
+
+/****************************************************************************
+ *	McResCtrl_ConfigHwAdj_AA
+ *
+ *	Description:
+ *			HWADJ configuration.
+ *	Arguments:
+ *			none
+ *	Return:
+ *			MCDRV_HWADJ
+ *
+ ****************************************************************************/
+MCDRV_HWADJ	McResCtrl_ConfigHwAdj_AA
+(
+	void
+)
+{
+	UINT8			bFs;
+	UINT8			bSrc1;
+	UINT8			bSrc2;
+	UINT8			bSrc3;
+	MCDRV_DST_TYPE_AA	eDstType;
+	MCDRV_SRC_TYPE_AA	eSrcType;
+	MCDRV_HWADJ		eHwAdj;
+
+	eDstType = eMCDRV_DST_DIT0_AA;
+	eSrcType = eMCDRV_SRC_DIR0_AA;
+	eHwAdj = eMCDRV_HWADJ_THRU;
+	bFs = 0xFF;
+
+	/* DIR0->AE or DIR0->MIX */
+	bSrc1 = gsGlobalInfo_AA.sPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK] & MCDRV_SRC3_DIR0_ON;
+	bSrc2 = gsGlobalInfo_AA.sPathInfo.asMix[0].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK] & MCDRV_SRC3_DIR0_ON;
+	if((bSrc1 != 0) || (bSrc2 != 0))
+	{
+		bFs = gsGlobalInfo_AA.sDioInfo.asPortInfo[0].sDioCommon.bFs;
+		eSrcType = eMCDRV_SRC_DIR0_AA;
+	}
+
+	/* DIR1->AE or DIR1->MIX */
+	bSrc1 = gsGlobalInfo_AA.sPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK] & MCDRV_SRC3_DIR1_ON;
+	bSrc2 = gsGlobalInfo_AA.sPathInfo.asMix[0].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK] & MCDRV_SRC3_DIR1_ON;
+	if((bSrc1 != 0) || (bSrc2 != 0))
+	{
+		if(bFs > gsGlobalInfo_AA.sDioInfo.asPortInfo[1].sDioCommon.bFs)
+		{
+			bFs = gsGlobalInfo_AA.sDioInfo.asPortInfo[1].sDioCommon.bFs;
+			eSrcType = eMCDRV_SRC_DIR1_AA;
+		}
+	}
+
+	/* DIR2->AE or DIR2->MIX */
+	bSrc1 = gsGlobalInfo_AA.sPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK] & MCDRV_SRC3_DIR2_ON;
+	bSrc2 = gsGlobalInfo_AA.sPathInfo.asMix[0].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK] & MCDRV_SRC3_DIR2_ON;
+	if((bSrc1 != 0) || (bSrc2 != 0))
+	{
+		if(bFs > gsGlobalInfo_AA.sDioInfo.asPortInfo[2].sDioCommon.bFs)
+		{
+			bFs = gsGlobalInfo_AA.sDioInfo.asPortInfo[2].sDioCommon.bFs;
+			eSrcType = eMCDRV_SRC_DIR2_AA;
+		}
+	}
+
+	if(bFs != 0xFF)
+	{
+		if((bFs != MCDRV_FS_48000) && (bFs != MCDRV_FS_44100) && (bFs != MCDRV_FS_8000))
+		{
+			bFs = 0xFF;
+		}
+
+		if(bFs != 0xFF)
+		{
+			switch(eSrcType)
+			{
+			case	eMCDRV_SRC_DIR0_AA:
+				if((gsGlobalInfo_AA.sPathInfo.asMix[0].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK] & MCDRV_SRC3_DIR0_ON) != 0)
+				{
+					if(McResCtrl_IsDstUsed_AA(eMCDRV_DST_AE_AA, eMCDRV_DST_CH0_AA) == 1)
+					{
+						if(((gsGlobalInfo_AA.sPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_MIX_BLOCK] & MCDRV_SRC6_MIX_ON) == 0) &&
+						   ((gsGlobalInfo_AA.sPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK] & MCDRV_SRC3_DIR0_ON) == 0))
+						{
+							bFs = 0xFF;
+						}
+					}
+					else
+					{
+						gsGlobalInfo_AA.sPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_PDM_BLOCK]	&= (UINT8)~MCDRV_SRC4_PDM_ON;
+						gsGlobalInfo_AA.sPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_PDM_BLOCK]	|= MCDRV_SRC4_PDM_OFF;
+						gsGlobalInfo_AA.sPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK]	&= (UINT8)~MCDRV_SRC4_ADC0_ON;
+						gsGlobalInfo_AA.sPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK]	|= MCDRV_SRC4_ADC0_OFF;
+						gsGlobalInfo_AA.sPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR0_OFF;
+						gsGlobalInfo_AA.sPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK]	|= MCDRV_SRC3_DIR0_ON;
+						gsGlobalInfo_AA.sPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR1_ON;
+						gsGlobalInfo_AA.sPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK]	|= MCDRV_SRC3_DIR1_OFF;
+						gsGlobalInfo_AA.sPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR2_ON;
+						gsGlobalInfo_AA.sPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK]	|= MCDRV_SRC3_DIR2_OFF;
+						gsGlobalInfo_AA.sPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_MIX_BLOCK]	&= (UINT8)~MCDRV_SRC6_MIX_ON;
+						gsGlobalInfo_AA.sPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_MIX_BLOCK]	|= MCDRV_SRC6_MIX_OFF;
+
+						gsGlobalInfo_AA.sPathInfo.asMix[0].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR0_ON;
+						gsGlobalInfo_AA.sPathInfo.asMix[0].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK]	|= MCDRV_SRC3_DIR0_OFF;
+						gsGlobalInfo_AA.sPathInfo.asMix[0].abSrcOnOff[MCDRV_SRC_AE_BLOCK]	&= (UINT8)~MCDRV_SRC6_AE_OFF;
+						gsGlobalInfo_AA.sPathInfo.asMix[0].abSrcOnOff[MCDRV_SRC_AE_BLOCK]	|= MCDRV_SRC6_AE_ON;
+					}
+				}
+				break;
+			case	eMCDRV_SRC_DIR1_AA:
+				if((gsGlobalInfo_AA.sPathInfo.asMix[0].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK] & MCDRV_SRC3_DIR1_ON) != 0)
+				{
+					if(McResCtrl_IsDstUsed_AA(eMCDRV_DST_AE_AA, eMCDRV_DST_CH0_AA) == 1)
+					{
+						if(((gsGlobalInfo_AA.sPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_MIX_BLOCK] & MCDRV_SRC6_MIX_ON) == 0) &&
+						   ((gsGlobalInfo_AA.sPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK] & MCDRV_SRC3_DIR1_ON) == 0))
+						{
+							bFs = 0xFF;
+						}
+					}
+					else
+					{
+						gsGlobalInfo_AA.sPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_PDM_BLOCK]	&= (UINT8)~MCDRV_SRC4_PDM_ON;
+						gsGlobalInfo_AA.sPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_PDM_BLOCK]	|= MCDRV_SRC4_PDM_OFF;
+						gsGlobalInfo_AA.sPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK]	&= (UINT8)~MCDRV_SRC4_ADC0_ON;
+						gsGlobalInfo_AA.sPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK]	|= MCDRV_SRC4_ADC0_OFF;
+						gsGlobalInfo_AA.sPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR0_ON;
+						gsGlobalInfo_AA.sPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK]	|= MCDRV_SRC3_DIR0_OFF;
+						gsGlobalInfo_AA.sPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR1_OFF;
+						gsGlobalInfo_AA.sPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK]	|= MCDRV_SRC3_DIR1_ON;
+						gsGlobalInfo_AA.sPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR2_ON;
+						gsGlobalInfo_AA.sPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK]	|= MCDRV_SRC3_DIR2_OFF;
+						gsGlobalInfo_AA.sPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_MIX_BLOCK]	&= (UINT8)~MCDRV_SRC6_MIX_ON;
+						gsGlobalInfo_AA.sPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_MIX_BLOCK]	|= MCDRV_SRC6_MIX_OFF;
+
+						gsGlobalInfo_AA.sPathInfo.asMix[0].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR1_ON;
+						gsGlobalInfo_AA.sPathInfo.asMix[0].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK]	|= MCDRV_SRC3_DIR1_OFF;
+						gsGlobalInfo_AA.sPathInfo.asMix[0].abSrcOnOff[MCDRV_SRC_AE_BLOCK]	&= (UINT8)~MCDRV_SRC6_AE_OFF;
+						gsGlobalInfo_AA.sPathInfo.asMix[0].abSrcOnOff[MCDRV_SRC_AE_BLOCK]	|= MCDRV_SRC6_AE_ON;
+					}
+				}
+				break;
+			case	eMCDRV_SRC_DIR2_AA:
+				if((gsGlobalInfo_AA.sPathInfo.asMix[0].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK] & MCDRV_SRC3_DIR2_ON) != 0)
+				{
+					if(McResCtrl_IsDstUsed_AA(eMCDRV_DST_AE_AA, eMCDRV_DST_CH0_AA) == 1)
+					{
+						if(((gsGlobalInfo_AA.sPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_MIX_BLOCK] & MCDRV_SRC6_MIX_ON) == 0) &&
+						   ((gsGlobalInfo_AA.sPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK] & MCDRV_SRC3_DIR2_ON) == 0))
+						{
+							bFs = 0xFF;
+						}
+					}
+					else
+					{
+						gsGlobalInfo_AA.sPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_PDM_BLOCK]	&= (UINT8)~MCDRV_SRC4_PDM_ON;
+						gsGlobalInfo_AA.sPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_PDM_BLOCK]	|= MCDRV_SRC4_PDM_OFF;
+						gsGlobalInfo_AA.sPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK]	&= (UINT8)~MCDRV_SRC4_ADC0_ON;
+						gsGlobalInfo_AA.sPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK]	|= MCDRV_SRC4_ADC0_OFF;
+						gsGlobalInfo_AA.sPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR0_ON;
+						gsGlobalInfo_AA.sPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK]	|= MCDRV_SRC3_DIR0_OFF;
+						gsGlobalInfo_AA.sPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR1_ON;
+						gsGlobalInfo_AA.sPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK]	|= MCDRV_SRC3_DIR1_OFF;
+						gsGlobalInfo_AA.sPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR2_OFF;
+						gsGlobalInfo_AA.sPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK]	|= MCDRV_SRC3_DIR2_ON;
+						gsGlobalInfo_AA.sPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_MIX_BLOCK]	&= (UINT8)~MCDRV_SRC6_MIX_ON;
+						gsGlobalInfo_AA.sPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_MIX_BLOCK]	|= MCDRV_SRC6_MIX_OFF;
+
+						gsGlobalInfo_AA.sPathInfo.asMix[0].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR2_ON;
+						gsGlobalInfo_AA.sPathInfo.asMix[0].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK]	|= MCDRV_SRC3_DIR2_OFF;
+						gsGlobalInfo_AA.sPathInfo.asMix[0].abSrcOnOff[MCDRV_SRC_AE_BLOCK]	&= (UINT8)~MCDRV_SRC6_AE_OFF;
+						gsGlobalInfo_AA.sPathInfo.asMix[0].abSrcOnOff[MCDRV_SRC_AE_BLOCK]	|= MCDRV_SRC6_AE_ON;
+					}
+				}
+				break;
+			default:
+				bFs = 0xFF;
+				break;
+			}
+
+			switch(bFs)
+			{
+			case	MCDRV_FS_48000:
+				eHwAdj = eMCDRV_HWADJ_PLAY48;
+				break;
+			case	MCDRV_FS_44100:
+				eHwAdj = eMCDRV_HWADJ_PLAY44;
+				break;
+			case	MCDRV_FS_8000:
+				eHwAdj = eMCDRV_HWADJ_PLAY8;
+				break;
+			default:
+				break;
+			}
+		}
+	}
+	else
+	{
+		/* AD->DIT0 or AD->AE->DIT0 */
+		bSrc1 = gsGlobalInfo_AA.sPathInfo.asDit0[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK] & MCDRV_SRC4_ADC0_ON;
+		bSrc2 = gsGlobalInfo_AA.sPathInfo.asDit0[0].abSrcOnOff[MCDRV_SRC_AE_BLOCK] & MCDRV_SRC6_AE_ON;
+		bSrc3 = gsGlobalInfo_AA.sPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK] & MCDRV_SRC4_ADC0_ON;
+		if((bSrc1 != 0) || ((bSrc2 != 0) && (bSrc3 != 0)))
+		{
+			bFs = gsGlobalInfo_AA.sDioInfo.asPortInfo[0].sDioCommon.bFs;
+			eDstType = eMCDRV_DST_DIT0_AA;
+		}
+
+		/* AD->DIT1 or AD->AE->DIT1 */
+		bSrc1 = gsGlobalInfo_AA.sPathInfo.asDit1[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK] & MCDRV_SRC4_ADC0_ON;
+		bSrc2 = gsGlobalInfo_AA.sPathInfo.asDit1[0].abSrcOnOff[MCDRV_SRC_AE_BLOCK] & MCDRV_SRC6_AE_ON;
+		bSrc3 = gsGlobalInfo_AA.sPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK] & MCDRV_SRC4_ADC0_ON;
+		if((bSrc1 != 0) || ((bSrc2 != 0) && (bSrc3 != 0)))
+		{
+			if(bFs > gsGlobalInfo_AA.sDioInfo.asPortInfo[1].sDioCommon.bFs)
+			{
+				bFs = gsGlobalInfo_AA.sDioInfo.asPortInfo[1].sDioCommon.bFs;
+				eDstType = eMCDRV_DST_DIT1_AA;
+			}
+		}
+
+		/* AD->DIT2 or AD->AE->DIT2 */
+		bSrc1 = gsGlobalInfo_AA.sPathInfo.asDit2[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK] & MCDRV_SRC4_ADC0_ON;
+		bSrc2 = gsGlobalInfo_AA.sPathInfo.asDit2[0].abSrcOnOff[MCDRV_SRC_AE_BLOCK] & MCDRV_SRC6_AE_ON;
+		bSrc3 = gsGlobalInfo_AA.sPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK] & MCDRV_SRC4_ADC0_ON;
+		if((bSrc1 != 0) || ((bSrc2 != 0) && (bSrc3 != 0)))
+		{
+			if(bFs > gsGlobalInfo_AA.sDioInfo.asPortInfo[2].sDioCommon.bFs)
+			{
+				bFs = gsGlobalInfo_AA.sDioInfo.asPortInfo[2].sDioCommon.bFs;
+				eDstType = eMCDRV_DST_DIT2_AA;
+			}
+		}
+
+		if((bFs != MCDRV_FS_48000) && (bFs != MCDRV_FS_44100) && (bFs != MCDRV_FS_8000))
+		{
+			bFs = 0xFF;
+		}
+
+		if(bFs != 0xFF)
+		{
+			switch(eDstType)
+			{
+			case	eMCDRV_DST_DIT0_AA:
+				if(((gsGlobalInfo_AA.sPathInfo.asDit1[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK] & MCDRV_SRC4_ADC0_ON) != 0) ||
+				   ((gsGlobalInfo_AA.sPathInfo.asDit2[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK] & MCDRV_SRC4_ADC0_ON) != 0))
+				{
+					bFs = 0xFF;
+				}
+				else
+				{
+					if((gsGlobalInfo_AA.sPathInfo.asDit0[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK] & MCDRV_SRC4_ADC0_ON) != 0)
+					{
+						if(McResCtrl_IsDstUsed_AA(eMCDRV_DST_AE_AA, eMCDRV_DST_CH0_AA) == 1)
+						{
+							bFs = 0xFF;
+						}
+						else
+						{
+							gsGlobalInfo_AA.sPathInfo.asDit0[0].abSrcOnOff[MCDRV_SRC_PDM_BLOCK]	&= (UINT8)~MCDRV_SRC4_PDM_ON;
+							gsGlobalInfo_AA.sPathInfo.asDit0[0].abSrcOnOff[MCDRV_SRC_PDM_BLOCK]	|= MCDRV_SRC4_PDM_OFF;
+							gsGlobalInfo_AA.sPathInfo.asDit0[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK]	&= (UINT8)~MCDRV_SRC4_ADC0_ON;
+							gsGlobalInfo_AA.sPathInfo.asDit0[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK]	|= MCDRV_SRC4_ADC0_OFF;
+							gsGlobalInfo_AA.sPathInfo.asDit0[0].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR0_ON;
+							gsGlobalInfo_AA.sPathInfo.asDit0[0].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK]	|= MCDRV_SRC3_DIR0_OFF;
+							gsGlobalInfo_AA.sPathInfo.asDit0[0].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR1_ON;
+							gsGlobalInfo_AA.sPathInfo.asDit0[0].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK]	|= MCDRV_SRC3_DIR1_OFF;
+							gsGlobalInfo_AA.sPathInfo.asDit0[0].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR2_ON;
+							gsGlobalInfo_AA.sPathInfo.asDit0[0].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK]	|= MCDRV_SRC3_DIR2_OFF;
+							gsGlobalInfo_AA.sPathInfo.asDit0[0].abSrcOnOff[MCDRV_SRC_AE_BLOCK]		&= (UINT8)~MCDRV_SRC6_AE_OFF;
+							gsGlobalInfo_AA.sPathInfo.asDit0[0].abSrcOnOff[MCDRV_SRC_AE_BLOCK]		|= MCDRV_SRC6_AE_ON;
+							gsGlobalInfo_AA.sPathInfo.asDit0[0].abSrcOnOff[MCDRV_SRC_MIX_BLOCK]	&= (UINT8)~MCDRV_SRC6_MIX_ON;
+							gsGlobalInfo_AA.sPathInfo.asDit0[0].abSrcOnOff[MCDRV_SRC_MIX_BLOCK]	|= MCDRV_SRC6_MIX_OFF;
+						}
+					}
+				}
+				break;
+			case	eMCDRV_DST_DIT1_AA:
+				if(((gsGlobalInfo_AA.sPathInfo.asDit0[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK] & MCDRV_SRC4_ADC0_ON) != 0) ||
+				   ((gsGlobalInfo_AA.sPathInfo.asDit2[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK] & MCDRV_SRC4_ADC0_ON) != 0))
+				{
+					bFs = 0xFF;
+				}
+				else
+				{
+					if((gsGlobalInfo_AA.sPathInfo.asDit1[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK] & MCDRV_SRC4_ADC0_ON) != 0)
+					{
+						if(McResCtrl_IsDstUsed_AA(eMCDRV_DST_AE_AA, eMCDRV_DST_CH0_AA) == 1)
+						{
+							bFs = 0xFF;
+						}
+						else
+						{
+							gsGlobalInfo_AA.sPathInfo.asDit1[0].abSrcOnOff[MCDRV_SRC_PDM_BLOCK]	&= (UINT8)~MCDRV_SRC4_PDM_ON;
+							gsGlobalInfo_AA.sPathInfo.asDit1[0].abSrcOnOff[MCDRV_SRC_PDM_BLOCK]	|= MCDRV_SRC4_PDM_OFF;
+							gsGlobalInfo_AA.sPathInfo.asDit1[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK]	&= (UINT8)~MCDRV_SRC4_ADC0_ON;
+							gsGlobalInfo_AA.sPathInfo.asDit1[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK]	|= MCDRV_SRC4_ADC0_OFF;
+							gsGlobalInfo_AA.sPathInfo.asDit1[0].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR0_ON;
+							gsGlobalInfo_AA.sPathInfo.asDit1[0].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK]	|= MCDRV_SRC3_DIR0_OFF;
+							gsGlobalInfo_AA.sPathInfo.asDit1[0].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR1_ON;
+							gsGlobalInfo_AA.sPathInfo.asDit1[0].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK]	|= MCDRV_SRC3_DIR1_OFF;
+							gsGlobalInfo_AA.sPathInfo.asDit1[0].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR2_ON;
+							gsGlobalInfo_AA.sPathInfo.asDit1[0].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK]	|= MCDRV_SRC3_DIR2_OFF;
+							gsGlobalInfo_AA.sPathInfo.asDit1[0].abSrcOnOff[MCDRV_SRC_AE_BLOCK]		&= (UINT8)~MCDRV_SRC6_AE_OFF;
+							gsGlobalInfo_AA.sPathInfo.asDit1[0].abSrcOnOff[MCDRV_SRC_AE_BLOCK]		|= MCDRV_SRC6_AE_ON;
+							gsGlobalInfo_AA.sPathInfo.asDit1[0].abSrcOnOff[MCDRV_SRC_MIX_BLOCK]	&= (UINT8)~MCDRV_SRC6_MIX_ON;
+							gsGlobalInfo_AA.sPathInfo.asDit1[0].abSrcOnOff[MCDRV_SRC_MIX_BLOCK]	|= MCDRV_SRC6_MIX_OFF;
+						}
+					}
+				}
+				break;
+			case	eMCDRV_DST_DIT2_AA:
+				if(((gsGlobalInfo_AA.sPathInfo.asDit0[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK] & MCDRV_SRC4_ADC0_ON) != 0) ||
+				   ((gsGlobalInfo_AA.sPathInfo.asDit1[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK] & MCDRV_SRC4_ADC0_ON) != 0))
+				{
+					bFs = 0xFF;
+				}
+				else
+				{
+					if((gsGlobalInfo_AA.sPathInfo.asDit2[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK] & MCDRV_SRC4_ADC0_ON) != 0)
+					{
+						if(McResCtrl_IsDstUsed_AA(eMCDRV_DST_AE_AA, eMCDRV_DST_CH0_AA) == 1)
+						{
+							bFs = 0xFF;
+						}
+						else
+						{
+							gsGlobalInfo_AA.sPathInfo.asDit2[0].abSrcOnOff[MCDRV_SRC_PDM_BLOCK]	&= (UINT8)~MCDRV_SRC4_PDM_ON;
+							gsGlobalInfo_AA.sPathInfo.asDit2[0].abSrcOnOff[MCDRV_SRC_PDM_BLOCK]	|= MCDRV_SRC4_PDM_OFF;
+							gsGlobalInfo_AA.sPathInfo.asDit2[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK]	&= (UINT8)~MCDRV_SRC4_ADC0_ON;
+							gsGlobalInfo_AA.sPathInfo.asDit2[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK]	|= MCDRV_SRC4_ADC0_OFF;
+							gsGlobalInfo_AA.sPathInfo.asDit2[0].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR0_ON;
+							gsGlobalInfo_AA.sPathInfo.asDit2[0].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK]	|= MCDRV_SRC3_DIR0_OFF;
+							gsGlobalInfo_AA.sPathInfo.asDit2[0].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR1_ON;
+							gsGlobalInfo_AA.sPathInfo.asDit2[0].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK]	|= MCDRV_SRC3_DIR1_OFF;
+							gsGlobalInfo_AA.sPathInfo.asDit2[0].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR2_ON;
+							gsGlobalInfo_AA.sPathInfo.asDit2[0].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK]	|= MCDRV_SRC3_DIR2_OFF;
+							gsGlobalInfo_AA.sPathInfo.asDit2[0].abSrcOnOff[MCDRV_SRC_AE_BLOCK]		&= (UINT8)~MCDRV_SRC6_AE_OFF;
+							gsGlobalInfo_AA.sPathInfo.asDit2[0].abSrcOnOff[MCDRV_SRC_AE_BLOCK]		|= MCDRV_SRC6_AE_ON;
+							gsGlobalInfo_AA.sPathInfo.asDit2[0].abSrcOnOff[MCDRV_SRC_MIX_BLOCK]	&= (UINT8)~MCDRV_SRC6_MIX_ON;
+							gsGlobalInfo_AA.sPathInfo.asDit2[0].abSrcOnOff[MCDRV_SRC_MIX_BLOCK]	|= MCDRV_SRC6_MIX_OFF;
+						}
+					}
+				}
+				break;
+			default:
+				bFs = 0xFF;
+				break;
+			}
+
+
+			if((bFs != 0xFF) && (McResCtrl_IsDstUsed_AA(eMCDRV_DST_AE_AA, eMCDRV_DST_CH0_AA) == 0))
+			{
+				gsGlobalInfo_AA.sPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_PDM_BLOCK]	&= (UINT8)~MCDRV_SRC4_PDM_ON;
+				gsGlobalInfo_AA.sPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_PDM_BLOCK]	|= MCDRV_SRC4_PDM_OFF;
+				gsGlobalInfo_AA.sPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK]	&= (UINT8)~MCDRV_SRC4_ADC0_OFF;
+				gsGlobalInfo_AA.sPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK]	|= MCDRV_SRC4_ADC0_ON;
+				gsGlobalInfo_AA.sPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR0_ON;
+				gsGlobalInfo_AA.sPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK]	|= MCDRV_SRC3_DIR0_OFF;
+				gsGlobalInfo_AA.sPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR1_ON;
+				gsGlobalInfo_AA.sPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK]	|= MCDRV_SRC3_DIR1_OFF;
+				gsGlobalInfo_AA.sPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR2_ON;
+				gsGlobalInfo_AA.sPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK]	|= MCDRV_SRC3_DIR2_OFF;
+				gsGlobalInfo_AA.sPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_MIX_BLOCK]	&= (UINT8)~MCDRV_SRC6_MIX_ON;
+				gsGlobalInfo_AA.sPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_MIX_BLOCK]	|= MCDRV_SRC6_MIX_OFF;
+			}
+
+			switch(bFs)
+			{
+			case	MCDRV_FS_48000:
+				eHwAdj = eMCDRV_HWADJ_REC48;
+				break;
+			case	MCDRV_FS_44100:
+				eHwAdj = eMCDRV_HWADJ_REC44;
+				break;
+			case	MCDRV_FS_8000:
+				eHwAdj = eMCDRV_HWADJ_REC8;
+				break;
+			default:
+				break;
+			}
+		}
+	}
+
+	if(gsGlobalInfo_AA.eHwAdj == eHwAdj)
+	{
+		eHwAdj = eMCDRV_HWADJ_NOCHANGE;
+	}
+	else
+	{
+		gsGlobalInfo_AA.eHwAdj = eHwAdj;
+	}
+
+	return eHwAdj;
+}
+
+/**************************************/
+
+/* volume update */
+typedef enum
+{
+	eMCDRV_VOLUPDATE_MUTE_AA,
+	eMCDRV_VOLUPDATE_ALL_AA
+} MCDRV_VOLUPDATE_MODE_AA;
+
+/* power update */
+typedef struct
+{
+	UINT32	dDigital;
+	UINT8	abAnalog[5];
+} MCDRV_POWER_UPDATE_AA;
+
+#define	MCDRV_POWUPDATE_DIGITAL_ALL_AA		(0xFFFFFFFFUL)
+#define	MCDRV_POWUPDATE_ANALOG0_ALL_AA		(0x0F)
+#define	MCDRV_POWUPDATE_ANALOG1_ALL_AA		(0xFF)
+#define	MCDRV_POWUPDATE_ANALOG2_ALL_AA		(0x3F)
+#define	MCDRV_POWUPDATE_ANALOG3_ALL_AA		(0x0F)
+#define	MCDRV_POWUPDATE_ANALOG4_ALL_AA		(0xF0)
+#define	MCDRV_POWUPDATE_ANALOG0_IN_AA		(0x0D)
+#define	MCDRV_POWUPDATE_ANALOG1_IN_AA		(0xC0)
+#define	MCDRV_POWUPDATE_ANALOG2_IN_AA		(0x00)
+#define	MCDRV_POWUPDATE_ANALOG3_IN_AA		(0x0F)
+#define	MCDRV_POWUPDATE_ANALOG4_IN_AA		(0xF0)
+#define	MCDRV_POWUPDATE_ANALOG0_OUT_AA		(0x02)
+#define	MCDRV_POWUPDATE_ANALOG1_OUT_AA		(0x3F)
+#define	MCDRV_POWUPDATE_ANALOG2_OUT_AA		(0x3F)
+#define	MCDRV_POWUPDATE_ANALOG3_OUT_AA		(0x00)
+#define	MCDRV_POWUPDATE_ANALOG4_OUT_AA		(0x00)
+
+
+#define	MCDRV_TCXO_WAIT_TIME_AA		((UINT32)2000)
+#define	MCDRV_PLRST_WAIT_TIME_AA	((UINT32)2000)
+#define	MCDRV_LDOA_WAIT_TIME_AA		((UINT32)1000)
+#define	MCDRV_SP_WAIT_TIME_AA		((UINT32)150)
+#define	MCDRV_HP_WAIT_TIME_AA		((UINT32)300)
+#define	MCDRV_RC_WAIT_TIME_AA		((UINT32)150)
+
+/* SrcRate default */
+#define	MCDRV_DIR_SRCRATE_48000_AA	(32768)
+#define	MCDRV_DIR_SRCRATE_44100_AA	(30106)
+#define	MCDRV_DIR_SRCRATE_32000_AA	(21845)
+#define	MCDRV_DIR_SRCRATE_24000_AA	(16384)
+#define	MCDRV_DIR_SRCRATE_22050_AA	(15053)
+#define	MCDRV_DIR_SRCRATE_16000_AA	(10923)
+#define	MCDRV_DIR_SRCRATE_12000_AA	(8192)
+#define	MCDRV_DIR_SRCRATE_11025_AA	(7526)
+#define	MCDRV_DIR_SRCRATE_8000_AA	(5461)
+
+#define	MCDRV_DIT_SRCRATE_48000_AA	(4096)
+#define	MCDRV_DIT_SRCRATE_44100_AA	(4458)
+#define	MCDRV_DIT_SRCRATE_32000_AA	(6144)
+#define	MCDRV_DIT_SRCRATE_24000_AA	(8192)
+#define	MCDRV_DIT_SRCRATE_22050_AA	(8916)
+#define	MCDRV_DIT_SRCRATE_16000_AA	(12288)
+#define	MCDRV_DIT_SRCRATE_12000_AA	(16384)
+#define	MCDRV_DIT_SRCRATE_11025_AA	(17833)
+#define	MCDRV_DIT_SRCRATE_8000_AA	(24576)
+
+static SINT32	AddAnalogPowerUpAuto(const MCDRV_POWER_INFO_AA* psPowerInfo, const MCDRV_POWER_UPDATE_AA* psPowerUpdate);
+
+static void		AddDIPad(void);
+static void		AddPAD(void);
+static SINT32	AddSource(void);
+static void		AddDIStart(void);
+static UINT8	GetMicMixBit(const MCDRV_CHANNEL* psChannel);
+static void		AddStopADC(void);
+static void		AddStopPDM(void);
+static UINT8	IsModifiedDIO(UINT32 dUpdateInfo);
+static UINT8	IsModifiedDIOCommon(MCDRV_DIO_PORT_NO_AA ePort);
+static UINT8	IsModifiedDIODIR(MCDRV_DIO_PORT_NO_AA ePort);
+static UINT8	IsModifiedDIODIT(MCDRV_DIO_PORT_NO_AA ePort);
+static void		AddDIOCommon(MCDRV_DIO_PORT_NO_AA ePort);
+static void		AddDIODIR(MCDRV_DIO_PORT_NO_AA ePort);
+static void		AddDIODIT(MCDRV_DIO_PORT_NO_AA ePort);
+
+#define	MCDRV_DPB_KEEP_AA	0
+#define	MCDRV_DPB_UP_AA	1
+static SINT32	PowerUpDig(UINT8 bDPBUp);
+
+static UINT32	GetMaxWait(UINT8 bRegChange);
+
+static SINT32		McPacket_AddInit_AA			(const MCDRV_INIT_INFO* psInitInfo);
+static SINT32		McPacket_AddVol_AA			(UINT32 dUpdate, MCDRV_VOLUPDATE_MODE_AA eMode);
+static SINT32		McPacket_AddPowerUp_AA		(const MCDRV_POWER_INFO_AA* psPowerInfo, const MCDRV_POWER_UPDATE_AA* psPowerUpdate);
+static SINT32		McPacket_AddPowerDown_AA	(const MCDRV_POWER_INFO_AA* psPowerInfo, const MCDRV_POWER_UPDATE_AA* psPowerUpdate);
+static SINT32		McPacket_AddPathSet_AA		(void);
+static SINT32		McPacket_AddMixSet_AA		(void);
+static SINT32		McPacket_AddStart_AA		(void);
+static SINT32		McPacket_AddStop_AA			(void);
+static SINT32		McPacket_AddDigitalIO_AA	(UINT32 dUpdateInfo);
+static SINT32		McPacket_AddDAC_AA			(UINT32 dUpdateInfo);
+static SINT32		McPacket_AddADC_AA			(UINT32 dUpdateInfo);
+static SINT32		McPacket_AddSP_AA			(void);
+static SINT32		McPacket_AddDNG_AA			(UINT32 dUpdateInfo);
+static SINT32		McPacket_AddAE_AA			(UINT32 dUpdateInfo);
+static SINT32		McPacket_AddPDM_AA			(UINT32 dUpdateInfo);
+static SINT32		McPacket_AddGPMode_AA		(void);
+static SINT32		McPacket_AddGPMask_AA		(UINT32 dPadNo);
+static SINT32		McPacket_AddGPSet_AA		(UINT8 bGpio, UINT32 dPadNo);
+
+/****************************************************************************
+ *	McPacket_AddInit_AA
+ *
+ *	Description:
+ *			Add initialize packet.
+ *	Arguments:
+ *			psInitInfo		information for initialization
+ *	Return:
+ *			MCDRV_SUCCESS
+ *			MCDRV_ERROR_RESOURCEOVER
+ *
+ ****************************************************************************/
+SINT32	McPacket_AddInit_AA
+(
+	const MCDRV_INIT_INFO*	psInitInfo
+)
+{
+	SINT32	sdRet	= MCDRV_SUCCESS;
+	UINT8	bReg;
+	MCDRV_POWER_INFO_AA	sPowerInfo;
+	MCDRV_POWER_UPDATE_AA	sPowerUpdate;
+
+
+	/*	RSTA	*/
+	McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_FORCE_WRITE_AA | MCDRV_PACKET_REGTYPE_A_AA | MCI_AA_RST, MCB_AA_RST);
+	McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_FORCE_WRITE_AA | MCDRV_PACKET_REGTYPE_A_AA | MCI_AA_RST, 0);
+
+	/*	ANA_RST	*/
+	McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_FORCE_WRITE_AA | MCDRV_PACKET_REGTYPE_B_ANA_AA | (UINT32)MCI_AA_ANA_RST, MCI_AA_ANA_RST_DEF);
+	McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_FORCE_WRITE_AA | MCDRV_PACKET_REGTYPE_B_ANA_AA | (UINT32)MCI_AA_ANA_RST, 0);
+
+	/*	SDIN_MSK*, SDO_DDR*	*/
+	bReg	= MCB_AA_SDIN_MSK2;
+	if(psInitInfo->bDioSdo2Hiz == MCDRV_DAHIZ_LOW)
+	{
+		bReg |= MCB_AA_SDO_DDR2;
+	}
+	bReg |= MCB_AA_SDIN_MSK1;
+	if(psInitInfo->bDioSdo1Hiz == MCDRV_DAHIZ_LOW)
+	{
+		bReg |= MCB_AA_SDO_DDR1;
+	}
+	McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_WRITE_AA | MCDRV_PACKET_REGTYPE_B_BASE_AA | MCI_AA_SD_MSK, bReg);
+
+	bReg	= MCB_AA_SDIN_MSK0;
+	if(psInitInfo->bDioSdo0Hiz == MCDRV_DAHIZ_LOW)
+	{
+		bReg |= MCB_AA_SDO_DDR0;
+	}
+	McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_WRITE_AA | MCDRV_PACKET_REGTYPE_B_BASE_AA | MCI_AA_SD_MSK_1, bReg);
+
+	/*	BCLK_MSK*, BCLD_DDR*, LRCK_MSK*, LRCK_DDR*, PCM_HIZ*	*/
+	bReg	= 0;
+	bReg |= MCB_AA_BCLK_MSK2;
+	bReg |= MCB_AA_LRCK_MSK2;
+	if(psInitInfo->bDioClk2Hiz == MCDRV_DAHIZ_LOW)
+	{
+		bReg |= MCB_AA_BCLK_DDR2;
+		bReg |= MCB_AA_LRCK_DDR2;
+	}
+	bReg |= MCB_AA_BCLK_MSK1;
+	bReg |= MCB_AA_LRCK_MSK1;
+	if(psInitInfo->bDioClk1Hiz == MCDRV_DAHIZ_LOW)
+	{
+		bReg |= MCB_AA_BCLK_DDR1;
+		bReg |= MCB_AA_LRCK_DDR1;
+	}
+	McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_WRITE_AA | MCDRV_PACKET_REGTYPE_B_BASE_AA | MCI_AA_BCLK_MSK, bReg);
+
+	bReg	= 0;
+	bReg |= MCB_AA_BCLK_MSK0;
+	bReg |= MCB_AA_LRCK_MSK0;
+	if(psInitInfo->bDioClk0Hiz == MCDRV_DAHIZ_LOW)
+	{
+		bReg |= MCB_AA_BCLK_DDR0;
+		bReg |= MCB_AA_LRCK_DDR0;
+	}
+	if(psInitInfo->bPcmHiz == MCDRV_PCMHIZ_HIZ)
+	{
+		bReg |= (MCB_AA_PCMOUT_HIZ2 | MCB_AA_PCMOUT_HIZ1 | MCB_AA_PCMOUT_HIZ0);
+	}
+	McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_WRITE_AA | MCDRV_PACKET_REGTYPE_B_BASE_AA | MCI_AA_BCLK_MSK_1, bReg);
+
+	/*	DI*_BCKP	*/
+
+	/*	PA*_MSK, PA*_DDR	*/
+	bReg	= MCI_AA_PA_MSK_1_DEF;
+	if(psInitInfo->bPad0Func == MCDRV_PAD_PDMCK)
+	{
+		bReg	|= MCB_AA_PA0_DDR;
+	}
+	McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_WRITE_AA | MCDRV_PACKET_REGTYPE_B_BASE_AA | MCI_AA_PA_MSK_1, bReg);
+
+	/*	PA0_OUT	*/
+	if(psInitInfo->bPad0Func == MCDRV_PAD_PDMCK)
+	{
+		McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_WRITE_AA | MCDRV_PACKET_REGTYPE_B_BASE_AA | MCI_AA_PA_OUT, MCB_AA_PA_OUT);
+	}
+
+	/*	SCU_PA*	*/
+
+	/*	CKSEL	*/
+	if(psInitInfo->bCkSel != MCDRV_CKSEL_CMOS)
+	{
+		McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_WRITE_AA | MCDRV_PACKET_REGTYPE_B_BASE_AA | MCI_AA_CKSEL, MCB_AA_CKSEL);
+	}
+
+	/*	DIVR0, DIVF0	*/
+	McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_WRITE_AA | MCDRV_PACKET_REGTYPE_B_BASE_AA | MCI_AA_DIVR0, psInitInfo->bDivR0);
+	McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_WRITE_AA | MCDRV_PACKET_REGTYPE_B_BASE_AA | MCI_AA_DIVF0, psInitInfo->bDivF0);
+
+	/*	Clock Start	*/
+	sdRet	= McDevIf_ExecutePacket_AA();
+	if(sdRet != MCDRV_SUCCESS)
+	{
+		return sdRet;
+	}
+	McSrv_ClockStart();
+
+	/*	DP0	*/
+	bReg	= MCB_AA_PWM_DP2|MCB_AA_PWM_DP1;
+	McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_WRITE_AA | MCDRV_PACKET_REGTYPE_B_BASE_AA | MCI_AA_PWM_DIGITAL, bReg);
+	if(psInitInfo->bCkSel != MCDRV_CKSEL_CMOS)
+	{
+		/*	2ms wait	*/
+		McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_TIMWAIT_AA | MCDRV_TCXO_WAIT_TIME_AA, 0);
+	}
+
+	/*	PLLRST0	*/
+	McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_WRITE_AA | MCDRV_PACKET_REGTYPE_B_BASE_AA | MCI_AA_PLL_RST, 0);
+	/*	2ms wait	*/
+	McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_TIMWAIT_AA | MCDRV_PLRST_WAIT_TIME_AA, 0);
+	/*	DP1/DP2 up	*/
+	McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_WRITE_AA | MCDRV_PACKET_REGTYPE_B_BASE_AA | MCI_AA_PWM_DIGITAL, 0);
+	/*	RSTB	*/
+	McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_WRITE_AA | MCDRV_PACKET_REGTYPE_B_BASE_AA | MCI_AA_RSTB, 0);
+	/*	DPB	*/
+	bReg	= MCB_AA_PWM_DPPDM|MCB_AA_PWM_DPDI2|MCB_AA_PWM_DPDI1|MCB_AA_PWM_DPDI0;
+	McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_WRITE_AA | MCDRV_PACKET_REGTYPE_B_BASE_AA | MCI_AA_PWM_DIGITAL_1, bReg);
+
+	/*	DCL_GAIN, DCL_LMT	*/
+	bReg	= (psInitInfo->bDclGain<<4) | psInitInfo->bDclLimit;
+	McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_WRITE_AA | MCDRV_PACKET_REGTYPE_B_CODEC_AA | MCI_AA_DCL, bReg);
+
+	/*	DIF_LI, DIF_LO*	*/
+	bReg	= (psInitInfo->bLineOut2Dif<<5) | (psInitInfo->bLineOut1Dif<<4) | psInitInfo->bLineIn1Dif;
+	McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_WRITE_AA | MCDRV_PACKET_REGTYPE_B_ANA_AA | MCI_AA_DIF_LINE, bReg);
+
+	/*	SP*_HIZ, SPMN	*/
+	bReg	= (psInitInfo->bSpmn << 1);
+	if(MCDRV_SPHIZ_HIZ == psInitInfo->bSpHiz)
+	{
+		bReg	|= (MCB_AA_SPL_HIZ|MCB_AA_SPR_HIZ);
+	}
+	McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_WRITE_AA | MCDRV_PACKET_REGTYPE_B_ANA_AA | MCI_AA_SP_MODE, bReg);
+
+	/*	MC*SNG	*/
+	bReg	= (psInitInfo->bMic2Sng<<6) | (psInitInfo->bMic1Sng<<2);
+	McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_WRITE_AA | MCDRV_PACKET_REGTYPE_B_ANA_AA | MCI_AA_MC_GAIN, bReg);
+	bReg	= (psInitInfo->bMic3Sng<<2);
+	McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_WRITE_AA | MCDRV_PACKET_REGTYPE_B_ANA_AA | MCI_AA_MC3_GAIN, bReg);
+
+	/*	AVDDLEV, VREFLEV	*/
+	bReg	= 0x20 | psInitInfo->bAvddLev;
+	McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_WRITE_AA | MCDRV_PACKET_REGTYPE_B_ANA_AA | MCI_AA_LEV, bReg);
+
+	McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_WRITE_AA | MCDRV_PACKET_REGTYPE_A_AA | (UINT32)MCI_AA_ANA_ADR, MCI_AA_PWM_ANALOG_0);
+	McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_WRITE_AA | MCDRV_PACKET_REGTYPE_A_AA | (UINT32)60, 0xD9);
+	McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_WRITE_AA | MCDRV_PACKET_REGTYPE_A_AA | (UINT32)MCI_AA_ANA_WINDOW, MCI_AA_PWM_ANALOG_0_DEF);
+
+	if((psInitInfo->bPowerMode & MCDRV_POWMODE_VREFON) != 0 || McResCtrl_GetAPMode_AA() == eMCDRV_APM_OFF_AA)
+	{
+		bReg	= MCI_AA_PWM_ANALOG_0_DEF;
+		if(psInitInfo->bLdo == MCDRV_LDO_ON)
+		{
+			/*	AP_LDOA	*/
+			bReg	&= (UINT8)~MCB_AA_PWM_LDOA;
+			McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_WRITE_AA | MCDRV_PACKET_REGTYPE_B_ANA_AA | MCI_AA_PWM_ANALOG_0, bReg);
+			McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_TIMWAIT_AA | MCDRV_LDOA_WAIT_TIME_AA, 0);
+		}
+		else
+		{
+			bReg	&= (UINT8)~MCB_AA_PWM_REFA;
+		}
+		/*	AP_VR up	*/
+		bReg	&= (UINT8)~MCB_AA_PWM_VR;
+		McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_WRITE_AA | MCDRV_PACKET_REGTYPE_B_ANA_AA | MCI_AA_PWM_ANALOG_0, bReg);
+		sdRet	= McDevIf_ExecutePacket_AA();
+		if(sdRet != MCDRV_SUCCESS)
+		{
+			return sdRet;
+		}
+		McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_TIMWAIT_AA | psInitInfo->sWaitTime.dVrefRdy2, 0);
+	}
+
+	if(McResCtrl_GetAPMode_AA() == eMCDRV_APM_OFF_AA)
+	{
+		bReg	= MCB_AA_AMPOFF_SP|MCB_AA_AMPOFF_HP|MCB_AA_AMPOFF_RC;
+		McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_WRITE_AA | MCDRV_PACKET_REGTYPE_B_ANA_AA | MCI_AA_AMP, bReg);
+	}
+
+	sdRet	= McDevIf_ExecutePacket_AA();
+	if (MCDRV_SUCCESS != sdRet)
+	{
+		return sdRet;
+	}
+
+	/*	unused path power down	*/
+	McResCtrl_GetPowerInfo_AA(&sPowerInfo);
+	sPowerUpdate.dDigital		= MCDRV_POWUPDATE_DIGITAL_ALL_AA;
+	sPowerUpdate.abAnalog[0]	= (UINT8)MCDRV_POWUPDATE_ANALOG0_ALL_AA;
+	sPowerUpdate.abAnalog[1]	= (UINT8)MCDRV_POWUPDATE_ANALOG1_ALL_AA;
+	sPowerUpdate.abAnalog[2]	= (UINT8)MCDRV_POWUPDATE_ANALOG2_ALL_AA;
+	sPowerUpdate.abAnalog[3]	= (UINT8)MCDRV_POWUPDATE_ANALOG3_ALL_AA;
+	sPowerUpdate.abAnalog[4]	= (UINT8)MCDRV_POWUPDATE_ANALOG4_ALL_AA;
+	return McPacket_AddPowerDown_AA(&sPowerInfo, &sPowerUpdate);
+}
+
+/****************************************************************************
+ *	McPacket_AddPowerUp_AA
+ *
+ *	Description:
+ *			Add powerup packet.
+ *	Arguments:
+ *			psPowerInfo		power information
+ *			psPowerUpdate	power update information
+ *	Return:
+ *			MCDRV_SUCCESS
+ *			MCDRV_ERROR_RESOURCEOVER
+ *			MCDRV_ERROR_TIMEOUT
+ *
+ ****************************************************************************/
+SINT32	McPacket_AddPowerUp_AA
+(
+	const MCDRV_POWER_INFO_AA*		psPowerInfo,
+	const MCDRV_POWER_UPDATE_AA*	psPowerUpdate
+)
+{
+	SINT32	sdRet	= MCDRV_SUCCESS;
+	UINT8	bReg;
+	UINT8	bRegCur;
+	UINT8	bRegAna1;
+	UINT8	bRegAna2;
+	UINT32	dUpdate;
+	UINT8	bRegChange;
+	UINT8	bSpHizReg;
+	UINT32	dWaitTime;
+	UINT32	dWaitTimeDone	= 0;
+	UINT8	bWaitVREFRDY	= 0;
+	UINT8	bWaitHPVolUp	= 0;
+	UINT8	bWaitSPVolUp	= 0;
+	MCDRV_INIT_INFO	sInitInfo;
+
+
+	McResCtrl_GetInitInfo_AA(&sInitInfo);
+
+	/*	Digital Power	*/
+	dUpdate	= ~psPowerInfo->dDigital & psPowerUpdate->dDigital;
+	if((dUpdate & MCDRV_POWINFO_DIGITAL_DP0_AA) != 0)
+	{
+		if((McResCtrl_GetRegVal_AA(MCDRV_PACKET_REGTYPE_B_BASE_AA, MCI_AA_PWM_DIGITAL) & MCB_AA_PWM_DP0) != 0)
+		{/*	DP0 changed	*/
+			/*	CKSEL	*/
+			if(sInitInfo.bCkSel != MCDRV_CKSEL_CMOS)
+			{
+				McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_WRITE_AA | MCDRV_PACKET_REGTYPE_B_BASE_AA | (UINT32)MCI_AA_CKSEL, MCB_AA_CKSEL);
+			}
+			else
+			{
+				McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_WRITE_AA | MCDRV_PACKET_REGTYPE_B_BASE_AA | (UINT32)MCI_AA_CKSEL, 0);
+			}
+			/*	DIVR0, DIVF0	*/
+			McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_WRITE_AA | MCDRV_PACKET_REGTYPE_B_BASE_AA | (UINT32)MCI_AA_DIVR0, sInitInfo.bDivR0);
+			McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_WRITE_AA | MCDRV_PACKET_REGTYPE_B_BASE_AA | (UINT32)MCI_AA_DIVF0, sInitInfo.bDivF0);
+			sdRet	= McDevIf_ExecutePacket_AA();
+			if(sdRet != MCDRV_SUCCESS)
+			{
+				return sdRet;
+			}
+			/*	Clock Start	*/
+			McSrv_ClockStart();
+			/*	DP0 up	*/
+			bReg	= MCB_AA_PWM_DP2|MCB_AA_PWM_DP1;
+			McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_WRITE_AA | MCDRV_PACKET_REGTYPE_B_BASE_AA | MCI_AA_PWM_DIGITAL, bReg);
+			if(sInitInfo.bCkSel != MCDRV_CKSEL_CMOS)
+			{
+				McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_TIMWAIT_AA | MCDRV_TCXO_WAIT_TIME_AA, 0);
+			}
+			/*	PLLRST0 up	*/
+			McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_WRITE_AA | MCDRV_PACKET_REGTYPE_B_BASE_AA | MCI_AA_PLL_RST, 0);
+			/*	2ms wait	*/
+			McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_TIMWAIT_AA | MCDRV_PLRST_WAIT_TIME_AA, 0);
+			/*	DP1/DP2 up	*/
+			McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_WRITE_AA | MCDRV_PACKET_REGTYPE_B_BASE_AA | MCI_AA_PWM_DIGITAL, 0);
+			/*	DPB/DPDI* up	*/
+			bReg	= McResCtrl_GetRegVal_AA(MCDRV_PACKET_REGTYPE_B_BASE_AA, MCI_AA_PWM_DIGITAL_1);
+			if((dUpdate & MCDRV_POWINFO_DIGITAL_DPDI0_AA) != 0)
+			{
+				bReg	&= (UINT8)~MCB_AA_PWM_DPDI0;
+			}
+			if((dUpdate & MCDRV_POWINFO_DIGITAL_DPDI1_AA) != 0)
+			{
+				bReg	&= (UINT8)~MCB_AA_PWM_DPDI1;
+			}
+			if((dUpdate & MCDRV_POWINFO_DIGITAL_DPDI2_AA) != 0)
+			{
+				bReg	&= (UINT8)~MCB_AA_PWM_DPDI2;
+			}
+			if((dUpdate & MCDRV_POWINFO_DIGITAL_DPPDM_AA) != 0)
+			{
+				bReg	&= (UINT8)~MCB_AA_PWM_DPPDM;
+			}
+			if((dUpdate & MCDRV_POWINFO_DIGITAL_DPB_AA) != 0)
+			{
+				bReg	&= (UINT8)~MCB_AA_PWM_DPB;
+			}
+			McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_WRITE_AA | MCDRV_PACKET_REGTYPE_B_BASE_AA | MCI_AA_PWM_DIGITAL_1, bReg);
+		}
+		else if((dUpdate & MCDRV_POWINFO_DIGITAL_DP2_AA) != 0)
+		{
+			/*	DP1/DP2 up	*/
+			McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_WRITE_AA | MCDRV_PACKET_REGTYPE_B_BASE_AA | MCI_AA_PWM_DIGITAL, 0);
+			/*	DPB/DPDI* up	*/
+			bReg	= McResCtrl_GetRegVal_AA(MCDRV_PACKET_REGTYPE_B_BASE_AA, MCI_AA_PWM_DIGITAL_1);
+			if((dUpdate & MCDRV_POWINFO_DIGITAL_DPDI0_AA) != 0)
+			{
+				bReg	&= (UINT8)~MCB_AA_PWM_DPDI0;
+			}
+			if((dUpdate & MCDRV_POWINFO_DIGITAL_DPDI1_AA) != 0)
+			{
+				bReg	&= (UINT8)~MCB_AA_PWM_DPDI1;
+			}
+			if((dUpdate & MCDRV_POWINFO_DIGITAL_DPDI2_AA) != 0)
+			{
+				bReg	&= (UINT8)~MCB_AA_PWM_DPDI2;
+			}
+			if((dUpdate & MCDRV_POWINFO_DIGITAL_DPPDM_AA) != 0)
+			{
+				bReg	&= (UINT8)~MCB_AA_PWM_DPPDM;
+			}
+			if((dUpdate & MCDRV_POWINFO_DIGITAL_DPB_AA) != 0)
+			{
+				bReg	&= (UINT8)~MCB_AA_PWM_DPB;
+			}
+			McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_WRITE_AA | MCDRV_PACKET_REGTYPE_B_BASE_AA | MCI_AA_PWM_DIGITAL_1, bReg);
+		}
+
+		/*	DPBDSP	*/
+		if((dUpdate & MCDRV_POWINFO_DIGITAL_DPBDSP_AA) != 0)
+		{
+			McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_WRITE_AA | MCDRV_PACKET_REGTYPE_B_BASE_AA | MCI_AA_PWM_DIGITAL_BDSP, 0);
+		}
+		/*	DPADIF	*/
+		if((dUpdate & MCDRV_POWINFO_DIGITAL_DPADIF_AA) != 0)
+		{
+			McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_WRITE_AA | MCDRV_PACKET_REGTYPE_B_CODEC_AA | MCI_AA_DPADIF, 0);
+		}
+	}
+
+	if(McResCtrl_GetAPMode_AA() == eMCDRV_APM_ON_AA)
+	{
+		return AddAnalogPowerUpAuto(psPowerInfo, psPowerUpdate);
+	}
+
+	/*	Analog Power	*/
+	dUpdate	= ~psPowerInfo->abAnalog[0] & psPowerUpdate->abAnalog[0];
+	if((dUpdate & MCB_AA_PWM_VR) != 0)
+	{
+		if((McResCtrl_GetRegVal_AA(MCDRV_PACKET_REGTYPE_B_ANA_AA, MCI_AA_PWM_ANALOG_0) & MCB_AA_PWM_VR) != 0)
+		{/*	AP_VR changed	*/
+			bReg	= MCI_AA_PWM_ANALOG_0_DEF;
+			if(sInitInfo.bLdo == MCDRV_LDO_ON)
+			{
+				/*	AP_LDOA	*/
+				bReg	&= (UINT8)~MCB_AA_PWM_LDOA;
+				McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_WRITE_AA | MCDRV_PACKET_REGTYPE_B_ANA_AA | (UINT32)MCI_AA_PWM_ANALOG_0, bReg);
+				McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_TIMWAIT_AA | MCDRV_LDOA_WAIT_TIME_AA, 0);
+			}
+			else
+			{
+				bReg	&= (UINT8)~MCB_AA_PWM_REFA;
+			}
+			/*	AP_VR up	*/
+			bReg	&= (UINT8)~MCB_AA_PWM_VR;
+			McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_WRITE_AA | MCDRV_PACKET_REGTYPE_B_ANA_AA | (UINT32)MCI_AA_PWM_ANALOG_0, bReg);
+			dWaitTimeDone	= sInitInfo.sWaitTime.dVrefRdy1;
+			McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_TIMWAIT_AA | dWaitTimeDone, 0);
+			bWaitVREFRDY	= 1;
+		}
+
+		bReg	= (UINT8)~((UINT8)~psPowerInfo->abAnalog[1] & psPowerUpdate->abAnalog[1]) & McResCtrl_GetRegVal_AA(MCDRV_PACKET_REGTYPE_B_ANA_AA, MCI_AA_PWM_ANALOG_1);
+		/*	SP_HIZ control	*/
+		if(MCDRV_SPHIZ_HIZ == sInitInfo.bSpHiz)
+		{
+			bSpHizReg	= 0;
+			if((bReg & (MCB_AA_PWM_SPL1 | MCB_AA_PWM_SPL2)) != 0)
+			{
+				bSpHizReg |= MCB_AA_SPL_HIZ;
+			}
+
+			if((bReg & (MCB_AA_PWM_SPR1 | MCB_AA_PWM_SPR2)) != 0)
+			{
+				bSpHizReg |= MCB_AA_SPR_HIZ;
+			}
+
+			bSpHizReg |= (McResCtrl_GetRegVal_AA(MCDRV_PACKET_REGTYPE_B_ANA_AA, MCI_AA_SP_MODE) & (MCB_AA_SPMN | MCB_AA_SP_SWAP));
+			McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_WRITE_AA | MCDRV_PACKET_REGTYPE_B_ANA_AA | MCI_AA_SP_MODE, bSpHizReg);
+		}
+
+		bRegCur	= McResCtrl_GetRegVal_AA(MCDRV_PACKET_REGTYPE_B_ANA_AA, MCI_AA_PWM_ANALOG_3);
+		bReg	= (UINT8)~((UINT8)~psPowerInfo->abAnalog[3] & psPowerUpdate->abAnalog[3]) & bRegCur;
+		bRegChange	= bReg ^ bRegCur;
+		/*	set DACON and NSMUTE before setting 0 to AP_DA	*/
+		if((bRegChange & MCB_AA_PWM_DA) != 0 && (psPowerInfo->abAnalog[3] & psPowerUpdate->abAnalog[3] & MCB_AA_PWM_DA) == 0)
+		{
+			McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_WRITE_AA | MCDRV_PACKET_REGTYPE_B_CODEC_AA | (UINT32)MCI_AA_DAC_CONFIG, MCB_AA_NSMUTE);
+			McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_WRITE_AA | MCDRV_PACKET_REGTYPE_B_CODEC_AA | (UINT32)MCI_AA_DAC_CONFIG, (MCB_AA_DACON | MCB_AA_NSMUTE));
+			McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_WRITE_AA | MCDRV_PACKET_REGTYPE_B_CODEC_AA | (UINT32)MCI_AA_DAC_CONFIG, MCB_AA_DACON);
+		}
+		McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_WRITE_AA | MCDRV_PACKET_REGTYPE_B_ANA_AA | MCI_AA_PWM_ANALOG_3, bReg);
+
+		bRegCur	= McResCtrl_GetRegVal_AA(MCDRV_PACKET_REGTYPE_B_ANA_AA, MCI_AA_PWM_ANALOG_4);
+		bReg	= (UINT8)~((UINT8)~psPowerInfo->abAnalog[4] & psPowerUpdate->abAnalog[4]) & bRegCur;
+		bRegChange	|= (bReg ^ bRegCur);
+		McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_WRITE_AA | MCDRV_PACKET_REGTYPE_B_ANA_AA | MCI_AA_PWM_ANALOG_4, bReg);
+
+		if(bWaitVREFRDY != 0)
+		{
+			/*	wait VREF_RDY	*/
+			dWaitTimeDone	= sInitInfo.sWaitTime.dVrefRdy2 - dWaitTimeDone;
+			McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_TIMWAIT_AA | dWaitTimeDone, 0);
+		}
+
+		sdRet	= McDevIf_ExecutePacket_AA();
+		if(sdRet != MCDRV_SUCCESS)
+		{
+			return sdRet;
+		}
+		bRegCur	= McResCtrl_GetRegVal_AA(MCDRV_PACKET_REGTYPE_B_ANA_AA, MCI_AA_PWM_ANALOG_0);
+		bReg	= (UINT8)~dUpdate & bRegCur;
+		McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_WRITE_AA | MCDRV_PACKET_REGTYPE_B_ANA_AA | MCI_AA_PWM_ANALOG_0, bReg);
+		if((bRegCur & MCB_AA_PWM_CP) != 0 && (bReg & MCB_AA_PWM_CP) == 0)
+		{/*	AP_CP up	*/
+			dWaitTime		= MCDRV_HP_WAIT_TIME_AA;
+		}
+		else
+		{
+			dWaitTime	= 0;
+		}
+
+		bRegCur	= McResCtrl_GetRegVal_AA(MCDRV_PACKET_REGTYPE_B_ANA_AA, MCI_AA_PWM_ANALOG_1);
+		bRegAna1	= (UINT8)~(~psPowerInfo->abAnalog[1] & psPowerUpdate->abAnalog[1]) & bRegCur;
+		if(((bRegCur & MCB_AA_PWM_SPL1) != 0 && (bRegAna1 & MCB_AA_PWM_SPL1) == 0)
+		|| ((bRegCur & MCB_AA_PWM_SPR1) != 0 && (bRegAna1 & MCB_AA_PWM_SPR1) == 0))
+		{/*	AP_SP* up	*/
+			bReg	= bRegAna1|(bRegCur&(UINT8)~(MCB_AA_PWM_SPL1|MCB_AA_PWM_SPR1));
+			McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_WRITE_AA | MCDRV_PACKET_REGTYPE_B_ANA_AA | MCI_AA_PWM_ANALOG_1, bReg);
+			if(dWaitTime == (UINT32)0)
+			{
+				dWaitTime		= MCDRV_SP_WAIT_TIME_AA;
+				bWaitSPVolUp	= 1;
+			}
+		}
+		if(((bRegCur & MCB_AA_PWM_HPL) != 0 && (bRegAna1 & MCB_AA_PWM_HPL) == 0)
+		|| ((bRegCur & MCB_AA_PWM_HPR) != 0 && (bRegAna1 & MCB_AA_PWM_HPR) == 0))
+		{
+			bWaitHPVolUp	= 1;
+		}
+
+		bRegCur	= McResCtrl_GetRegVal_AA(MCDRV_PACKET_REGTYPE_B_ANA_AA, MCI_AA_PWM_ANALOG_2);
+		bRegAna2	= (UINT8)~(~psPowerInfo->abAnalog[2] & psPowerUpdate->abAnalog[2]) & bRegCur;
+		if((bRegCur & MCB_AA_PWM_RC1) != 0 && (bRegAna2 & MCB_AA_PWM_RC1) == 0)
+		{/*	AP_RC up	*/
+			bReg	= bRegAna2|(bRegCur&~MCB_AA_PWM_RC1);
+			McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_WRITE_AA | MCDRV_PACKET_REGTYPE_B_ANA_AA | MCI_AA_PWM_ANALOG_2, bReg);
+			if(dWaitTime == (UINT32)0)
+			{
+				dWaitTime	= MCDRV_RC_WAIT_TIME_AA;
+			}
+		}
+		if(dWaitTime > (UINT32)0)
+		{
+			McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_TIMWAIT_AA | dWaitTime, 0);
+			dWaitTimeDone	+= dWaitTime;
+		}
+
+		McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_WRITE_AA | MCDRV_PACKET_REGTYPE_B_ANA_AA | MCI_AA_PWM_ANALOG_1, bRegAna1);
+		McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_WRITE_AA | MCDRV_PACKET_REGTYPE_B_ANA_AA | MCI_AA_PWM_ANALOG_2, bRegAna2);
+
+		/*	time wait	*/
+		dWaitTime	= GetMaxWait(bRegChange);
+		if(dWaitTime > dWaitTimeDone)
+		{
+			dWaitTime	= dWaitTime - dWaitTimeDone;
+			McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_TIMWAIT_AA | dWaitTime, 0);
+			dWaitTimeDone	+= dWaitTime;
+		}
+
+		if(bWaitSPVolUp != 0 && sInitInfo.sWaitTime.dSpRdy > dWaitTimeDone)
+		{
+			dWaitTime	= sInitInfo.sWaitTime.dSpRdy - dWaitTimeDone;
+			McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_TIMWAIT_AA | dWaitTime, 0);
+			dWaitTimeDone	+= dWaitTime;
+		}
+		if(bWaitHPVolUp != 0 && sInitInfo.sWaitTime.dHpRdy > dWaitTimeDone)
+		{
+			dWaitTime	= sInitInfo.sWaitTime.dHpRdy - dWaitTimeDone;
+			McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_TIMWAIT_AA | dWaitTime, 0);
+			dWaitTimeDone	+= dWaitTime;
+		}
+	}
+	return sdRet;
+}
+
+/****************************************************************************
+ *	AddAnalogPowerUpAuto
+ *
+ *	Description:
+ *			Add analog auto powerup packet.
+ *	Arguments:
+ *			psPowerInfo		power information
+ *			psPowerUpdate	power update information
+ *	Return:
+ *			MCDRV_SUCCESS
+ *			MCDRV_ERROR_RESOURCEOVER
+ *			MCDRV_ERROR_TIMEOUT
+ *
+ ****************************************************************************/
+static SINT32	AddAnalogPowerUpAuto
+(
+	const MCDRV_POWER_INFO_AA*		psPowerInfo,
+	const MCDRV_POWER_UPDATE_AA*	psPowerUpdate
+)
+{
+	SINT32	sdRet	= MCDRV_SUCCESS;
+	UINT8	bReg;
+	UINT8	bRegCur;
+	UINT32	dUpdate;
+	UINT8	bRegChange;
+	UINT8	bSpHizReg;
+	MCDRV_INIT_INFO	sInitInfo;
+	UINT32	dWaitTime	= 0;
+
+
+	McResCtrl_GetInitInfo_AA(&sInitInfo);
+
+	/*	Analog Power	*/
+	dUpdate	= (UINT32)~psPowerInfo->abAnalog[0] & psPowerUpdate->abAnalog[0];
+	if((dUpdate & MCB_AA_PWM_VR) != 0)
+	{
+		if((McResCtrl_GetRegVal_AA(MCDRV_PACKET_REGTYPE_B_ANA_AA, MCI_AA_PWM_ANALOG_0) & MCB_AA_PWM_VR) != 0)
+		{/*	AP_VR changed	*/
+			/*	AP_VR up	*/
+			bReg	= MCI_AA_PWM_ANALOG_0_DEF;
+			if(sInitInfo.bLdo == MCDRV_LDO_ON)
+			{
+				/*	AP_LDOA	*/
+				bReg	&= (UINT8)~MCB_AA_PWM_LDOA;
+				McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_WRITE_AA | MCDRV_PACKET_REGTYPE_B_ANA_AA | (UINT32)MCI_AA_PWM_ANALOG_0, bReg);
+				McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_TIMWAIT_AA | MCDRV_LDOA_WAIT_TIME_AA, 0);
+			}
+			else
+			{
+				bReg	&= (UINT8)~MCB_AA_PWM_REFA;
+			}
+			bReg	&= (UINT8)~MCB_AA_PWM_VR;
+			McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_WRITE_AA | MCDRV_PACKET_REGTYPE_B_ANA_AA | (UINT32)MCI_AA_PWM_ANALOG_0, bReg);
+			McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_TIMWAIT_AA | sInitInfo.sWaitTime.dVrefRdy1, 0);
+			if(sInitInfo.sWaitTime.dVrefRdy2 > sInitInfo.sWaitTime.dVrefRdy1)
+			{
+				dWaitTime	= sInitInfo.sWaitTime.dVrefRdy2 - sInitInfo.sWaitTime.dVrefRdy1;
+			}
+		}
+
+		bReg	= (UINT8)~((UINT8)~psPowerInfo->abAnalog[1] & psPowerUpdate->abAnalog[1]) & McResCtrl_GetRegVal_AA(MCDRV_PACKET_REGTYPE_B_ANA_AA, MCI_AA_PWM_ANALOG_1);
+		/*	SP_HIZ control	*/
+		if(MCDRV_SPHIZ_HIZ == sInitInfo.bSpHiz)
+		{
+			bSpHizReg	= 0;
+			if((bReg & (MCB_AA_PWM_SPL1 | MCB_AA_PWM_SPL2)) != 0)
+			{
+				bSpHizReg |= MCB_AA_SPL_HIZ;
+			}
+
+			if((bReg & (MCB_AA_PWM_SPR1 | MCB_AA_PWM_SPR2)) != 0)
+			{
+				bSpHizReg |= MCB_AA_SPR_HIZ;
+			}
+
+			bSpHizReg |= (McResCtrl_GetRegVal_AA(MCDRV_PACKET_REGTYPE_B_ANA_AA, MCI_AA_SP_MODE) & (MCB_AA_SPMN | MCB_AA_SP_SWAP));
+			McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_WRITE_AA | MCDRV_PACKET_REGTYPE_B_ANA_AA | MCI_AA_SP_MODE, bSpHizReg);
+		}
+
+		bRegCur	= McResCtrl_GetRegVal_AA(MCDRV_PACKET_REGTYPE_B_ANA_AA, MCI_AA_PWM_ANALOG_3);
+		bReg	= (UINT8)~((UINT8)~psPowerInfo->abAnalog[3] & psPowerUpdate->abAnalog[3]) & bRegCur;
+		bRegChange	= bReg ^ bRegCur;
+		/*	set DACON and NSMUTE before setting 0 to AP_DA	*/
+		if((bRegChange & MCB_AA_PWM_DA) != 0 && (psPowerInfo->abAnalog[3] & psPowerUpdate->abAnalog[3] & MCB_AA_PWM_DA) == 0)
+		{
+			McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_WRITE_AA | MCDRV_PACKET_REGTYPE_B_CODEC_AA | (UINT32)MCI_AA_DAC_CONFIG, MCB_AA_NSMUTE);
+			McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_WRITE_AA | MCDRV_PACKET_REGTYPE_B_CODEC_AA | (UINT32)MCI_AA_DAC_CONFIG, (MCB_AA_DACON | MCB_AA_NSMUTE));
+			McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_WRITE_AA | MCDRV_PACKET_REGTYPE_B_CODEC_AA | (UINT32)MCI_AA_DAC_CONFIG, MCB_AA_DACON);
+		}
+		McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_WRITE_AA | MCDRV_PACKET_REGTYPE_B_ANA_AA | MCI_AA_PWM_ANALOG_3, bReg);
+
+		bRegCur	= McResCtrl_GetRegVal_AA(MCDRV_PACKET_REGTYPE_B_ANA_AA, MCI_AA_PWM_ANALOG_4);
+		bReg	= (UINT8)~((UINT8)~psPowerInfo->abAnalog[4] & psPowerUpdate->abAnalog[4]) & bRegCur;
+		bRegChange	|= (bReg ^ bRegCur);
+		McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_WRITE_AA | MCDRV_PACKET_REGTYPE_B_ANA_AA | MCI_AA_PWM_ANALOG_4, bReg);
+
+		if(dWaitTime > (UINT32)0)
+		{
+			McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_TIMWAIT_AA | dWaitTime, 0);
+		}
+
+		sdRet	= McDevIf_ExecutePacket_AA();
+		if(sdRet != MCDRV_SUCCESS)
+		{
+			return sdRet;
+		}
+		bRegCur	= McResCtrl_GetRegVal_AA(MCDRV_PACKET_REGTYPE_B_ANA_AA, MCI_AA_PWM_ANALOG_0);
+		bReg	= (UINT8)~dUpdate & bRegCur;
+		McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_WRITE_AA | MCDRV_PACKET_REGTYPE_B_ANA_AA | MCI_AA_PWM_ANALOG_0, bReg);
+
+		bRegCur	= McResCtrl_GetRegVal_AA(MCDRV_PACKET_REGTYPE_B_ANA_AA, MCI_AA_PWM_ANALOG_1);
+		bReg	= (UINT8)~((UINT8)~psPowerInfo->abAnalog[1] & psPowerUpdate->abAnalog[1]) & bRegCur;
+		if((bRegCur & (MCB_AA_PWM_ADL|MCB_AA_PWM_ADR)) != (bReg & (MCB_AA_PWM_ADL|MCB_AA_PWM_ADR)))
+		{
+			McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_WRITE_AA | MCDRV_PACKET_REGTYPE_B_ANA_AA | MCI_AA_PWM_ANALOG_1, bReg);
+		}
+		else
+		{
+			sdRet	= McDevIf_ExecutePacket_AA();
+			if(sdRet != MCDRV_SUCCESS)
+			{
+				return sdRet;
+			}
+			McResCtrl_SetRegVal_AA(MCDRV_PACKET_REGTYPE_B_ANA_AA, MCI_AA_PWM_ANALOG_1, bReg);
+		}
+
+		bRegCur	= McResCtrl_GetRegVal_AA(MCDRV_PACKET_REGTYPE_B_ANA_AA, MCI_AA_PWM_ANALOG_2);
+		bReg	= (UINT8)~((UINT8)~psPowerInfo->abAnalog[2] & psPowerUpdate->abAnalog[2]) & bRegCur;
+		if((bRegCur & (MCB_AA_PWM_LO1L|MCB_AA_PWM_LO1R|MCB_AA_PWM_LO2L|MCB_AA_PWM_LO2R)) != (bReg & (MCB_AA_PWM_LO1L|MCB_AA_PWM_LO1R|MCB_AA_PWM_LO2L|MCB_AA_PWM_LO2R)))
+		{
+			bReg	= bReg|(bRegCur&(MCB_AA_PWM_RC1|MCB_AA_PWM_RC2));
+			McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_WRITE_AA | MCDRV_PACKET_REGTYPE_B_ANA_AA | MCI_AA_PWM_ANALOG_2, bReg);
+		}
+		else
+		{
+			sdRet	= McDevIf_ExecutePacket_AA();
+			if(sdRet != MCDRV_SUCCESS)
+			{
+				return sdRet;
+			}
+			McResCtrl_SetRegVal_AA(MCDRV_PACKET_REGTYPE_B_ANA_AA, MCI_AA_PWM_ANALOG_2, bReg);
+		}
+
+		/*	time wait	*/
+		if(dWaitTime < GetMaxWait(bRegChange))
+		{
+			dWaitTime	= GetMaxWait(bRegChange) - dWaitTime;
+			McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_TIMWAIT_AA | dWaitTime, 0);
+		}
+	}
+	return sdRet;
+}
+
+/****************************************************************************
+ *	McPacket_AddPowerDown_AA
+ *
+ *	Description:
+ *			Add powerdown packet.
+ *	Arguments:
+ *			psPowerInfo		power information
+ *			psPowerUpdate	power update information
+ *	Return:
+ *			MCDRV_SUCCESS
+ *			MCDRV_ERROR_RESOURCEOVER
+ *			MCDRV_ERROR_TIMEOUT
+ *
+ ****************************************************************************/
+SINT32	McPacket_AddPowerDown_AA
+(
+	const MCDRV_POWER_INFO_AA*		psPowerInfo,
+	const MCDRV_POWER_UPDATE_AA*	psPowerUpdate
+)
+{
+	SINT32	sdRet	= MCDRV_SUCCESS;
+	UINT8	bReg;
+	UINT8	bRegCur;
+	UINT32	dUpdate	= psPowerInfo->dDigital & psPowerUpdate->dDigital;
+	UINT32	dAPMDoneParam;
+	UINT32	dAnaRdyParam;
+	UINT8	bSpHizReg;
+	MCDRV_INIT_INFO	sInitInfo;
+
+
+	McResCtrl_GetInitInfo_AA(&sInitInfo);
+
+	if(McResCtrl_GetAPMode_AA() == eMCDRV_APM_ON_AA)
+	{
+		if(((psPowerInfo->abAnalog[0] & psPowerUpdate->abAnalog[0] & MCB_AA_PWM_VR) != 0
+			&& (McResCtrl_GetRegVal_AA(MCDRV_PACKET_REGTYPE_B_ANA_AA, MCI_AA_PWM_ANALOG_0) & MCB_AA_PWM_VR) == 0))
+		{
+			/*	wait AP_XX_A	*/
+			dAPMDoneParam	= ((MCB_AA_AP_CP_A|MCB_AA_AP_HPL_A|MCB_AA_AP_HPR_A)<<8)
+							| (MCB_AA_AP_RC1_A|MCB_AA_AP_RC2_A|MCB_AA_AP_SPL1_A|MCB_AA_AP_SPR1_A|MCB_AA_AP_SPL2_A|MCB_AA_AP_SPR2_A);
+			McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_EVTWAIT_AA | MCDRV_EVT_APM_DONE_AA | dAPMDoneParam, 0);
+		}
+	}
+
+	if((dUpdate & MCDRV_POWINFO_DIGITAL_DP0_AA) != 0
+	&& (McResCtrl_GetRegVal_AA(MCDRV_PACKET_REGTYPE_B_BASE_AA, MCI_AA_PWM_DIGITAL) & MCB_AA_PWM_DP0) == 0)
+	{
+		/*	wait mute complete	*/
+		sdRet	= McDevIf_ExecutePacket_AA();
+		if(sdRet != MCDRV_SUCCESS)
+		{
+			return sdRet;
+		}
+		McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_EVTWAIT_AA | MCDRV_EVT_ALLMUTE_AA, 0);
+	}
+
+	/*	Analog Power	*/
+	bRegCur	= McResCtrl_GetRegVal_AA(MCDRV_PACKET_REGTYPE_B_ANA_AA, MCI_AA_PWM_ANALOG_1);
+	bReg	= (psPowerInfo->abAnalog[1] & psPowerUpdate->abAnalog[1]) | bRegCur;
+	if((psPowerUpdate->abAnalog[1] & MCDRV_POWUPDATE_ANALOG1_OUT_AA) != 0 && (MCDRV_SPHIZ_HIZ == sInitInfo.bSpHiz))
+	{
+		/*	SP_HIZ control	*/
+		bSpHizReg	= 0;
+		if((bReg & (MCB_AA_PWM_SPL1 | MCB_AA_PWM_SPL2)) != 0)
+		{
+			bSpHizReg |= MCB_AA_SPL_HIZ;
+		}
+
+		if((bReg & (MCB_AA_PWM_SPR1 | MCB_AA_PWM_SPR2)) != 0)
+		{
+			bSpHizReg |= MCB_AA_SPR_HIZ;
+		}
+
+		bSpHizReg |= (McResCtrl_GetRegVal_AA(MCDRV_PACKET_REGTYPE_B_ANA_AA, MCI_AA_SP_MODE) & (MCB_AA_SPMN | MCB_AA_SP_SWAP));
+		McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_WRITE_AA | MCDRV_PACKET_REGTYPE_B_ANA_AA | MCI_AA_SP_MODE, bSpHizReg);
+	}
+
+	if(McResCtrl_GetAPMode_AA() == eMCDRV_APM_ON_AA)
+	{
+		if((bRegCur & (MCB_AA_PWM_ADL|MCB_AA_PWM_ADR)) != (bReg & (MCB_AA_PWM_ADL|MCB_AA_PWM_ADR)))
+		{
+			McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_WRITE_AA | MCDRV_PACKET_REGTYPE_B_ANA_AA | MCI_AA_PWM_ANALOG_1, bReg);
+		}
+		else
+		{
+			sdRet	= McDevIf_ExecutePacket_AA();
+			if(sdRet != MCDRV_SUCCESS)
+			{
+				return sdRet;
+			}
+			McResCtrl_SetRegVal_AA(MCDRV_PACKET_REGTYPE_B_ANA_AA, MCI_AA_PWM_ANALOG_1, bReg);
+		}
+	}
+	else
+	{
+		McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_WRITE_AA | MCDRV_PACKET_REGTYPE_B_ANA_AA | (UINT32)MCI_AA_PWM_ANALOG_1, bReg);
+	}
+
+	bRegCur	= McResCtrl_GetRegVal_AA(MCDRV_PACKET_REGTYPE_B_ANA_AA, MCI_AA_PWM_ANALOG_2);
+	bReg	= (psPowerInfo->abAnalog[2] & psPowerUpdate->abAnalog[2]) | bRegCur;
+	if(McResCtrl_GetAPMode_AA() == eMCDRV_APM_ON_AA)
+	{
+		if((bRegCur & (MCB_AA_PWM_LO1L|MCB_AA_PWM_LO1R|MCB_AA_PWM_LO2L|MCB_AA_PWM_LO2R)) != (bReg & (MCB_AA_PWM_LO1L|MCB_AA_PWM_LO1R|MCB_AA_PWM_LO2L|MCB_AA_PWM_LO2R)))
+		{
+			McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_WRITE_AA | MCDRV_PACKET_REGTYPE_B_ANA_AA | MCI_AA_PWM_ANALOG_2, bReg);
+		}
+		else
+		{
+			sdRet	= McDevIf_ExecutePacket_AA();
+			if(sdRet != MCDRV_SUCCESS)
+			{
+				return sdRet;
+			}
+			McResCtrl_SetRegVal_AA(MCDRV_PACKET_REGTYPE_B_ANA_AA, MCI_AA_PWM_ANALOG_2, bReg);
+		}
+	}
+	else
+	{
+		McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_WRITE_AA | MCDRV_PACKET_REGTYPE_B_ANA_AA | (UINT32)MCI_AA_PWM_ANALOG_2, bReg);
+	}
+
+	bReg	= (UINT8)(psPowerInfo->abAnalog[3] & psPowerUpdate->abAnalog[3]) | McResCtrl_GetRegVal_AA(MCDRV_PACKET_REGTYPE_B_ANA_AA, MCI_AA_PWM_ANALOG_3);
+	McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_WRITE_AA | MCDRV_PACKET_REGTYPE_B_ANA_AA | MCI_AA_PWM_ANALOG_3, bReg);
+	bReg	= (UINT8)(psPowerInfo->abAnalog[4] & psPowerUpdate->abAnalog[4]) | McResCtrl_GetRegVal_AA(MCDRV_PACKET_REGTYPE_B_ANA_AA, MCI_AA_PWM_ANALOG_4);
+	McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_WRITE_AA | MCDRV_PACKET_REGTYPE_B_ANA_AA | MCI_AA_PWM_ANALOG_4, bReg);
+
+	/*	set DACON and NSMUTE after setting 1 to AP_DA	*/
+	if((psPowerInfo->abAnalog[3] & psPowerUpdate->abAnalog[3] & MCB_AA_PWM_DA) != 0)
+	{
+		if((McResCtrl_GetRegVal_AA(MCDRV_PACKET_REGTYPE_B_CODEC_AA, MCI_AA_DAC_CONFIG) & MCB_AA_DACON) == MCB_AA_DACON)
+		{
+			McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_EVTWAIT_AA | MCDRV_EVT_DACMUTE_AA | (UINT32)((MCB_AA_DAC_FLAGL<<8)|MCB_AA_DAC_FLAGR), 0);
+		}
+		McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_WRITE_AA | MCDRV_PACKET_REGTYPE_B_CODEC_AA | (UINT32)MCI_AA_DAC_CONFIG, MCB_AA_NSMUTE);
+	}
+
+	bRegCur	= McResCtrl_GetRegVal_AA(MCDRV_PACKET_REGTYPE_B_ANA_AA, MCI_AA_PWM_ANALOG_0);
+	bReg	= psPowerInfo->abAnalog[0] & psPowerUpdate->abAnalog[0];
+	if(McResCtrl_GetAPMode_AA() == eMCDRV_APM_OFF_AA)
+	{
+		/*	wait CPPDRDY	*/
+		dAnaRdyParam	= 0;
+		if((bRegCur & MCB_AA_PWM_CP) == 0 && (bReg & MCB_AA_PWM_CP) == MCB_AA_PWM_CP)
+		{
+			dAnaRdyParam	= MCB_AA_CPPDRDY;
+			McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_EVTWAIT_AA | MCDRV_EVT_ANA_RDY_AA | dAnaRdyParam, 0);
+			McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_WRITE_AA | MCDRV_PACKET_REGTYPE_B_ANA_AA | (UINT32)MCI_AA_PWM_ANALOG_0, (bRegCur|MCB_AA_PWM_CP));
+		}
+	}
+
+	if((bReg & MCB_AA_PWM_VR) != 0 && (bRegCur & MCB_AA_PWM_VR) == 0)
+	{/*	AP_VR changed	*/
+		/*	AP_xx down	*/
+		McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_WRITE_AA | MCDRV_PACKET_REGTYPE_B_ANA_AA | (UINT32)MCI_AA_PWM_ANALOG_0, MCI_AA_PWM_ANALOG_0_DEF);
+	}
+	else
+	{
+		bReg	|= bRegCur;
+		McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_WRITE_AA | MCDRV_PACKET_REGTYPE_B_ANA_AA | (UINT32)MCI_AA_PWM_ANALOG_0, bReg);
+	}
+
+
+	/*	Digital Power	*/
+	if((dUpdate & MCDRV_POWINFO_DIGITAL_DPADIF_AA) != 0
+	&& McResCtrl_GetRegVal_AA(MCDRV_PACKET_REGTYPE_B_CODEC_AA, MCI_AA_DPADIF) != MCB_AA_DPADIF)
+	{
+		/*	AD_MUTE	*/
+		McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_WRITE_AA | MCDRV_PACKET_REGTYPE_B_CODEC_AA | MCI_AA_AD_MUTE, MCB_AA_AD_MUTE);
+		/*	DPADIF	*/
+		McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_WRITE_AA | MCDRV_PACKET_REGTYPE_B_CODEC_AA | MCI_AA_DPADIF, MCB_AA_DPADIF);
+	}
+
+	if((dUpdate & MCDRV_POWINFO_DIGITAL_DPPDM_AA) != 0
+	&& (McResCtrl_GetRegVal_AA(MCDRV_PACKET_REGTYPE_B_BASE_AA, MCI_AA_PWM_DIGITAL_1) & MCB_AA_PWM_DPPDM) == 0)
+	{
+		/*	PDM_MUTE	*/
+		McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_WRITE_AA | MCDRV_PACKET_REGTYPE_B_MIXER_AA | MCI_AA_PDM_MUTE, MCB_AA_PDM_MUTE);
+	}
+
+	if((dUpdate & MCDRV_POWINFO_DIGITAL_DPBDSP_AA) != 0)
+	{
+		/*	DPBDSP	*/
+		McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_WRITE_AA | MCDRV_PACKET_REGTYPE_B_BASE_AA | MCI_AA_PWM_DIGITAL_BDSP, MCB_AA_PWM_DPBDSP);
+	}
+
+	/*	DPDI*, DPPDM	*/
+	bReg	= McResCtrl_GetRegVal_AA(MCDRV_PACKET_REGTYPE_B_BASE_AA, MCI_AA_PWM_DIGITAL_1);
+	if((dUpdate & MCDRV_POWINFO_DIGITAL_DPDI0_AA) != 0 || (dUpdate & MCDRV_POWINFO_DIGITAL_DP2_AA) != 0)
+	{
+		bReg |= MCB_AA_PWM_DPDI0;
+	}
+	if((dUpdate & MCDRV_POWINFO_DIGITAL_DPDI1_AA) != 0 || (dUpdate & MCDRV_POWINFO_DIGITAL_DP2_AA) != 0)
+	{
+		bReg |= MCB_AA_PWM_DPDI1;
+	}
+	if((dUpdate & MCDRV_POWINFO_DIGITAL_DPDI2_AA) != 0 || (dUpdate & MCDRV_POWINFO_DIGITAL_DP2_AA) != 0)
+	{
+		bReg |= MCB_AA_PWM_DPDI2;
+	}
+	if((dUpdate & MCDRV_POWINFO_DIGITAL_DPPDM_AA) != 0)
+	{
+		bReg |= MCB_AA_PWM_DPPDM;
+	}
+	if(bReg != 0)
+	{
+		/*	cannot set DP* & DPB at the same time	*/
+		McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_WRITE_AA | MCDRV_PACKET_REGTYPE_B_BASE_AA | MCI_AA_PWM_DIGITAL_1, bReg);
+	}
+	/*	DPB	*/
+	if((dUpdate & MCDRV_POWINFO_DIGITAL_DPB_AA) != 0)
+	{
+		bReg |= MCB_AA_PWM_DPB;
+	}
+	if(bReg != 0)
+	{
+		McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_WRITE_AA | MCDRV_PACKET_REGTYPE_B_BASE_AA | MCI_AA_PWM_DIGITAL_1, bReg);
+	}
+
+	if((dUpdate & MCDRV_POWINFO_DIGITAL_DP2_AA) != 0
+	&& (McResCtrl_GetRegVal_AA(MCDRV_PACKET_REGTYPE_B_BASE_AA, MCI_AA_PWM_DIGITAL) & MCB_AA_PWM_DP2) == 0)
+	{
+		if((dUpdate & MCDRV_POWINFO_DIGITAL_DP0_AA) != 0)
+		{
+			/*	DP2, DP1	*/
+			McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_WRITE_AA | MCDRV_PACKET_REGTYPE_B_BASE_AA | MCI_AA_PWM_DIGITAL, (MCB_AA_PWM_DP2 | MCB_AA_PWM_DP1));
+			if((dUpdate & MCDRV_POWINFO_DIGITAL_PLLRST0_AA) != 0)
+			{
+				/*	PLLRST0	*/
+				McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_WRITE_AA | MCDRV_PACKET_REGTYPE_B_BASE_AA | MCI_AA_PLL_RST, MCB_AA_PLLRST0);
+			}
+			/*	DP0	*/
+			McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_WRITE_AA | MCDRV_PACKET_REGTYPE_B_BASE_AA | MCI_AA_PWM_DIGITAL, (MCB_AA_PWM_DP2 | MCB_AA_PWM_DP1 | MCB_AA_PWM_DP0));
+			sdRet	= McDevIf_ExecutePacket_AA();
+			if(sdRet != MCDRV_SUCCESS)
+			{
+				return sdRet;
+			}
+			McSrv_ClockStop();
+		}
+		else
+		{
+			/*	DP2	*/
+			McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_WRITE_AA | MCDRV_PACKET_REGTYPE_B_BASE_AA | MCI_AA_PWM_DIGITAL, MCB_AA_PWM_DP2);
+		}
+	}
+	return sdRet;
+}
+
+/****************************************************************************
+ *	McPacket_AddPathSet_AA
+ *
+ *	Description:
+ *			Add path update packet.
+ *	Arguments:
+ *			none
+ *	Return:
+ *			MCDRV_SUCCESS
+ *			MCDRV_ERROR_RESOURCEOVER
+ *			MCDRV_ERROR_TIMEOUT
+ *
+ ****************************************************************************/
+SINT32	McPacket_AddPathSet_AA
+(
+	void
+)
+{
+	SINT32	sdRet	= MCDRV_SUCCESS;
+
+	/*	DI Pad	*/
+	AddDIPad();
+
+	/*	PAD(PDM)	*/
+	AddPAD();
+
+	/*	Digital Mixer Source	*/
+	sdRet	= AddSource();
+	if(sdRet != MCDRV_SUCCESS)
+	{
+		return sdRet;
+	}
+
+	/*	DIR*_START, DIT*_START	*/
+	AddDIStart();
+
+	return sdRet;
+}
+
+/****************************************************************************
+ *	AddDIPad
+ *
+ *	Description:
+ *			Add DI Pad setup packet.
+ *	Arguments:
+ *			none
+ *	Return:
+ *			none
+ *
+ ****************************************************************************/
+static void	AddDIPad
+(
+	void
+)
+{
+	UINT8	bReg;
+	UINT8	bIsUsedDIR[3];
+	MCDRV_INIT_INFO	sInitInfo;
+	MCDRV_PATH_INFO	sPathInfo;
+	MCDRV_DIO_INFO	sDioInfo;
+
+	McResCtrl_GetInitInfo_AA(&sInitInfo);
+	McResCtrl_GetPathInfo_AA(&sPathInfo);
+	McResCtrl_GetDioInfo_AA(&sDioInfo);
+
+	/*	SDIN_MSK2/1	*/
+	bReg	= 0;
+	if(McResCtrl_IsSrcUsed_AA(eMCDRV_SRC_DIR2_AA) == 0)
+	{
+		bReg |= MCB_AA_SDIN_MSK2;
+		bIsUsedDIR[2]	= 0;
+	}
+	else
+	{
+		bIsUsedDIR[2]	= 1;
+	}
+	if(McResCtrl_IsSrcUsed_AA(eMCDRV_SRC_DIR1_AA) == 0)
+	{
+		bReg |= MCB_AA_SDIN_MSK1;
+		bIsUsedDIR[1]	= 0;
+	}
+	else
+	{
+		bIsUsedDIR[1]	= 1;
+	}
+	/*	SDO_DDR2/1	*/
+	if(McResCtrl_IsDstUsed_AA(eMCDRV_DST_DIT2_AA, eMCDRV_DST_CH0_AA) == 0)
+	{
+		if(sInitInfo.bDioSdo2Hiz == MCDRV_DAHIZ_LOW)
+		{
+			bReg |= MCB_AA_SDO_DDR2;
+		}
+	}
+	else
+	{
+		bReg |= MCB_AA_SDO_DDR2;
+	}
+	if(McResCtrl_IsDstUsed_AA(eMCDRV_DST_DIT1_AA, eMCDRV_DST_CH0_AA) == 0)
+	{
+		if(sInitInfo.bDioSdo1Hiz == MCDRV_DAHIZ_LOW)
+		{
+			bReg |= MCB_AA_SDO_DDR1;
+		}
+	}
+	else
+	{
+		bReg |= MCB_AA_SDO_DDR1;
+	}
+	McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_WRITE_AA | MCDRV_PACKET_REGTYPE_B_BASE_AA | (UINT32)MCI_AA_SD_MSK, bReg);
+
+	/*	SDIN_MSK0	*/
+	bReg	= 0;
+	if(McResCtrl_IsSrcUsed_AA(eMCDRV_SRC_DIR0_AA) == 0)
+	{
+		bReg |= MCB_AA_SDIN_MSK0;
+		bIsUsedDIR[0]	= 0;
+	}
+	else
+	{
+		bIsUsedDIR[0]	= 1;
+	}
+	/*	SDO_DDR0	*/
+	if(McResCtrl_IsDstUsed_AA(eMCDRV_DST_DIT0_AA, eMCDRV_DST_CH0_AA) == 0)
+	{
+		if(sInitInfo.bDioSdo0Hiz == MCDRV_DAHIZ_LOW)
+		{
+			bReg |= MCB_AA_SDO_DDR0;
+		}
+	}
+	else
+	{
+		bReg |= MCB_AA_SDO_DDR0;
+	}
+	McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_WRITE_AA | MCDRV_PACKET_REGTYPE_B_BASE_AA | (UINT32)MCI_AA_SD_MSK_1, bReg);
+
+	/*	BCLK_MSK*, BCLD_DDR*, LRCK_MSK*, LRCK_DDR*	*/
+	bReg	= 0;
+	if(bIsUsedDIR[2] == 0 && McResCtrl_GetDITSource_AA(eMCDRV_DIO_2_AA) == eMCDRV_SRC_NONE_AA)
+	{
+		bReg |= MCB_AA_BCLK_MSK2;
+		bReg |= MCB_AA_LRCK_MSK2;
+		if(sInitInfo.bDioClk2Hiz == MCDRV_DAHIZ_LOW)
+		{
+			bReg |= MCB_AA_BCLK_DDR2;
+			bReg |= MCB_AA_LRCK_DDR2;
+		}
+	}
+	else
+	{
+		if(sDioInfo.asPortInfo[2].sDioCommon.bMasterSlave == MCDRV_DIO_MASTER)
+		{
+			bReg |= MCB_AA_BCLK_DDR2;
+			bReg |= MCB_AA_LRCK_DDR2;
+		}
+	}
+	if(bIsUsedDIR[1] == 0 && McResCtrl_GetDITSource_AA(eMCDRV_DIO_1_AA) == eMCDRV_SRC_NONE_AA)
+	{
+		bReg |= MCB_AA_BCLK_MSK1;
+		bReg |= MCB_AA_LRCK_MSK1;
+		if(sInitInfo.bDioClk1Hiz == MCDRV_DAHIZ_LOW)
+		{
+			bReg |= MCB_AA_BCLK_DDR1;
+			bReg |= MCB_AA_LRCK_DDR1;
+		}
+	}
+	else
+	{
+		if(sDioInfo.asPortInfo[1].sDioCommon.bMasterSlave == MCDRV_DIO_MASTER)
+		{
+			bReg |= MCB_AA_BCLK_DDR1;
+			bReg |= MCB_AA_LRCK_DDR1;
+		}
+	}
+	McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_WRITE_AA | MCDRV_PACKET_REGTYPE_B_BASE_AA | MCI_AA_BCLK_MSK, bReg);
+
+	/*	BCLK_MSK*, BCLD_DDR*, LRCK_MSK*, LRCK_DDR*, PCM_HIZ*	*/
+	bReg	= 0;
+	if(bIsUsedDIR[0] == 0 && McResCtrl_GetDITSource_AA(eMCDRV_DIO_0_AA) == eMCDRV_SRC_NONE_AA)
+	{
+		bReg |= MCB_AA_BCLK_MSK0;
+		bReg |= MCB_AA_LRCK_MSK0;
+		if(sInitInfo.bDioClk0Hiz == MCDRV_DAHIZ_LOW)
+		{
+			bReg |= MCB_AA_BCLK_DDR0;
+			bReg |= MCB_AA_LRCK_DDR0;
+		}
+	}
+	else
+	{
+		if(sDioInfo.asPortInfo[0].sDioCommon.bMasterSlave == MCDRV_DIO_MASTER)
+		{
+			bReg |= MCB_AA_BCLK_DDR0;
+			bReg |= MCB_AA_LRCK_DDR0;
+		}
+	}
+	if(sInitInfo.bPcmHiz == MCDRV_PCMHIZ_HIZ)
+	{
+		bReg |= (MCB_AA_PCMOUT_HIZ2 | MCB_AA_PCMOUT_HIZ1 | MCB_AA_PCMOUT_HIZ0);
+	}
+	McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_WRITE_AA | MCDRV_PACKET_REGTYPE_B_BASE_AA | MCI_AA_BCLK_MSK_1, bReg);
+}
+
+/****************************************************************************
+ *	AddPAD
+ *
+ *	Description:
+ *			Add PAD setup packet.
+ *	Arguments:
+ *			none
+ *	Return:
+ *			none
+ *
+ ****************************************************************************/
+static void	AddPAD
+(
+	void
+)
+{
+	UINT8	bReg;
+	MCDRV_INIT_INFO	sInitInfo;
+
+	McResCtrl_GetInitInfo_AA(&sInitInfo);
+
+	/*	PA*_MSK	*/
+	bReg	= McResCtrl_GetRegVal_AA(MCDRV_PACKET_REGTYPE_B_BASE_AA, MCI_AA_PA_MSK_1);
+	if(McResCtrl_IsSrcUsed_AA(eMCDRV_SRC_PDM_AA) == 0)
+	{
+		bReg	|= MCB_AA_PA0_MSK;
+		if(sInitInfo.bPad1Func == MCDRV_PAD_PDMDI)
+		{
+			bReg	|= MCB_AA_PA1_MSK;
+		}
+	}
+	else
+	{
+		bReg	&= (UINT8)~MCB_AA_PA0_MSK;
+		if(sInitInfo.bPad1Func == MCDRV_PAD_PDMDI)
+		{
+			bReg	&= (UINT8)~MCB_AA_PA1_MSK;
+		}
+	}
+	McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_WRITE_AA | MCDRV_PACKET_REGTYPE_B_BASE_AA | MCI_AA_PA_MSK_1, bReg);
+}
+
+/****************************************************************************
+ *	AddSource
+ *
+ *	Description:
+ *			Add source setup packet.
+ *	Arguments:
+ *			none
+ *	Return:
+ *			MCDRV_SUCCESS
+ *			MCDRV_ERROR_TIMEOUT
+ *
+ ****************************************************************************/
+static SINT32	AddSource
+(
+	void
+)
+{
+	SINT32	sdRet			= MCDRV_SUCCESS;
+	UINT8	bReg;
+	UINT8	bAEng6			= McResCtrl_GetRegVal_AA(MCDRV_PACKET_REGTYPE_B_MIXER_AA, MCI_AA_AENG6_SOURCE);
+	UINT8	bRegAESource	= 0;
+	UINT8	bAESourceChange	= 0;
+	UINT32	dXFadeParam		= 0;
+	MCDRV_SRC_TYPE_AA	eAESource	= McResCtrl_GetAESource_AA();
+	MCDRV_PATH_INFO	sPathInfo;
+	MCDRV_DAC_INFO	sDacInfo;
+	MCDRV_AE_INFO	sAeInfo;
+
+	McResCtrl_GetPathInfo_AA(&sPathInfo);
+	McResCtrl_GetAeInfo_AA(&sAeInfo);
+
+	switch(eAESource)
+	{
+	case	eMCDRV_SRC_PDM_AA:		bRegAESource	= MCB_AA_AE_SOURCE_AD;		bAEng6	= MCB_AA_AENG6_PDM;	break;
+	case	eMCDRV_SRC_ADC0_AA:	bRegAESource	= MCB_AA_AE_SOURCE_AD;		bAEng6	= MCB_AA_AENG6_ADC0;	break;
+	case	eMCDRV_SRC_DIR0_AA:	bRegAESource	= MCB_AA_AE_SOURCE_DIR0;	break;
+	case	eMCDRV_SRC_DIR1_AA:	bRegAESource	= MCB_AA_AE_SOURCE_DIR1;	break;
+	case	eMCDRV_SRC_DIR2_AA:	bRegAESource	= MCB_AA_AE_SOURCE_DIR2;	break;
+	case	eMCDRV_SRC_MIX_AA:		bRegAESource	= MCB_AA_AE_SOURCE_MIX;	break;
+	default:					bRegAESource	= 0;
+	}
+	if(bRegAESource != (McResCtrl_GetRegVal_AA(MCDRV_PACKET_REGTYPE_B_MIXER_AA, MCI_AA_SRC_SOURCE_1)&0xF0))
+	{
+		/*	xxx_INS	*/
+		dXFadeParam	= McResCtrl_GetRegVal_AA(MCDRV_PACKET_REGTYPE_B_MIXER_AA, MCI_AA_DAC_INS);
+		dXFadeParam <<= 8;
+		dXFadeParam	|= McResCtrl_GetRegVal_AA(MCDRV_PACKET_REGTYPE_B_MIXER_AA, MCI_AA_INS);
+		McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_WRITE_AA | MCDRV_PACKET_REGTYPE_B_MIXER_AA | (UINT32)MCI_AA_DAC_INS, 0);
+		McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_WRITE_AA | MCDRV_PACKET_REGTYPE_B_MIXER_AA | (UINT32)MCI_AA_INS, 0);
+		bAESourceChange	= 1;
+		sdRet	= McDevIf_ExecutePacket_AA();
+		if(sdRet != MCDRV_SUCCESS)
+		{
+			return sdRet;
+		}
+	}
+
+	McResCtrl_GetDacInfo_AA(&sDacInfo);
+
+	/*	DAC_SOURCE/VOICE_SOURCE	*/
+	bReg	= 0;
+	switch(McResCtrl_GetDACSource_AA(eMCDRV_DAC_MASTER_AA))
+	{
+	case	eMCDRV_SRC_PDM_AA:
+		bReg |= MCB_AA_DAC_SOURCE_AD;
+		bAEng6	= MCB_AA_AENG6_PDM;
+		break;
+	case	eMCDRV_SRC_ADC0_AA:
+		bReg |= MCB_AA_DAC_SOURCE_AD;
+		bAEng6	= MCB_AA_AENG6_ADC0;
+		break;
+	case	eMCDRV_SRC_DIR0_AA:
+		bReg |= MCB_AA_DAC_SOURCE_DIR0;
+		break;
+	case	eMCDRV_SRC_DIR1_AA:
+		bReg |= MCB_AA_DAC_SOURCE_DIR1;
+		break;
+	case	eMCDRV_SRC_DIR2_AA:
+		bReg |= MCB_AA_DAC_SOURCE_DIR2;
+		break;
+	case	eMCDRV_SRC_MIX_AA:
+		bReg |= MCB_AA_DAC_SOURCE_MIX;
+		break;
+	default:
+		break;
+	}
+	switch(McResCtrl_GetDACSource_AA(eMCDRV_DAC_VOICE_AA))
+	{
+	case	eMCDRV_SRC_PDM_AA:
+		bReg |= MCB_AA_VOICE_SOURCE_AD;
+		bAEng6	= MCB_AA_AENG6_PDM;
+		break;
+	case	eMCDRV_SRC_ADC0_AA:
+		bReg |= MCB_AA_VOICE_SOURCE_AD;
+		bAEng6	= MCB_AA_AENG6_ADC0;
+		break;
+	case	eMCDRV_SRC_DIR0_AA:
+		bReg |= MCB_AA_VOICE_SOURCE_DIR0;
+		break;
+	case	eMCDRV_SRC_DIR1_AA:
+		bReg |= MCB_AA_VOICE_SOURCE_DIR1;
+		break;
+	case	eMCDRV_SRC_DIR2_AA:
+		bReg |= MCB_AA_VOICE_SOURCE_DIR2;
+		break;
+	case	eMCDRV_SRC_MIX_AA:
+		bReg |= MCB_AA_VOICE_SOURCE_MIX;
+		break;
+	default:
+		break;
+	}
+	McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_WRITE_AA | MCDRV_PACKET_REGTYPE_B_MIXER_AA | MCI_AA_SOURCE, bReg);
+
+	/*	SWP/VOICE_SWP	*/
+	bReg	= (sDacInfo.bMasterSwap << 4) | sDacInfo.bVoiceSwap;
+	McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_WRITE_AA | MCDRV_PACKET_REGTYPE_B_MIXER_AA | MCI_AA_SWP, bReg);
+
+	/*	DIT0SRC_SOURCE/DIT1SRC_SOURCE	*/
+	bReg	= 0;
+	switch(McResCtrl_GetDITSource_AA(eMCDRV_DIO_0_AA))
+	{
+	case	eMCDRV_SRC_PDM_AA:
+		bReg |= MCB_AA_DIT0_SOURCE_AD;
+			bAEng6	= MCB_AA_AENG6_PDM;
+		break;
+	case	eMCDRV_SRC_ADC0_AA:
+		bReg |= MCB_AA_DIT0_SOURCE_AD;
+			bAEng6	= MCB_AA_AENG6_ADC0;
+		break;
+	case	eMCDRV_SRC_DIR0_AA:
+		bReg |= MCB_AA_DIT0_SOURCE_DIR0;
+		break;
+	case	eMCDRV_SRC_DIR1_AA:
+		bReg |= MCB_AA_DIT0_SOURCE_DIR1;
+		break;
+	case	eMCDRV_SRC_DIR2_AA:
+		bReg |= MCB_AA_DIT0_SOURCE_DIR2;
+		break;
+	case	eMCDRV_SRC_MIX_AA:
+		bReg |= MCB_AA_DIT0_SOURCE_MIX;
+		break;
+	default:
+		break;
+	}
+	switch(McResCtrl_GetDITSource_AA(eMCDRV_DIO_1_AA))
+	{
+	case	eMCDRV_SRC_PDM_AA:
+		bReg |= MCB_AA_DIT1_SOURCE_AD;
+			bAEng6	= MCB_AA_AENG6_PDM;
+		break;
+	case	eMCDRV_SRC_ADC0_AA:
+		bReg |= MCB_AA_DIT1_SOURCE_AD;
+			bAEng6	= MCB_AA_AENG6_ADC0;
+		break;
+	case	eMCDRV_SRC_DIR0_AA:
+		bReg |= MCB_AA_DIT1_SOURCE_DIR0;
+		break;
+	case	eMCDRV_SRC_DIR1_AA:
+		bReg |= MCB_AA_DIT1_SOURCE_DIR1;
+		break;
+	case	eMCDRV_SRC_DIR2_AA:
+		bReg |= MCB_AA_DIT1_SOURCE_DIR2;
+		break;
+	case	eMCDRV_SRC_MIX_AA:
+		bReg |= MCB_AA_DIT1_SOURCE_MIX;
+		break;
+	default:
+		break;
+	}
+	McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_WRITE_AA | MCDRV_PACKET_REGTYPE_B_MIXER_AA | MCI_AA_SRC_SOURCE, bReg);
+
+	/*	AE_SOURCE/DIT2SRC_SOURCE	*/
+	bReg	= bRegAESource;
+	switch(McResCtrl_GetDITSource_AA(eMCDRV_DIO_2_AA))
+	{
+	case	eMCDRV_SRC_PDM_AA:
+		bReg |= MCB_AA_DIT2_SOURCE_AD;
+			bAEng6	= MCB_AA_AENG6_PDM;
+		break;
+	case	eMCDRV_SRC_ADC0_AA:
+		bReg |= MCB_AA_DIT2_SOURCE_AD;
+			bAEng6	= MCB_AA_AENG6_ADC0;
+		break;
+	case	eMCDRV_SRC_DIR0_AA:
+		bReg |= MCB_AA_DIT2_SOURCE_DIR0;
+		break;
+	case	eMCDRV_SRC_DIR1_AA:
+		bReg |= MCB_AA_DIT2_SOURCE_DIR1;
+		break;
+	case	eMCDRV_SRC_DIR2_AA:
+		bReg |= MCB_AA_DIT2_SOURCE_DIR2;
+		break;
+	case	eMCDRV_SRC_MIX_AA:
+		bReg |= MCB_AA_DIT2_SOURCE_MIX;
+		break;
+	default:
+		break;
+	}
+	if(bAESourceChange != 0)
+	{
+		/*	wait xfade complete	*/
+		McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_EVTWAIT_AA | MCDRV_EVT_INSFLG_AA | dXFadeParam, 0);
+	}
+	McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_WRITE_AA | MCDRV_PACKET_REGTYPE_B_MIXER_AA | MCI_AA_SRC_SOURCE_1, bReg);
+
+	/*	BDSP_ST	*/
+	if(McResCtrl_GetAESource_AA() == eMCDRV_SRC_NONE_AA)
+	{/*	AE is unused	*/
+		/*	BDSP stop & reset	*/
+		if((McResCtrl_GetRegVal_AA(MCDRV_PACKET_REGTYPE_A_AA, MCI_AA_BDSP_ST)&MCB_AA_BDSP_ST) != 0)
+		{
+			bReg	= 0;
+			if((sAeInfo.bOnOff & MCDRV_EQ5_ON) != 0)
+			{
+				bReg |= MCB_AA_EQ5ON;
+			}
+			if((sAeInfo.bOnOff & MCDRV_DRC_ON) != 0)
+			{
+				bReg |= MCB_AA_DRCON;
+			}
+			if((sAeInfo.bOnOff & MCDRV_EQ3_ON) != 0)
+			{
+				bReg |= MCB_AA_EQ3ON;
+			}
+			if(McDevProf_IsValid(eMCDRV_FUNC_DBEX) == 1)
+			{
+				if((sAeInfo.bOnOff & MCDRV_BEXWIDE_ON) != 0)
+				{
+					bReg |= MCB_AA_DBEXON;
+				}
+			}
+			McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_WRITE_AA | MCDRV_PACKET_REGTYPE_A_AA | MCI_AA_BDSP_ST, bReg);
+			McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_WRITE_AA | MCDRV_PACKET_REGTYPE_A_AA | MCI_AA_BDSP_RST, MCB_AA_TRAM_RST);
+			McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_WRITE_AA | MCDRV_PACKET_REGTYPE_A_AA | MCI_AA_BDSP_RST, 0);
+		}
+	}
+	else
+	{/*	AE is used	*/
+		bReg	= 0;
+		if((sAeInfo.bOnOff & MCDRV_EQ5_ON) != 0)
+		{
+			bReg |= MCB_AA_EQ5ON;
+		}
+		if((sAeInfo.bOnOff & MCDRV_DRC_ON) != 0)
+		{
+			bReg |= MCB_AA_DRCON;
+			bReg |= MCB_AA_BDSP_ST;
+		}
+		if((sAeInfo.bOnOff & MCDRV_EQ3_ON) != 0)
+		{
+			bReg |= MCB_AA_EQ3ON;
+		}
+		if(McDevProf_IsValid(eMCDRV_FUNC_DBEX) == 1)
+		{
+			if((sAeInfo.bOnOff & MCDRV_BEXWIDE_ON) != 0)
+			{
+				bReg |= MCB_AA_DBEXON;
+				bReg |= MCB_AA_BDSP_ST;
+			}
+		}
+		McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_WRITE_AA | MCDRV_PACKET_REGTYPE_A_AA | MCI_AA_BDSP_ST, bReg);
+	}
+
+	/*	check MIX SOURCE for AENG6_SOURCE	*/
+	if(McResCtrl_IsSrcUsed_AA(eMCDRV_SRC_PDM_AA) != 0)
+	{
+		bAEng6	= MCB_AA_AENG6_PDM;
+	}
+	else if(McResCtrl_IsSrcUsed_AA(eMCDRV_SRC_ADC0_AA) != 0)
+	{
+		bAEng6	= MCB_AA_AENG6_ADC0;
+	}
+
+	/*	AENG6_SOURCE	*/
+	if(bAEng6 != McResCtrl_GetRegVal_AA(MCDRV_PACKET_REGTYPE_B_MIXER_AA, MCI_AA_AENG6_SOURCE))
+	{
+		bReg	= McResCtrl_GetRegVal_AA(MCDRV_PACKET_REGTYPE_B_CODEC_AA, MCI_AA_AD_START);
+		if((bReg & MCB_AA_AD_START) != 0)
+		{
+			McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_WRITE_AA | MCDRV_PACKET_REGTYPE_B_CODEC_AA | MCI_AA_AD_MUTE, MCB_AA_AD_MUTE);
+			McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_WRITE_AA | MCDRV_PACKET_REGTYPE_B_CODEC_AA | MCI_AA_AD_START, bReg&(UINT8)~MCB_AA_AD_START);
+		}
+		bReg	= McResCtrl_GetRegVal_AA(MCDRV_PACKET_REGTYPE_B_MIXER_AA, MCI_AA_PDM_START);
+		if((bReg & MCB_AA_PDM_START) != 0)
+		{
+			McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_WRITE_AA | MCDRV_PACKET_REGTYPE_B_MIXER_AA | MCI_AA_PDM_MUTE, MCB_AA_PDM_MUTE);
+			McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_WRITE_AA | MCDRV_PACKET_REGTYPE_B_MIXER_AA | MCI_AA_PDM_START, bReg&(UINT8)~MCB_AA_PDM_START);
+		}
+	}
+	McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_WRITE_AA | MCDRV_PACKET_REGTYPE_B_MIXER_AA | MCI_AA_AENG6_SOURCE, bAEng6);
+
+	/*	xxx_INS	*/
+	if(McResCtrl_IsSrcUsed_AA(eMCDRV_SRC_AE_AA) != 0)
+	{
+		switch(eAESource)
+		{
+		case	eMCDRV_SRC_PDM_AA:
+		case	eMCDRV_SRC_ADC0_AA:
+			McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_WRITE_AA | MCDRV_PACKET_REGTYPE_B_MIXER_AA | (UINT32)MCI_AA_INS, MCB_AA_ADC_INS);
+			break;
+		case	eMCDRV_SRC_DIR0_AA:
+			McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_WRITE_AA | MCDRV_PACKET_REGTYPE_B_MIXER_AA | (UINT32)MCI_AA_INS, MCB_AA_DIR0_INS);
+			break;
+		case	eMCDRV_SRC_DIR1_AA:
+			McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_WRITE_AA | MCDRV_PACKET_REGTYPE_B_MIXER_AA | (UINT32)MCI_AA_INS, MCB_AA_DIR1_INS);
+			break;
+		case	eMCDRV_SRC_DIR2_AA:
+			McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_WRITE_AA | MCDRV_PACKET_REGTYPE_B_MIXER_AA | (UINT32)MCI_AA_INS, MCB_AA_DIR2_INS);
+			break;
+		case	eMCDRV_SRC_MIX_AA:
+			McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_WRITE_AA | MCDRV_PACKET_REGTYPE_B_MIXER_AA | (UINT32)MCI_AA_DAC_INS, MCB_AA_DAC_INS);
+			break;
+		default:
+			break;
+		}
+	}
+
+	return sdRet;
+}
+
+/****************************************************************************
+ *	AddDIStart
+ *
+ *	Description:
+ *			Add DIStart setup packet.
+ *	Arguments:
+ *			none
+ *	Return:
+ *			none
+ *
+ ****************************************************************************/
+static void	AddDIStart
+(
+	void
+)
+{
+	UINT8	bReg;
+	MCDRV_PATH_INFO	sPathInfo;
+	MCDRV_DIO_INFO	sDioInfo;
+
+	McResCtrl_GetPathInfo_AA(&sPathInfo);
+	McResCtrl_GetDioInfo_AA(&sDioInfo);
+
+	/*	DIR*_START, DIT*_START	*/
+	bReg	= 0;
+	if(McResCtrl_GetDITSource_AA(eMCDRV_DIO_0_AA) != eMCDRV_SRC_NONE_AA)
+	{
+		if(sDioInfo.asPortInfo[0].sDioCommon.bMasterSlave == MCDRV_DIO_MASTER)
+		{
+			bReg |= MCB_AA_DITIM0_START;
+		}
+		bReg |= MCB_AA_DIT0_SRC_START;
+		bReg |= MCB_AA_DIT0_START;
+	}
+	if(McResCtrl_IsSrcUsed_AA(eMCDRV_SRC_DIR0_AA) != 0)
+	{
+		if(sDioInfo.asPortInfo[0].sDioCommon.bMasterSlave == MCDRV_DIO_MASTER)
+		{
+			bReg |= MCB_AA_DITIM0_START;
+		}
+		bReg |= MCB_AA_DIR0_SRC_START;
+		bReg |= MCB_AA_DIR0_START;
+	}
+	McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_WRITE_AA | MCDRV_PACKET_REGTYPE_B_MIXER_AA | MCI_AA_DIX0_START, bReg);
+
+	bReg	= 0;
+	if(McResCtrl_GetDITSource_AA(eMCDRV_DIO_1_AA) != eMCDRV_SRC_NONE_AA)
+	{
+		if(sDioInfo.asPortInfo[1].sDioCommon.bMasterSlave == MCDRV_DIO_MASTER)
+		{
+			bReg |= MCB_AA_DITIM1_START;
+		}
+		bReg |= MCB_AA_DIT1_SRC_START;
+		bReg |= MCB_AA_DIT1_START;
+	}
+	if(McResCtrl_IsSrcUsed_AA(eMCDRV_SRC_DIR1_AA) != 0)
+	{
+		if(sDioInfo.asPortInfo[1].sDioCommon.bMasterSlave == MCDRV_DIO_MASTER)
+		{
+			bReg |= MCB_AA_DITIM1_START;
+		}
+		bReg |= MCB_AA_DIR1_SRC_START;
+		bReg |= MCB_AA_DIR1_START;
+	}
+	McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_WRITE_AA | MCDRV_PACKET_REGTYPE_B_MIXER_AA | MCI_AA_DIX1_START, bReg);
+
+	bReg	= 0;
+	if(McResCtrl_GetDITSource_AA(eMCDRV_DIO_2_AA) != eMCDRV_SRC_NONE_AA)
+	{
+		if(sDioInfo.asPortInfo[2].sDioCommon.bMasterSlave == MCDRV_DIO_MASTER)
+		{
+			bReg |= MCB_AA_DITIM2_START;
+		}
+		bReg |= MCB_AA_DIT2_SRC_START;
+		bReg |= MCB_AA_DIT2_START;
+	}
+	if(McResCtrl_IsSrcUsed_AA(eMCDRV_SRC_DIR2_AA) != 0)
+	{
+		if(sDioInfo.asPortInfo[2].sDioCommon.bMasterSlave == MCDRV_DIO_MASTER)
+		{
+			bReg |= MCB_AA_DITIM2_START;
+		}
+		bReg |= MCB_AA_DIR2_SRC_START;
+		bReg |= MCB_AA_DIR2_START;
+	}
+	McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_WRITE_AA | MCDRV_PACKET_REGTYPE_B_MIXER_AA | MCI_AA_DIX2_START, bReg);
+}
+
+/****************************************************************************
+ *	McPacket_AddMixSet_AA
+ *
+ *	Description:
+ *			Add analog mixer set packet.
+ *	Arguments:
+ *			none
+ *	Return:
+ *			MCDRV_SUCCESS
+ *			MCDRV_ERROR_RESOURCEOVER
+ *
+ ****************************************************************************/
+SINT32	McPacket_AddMixSet_AA
+(
+	void
+)
+{
+	UINT8	bReg;
+	MCDRV_INIT_INFO	sInitInfo;
+	MCDRV_PATH_INFO	sPathInfo;
+
+	McResCtrl_GetInitInfo_AA(&sInitInfo);
+	McResCtrl_GetPathInfo_AA(&sPathInfo);
+
+	/*	ADL_MIX	*/
+	bReg	= GetMicMixBit(&sPathInfo.asAdc0[0]);
+	if((sPathInfo.asAdc0[0].abSrcOnOff[MCDRV_SRC_LINE1_L_BLOCK] & MCDRV_SRC1_LINE1_L_ON) == MCDRV_SRC1_LINE1_L_ON
+	|| (sPathInfo.asAdc0[0].abSrcOnOff[MCDRV_SRC_LINE1_M_BLOCK] & MCDRV_SRC1_LINE1_M_ON) == MCDRV_SRC1_LINE1_M_ON)
+	{
+		bReg |= MCB_AA_LI1MIX;
+	}
+	McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_WRITE_AA | MCDRV_PACKET_REGTYPE_B_ANA_AA | MCI_AA_ADL_MIX, bReg);
+	/*	ADL_MONO	*/
+	bReg	= 0;
+	if((sPathInfo.asAdc0[0].abSrcOnOff[MCDRV_SRC_LINE1_M_BLOCK] & MCDRV_SRC1_LINE1_M_ON) == MCDRV_SRC1_LINE1_M_ON)
+	{
+		bReg |= MCB_AA_MONO_LI1;
+	}
+	McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_WRITE_AA | MCDRV_PACKET_REGTYPE_B_ANA_AA | MCI_AA_ADL_MONO, bReg);
+
+	/*	ADR_MIX	*/
+	bReg	= GetMicMixBit(&sPathInfo.asAdc0[1]);
+	if((sPathInfo.asAdc0[1].abSrcOnOff[MCDRV_SRC_LINE1_R_BLOCK] & MCDRV_SRC1_LINE1_R_ON) == MCDRV_SRC1_LINE1_R_ON
+	|| (sPathInfo.asAdc0[1].abSrcOnOff[MCDRV_SRC_LINE1_M_BLOCK] & MCDRV_SRC1_LINE1_M_ON) == MCDRV_SRC1_LINE1_M_ON)
+	{
+		bReg |= MCB_AA_LI1MIX;
+	}
+	McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_WRITE_AA | MCDRV_PACKET_REGTYPE_B_ANA_AA | MCI_AA_ADR_MIX, bReg);
+	/*	ADR_MONO	*/
+	bReg	= 0;
+	if((sPathInfo.asAdc0[1].abSrcOnOff[MCDRV_SRC_LINE1_M_BLOCK] & MCDRV_SRC1_LINE1_M_ON) == MCDRV_SRC1_LINE1_M_ON)
+	{
+		bReg |= MCB_AA_MONO_LI1;
+	}
+	McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_WRITE_AA | MCDRV_PACKET_REGTYPE_B_ANA_AA | MCI_AA_ADR_MONO, bReg);
+
+	/*	L1L_MIX	*/
+	bReg	= GetMicMixBit(&sPathInfo.asLout1[0]);
+	if((sPathInfo.asLout1[0].abSrcOnOff[MCDRV_SRC_LINE1_L_BLOCK] & MCDRV_SRC1_LINE1_L_ON) == MCDRV_SRC1_LINE1_L_ON
+	|| (sPathInfo.asLout1[0].abSrcOnOff[MCDRV_SRC_LINE1_M_BLOCK] & MCDRV_SRC1_LINE1_M_ON) == MCDRV_SRC1_LINE1_M_ON)
+	{
+		bReg |= MCB_AA_LI1MIX;
+	}
+	if((sPathInfo.asLout1[0].abSrcOnOff[MCDRV_SRC_DAC_L_BLOCK] & MCDRV_SRC5_DAC_L_ON) == MCDRV_SRC5_DAC_L_ON
+	|| (sPathInfo.asLout1[0].abSrcOnOff[MCDRV_SRC_DAC_M_BLOCK] & MCDRV_SRC5_DAC_M_ON) == MCDRV_SRC5_DAC_M_ON)
+	{
+		bReg |= MCB_AA_DAMIX;
+	}
+	McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_WRITE_AA | MCDRV_PACKET_REGTYPE_B_ANA_AA | MCI_AA_LO1L_MIX, bReg);
+	/*	L1L_MONO	*/
+	bReg	= 0;
+	if((sPathInfo.asLout1[0].abSrcOnOff[MCDRV_SRC_LINE1_M_BLOCK] & MCDRV_SRC1_LINE1_M_ON) == MCDRV_SRC1_LINE1_M_ON)
+	{
+		bReg |= MCB_AA_MONO_LI1;
+	}
+	if((sPathInfo.asLout1[0].abSrcOnOff[MCDRV_SRC_DAC_M_BLOCK] & MCDRV_SRC5_DAC_M_ON) == MCDRV_SRC5_DAC_M_ON)
+	{
+		bReg |= MCB_AA_MONO_DA;
+	}
+	McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_WRITE_AA | MCDRV_PACKET_REGTYPE_B_ANA_AA | MCI_AA_LO1L_MONO, bReg);
+
+	/*	L1R_MIX	*/
+	if(sInitInfo.bLineOut1Dif != MCDRV_LINE_DIF)
+	{
+		bReg	= GetMicMixBit(&sPathInfo.asLout1[1]);
+		if((sPathInfo.asLout1[1].abSrcOnOff[MCDRV_SRC_LINE1_R_BLOCK] & MCDRV_SRC1_LINE1_R_ON) == MCDRV_SRC1_LINE1_R_ON)
+		{
+			bReg |= MCB_AA_LI1MIX;
+		}
+		if((sPathInfo.asLout1[1].abSrcOnOff[MCDRV_SRC_DAC_R_BLOCK] & MCDRV_SRC5_DAC_R_ON) == MCDRV_SRC5_DAC_R_ON)
+		{
+			bReg |= MCB_AA_DAMIX;
+		}
+		McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_WRITE_AA | MCDRV_PACKET_REGTYPE_B_ANA_AA | (UINT32)MCI_AA_LO1R_MIX, bReg);
+	}
+
+	/*	L2L_MIX	*/
+	bReg	= GetMicMixBit(&sPathInfo.asLout2[0]);
+	if((sPathInfo.asLout2[0].abSrcOnOff[MCDRV_SRC_LINE1_L_BLOCK] & MCDRV_SRC1_LINE1_L_ON) == MCDRV_SRC1_LINE1_L_ON
+	|| (sPathInfo.asLout2[0].abSrcOnOff[MCDRV_SRC_LINE1_M_BLOCK] & MCDRV_SRC1_LINE1_M_ON) == MCDRV_SRC1_LINE1_M_ON)
+	{
+		bReg |= MCB_AA_LI1MIX;
+	}
+	if((sPathInfo.asLout2[0].abSrcOnOff[MCDRV_SRC_DAC_L_BLOCK] & MCDRV_SRC5_DAC_L_ON) == MCDRV_SRC5_DAC_L_ON
+	|| (sPathInfo.asLout2[0].abSrcOnOff[MCDRV_SRC_DAC_M_BLOCK] & MCDRV_SRC5_DAC_M_ON) == MCDRV_SRC5_DAC_M_ON)
+	{
+		bReg |= MCB_AA_DAMIX;
+	}
+	McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_WRITE_AA | MCDRV_PACKET_REGTYPE_B_ANA_AA | MCI_AA_LO2L_MIX, bReg);
+	/*	L2L_MONO	*/
+	bReg	= 0;
+	if((sPathInfo.asLout2[0].abSrcOnOff[MCDRV_SRC_LINE1_M_BLOCK] & MCDRV_SRC1_LINE1_M_ON) == MCDRV_SRC1_LINE1_M_ON)
+	{
+		bReg |= MCB_AA_MONO_LI1;
+	}
+	if((sPathInfo.asLout2[0].abSrcOnOff[MCDRV_SRC_DAC_M_BLOCK] & MCDRV_SRC5_DAC_M_ON) == MCDRV_SRC5_DAC_M_ON)
+	{
+		bReg |= MCB_AA_MONO_DA;
+	}
+	McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_WRITE_AA | MCDRV_PACKET_REGTYPE_B_ANA_AA | MCI_AA_LO2L_MONO, bReg);
+
+	/*	L2R_MIX	*/
+	if(sInitInfo.bLineOut2Dif != MCDRV_LINE_DIF)
+	{
+		bReg	= GetMicMixBit(&sPathInfo.asLout2[1]);
+		if((sPathInfo.asLout2[1].abSrcOnOff[MCDRV_SRC_LINE1_R_BLOCK] & MCDRV_SRC1_LINE1_R_ON) == MCDRV_SRC1_LINE1_R_ON)
+		{
+			bReg |= MCB_AA_LI1MIX;
+		}
+		if((sPathInfo.asLout2[1].abSrcOnOff[MCDRV_SRC_DAC_R_BLOCK] & MCDRV_SRC5_DAC_R_ON) == MCDRV_SRC5_DAC_R_ON)
+		{
+			bReg |= MCB_AA_DAMIX;
+		}
+		McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_WRITE_AA | MCDRV_PACKET_REGTYPE_B_ANA_AA | (UINT32)MCI_AA_LO2R_MIX, bReg);
+	}
+
+	/*	HPL_MIX	*/
+	bReg	= GetMicMixBit(&sPathInfo.asHpOut[0]);
+	if((sPathInfo.asHpOut[0].abSrcOnOff[MCDRV_SRC_LINE1_L_BLOCK] & MCDRV_SRC1_LINE1_L_ON) == MCDRV_SRC1_LINE1_L_ON
+	|| (sPathInfo.asHpOut[0].abSrcOnOff[MCDRV_SRC_LINE1_M_BLOCK] & MCDRV_SRC1_LINE1_M_ON) == MCDRV_SRC1_LINE1_M_ON)
+	{
+		bReg |= MCB_AA_LI1MIX;
+	}
+	if((sPathInfo.asHpOut[0].abSrcOnOff[MCDRV_SRC_DAC_L_BLOCK] & MCDRV_SRC5_DAC_L_ON) == MCDRV_SRC5_DAC_L_ON
+	|| (sPathInfo.asHpOut[0].abSrcOnOff[MCDRV_SRC_DAC_M_BLOCK] & MCDRV_SRC5_DAC_M_ON) == MCDRV_SRC5_DAC_M_ON)
+	{
+		bReg |= MCB_AA_DAMIX;
+	}
+	McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_WRITE_AA | MCDRV_PACKET_REGTYPE_B_ANA_AA | MCI_AA_HPL_MIX, bReg);
+	/*	HPL_MONO	*/
+	bReg	= 0;
+	if((sPathInfo.asHpOut[0].abSrcOnOff[MCDRV_SRC_LINE1_M_BLOCK] & MCDRV_SRC1_LINE1_M_ON) == MCDRV_SRC1_LINE1_M_ON)
+	{
+		bReg |= MCB_AA_MONO_LI1;
+	}
+	if((sPathInfo.asHpOut[0].abSrcOnOff[MCDRV_SRC_DAC_M_BLOCK] & MCDRV_SRC5_DAC_M_ON) == MCDRV_SRC5_DAC_M_ON)
+	{
+		bReg |= MCB_AA_MONO_DA;
+	}
+	McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_WRITE_AA | MCDRV_PACKET_REGTYPE_B_ANA_AA | MCI_AA_HPL_MONO, bReg);
+
+	/*	HPR_MIX	*/
+	bReg	= GetMicMixBit(&sPathInfo.asHpOut[1]);
+	if((sPathInfo.asHpOut[1].abSrcOnOff[MCDRV_SRC_LINE1_R_BLOCK] & MCDRV_SRC1_LINE1_R_ON) == MCDRV_SRC1_LINE1_R_ON)
+	{
+		bReg |= MCB_AA_LI1MIX;
+	}
+	if((sPathInfo.asHpOut[1].abSrcOnOff[MCDRV_SRC_DAC_R_BLOCK] & MCDRV_SRC5_DAC_R_ON) == MCDRV_SRC5_DAC_R_ON)
+	{
+		bReg |= MCB_AA_DAMIX;
+	}
+	McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_WRITE_AA | MCDRV_PACKET_REGTYPE_B_ANA_AA | MCI_AA_HPR_MIX, bReg);
+
+	/*	SPL_MIX	*/
+	bReg	= 0;
+	if((sPathInfo.asSpOut[0].abSrcOnOff[MCDRV_SRC_LINE1_L_BLOCK] & MCDRV_SRC1_LINE1_L_ON) == MCDRV_SRC1_LINE1_L_ON
+	|| (sPathInfo.asSpOut[0].abSrcOnOff[MCDRV_SRC_LINE1_M_BLOCK] & MCDRV_SRC1_LINE1_M_ON) == MCDRV_SRC1_LINE1_M_ON)
+	{
+		bReg |= MCB_AA_LI1MIX;
+	}
+	if((sPathInfo.asSpOut[0].abSrcOnOff[MCDRV_SRC_DAC_L_BLOCK] & MCDRV_SRC5_DAC_L_ON) == MCDRV_SRC5_DAC_L_ON
+	|| (sPathInfo.asSpOut[0].abSrcOnOff[MCDRV_SRC_DAC_M_BLOCK] & MCDRV_SRC5_DAC_M_ON) == MCDRV_SRC5_DAC_M_ON)
+	{
+		bReg |= MCB_AA_DAMIX;
+	}
+	McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_WRITE_AA | MCDRV_PACKET_REGTYPE_B_ANA_AA | MCI_AA_SPL_MIX, bReg);
+	/*	SPL_MONO	*/
+	bReg	= 0;
+	if((sPathInfo.asSpOut[0].abSrcOnOff[MCDRV_SRC_LINE1_M_BLOCK] & MCDRV_SRC1_LINE1_M_ON) == MCDRV_SRC1_LINE1_M_ON)
+	{
+		bReg |= MCB_AA_MONO_LI1;
+	}
+	if((sPathInfo.asSpOut[0].abSrcOnOff[MCDRV_SRC_DAC_M_BLOCK] & MCDRV_SRC5_DAC_M_ON) == MCDRV_SRC5_DAC_M_ON)
+	{
+		bReg |= MCB_AA_MONO_DA;
+	}
+	McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_WRITE_AA | MCDRV_PACKET_REGTYPE_B_ANA_AA | MCI_AA_SPL_MONO, bReg);
+
+	/*	SPR_MIX	*/
+	bReg	= 0;
+	if((sPathInfo.asSpOut[1].abSrcOnOff[MCDRV_SRC_LINE1_R_BLOCK] & MCDRV_SRC1_LINE1_R_ON) == MCDRV_SRC1_LINE1_R_ON
+	|| (sPathInfo.asSpOut[1].abSrcOnOff[MCDRV_SRC_LINE1_M_BLOCK] & MCDRV_SRC1_LINE1_M_ON) == MCDRV_SRC1_LINE1_M_ON)
+	{
+		bReg |= MCB_AA_LI1MIX;
+	}
+	if((sPathInfo.asSpOut[1].abSrcOnOff[MCDRV_SRC_DAC_R_BLOCK] & MCDRV_SRC5_DAC_R_ON) == MCDRV_SRC5_DAC_R_ON
+	|| (sPathInfo.asSpOut[1].abSrcOnOff[MCDRV_SRC_DAC_M_BLOCK] & MCDRV_SRC5_DAC_M_ON) == MCDRV_SRC5_DAC_M_ON)
+	{
+		bReg |= MCB_AA_DAMIX;
+	}
+	McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_WRITE_AA | MCDRV_PACKET_REGTYPE_B_ANA_AA | MCI_AA_SPR_MIX, bReg);
+	/*	SPR_MONO	*/
+	bReg	= 0;
+	if((sPathInfo.asSpOut[1].abSrcOnOff[MCDRV_SRC_LINE1_M_BLOCK] & MCDRV_SRC1_LINE1_M_ON) == MCDRV_SRC1_LINE1_M_ON)
+	{
+		bReg |= MCB_AA_MONO_LI1;
+	}
+	if((sPathInfo.asSpOut[1].abSrcOnOff[MCDRV_SRC_DAC_M_BLOCK] & MCDRV_SRC5_DAC_M_ON) == MCDRV_SRC5_DAC_M_ON)
+	{
+		bReg |= MCB_AA_MONO_DA;
+	}
+	McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_WRITE_AA | MCDRV_PACKET_REGTYPE_B_ANA_AA | MCI_AA_SPR_MONO, bReg);
+
+	/*	RCV_MIX	*/
+	bReg	= GetMicMixBit(&sPathInfo.asRcOut[0]);
+	if((sPathInfo.asRcOut[0].abSrcOnOff[MCDRV_SRC_LINE1_M_BLOCK] & MCDRV_SRC1_LINE1_M_ON) == MCDRV_SRC1_LINE1_M_ON)
+	{
+		bReg |= MCB_AA_LI1MIX;
+	}
+	if((sPathInfo.asRcOut[0].abSrcOnOff[MCDRV_SRC_DAC_L_BLOCK] & MCDRV_SRC5_DAC_L_ON) == MCDRV_SRC5_DAC_L_ON)
+	{
+		bReg |= MCB_AA_DALMIX;
+	}
+	if((sPathInfo.asRcOut[0].abSrcOnOff[MCDRV_SRC_DAC_R_BLOCK] & MCDRV_SRC5_DAC_R_ON) == MCDRV_SRC5_DAC_R_ON)
+	{
+		bReg |= MCB_AA_DARMIX;
+	}
+	McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_WRITE_AA | MCDRV_PACKET_REGTYPE_B_ANA_AA | MCI_AA_RC_MIX, bReg);
+
+	return MCDRV_SUCCESS;
+}
+
+/****************************************************************************
+ *	GetMicMixBit
+ *
+ *	Description:
+ *			Get mic mixer bit.
+ *	Arguments:
+ *			source info
+ *	Return:
+ *			mic mixer bit
+ *
+ ****************************************************************************/
+static UINT8	GetMicMixBit
+(
+	const MCDRV_CHANNEL* psChannel
+)
+{
+	UINT8	bMicMix	= 0;
+
+	if((psChannel->abSrcOnOff[MCDRV_SRC_MIC1_BLOCK] & MCDRV_SRC0_MIC1_ON) == MCDRV_SRC0_MIC1_ON)
+	{
+		bMicMix |= MCB_AA_M1MIX;
+	}
+	if((psChannel->abSrcOnOff[MCDRV_SRC_MIC2_BLOCK] & MCDRV_SRC0_MIC2_ON) == MCDRV_SRC0_MIC2_ON)
+	{
+		bMicMix |= MCB_AA_M2MIX;
+	}
+	if((psChannel->abSrcOnOff[MCDRV_SRC_MIC3_BLOCK] & MCDRV_SRC0_MIC3_ON) == MCDRV_SRC0_MIC3_ON)
+	{
+		bMicMix |= MCB_AA_M3MIX;
+	}
+	return bMicMix;
+}
+
+/****************************************************************************
+ *	McPacket_AddStart_AA
+ *
+ *	Description:
+ *			Add start packet.
+ *	Arguments:
+ *			none
+ *	Return:
+ *			MCDRV_SUCCESS
+ *			MCDRV_ERROR_RESOURCEOVER
+ *			MCDRV_ERROR_TIMEOUT
+ *
+ ****************************************************************************/
+SINT32	McPacket_AddStart_AA
+(
+	void
+)
+{
+	SINT32	sdRet	= MCDRV_SUCCESS;
+	UINT8	bReg;
+	UINT8	bADStart	= 0;
+	UINT8	bPDMStart	= 0;
+	MCDRV_INIT_INFO	sInitInfo;
+	MCDRV_PATH_INFO	sPathInfo;
+	MCDRV_ADC_INFO	sAdcInfo;
+	MCDRV_PDM_INFO	sPdmInfo;
+
+	McResCtrl_GetInitInfo_AA(&sInitInfo);
+	McResCtrl_GetPathInfo_AA(&sPathInfo);
+	McResCtrl_GetAdcInfo_AA(&sAdcInfo);
+	McResCtrl_GetPdmInfo_AA(&sPdmInfo);
+
+	if(McResCtrl_IsDstUsed_AA(eMCDRV_DST_ADC0_AA, eMCDRV_DST_CH0_AA) == 1
+	|| McResCtrl_IsDstUsed_AA(eMCDRV_DST_ADC0_AA, eMCDRV_DST_CH1_AA) == 1)
+	{/*	ADC0 source is used	*/
+		if((McResCtrl_GetRegVal_AA(MCDRV_PACKET_REGTYPE_B_CODEC_AA, MCI_AA_AD_START) & MCB_AA_AD_START) == 0)
+		{
+			bReg	= (sAdcInfo.bAgcOn << 2) | sAdcInfo.bAgcAdjust;
+			McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_WRITE_AA | MCDRV_PACKET_REGTYPE_B_CODEC_AA | MCI_AA_AD_AGC, bReg);
+			McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_WRITE_AA | MCDRV_PACKET_REGTYPE_B_CODEC_AA | MCI_AA_AD_MUTE, MCB_AA_AD_MUTE);
+			bReg	= (sAdcInfo.bMono << 1) | MCB_AA_AD_START;
+			McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_WRITE_AA | MCDRV_PACKET_REGTYPE_B_CODEC_AA | MCI_AA_AD_START, bReg);
+			bADStart	= 1;
+		}
+	}
+	else if(McResCtrl_IsSrcUsed_AA(eMCDRV_SRC_PDM_AA) != 0)
+	{/*	PDM is used	*/
+		if((McResCtrl_GetRegVal_AA(MCDRV_PACKET_REGTYPE_B_MIXER_AA, MCI_AA_PDM_START) & MCB_AA_PDM_START) == 0)
+		{
+			bReg	= (sPdmInfo.bAgcOn << 2) | sPdmInfo.bAgcAdjust;
+			McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_WRITE_AA | MCDRV_PACKET_REGTYPE_B_MIXER_AA | MCI_AA_PDM_AGC, bReg);
+			McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_WRITE_AA | MCDRV_PACKET_REGTYPE_B_MIXER_AA | MCI_AA_PDM_MUTE, MCB_AA_PDM_MUTE);
+			bReg	= (sPdmInfo.bMono << 1) | MCB_AA_PDM_START;
+			McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_WRITE_AA | MCDRV_PACKET_REGTYPE_B_MIXER_AA | MCI_AA_PDM_START, bReg);
+			bPDMStart	= 1;
+		}
+	}
+
+	if(bADStart == 1 || bPDMStart == 1)
+	{
+		sdRet	= McDevIf_ExecutePacket_AA();
+		if(sdRet != MCDRV_SUCCESS)
+		{
+			return sdRet;
+		}
+		McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_TIMWAIT_AA | sInitInfo.sWaitTime.dAdHpf, 0);
+		if(bADStart == 1)
+		{
+			McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_WRITE_AA | MCDRV_PACKET_REGTYPE_B_CODEC_AA | MCI_AA_AD_MUTE, 0);
+		}
+		else
+		{
+			McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_WRITE_AA | MCDRV_PACKET_REGTYPE_B_MIXER_AA | MCI_AA_PDM_MUTE, 0);
+		}
+	}
+	return sdRet;
+}
+
+/****************************************************************************
+ *	McPacket_AddStop_AA
+ *
+ *	Description:
+ *			Add stop packet.
+ *	Arguments:
+ *			none
+ *	Return:
+ *			MCDRV_SUCCESS
+ *			MCDRV_ERROR_RESOURCEOVER
+ *
+ ****************************************************************************/
+SINT32	McPacket_AddStop_AA
+(
+	void
+)
+{
+	UINT8	bReg;
+
+	bReg	= McResCtrl_GetRegVal_AA(MCDRV_PACKET_REGTYPE_B_MIXER_AA, MCI_AA_DIX0_START);
+	if(McResCtrl_GetDITSource_AA(eMCDRV_DIO_0_AA) == eMCDRV_SRC_NONE_AA)
+	{/*	DIT is unused	*/
+		bReg &= (UINT8)~MCB_AA_DIT0_SRC_START;
+		bReg &= (UINT8)~MCB_AA_DIT0_START;
+	}
+	if(McResCtrl_IsSrcUsed_AA(eMCDRV_SRC_DIR0_AA) == 0)
+	{/*	DIR is unused	*/
+		bReg &= (UINT8)~MCB_AA_DIR0_SRC_START;
+		bReg &= (UINT8)~MCB_AA_DIR0_START;
+	}
+	if((bReg & 0x0F) == 0)
+	{
+		bReg &= (UINT8)~MCB_AA_DITIM0_START;
+	}
+	McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_WRITE_AA | MCDRV_PACKET_REGTYPE_B_MIXER_AA | MCI_AA_DIX0_START, bReg);
+
+	bReg	= McResCtrl_GetRegVal_AA(MCDRV_PACKET_REGTYPE_B_MIXER_AA, MCI_AA_DIX1_START);
+	if(McResCtrl_GetDITSource_AA(eMCDRV_DIO_1_AA) == eMCDRV_SRC_NONE_AA)
+	{/*	DIT is unused	*/
+		bReg &= (UINT8)~MCB_AA_DIT1_SRC_START;
+		bReg &= (UINT8)~MCB_AA_DIT1_START;
+	}
+	if(McResCtrl_IsSrcUsed_AA(eMCDRV_SRC_DIR1_AA) == 0)
+	{/*	DIR is unused	*/
+		bReg &= (UINT8)~MCB_AA_DIR1_SRC_START;
+		bReg &= (UINT8)~MCB_AA_DIR1_START;
+	}
+	if((bReg & 0x0F) == 0)
+	{
+		bReg &= (UINT8)~MCB_AA_DITIM1_START;
+	}
+	McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_WRITE_AA | MCDRV_PACKET_REGTYPE_B_MIXER_AA | MCI_AA_DIX1_START, bReg);
+
+	bReg	= McResCtrl_GetRegVal_AA(MCDRV_PACKET_REGTYPE_B_MIXER_AA, MCI_AA_DIX2_START);
+	if(McResCtrl_GetDITSource_AA(eMCDRV_DIO_2_AA) == eMCDRV_SRC_NONE_AA)
+	{/*	DIT is unused	*/
+		bReg &= (UINT8)~MCB_AA_DIT2_SRC_START;
+		bReg &= (UINT8)~MCB_AA_DIT2_START;
+	}
+	if(McResCtrl_IsSrcUsed_AA(eMCDRV_SRC_DIR2_AA) == 0)
+	{/*	DIR is unused	*/
+		bReg &= (UINT8)~MCB_AA_DIR2_SRC_START;
+		bReg &= (UINT8)~MCB_AA_DIR2_START;
+	}
+	if((bReg & 0x0F) == 0)
+	{
+		bReg &= (UINT8)~MCB_AA_DITIM2_START;
+	}
+	McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_WRITE_AA | MCDRV_PACKET_REGTYPE_B_MIXER_AA | MCI_AA_DIX2_START, bReg);
+
+	if(McResCtrl_IsDstUsed_AA(eMCDRV_DST_ADC0_AA, eMCDRV_DST_CH0_AA) == 0
+	&& McResCtrl_IsDstUsed_AA(eMCDRV_DST_ADC0_AA, eMCDRV_DST_CH1_AA) == 0)
+	{/*	ADC0 source is unused	*/
+		AddStopADC();
+	}
+	if(McResCtrl_IsSrcUsed_AA(eMCDRV_SRC_PDM_AA) == 0)
+	{/*	PDM is unused	*/
+		AddStopPDM();
+	}
+
+	return MCDRV_SUCCESS;
+}
+
+/****************************************************************************
+ *	McPacket_AddVol_AA
+ *
+ *	Description:
+ *			Add volume mute packet.
+ *	Arguments:
+ *			dUpdate		target volume items
+ *			eMode		update mode
+ *	Return:
+ *			MCDRV_SUCCESS
+ *			MCDRV_ERROR_RESOURCEOVER
+ *
+ ****************************************************************************/
+SINT32	McPacket_AddVol_AA
+(
+	UINT32					dUpdate,
+	MCDRV_VOLUPDATE_MODE_AA	eMode
+)
+{
+	UINT8			bVolL;
+	UINT8			bVolR;
+	UINT8			bLAT;
+	UINT8			bReg;
+	UINT32			dSVolDoneParam	= 0;
+	MCDRV_INIT_INFO	sInitInfo;
+	MCDRV_VOL_INFO	sVolInfo;
+
+	McResCtrl_GetInitInfo_AA(&sInitInfo);
+	McResCtrl_GetVolReg_AA(&sVolInfo);
+
+	if((dUpdate & MCDRV_VOLUPDATE_ANAOUT_ALL_AA) != (UINT32)0)
+	{
+		bVolL	= (UINT8)sVolInfo.aswA_Hp[0]&MCB_AA_HPVOL_L;
+		bVolR	= (UINT8)sVolInfo.aswA_Hp[1]&MCB_AA_HPVOL_R;
+		if(bVolL != (McResCtrl_GetRegVal_AA(MCDRV_PACKET_REGTYPE_B_ANA_AA, MCI_AA_HPVOL_L) & MCB_AA_HPVOL_L))
+		{
+			if((eMode != eMCDRV_VOLUPDATE_MUTE_AA) || (bVolL == MCDRV_REG_MUTE))
+			{
+				if(((eMode != eMCDRV_VOLUPDATE_MUTE_AA) || (bVolR == MCDRV_REG_MUTE))
+				&& (bVolR != McResCtrl_GetRegVal_AA(MCDRV_PACKET_REGTYPE_B_ANA_AA, MCI_AA_HPVOL_R)))
+				{
+					bLAT	= MCB_AA_ALAT_HP;
+				}
+				else
+				{
+					bLAT	= 0;
+				}
+				bReg	= bLAT|MCB_AA_SVOL_HP|bVolL;
+				McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_WRITE_AA | MCDRV_PACKET_REGTYPE_B_ANA_AA | (UINT32)MCI_AA_HPVOL_L, bReg);
+				if(bVolL == MCDRV_REG_MUTE)
+				{
+					dSVolDoneParam	|= (MCB_AA_HPL_BUSY<<8);
+				}
+			}
+		}
+		if((eMode != eMCDRV_VOLUPDATE_MUTE_AA) || (bVolR == MCDRV_REG_MUTE))
+		{
+			if((bVolR == MCDRV_REG_MUTE) && (McResCtrl_GetRegVal_AA(MCDRV_PACKET_REGTYPE_B_ANA_AA, MCI_AA_HPVOL_R) != 0))
+			{
+				dSVolDoneParam	|= (UINT8)MCB_AA_HPR_BUSY;
+			}
+			McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_WRITE_AA | MCDRV_PACKET_REGTYPE_B_ANA_AA | (UINT32)MCI_AA_HPVOL_R, bVolR);
+		}
+
+		bVolL	= (UINT8)sVolInfo.aswA_Sp[0]&MCB_AA_SPVOL_L;
+		bVolR	= (UINT8)sVolInfo.aswA_Sp[1]&MCB_AA_SPVOL_R;
+		if(bVolL != (McResCtrl_GetRegVal_AA(MCDRV_PACKET_REGTYPE_B_ANA_AA, MCI_AA_SPVOL_L) & MCB_AA_SPVOL_L))
+		{
+			if((eMode != eMCDRV_VOLUPDATE_MUTE_AA) || (bVolL == MCDRV_REG_MUTE))
+			{
+				if(((eMode != eMCDRV_VOLUPDATE_MUTE_AA) || (bVolR == MCDRV_REG_MUTE))
+				&& (bVolR != McResCtrl_GetRegVal_AA(MCDRV_PACKET_REGTYPE_B_ANA_AA, MCI_AA_SPVOL_R)))
+				{
+					bLAT	= MCB_AA_ALAT_SP;
+				}
+				else
+				{
+					bLAT	= 0;
+				}
+				bReg	= bLAT|MCB_AA_SVOL_SP|bVolL;
+				McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_WRITE_AA | MCDRV_PACKET_REGTYPE_B_ANA_AA | (UINT32)MCI_AA_SPVOL_L, bReg);
+				if(bVolL == MCDRV_REG_MUTE)
+				{
+					dSVolDoneParam	|= (MCB_AA_SPL_BUSY<<8);
+				}
+			}
+		}
+		if((eMode != eMCDRV_VOLUPDATE_MUTE_AA) || (bVolR == MCDRV_REG_MUTE))
+		{
+			if((bVolR == MCDRV_REG_MUTE) && (McResCtrl_GetRegVal_AA(MCDRV_PACKET_REGTYPE_B_ANA_AA, MCI_AA_SPVOL_R) != 0))
+			{
+				dSVolDoneParam	|= (UINT8)MCB_AA_SPR_BUSY;
+			}
+			McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_WRITE_AA | MCDRV_PACKET_REGTYPE_B_ANA_AA | (UINT32)MCI_AA_SPVOL_R, bVolR);
+		}
+
+		bVolL	= (UINT8)sVolInfo.aswA_Rc[0]&MCB_AA_RCVOL;
+		if(bVolL != (McResCtrl_GetRegVal_AA(MCDRV_PACKET_REGTYPE_B_ANA_AA, MCI_AA_RCVOL) & MCB_AA_RCVOL))
+		{
+			if((eMode != eMCDRV_VOLUPDATE_MUTE_AA) || (bVolL == MCDRV_REG_MUTE))
+			{
+				bReg	= MCB_AA_SVOL_RC|bVolL;
+				McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_WRITE_AA | MCDRV_PACKET_REGTYPE_B_ANA_AA | (UINT32)MCI_AA_RCVOL, bReg);
+				if(bVolL == MCDRV_REG_MUTE)
+				{
+					dSVolDoneParam	|= (MCB_AA_RC_BUSY<<8);
+				}
+			}
+		}
+
+		bVolL	= (UINT8)sVolInfo.aswA_Lout1[0]&MCB_AA_LO1VOL_L;
+		bVolR	= (UINT8)sVolInfo.aswA_Lout1[1]&MCB_AA_LO1VOL_R;
+		if(bVolL != (McResCtrl_GetRegVal_AA(MCDRV_PACKET_REGTYPE_B_ANA_AA, MCI_AA_LO1VOL_L) & MCB_AA_LO1VOL_L))
+		{
+			if(eMode != eMCDRV_VOLUPDATE_MUTE_AA || bVolL == MCDRV_REG_MUTE)
+			{
+				if((eMode != eMCDRV_VOLUPDATE_MUTE_AA || bVolR == MCDRV_REG_MUTE)
+				&& bVolR != McResCtrl_GetRegVal_AA(MCDRV_PACKET_REGTYPE_B_ANA_AA, MCI_AA_LO1VOL_R))
+				{
+					bLAT	= MCB_AA_ALAT_LO1;
+				}
+				else
+				{
+					bLAT	= 0;
+				}
+				bReg	= bLAT|bVolL;
+				McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_WRITE_AA | MCDRV_PACKET_REGTYPE_B_ANA_AA | MCI_AA_LO1VOL_L, bReg);
+			}
+		}
+		if(eMode != eMCDRV_VOLUPDATE_MUTE_AA || bVolR == MCDRV_REG_MUTE)
+		{
+			McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_WRITE_AA | MCDRV_PACKET_REGTYPE_B_ANA_AA | MCI_AA_LO1VOL_R, bVolR);
+		}
+
+		bVolL	= (UINT8)sVolInfo.aswA_Lout2[0]&MCB_AA_LO2VOL_L;
+		bVolR	= (UINT8)sVolInfo.aswA_Lout2[1]&MCB_AA_LO2VOL_R;
+		if(bVolL != (McResCtrl_GetRegVal_AA(MCDRV_PACKET_REGTYPE_B_ANA_AA, MCI_AA_LO2VOL_L) & MCB_AA_LO2VOL_L))
+		{
+			if(eMode != eMCDRV_VOLUPDATE_MUTE_AA || bVolL == MCDRV_REG_MUTE)
+			{
+				if((eMode != eMCDRV_VOLUPDATE_MUTE_AA || bVolR == MCDRV_REG_MUTE)
+				&& bVolR != McResCtrl_GetRegVal_AA(MCDRV_PACKET_REGTYPE_B_ANA_AA, MCI_AA_LO2VOL_R))
+				{
+					bLAT	= MCB_AA_ALAT_LO2;
+				}
+				else
+				{
+					bLAT	= 0;
+				}
+				bReg	= bLAT|bVolL;
+				McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_WRITE_AA | MCDRV_PACKET_REGTYPE_B_ANA_AA | MCI_AA_LO2VOL_L, bReg);
+			}
+		}
+		if(eMode != eMCDRV_VOLUPDATE_MUTE_AA || bVolR == MCDRV_REG_MUTE)
+		{
+			McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_WRITE_AA | MCDRV_PACKET_REGTYPE_B_ANA_AA | MCI_AA_LO2VOL_R, bVolR);
+		}
+
+		bVolL	= (UINT8)sVolInfo.aswA_HpGain[0];
+		if(bVolL != McResCtrl_GetRegVal_AA(MCDRV_PACKET_REGTYPE_B_ANA_AA, MCI_AA_HP_GAIN))
+		{
+			if(eMode != eMCDRV_VOLUPDATE_MUTE_AA || bVolL == MCDRV_REG_MUTE)
+			{
+				McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_WRITE_AA | MCDRV_PACKET_REGTYPE_B_ANA_AA | MCI_AA_HP_GAIN, bVolL);
+			}
+		}
+		/*	wait XX_BUSY	*/
+		if(dSVolDoneParam != (UINT32)0)
+		{
+			McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_EVTWAIT_AA | MCDRV_EVT_SVOL_DONE_AA | dSVolDoneParam, 0);
+		}
+	}
+	if((dUpdate & (UINT32)~MCDRV_VOLUPDATE_ANAOUT_ALL_AA) != (UINT32)0)
+	{
+		bVolL	= (UINT8)sVolInfo.aswA_Lin1[0]&MCB_AA_LI1VOL_L;
+		bVolR	= (UINT8)sVolInfo.aswA_Lin1[1]&MCB_AA_LI1VOL_R;
+		if(bVolL != (McResCtrl_GetRegVal_AA(MCDRV_PACKET_REGTYPE_B_ANA_AA, MCI_AA_LI1VOL_L) & MCB_AA_LI1VOL_L))
+		{
+			if(eMode != eMCDRV_VOLUPDATE_MUTE_AA || bVolL == MCDRV_REG_MUTE)
+			{
+				if((eMode != eMCDRV_VOLUPDATE_MUTE_AA || bVolR == MCDRV_REG_MUTE)
+				&& bVolR != McResCtrl_GetRegVal_AA(MCDRV_PACKET_REGTYPE_B_ANA_AA, MCI_AA_LI1VOL_R))
+				{
+					bLAT	= MCB_AA_ALAT_LI1;
+				}
+				else
+				{
+					bLAT	= 0;
+				}
+				bReg	= bLAT|bVolL;
+				McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_WRITE_AA | MCDRV_PACKET_REGTYPE_B_ANA_AA | MCI_AA_LI1VOL_L, bReg);
+			}
+		}
+		if(eMode != eMCDRV_VOLUPDATE_MUTE_AA || bVolR == MCDRV_REG_MUTE)
+		{
+			McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_WRITE_AA | MCDRV_PACKET_REGTYPE_B_ANA_AA | MCI_AA_LI1VOL_R, bVolR);
+		}
+
+		if(McDevProf_IsValid(eMCDRV_FUNC_LI2) == 1)
+		{
+			bVolL	= (UINT8)sVolInfo.aswA_Lin2[0]&MCB_AA_LI2VOL_L;
+			bVolR	= (UINT8)sVolInfo.aswA_Lin2[1]&MCB_AA_LI2VOL_R;
+			if(bVolL != (McResCtrl_GetRegVal_AA(MCDRV_PACKET_REGTYPE_B_ANA_AA, MCI_AA_LI2VOL_L) & MCB_AA_LI2VOL_L))
+			{
+				if(eMode != eMCDRV_VOLUPDATE_MUTE_AA || bVolL == MCDRV_REG_MUTE)
+				{
+					if((eMode != eMCDRV_VOLUPDATE_MUTE_AA || bVolR == MCDRV_REG_MUTE)
+					&& bVolR != McResCtrl_GetRegVal_AA(MCDRV_PACKET_REGTYPE_B_ANA_AA, MCI_AA_LI2VOL_R))
+					{
+						bLAT	= MCB_AA_ALAT_LI2;
+					}
+					else
+					{
+						bLAT	= 0;
+					}
+					bReg	= bLAT|bVolL;
+					McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_WRITE_AA | MCDRV_PACKET_REGTYPE_B_ANA_AA | MCI_AA_LI2VOL_L, bReg);
+				}
+			}
+			if(eMode != eMCDRV_VOLUPDATE_MUTE_AA || bVolR == MCDRV_REG_MUTE)
+			{
+				McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_WRITE_AA | MCDRV_PACKET_REGTYPE_B_ANA_AA | MCI_AA_LI2VOL_R, bVolR);
+			}
+		}
+
+		bVolL	= (UINT8)sVolInfo.aswA_Mic1[0]&MCB_AA_MC1VOL;
+		if(eMode != eMCDRV_VOLUPDATE_MUTE_AA || bVolL == MCDRV_REG_MUTE)
+		{
+			McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_WRITE_AA | MCDRV_PACKET_REGTYPE_B_ANA_AA | MCI_AA_MC1VOL, bVolL);
+		}
+		bVolL	= (UINT8)sVolInfo.aswA_Mic2[0]&MCB_AA_MC2VOL;
+		if(eMode != eMCDRV_VOLUPDATE_MUTE_AA || bVolL == MCDRV_REG_MUTE)
+		{
+			McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_WRITE_AA | MCDRV_PACKET_REGTYPE_B_ANA_AA | MCI_AA_MC2VOL, bVolL);
+		}
+		bVolL	= (UINT8)sVolInfo.aswA_Mic3[0]&MCB_AA_MC3VOL;
+		if(eMode != eMCDRV_VOLUPDATE_MUTE_AA || bVolL == MCDRV_REG_MUTE)
+		{
+			McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_WRITE_AA | MCDRV_PACKET_REGTYPE_B_ANA_AA | MCI_AA_MC3VOL, bVolL);
+		}
+
+		bVolL	= (UINT8)sVolInfo.aswA_Ad0[0]&MCB_AA_ADVOL_L;
+		bVolR	= (UINT8)sVolInfo.aswA_Ad0[1]&MCB_AA_ADVOL_R;
+		if(bVolL != (McResCtrl_GetRegVal_AA(MCDRV_PACKET_REGTYPE_B_ANA_AA, MCI_AA_ADVOL_L) & MCB_AA_ADVOL_L))
+		{
+			if(eMode != eMCDRV_VOLUPDATE_MUTE_AA || bVolL == MCDRV_REG_MUTE)
+			{
+				if((eMode != eMCDRV_VOLUPDATE_MUTE_AA || bVolR == MCDRV_REG_MUTE)
+				&& bVolR != McResCtrl_GetRegVal_AA(MCDRV_PACKET_REGTYPE_B_ANA_AA, MCI_AA_ADVOL_R))
+				{
+					bLAT	= MCB_AA_ALAT_AD;
+				}
+				else
+				{
+					bLAT	= 0;
+				}
+				bReg	= bLAT|bVolL;
+				McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_WRITE_AA | MCDRV_PACKET_REGTYPE_B_ANA_AA | MCI_AA_ADVOL_L, bReg);
+			}
+		}
+		if(eMode != eMCDRV_VOLUPDATE_MUTE_AA || bVolR == MCDRV_REG_MUTE)
+		{
+			McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_WRITE_AA | MCDRV_PACKET_REGTYPE_B_ANA_AA | MCI_AA_ADVOL_R, bVolR);
+		}
+
+		bVolL	= (UINT8)sVolInfo.aswA_Mic2Gain[0]&0x03;
+		bVolL	= (UINT8)((bVolL << 4) & MCB_AA_MC2GAIN) | (UINT8)(sVolInfo.aswA_Mic1Gain[0]&MCB_AA_MC1GAIN);
+		bVolL |= ((sInitInfo.bMic2Sng << 6) & MCB_AA_MC2SNG);
+		bVolL |= ((sInitInfo.bMic1Sng << 2) & MCB_AA_MC1SNG);
+		if(eMode == eMCDRV_VOLUPDATE_MUTE_AA)
+		{
+			bReg	= McResCtrl_GetRegVal_AA(MCDRV_PACKET_REGTYPE_B_ANA_AA, MCI_AA_MC_GAIN);
+			if(((bReg & MCB_AA_MC2GAIN) == 0) && ((bReg & MCB_AA_MC1GAIN) == 0))
+			{
+				;
+			}
+			else
+			{
+				if((bReg & MCB_AA_MC2GAIN) == 0)
+				{
+					bVolL &= (UINT8)~MCB_AA_MC2GAIN;
+				}
+				else if((bReg & MCB_AA_MC1GAIN) == 0)
+				{
+					bVolL &= (UINT8)~MCB_AA_MC1GAIN;
+				}
+				McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_WRITE_AA | MCDRV_PACKET_REGTYPE_B_ANA_AA | MCI_AA_MC_GAIN, bVolL);
+			}
+		}
+		else
+		{
+			McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_WRITE_AA | MCDRV_PACKET_REGTYPE_B_ANA_AA | MCI_AA_MC_GAIN, bVolL);
+		}
+
+		bVolL	= (UINT8)(sVolInfo.aswA_Mic3Gain[0]&MCB_AA_MC3GAIN) | ((sInitInfo.bMic3Sng << 2) & MCB_AA_MC3SNG);
+		if(eMode == eMCDRV_VOLUPDATE_MUTE_AA)
+		{
+			bReg	= McResCtrl_GetRegVal_AA(MCDRV_PACKET_REGTYPE_B_ANA_AA, MCI_AA_MC3_GAIN);
+			if((bReg & MCB_AA_MC3GAIN) == 0)
+			{
+				;
+			}
+			else
+			{
+				McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_WRITE_AA | MCDRV_PACKET_REGTYPE_B_ANA_AA | MCI_AA_MC3_GAIN, bVolL);
+			}
+		}
+		else
+		{
+			McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_WRITE_AA | MCDRV_PACKET_REGTYPE_B_ANA_AA | MCI_AA_MC3_GAIN, bVolL);
+		}
+
+		bVolL	= (UINT8)sVolInfo.aswD_Dit0[0]&MCB_AA_DIT0_INVOLL;
+		bVolR	= (UINT8)sVolInfo.aswD_Dit0[1]&MCB_AA_DIT0_INVOLR;
+		if(bVolL != (McResCtrl_GetRegVal_AA(MCDRV_PACKET_REGTYPE_B_MIXER_AA, MCI_AA_DIT0_INVOLL) & MCB_AA_DIT0_INVOLL))
+		{
+			if(eMode != eMCDRV_VOLUPDATE_MUTE_AA || bVolL == MCDRV_REG_MUTE)
+			{
+				if((eMode != eMCDRV_VOLUPDATE_MUTE_AA || bVolR == MCDRV_REG_MUTE)
+				&& bVolR != McResCtrl_GetRegVal_AA(MCDRV_PACKET_REGTYPE_B_MIXER_AA, MCI_AA_DIT0_INVOLR))
+				{
+					bLAT	= MCB_AA_DIT0_INLAT;
+				}
+				else
+				{
+					bLAT	= 0;
+				}
+				bReg	= bLAT|bVolL;
+				McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_WRITE_AA | MCDRV_PACKET_REGTYPE_B_MIXER_AA | MCI_AA_DIT0_INVOLL, bReg);
+			}
+		}
+		if(eMode != eMCDRV_VOLUPDATE_MUTE_AA || bVolR == MCDRV_REG_MUTE)
+		{
+			McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_WRITE_AA | MCDRV_PACKET_REGTYPE_B_MIXER_AA | MCI_AA_DIT0_INVOLR, bVolR);
+		}
+
+		bVolL	= (UINT8)sVolInfo.aswD_Dit1[0]&MCB_AA_DIT1_INVOLL;
+		bVolR	= (UINT8)sVolInfo.aswD_Dit1[1]&MCB_AA_DIT1_INVOLR;
+		if(bVolL != (McResCtrl_GetRegVal_AA(MCDRV_PACKET_REGTYPE_B_MIXER_AA, MCI_AA_DIT1_INVOLL) & MCB_AA_DIT1_INVOLL))
+		{
+			if(eMode != eMCDRV_VOLUPDATE_MUTE_AA || bVolL == MCDRV_REG_MUTE)
+			{
+				if((eMode != eMCDRV_VOLUPDATE_MUTE_AA || bVolR == MCDRV_REG_MUTE)
+				&& bVolR != McResCtrl_GetRegVal_AA(MCDRV_PACKET_REGTYPE_B_MIXER_AA, MCI_AA_DIT1_INVOLR))
+				{
+					bLAT	= MCB_AA_DIT1_INLAT;
+				}
+				else
+				{
+					bLAT	= 0;
+				}
+				bReg	= bLAT|bVolL;
+				McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_WRITE_AA | MCDRV_PACKET_REGTYPE_B_MIXER_AA | MCI_AA_DIT1_INVOLL, bReg);
+			}
+		}
+		if(eMode != eMCDRV_VOLUPDATE_MUTE_AA || bVolR == MCDRV_REG_MUTE)
+		{
+			McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_WRITE_AA | MCDRV_PACKET_REGTYPE_B_MIXER_AA | MCI_AA_DIT1_INVOLR, bVolR);
+		}
+
+		bVolL	= (UINT8)sVolInfo.aswD_Dit2[0]&MCB_AA_DIT2_INVOLL;
+		bVolR	= (UINT8)sVolInfo.aswD_Dit2[1]&MCB_AA_DIT2_INVOLR;
+		if(bVolL != (McResCtrl_GetRegVal_AA(MCDRV_PACKET_REGTYPE_B_MIXER_AA, MCI_AA_DIT2_INVOLL) & MCB_AA_DIT2_INVOLL))
+		{
+			if(eMode != eMCDRV_VOLUPDATE_MUTE_AA || bVolL == MCDRV_REG_MUTE)
+			{
+				if((eMode != eMCDRV_VOLUPDATE_MUTE_AA || bVolR == MCDRV_REG_MUTE)
+				&& bVolR != McResCtrl_GetRegVal_AA(MCDRV_PACKET_REGTYPE_B_MIXER_AA, MCI_AA_DIT2_INVOLR))
+				{
+					bLAT	= MCB_AA_DIT2_INLAT;
+				}
+				else
+				{
+					bLAT	= 0;
+				}
+				bReg	= bLAT|bVolL;
+				McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_WRITE_AA | MCDRV_PACKET_REGTYPE_B_MIXER_AA | MCI_AA_DIT2_INVOLL, bReg);
+			}
+		}
+		if(eMode != eMCDRV_VOLUPDATE_MUTE_AA || bVolR == MCDRV_REG_MUTE)
+		{
+			McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_WRITE_AA | MCDRV_PACKET_REGTYPE_B_MIXER_AA | MCI_AA_DIT2_INVOLR, bVolR);
+		}
+
+		bVolL	= (UINT8)sVolInfo.aswD_Pdm[0]&MCB_AA_PDM0_VOLL;
+		bVolR	= (UINT8)sVolInfo.aswD_Pdm[1]&MCB_AA_PDM0_VOLR;
+		if(bVolL != (McResCtrl_GetRegVal_AA(MCDRV_PACKET_REGTYPE_B_MIXER_AA, MCI_AA_PDM0_VOLL) & MCB_AA_PDM0_VOLL))
+		{
+			if(eMode != eMCDRV_VOLUPDATE_MUTE_AA || bVolL == MCDRV_REG_MUTE)
+			{
+				if((eMode != eMCDRV_VOLUPDATE_MUTE_AA || bVolR == MCDRV_REG_MUTE)
+				&& bVolR != McResCtrl_GetRegVal_AA(MCDRV_PACKET_REGTYPE_B_MIXER_AA, MCI_AA_PDM0_VOLR))
+				{
+					bLAT	= MCB_AA_PDM0_INLAT;
+				}
+				else
+				{
+					bLAT	= 0;
+				}
+				bReg	= bLAT|bVolL;
+				McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_WRITE_AA | MCDRV_PACKET_REGTYPE_B_MIXER_AA | MCI_AA_PDM0_VOLL, bReg);
+			}
+		}
+		if(eMode != eMCDRV_VOLUPDATE_MUTE_AA || bVolR == MCDRV_REG_MUTE)
+		{
+			McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_WRITE_AA | MCDRV_PACKET_REGTYPE_B_MIXER_AA | MCI_AA_PDM0_VOLR, bVolR);
+		}
+
+		bVolL	= (UINT8)sVolInfo.aswD_Dir0[0]&MCB_AA_DIR0_VOLL;
+		bVolR	= (UINT8)sVolInfo.aswD_Dir0[1]&MCB_AA_DIR0_VOLR;
+		if(bVolL != (McResCtrl_GetRegVal_AA(MCDRV_PACKET_REGTYPE_B_MIXER_AA, MCI_AA_DIR0_VOLL) & MCB_AA_DIR0_VOLL))
+		{
+			if(eMode != eMCDRV_VOLUPDATE_MUTE_AA || bVolL == MCDRV_REG_MUTE)
+			{
+				if((eMode != eMCDRV_VOLUPDATE_MUTE_AA || bVolR == MCDRV_REG_MUTE)
+				&& bVolR != McResCtrl_GetRegVal_AA(MCDRV_PACKET_REGTYPE_B_MIXER_AA, MCI_AA_DIR0_VOLR))
+				{
+					bLAT	= MCB_AA_DIR0_LAT;
+				}
+				else
+				{
+					bLAT	= 0;
+				}
+				bReg	= bLAT|bVolL;
+				McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_WRITE_AA | MCDRV_PACKET_REGTYPE_B_MIXER_AA | MCI_AA_DIR0_VOLL, bReg);
+			}
+		}
+		if(eMode != eMCDRV_VOLUPDATE_MUTE_AA || bVolR == MCDRV_REG_MUTE)
+		{
+			McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_WRITE_AA | MCDRV_PACKET_REGTYPE_B_MIXER_AA | MCI_AA_DIR0_VOLR, bVolR);
+		}
+
+		bVolL	= (UINT8)sVolInfo.aswD_Dir1[0]&MCB_AA_DIR1_VOLL;
+		bVolR	= (UINT8)sVolInfo.aswD_Dir1[1]&MCB_AA_DIR1_VOLR;
+		if(bVolL != (McResCtrl_GetRegVal_AA(MCDRV_PACKET_REGTYPE_B_MIXER_AA, MCI_AA_DIR1_VOLL) & MCB_AA_DIR1_VOLL))
+		{
+			if(eMode != eMCDRV_VOLUPDATE_MUTE_AA || bVolL == MCDRV_REG_MUTE)
+			{
+				if((eMode != eMCDRV_VOLUPDATE_MUTE_AA || bVolR == MCDRV_REG_MUTE)
+				&& bVolR != McResCtrl_GetRegVal_AA(MCDRV_PACKET_REGTYPE_B_MIXER_AA, MCI_AA_DIR1_VOLR))
+				{
+					bLAT	= MCB_AA_DIR1_LAT;
+				}
+				else
+				{
+					bLAT	= 0;
+				}
+				bReg	= bLAT|bVolL;
+				McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_WRITE_AA | MCDRV_PACKET_REGTYPE_B_MIXER_AA | MCI_AA_DIR1_VOLL, bReg);
+			}
+		}
+		if(eMode != eMCDRV_VOLUPDATE_MUTE_AA || bVolR == MCDRV_REG_MUTE)
+		{
+			McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_WRITE_AA | MCDRV_PACKET_REGTYPE_B_MIXER_AA | MCI_AA_DIR1_VOLR, bVolR);
+		}
+
+		bVolL	= (UINT8)sVolInfo.aswD_Dir2[0]&MCB_AA_DIR2_VOLL;
+		bVolR	= (UINT8)sVolInfo.aswD_Dir2[1]&MCB_AA_DIR2_VOLR;
+		if(bVolL != (McResCtrl_GetRegVal_AA(MCDRV_PACKET_REGTYPE_B_MIXER_AA, MCI_AA_DIR2_VOLL) & MCB_AA_DIR2_VOLL))
+		{
+			if(eMode != eMCDRV_VOLUPDATE_MUTE_AA || bVolL == MCDRV_REG_MUTE)
+			{
+				if((eMode != eMCDRV_VOLUPDATE_MUTE_AA || bVolR == MCDRV_REG_MUTE)
+				&& bVolR != McResCtrl_GetRegVal_AA(MCDRV_PACKET_REGTYPE_B_MIXER_AA, MCI_AA_DIR2_VOLR))
+				{
+					bLAT	= MCB_AA_DIR2_LAT;
+				}
+				else
+				{
+					bLAT	= 0;
+				}
+				bReg	= bLAT|bVolL;
+				McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_WRITE_AA | MCDRV_PACKET_REGTYPE_B_MIXER_AA | MCI_AA_DIR2_VOLL, bReg);
+			}
+		}
+		if(eMode != eMCDRV_VOLUPDATE_MUTE_AA || bVolR == MCDRV_REG_MUTE)
+		{
+			McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_WRITE_AA | MCDRV_PACKET_REGTYPE_B_MIXER_AA | MCI_AA_DIR2_VOLR, bVolR);
+		}
+
+		bVolL	= (UINT8)sVolInfo.aswD_Ad0[0]&MCB_AA_ADC_VOLL;
+		bVolR	= (UINT8)sVolInfo.aswD_Ad0[1]&MCB_AA_ADC_VOLR;
+		if(bVolL != (McResCtrl_GetRegVal_AA(MCDRV_PACKET_REGTYPE_B_MIXER_AA, MCI_AA_ADC_VOLL) & MCB_AA_ADC_VOLL))
+		{
+			if(eMode != eMCDRV_VOLUPDATE_MUTE_AA || bVolL == MCDRV_REG_MUTE)
+			{
+				if((eMode != eMCDRV_VOLUPDATE_MUTE_AA || bVolR == MCDRV_REG_MUTE)
+				&& bVolR != McResCtrl_GetRegVal_AA(MCDRV_PACKET_REGTYPE_B_MIXER_AA, MCI_AA_ADC_VOLR))
+				{
+					bLAT	= MCB_AA_ADC_LAT;
+				}
+				else
+				{
+					bLAT	= 0;
+				}
+				bReg	= bLAT|bVolL;
+				McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_WRITE_AA | MCDRV_PACKET_REGTYPE_B_MIXER_AA | MCI_AA_ADC_VOLL, bReg);
+			}
+		}
+		if(eMode != eMCDRV_VOLUPDATE_MUTE_AA || bVolR == MCDRV_REG_MUTE)
+		{
+			McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_WRITE_AA | MCDRV_PACKET_REGTYPE_B_MIXER_AA | MCI_AA_ADC_VOLR, bVolR);
+		}
+
+		if(McDevProf_IsValid(eMCDRV_FUNC_ADC1) == 1)
+		{
+#if 0
+			bVolL	= (UINT8)sVolInfo.aswD_Ad1[0]&MCB_AA_ADC1_VOLL;
+			bVolR	= (UINT8)sVolInfo.aswD_Ad1[1]&MCB_AA_ADC1_VOLR;
+			if(bVolL != (McResCtrl_GetRegVal_AA(MCDRV_PACKET_REGTYPE_B_MIXER_AA, MCI_AA_ADC1_VOLL) & MCB_AA_ADC1_VOLL))
+			{
+				if(eMode != eMCDRV_VOLUPDATE_MUTE_AA || bVolL == MCDRV_REG_MUTE)
+				{
+					if((eMode != eMCDRV_VOLUPDATE_MUTE_AA || bVolR == MCDRV_REG_MUTE)
+					&& bVolR != McResCtrl_GetRegVal_AA(MCDRV_PACKET_REGTYPE_B_MIXER_AA, MCI_AA_ADC1_VOLR))
+					{
+						bLAT	= MCB_AA_ADC_LAT;
+					}
+					else
+					{
+						bLAT	= 0;
+					}
+					bReg	= bLAT|bVolL;
+					McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_WRITE_AA | MCDRV_PACKET_REGTYPE_B_MIXER_AA | MCI_AA_ADC1_VOLL, bReg);
+				}
+			}
+			if(eMode != eMCDRV_VOLUPDATE_MUTE_AA || bVolR == MCDRV_REG_MUTE)
+			{
+				McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_WRITE_AA | MCDRV_PACKET_REGTYPE_B_MIXER_AA | MCI_AA_ADC1_VOLR, bVolR);
+			}
+#endif
+		}
+
+		bVolL	= (UINT8)sVolInfo.aswD_Aeng6[0]&MCB_AA_AENG6_VOLL;
+		bVolR	= (UINT8)sVolInfo.aswD_Aeng6[1]&MCB_AA_AENG6_VOLR;
+		if(bVolL != (McResCtrl_GetRegVal_AA(MCDRV_PACKET_REGTYPE_B_MIXER_AA, MCI_AA_AENG6_VOLL) & MCB_AA_AENG6_VOLL))
+		{
+			if(eMode != eMCDRV_VOLUPDATE_MUTE_AA || bVolL == MCDRV_REG_MUTE)
+			{
+				if((eMode != eMCDRV_VOLUPDATE_MUTE_AA || bVolR == MCDRV_REG_MUTE)
+				&& bVolR != McResCtrl_GetRegVal_AA(MCDRV_PACKET_REGTYPE_B_MIXER_AA, MCI_AA_AENG6_VOLR))
+				{
+					bLAT	= MCB_AA_AENG6_LAT;
+				}
+				else
+				{
+					bLAT	= 0;
+				}
+				bReg	= bLAT|bVolL;
+				McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_WRITE_AA | MCDRV_PACKET_REGTYPE_B_MIXER_AA | MCI_AA_AENG6_VOLL, bReg);
+			}
+		}
+		if(eMode != eMCDRV_VOLUPDATE_MUTE_AA || bVolR == MCDRV_REG_MUTE)
+		{
+			McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_WRITE_AA | MCDRV_PACKET_REGTYPE_B_MIXER_AA | MCI_AA_AENG6_VOLR, bVolR);
+		}
+
+		bVolL	= (UINT8)sVolInfo.aswD_Ad0Att[0]&MCB_AA_ADC_ATTL;
+		bVolR	= (UINT8)sVolInfo.aswD_Ad0Att[1]&MCB_AA_ADC_ATTR;
+		if(bVolL != (McResCtrl_GetRegVal_AA(MCDRV_PACKET_REGTYPE_B_MIXER_AA, MCI_AA_ADC_ATTL) & MCB_AA_ADC_ATTL))
+		{
+			if(eMode != eMCDRV_VOLUPDATE_MUTE_AA || bVolL == MCDRV_REG_MUTE)
+			{
+				if((eMode != eMCDRV_VOLUPDATE_MUTE_AA || bVolR == MCDRV_REG_MUTE)
+				&& bVolR != McResCtrl_GetRegVal_AA(MCDRV_PACKET_REGTYPE_B_MIXER_AA, MCI_AA_ADC_ATTR))
+				{
+					bLAT	= MCB_AA_ADC_ALAT;
+				}
+				else
+				{
+					bLAT	= 0;
+				}
+				bReg	= bLAT|bVolL;
+				McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_WRITE_AA | MCDRV_PACKET_REGTYPE_B_MIXER_AA | MCI_AA_ADC_ATTL, bReg);
+			}
+		}
+		if(eMode != eMCDRV_VOLUPDATE_MUTE_AA || bVolR == MCDRV_REG_MUTE)
+		{
+			McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_WRITE_AA | MCDRV_PACKET_REGTYPE_B_MIXER_AA | MCI_AA_ADC_ATTR, bVolR);
+		}
+
+		bVolL	= (UINT8)sVolInfo.aswD_Dir0Att[0]&MCB_AA_DIR0_ATTL;
+		bVolR	= (UINT8)sVolInfo.aswD_Dir0Att[1]&MCB_AA_DIR0_ATTR;
+		if(bVolL != (McResCtrl_GetRegVal_AA(MCDRV_PACKET_REGTYPE_B_MIXER_AA, MCI_AA_DIR0_ATTL) & MCB_AA_DIR0_ATTL))
+		{
+			if(eMode != eMCDRV_VOLUPDATE_MUTE_AA || bVolL == MCDRV_REG_MUTE)
+			{
+				if((eMode != eMCDRV_VOLUPDATE_MUTE_AA || bVolR == MCDRV_REG_MUTE)
+				&& bVolR != McResCtrl_GetRegVal_AA(MCDRV_PACKET_REGTYPE_B_MIXER_AA, MCI_AA_DIR0_ATTR))
+				{
+					bLAT	= MCB_AA_DIR0_ALAT;
+				}
+				else
+				{
+					bLAT	= 0;
+				}
+				bReg	= bLAT|bVolL;
+				McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_WRITE_AA | MCDRV_PACKET_REGTYPE_B_MIXER_AA | MCI_AA_DIR0_ATTL, bReg);
+			}
+		}
+		if(eMode != eMCDRV_VOLUPDATE_MUTE_AA || bVolR == MCDRV_REG_MUTE)
+		{
+			McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_WRITE_AA | MCDRV_PACKET_REGTYPE_B_MIXER_AA | MCI_AA_DIR0_ATTR, bVolR);
+		}
+
+		bVolL	= (UINT8)sVolInfo.aswD_Dir1Att[0]&MCB_AA_DIR1_ATTL;
+		bVolR	= (UINT8)sVolInfo.aswD_Dir1Att[1]&MCB_AA_DIR1_ATTR;
+		if(bVolL != (McResCtrl_GetRegVal_AA(MCDRV_PACKET_REGTYPE_B_MIXER_AA, MCI_AA_DIR1_ATTL) & MCB_AA_DIR1_ATTL))
+		{
+			if(eMode != eMCDRV_VOLUPDATE_MUTE_AA || bVolL == MCDRV_REG_MUTE)
+			{
+				if((eMode != eMCDRV_VOLUPDATE_MUTE_AA || bVolR == MCDRV_REG_MUTE)
+				&& bVolR != McResCtrl_GetRegVal_AA(MCDRV_PACKET_REGTYPE_B_MIXER_AA, MCI_AA_DIR1_ATTR))
+				{
+					bLAT	= MCB_AA_DIR1_ALAT;
+				}
+				else
+				{
+					bLAT	= 0;
+				}
+				bReg	= bLAT|bVolL;
+				McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_WRITE_AA | MCDRV_PACKET_REGTYPE_B_MIXER_AA | MCI_AA_DIR1_ATTL, bReg);
+			}
+		}
+		if(eMode != eMCDRV_VOLUPDATE_MUTE_AA || bVolR == MCDRV_REG_MUTE)
+		{
+			McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_WRITE_AA | MCDRV_PACKET_REGTYPE_B_MIXER_AA | MCI_AA_DIR1_ATTR, bVolR);
+		}
+
+		bVolL	= (UINT8)sVolInfo.aswD_Dir2Att[0]&MCB_AA_DIR2_ATTL;
+		bVolR	= (UINT8)sVolInfo.aswD_Dir2Att[1]&MCB_AA_DIR2_ATTR;
+		if(bVolL != (McResCtrl_GetRegVal_AA(MCDRV_PACKET_REGTYPE_B_MIXER_AA, MCI_AA_DIR2_ATTL) & MCB_AA_DIR2_ATTL))
+		{
+			if(eMode != eMCDRV_VOLUPDATE_MUTE_AA || bVolL == MCDRV_REG_MUTE)
+			{
+				if((eMode != eMCDRV_VOLUPDATE_MUTE_AA || bVolR == MCDRV_REG_MUTE)
+				&& bVolR != McResCtrl_GetRegVal_AA(MCDRV_PACKET_REGTYPE_B_MIXER_AA, MCI_AA_DIR2_ATTR))
+				{
+					bLAT	= MCB_AA_DIR2_ALAT;
+				}
+				else
+				{
+					bLAT	= 0;
+				}
+				bReg	= bLAT|bVolL;
+				McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_WRITE_AA | MCDRV_PACKET_REGTYPE_B_MIXER_AA | MCI_AA_DIR2_ATTL, bReg);
+			}
+		}
+		if(eMode != eMCDRV_VOLUPDATE_MUTE_AA || bVolR == MCDRV_REG_MUTE)
+		{
+			McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_WRITE_AA | MCDRV_PACKET_REGTYPE_B_MIXER_AA | MCI_AA_DIR2_ATTR, bVolR);
+		}
+
+		if(McResCtrl_GetRegVal_AA(MCDRV_PACKET_REGTYPE_B_MIXER_AA, MCI_AA_AENG6_SOURCE) == MCB_AA_AENG6_PDM)
+		{
+			bVolL	= (UINT8)sVolInfo.aswD_SideTone[0]&MCB_AA_ST_VOLL;
+			bVolR	= (UINT8)sVolInfo.aswD_SideTone[1]&MCB_AA_ST_VOLR;
+			if(bVolL != (McResCtrl_GetRegVal_AA(MCDRV_PACKET_REGTYPE_B_MIXER_AA, MCI_AA_ST_VOLL) & MCB_AA_ST_VOLL))
+			{
+				if(eMode != eMCDRV_VOLUPDATE_MUTE_AA || bVolL == MCDRV_REG_MUTE)
+				{
+					if((eMode != eMCDRV_VOLUPDATE_MUTE_AA || bVolR == MCDRV_REG_MUTE)
+					&& bVolR != McResCtrl_GetRegVal_AA(MCDRV_PACKET_REGTYPE_B_MIXER_AA, MCI_AA_ST_VOLR))
+					{
+						bLAT	= MCB_AA_ST_LAT;
+					}
+					else
+					{
+						bLAT	= 0;
+					}
+					bReg	= bLAT|bVolL;
+					McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_WRITE_AA | MCDRV_PACKET_REGTYPE_B_MIXER_AA | MCI_AA_ST_VOLL, bReg);
+				}
+			}
+			if(eMode != eMCDRV_VOLUPDATE_MUTE_AA || bVolR == MCDRV_REG_MUTE)
+			{
+				McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_WRITE_AA | MCDRV_PACKET_REGTYPE_B_MIXER_AA | MCI_AA_ST_VOLR, bVolR);
+			}
+		}
+
+		bVolL	= (UINT8)sVolInfo.aswD_DacMaster[0]&MCB_AA_MASTER_OUTL;
+		bVolR	= (UINT8)sVolInfo.aswD_DacMaster[1]&MCB_AA_MASTER_OUTR;
+		if(bVolL != (McResCtrl_GetRegVal_AA(MCDRV_PACKET_REGTYPE_B_MIXER_AA, MCI_AA_MASTER_OUTL) & MCB_AA_MASTER_OUTL))
+		{
+			if(eMode != eMCDRV_VOLUPDATE_MUTE_AA || bVolL == MCDRV_REG_MUTE)
+			{
+				if((eMode != eMCDRV_VOLUPDATE_MUTE_AA || bVolR == MCDRV_REG_MUTE)
+				&& bVolR != McResCtrl_GetRegVal_AA(MCDRV_PACKET_REGTYPE_B_MIXER_AA, MCI_AA_MASTER_OUTR))
+				{
+					bLAT	= MCB_AA_MASTER_OLAT;
+				}
+				else
+				{
+					bLAT	= 0;
+				}
+				bReg	= bLAT|bVolL;
+				McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_WRITE_AA | MCDRV_PACKET_REGTYPE_B_MIXER_AA | MCI_AA_MASTER_OUTL, bReg);
+			}
+		}
+		if(eMode != eMCDRV_VOLUPDATE_MUTE_AA || bVolR == MCDRV_REG_MUTE)
+		{
+			McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_WRITE_AA | MCDRV_PACKET_REGTYPE_B_MIXER_AA | MCI_AA_MASTER_OUTR, bVolR);
+		}
+
+		bVolL	= (UINT8)sVolInfo.aswD_DacVoice[0]&MCB_AA_VOICE_ATTL;
+		bVolR	= (UINT8)sVolInfo.aswD_DacVoice[1]&MCB_AA_VOICE_ATTR;
+		if(bVolL != (McResCtrl_GetRegVal_AA(MCDRV_PACKET_REGTYPE_B_MIXER_AA, MCI_AA_VOICE_ATTL) & MCB_AA_VOICE_ATTL))
+		{
+			if(eMode != eMCDRV_VOLUPDATE_MUTE_AA || bVolL == MCDRV_REG_MUTE)
+			{
+				if((eMode != eMCDRV_VOLUPDATE_MUTE_AA || bVolR == MCDRV_REG_MUTE)
+				&& bVolR != McResCtrl_GetRegVal_AA(MCDRV_PACKET_REGTYPE_B_MIXER_AA, MCI_AA_VOICE_ATTR))
+				{
+					bLAT	= MCB_AA_VOICE_LAT;
+				}
+				else
+				{
+					bLAT	= 0;
+				}
+				bReg	= bLAT|bVolL;
+				McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_WRITE_AA | MCDRV_PACKET_REGTYPE_B_MIXER_AA | MCI_AA_VOICE_ATTL, bReg);
+			}
+		}
+		if(eMode != eMCDRV_VOLUPDATE_MUTE_AA || bVolR == MCDRV_REG_MUTE)
+		{
+			McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_WRITE_AA | MCDRV_PACKET_REGTYPE_B_MIXER_AA | MCI_AA_VOICE_ATTR, bVolR);
+		}
+
+		bVolL	= (UINT8)sVolInfo.aswD_DacAtt[0]&MCB_AA_DAC_ATTL;
+		bVolR	= (UINT8)sVolInfo.aswD_DacAtt[1]&MCB_AA_DAC_ATTR;
+		if(bVolL != (McResCtrl_GetRegVal_AA(MCDRV_PACKET_REGTYPE_B_MIXER_AA, MCI_AA_DAC_ATTL) & MCB_AA_DAC_ATTL))
+		{
+			if(eMode != eMCDRV_VOLUPDATE_MUTE_AA || bVolL == MCDRV_REG_MUTE)
+			{
+				if((eMode != eMCDRV_VOLUPDATE_MUTE_AA || bVolR == MCDRV_REG_MUTE)
+				&& bVolR != McResCtrl_GetRegVal_AA(MCDRV_PACKET_REGTYPE_B_MIXER_AA, MCI_AA_DAC_ATTR))
+				{
+					bLAT	= MCB_AA_DAC_LAT;
+				}
+				else
+				{
+					bLAT	= 0;
+				}
+				bReg	= bLAT|bVolL;
+				McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_WRITE_AA | MCDRV_PACKET_REGTYPE_B_MIXER_AA | MCI_AA_DAC_ATTL, bReg);
+			}
+		}
+		if(eMode != eMCDRV_VOLUPDATE_MUTE_AA || bVolR == MCDRV_REG_MUTE)
+		{
+			McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_WRITE_AA | MCDRV_PACKET_REGTYPE_B_MIXER_AA | MCI_AA_DAC_ATTR, bVolR);
+		}
+	}
+
+	return MCDRV_SUCCESS;
+}
+
+/****************************************************************************
+ *	AddStopADC
+ *
+ *	Description:
+ *			Add stop ADC packet.
+ *	Arguments:
+ *			none
+ *	Return:
+ *			none
+ *
+ ****************************************************************************/
+static void	AddStopADC
+(
+	void
+)
+{
+	UINT8	bReg	= McResCtrl_GetRegVal_AA(MCDRV_PACKET_REGTYPE_B_CODEC_AA, MCI_AA_AD_START);
+	if((bReg & MCB_AA_AD_START) != 0)
+	{
+		McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_WRITE_AA | MCDRV_PACKET_REGTYPE_B_CODEC_AA | MCI_AA_AD_MUTE, MCB_AA_AD_MUTE);
+		McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_WRITE_AA | MCDRV_PACKET_REGTYPE_B_CODEC_AA | MCI_AA_AD_START, bReg&(UINT8)~MCB_AA_AD_START);
+	}
+}
+
+/****************************************************************************
+ *	AddStopPDM
+ *
+ *	Description:
+ *			Add stop PDM packet.
+ *	Arguments:
+ *			none
+ *	Return:
+ *			none
+ *
+ ****************************************************************************/
+static void	AddStopPDM
+(
+	void
+)
+{
+	UINT8	bReg	= McResCtrl_GetRegVal_AA(MCDRV_PACKET_REGTYPE_B_MIXER_AA, MCI_AA_PDM_START);
+	if((bReg & MCB_AA_PDM_START) != 0)
+	{
+		McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_WRITE_AA | MCDRV_PACKET_REGTYPE_B_MIXER_AA | MCI_AA_PDM_MUTE, MCB_AA_PDM_MUTE);
+		McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_WRITE_AA | MCDRV_PACKET_REGTYPE_B_MIXER_AA | MCI_AA_PDM_START, bReg&(UINT8)~MCB_AA_PDM_START);
+	}
+}
+
+/****************************************************************************
+ *	McPacket_AddDigitalIO_AA
+ *
+ *	Description:
+ *			Add DigitalI0 setup packet.
+ *	Arguments:
+ *			dUpdateInfo	update information
+ *	Return:
+ *			MCDRV_SUCCESS
+ *			MCDRV_ERROR_RESOURCEOVER
+ *			MCDRV_ERROR_TIMEOUT
+ *
+ ****************************************************************************/
+SINT32	McPacket_AddDigitalIO_AA
+(
+	UINT32	dUpdateInfo
+)
+{
+	SINT32	sdRet	= MCDRV_SUCCESS;
+	UINT8	bReg;
+	MCDRV_POWER_INFO_AA	sPowerInfo;
+	MCDRV_POWER_UPDATE_AA	sPowerUpdate;
+	MCDRV_DIO_INFO		sDioInfo;
+
+	if(IsModifiedDIO(dUpdateInfo) == 0)
+	{
+		return sdRet;
+	}
+
+	McResCtrl_GetCurPowerInfo_AA(&sPowerInfo);
+	sdRet	= PowerUpDig(MCDRV_DPB_UP_AA);
+	if(sdRet != MCDRV_SUCCESS)
+	{
+		return sdRet;
+	}
+
+	if((dUpdateInfo & MCDRV_DIO0_COM_UPDATE_FLAG) != (UINT32)0)
+	{
+		AddDIOCommon(eMCDRV_DIO_0_AA);
+	}
+	if((dUpdateInfo & MCDRV_DIO1_COM_UPDATE_FLAG) != (UINT32)0)
+	{
+		AddDIOCommon(eMCDRV_DIO_1_AA);
+	}
+	if((dUpdateInfo & MCDRV_DIO2_COM_UPDATE_FLAG) != (UINT32)0)
+	{
+		AddDIOCommon(eMCDRV_DIO_2_AA);
+	}
+
+	/*	DI*_BCKP	*/
+	if((dUpdateInfo & MCDRV_DIO0_COM_UPDATE_FLAG) != (UINT32)0
+	|| (dUpdateInfo & MCDRV_DIO1_COM_UPDATE_FLAG) != (UINT32)0
+	|| (dUpdateInfo & MCDRV_DIO2_COM_UPDATE_FLAG) != (UINT32)0)
+	{
+		McResCtrl_GetDioInfo_AA(&sDioInfo);
+		bReg	= 0;
+		if(sDioInfo.asPortInfo[0].sDioCommon.bBckInvert == MCDRV_BCLK_INVERT)
+		{
+			bReg |= MCB_AA_DI0_BCKP;
+		}
+		if(sDioInfo.asPortInfo[1].sDioCommon.bBckInvert == MCDRV_BCLK_INVERT)
+		{
+			bReg |= MCB_AA_DI1_BCKP;
+		}
+		if(sDioInfo.asPortInfo[2].sDioCommon.bBckInvert == MCDRV_BCLK_INVERT)
+		{
+			bReg |= MCB_AA_DI2_BCKP;
+		}
+		if(bReg != McResCtrl_GetRegVal_AA(MCDRV_PACKET_REGTYPE_B_BASE_AA, MCI_AA_BCKP))
+		{
+			McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_WRITE_AA | MCDRV_PACKET_REGTYPE_B_BASE_AA | (UINT32)MCI_AA_BCKP, bReg);
+		}
+	}
+
+	if((dUpdateInfo & MCDRV_DIO0_DIR_UPDATE_FLAG) != (UINT32)0)
+	{
+		AddDIODIR(eMCDRV_DIO_0_AA);
+	}
+	if((dUpdateInfo & MCDRV_DIO1_DIR_UPDATE_FLAG) != (UINT32)0)
+	{
+		AddDIODIR(eMCDRV_DIO_1_AA);
+	}
+	if((dUpdateInfo & MCDRV_DIO2_DIR_UPDATE_FLAG) != (UINT32)0)
+	{
+		AddDIODIR(eMCDRV_DIO_2_AA);
+	}
+
+	if((dUpdateInfo & MCDRV_DIO0_DIT_UPDATE_FLAG) != (UINT32)0)
+	{
+		AddDIODIT(eMCDRV_DIO_0_AA);
+	}
+	if((dUpdateInfo & MCDRV_DIO1_DIT_UPDATE_FLAG) != (UINT32)0)
+	{
+		AddDIODIT(eMCDRV_DIO_1_AA);
+	}
+	if((dUpdateInfo & MCDRV_DIO2_DIT_UPDATE_FLAG) != (UINT32)0)
+	{
+		AddDIODIT(eMCDRV_DIO_2_AA);
+	}
+
+	/*	unused path power down	*/
+	sPowerUpdate.dDigital		= MCDRV_POWUPDATE_DIGITAL_ALL_AA;
+	sPowerUpdate.abAnalog[0]	=
+	sPowerUpdate.abAnalog[1]	=
+	sPowerUpdate.abAnalog[2]	=
+	sPowerUpdate.abAnalog[3]	=
+	sPowerUpdate.abAnalog[4]	= 0;
+	return McPacket_AddPowerDown_AA(&sPowerInfo, &sPowerUpdate);
+}
+
+/****************************************************************************
+ *	IsModifiedDIO
+ *
+ *	Description:
+ *			Is modified DigitalIO.
+ *	Arguments:
+ *			dUpdateInfo	update information
+ *	Return:
+ *			0:not modified/1:modified
+ *
+ ****************************************************************************/
+static UINT8	IsModifiedDIO
+(
+	UINT32		dUpdateInfo
+)
+{
+	if((dUpdateInfo & MCDRV_DIO0_COM_UPDATE_FLAG) != (UINT32)0 && IsModifiedDIOCommon(eMCDRV_DIO_0_AA) == 1)
+	{
+		return 1;
+	}
+	if((dUpdateInfo & MCDRV_DIO1_COM_UPDATE_FLAG) != (UINT32)0 && IsModifiedDIOCommon(eMCDRV_DIO_1_AA) == 1)
+	{
+		return 1;
+	}
+	if((dUpdateInfo & MCDRV_DIO2_COM_UPDATE_FLAG) != (UINT32)0 && IsModifiedDIOCommon(eMCDRV_DIO_2_AA) == 1)
+	{
+		return 1;
+	}
+
+	if((dUpdateInfo & MCDRV_DIO0_DIR_UPDATE_FLAG) != (UINT32)0 && IsModifiedDIODIR(eMCDRV_DIO_0_AA) == 1)
+	{
+		return 1;
+	}
+	if((dUpdateInfo & MCDRV_DIO1_DIR_UPDATE_FLAG) != (UINT32)0 && IsModifiedDIODIR(eMCDRV_DIO_1_AA) == 1)
+	{
+		return 1;
+	}
+	if((dUpdateInfo & MCDRV_DIO2_DIR_UPDATE_FLAG) != (UINT32)0 && IsModifiedDIODIR(eMCDRV_DIO_2_AA) == 1)
+	{
+		return 1;
+	}
+
+	if((dUpdateInfo & MCDRV_DIO0_DIT_UPDATE_FLAG) != (UINT32)0 && IsModifiedDIODIT(eMCDRV_DIO_0_AA) == 1)
+	{
+		return 1;
+	}
+	if((dUpdateInfo & MCDRV_DIO1_DIT_UPDATE_FLAG) != (UINT32)0 && IsModifiedDIODIT(eMCDRV_DIO_1_AA) == 1)
+	{
+		return 1;
+	}
+	if((dUpdateInfo & MCDRV_DIO2_DIT_UPDATE_FLAG) != (UINT32)0 && IsModifiedDIODIT(eMCDRV_DIO_2_AA) == 1)
+	{
+		return 1;
+	}
+	return 0;
+}
+
+/****************************************************************************
+ *	IsModifiedDIOCommon
+ *
+ *	Description:
+ *			Is modified DigitalIO Common.
+ *	Arguments:
+ *			ePort		port number
+ *	Return:
+ *			0:not modified/1:modified
+ *
+ ****************************************************************************/
+static UINT8	IsModifiedDIOCommon
+(
+	MCDRV_DIO_PORT_NO_AA	ePort
+)
+{
+	UINT8	bReg;
+	UINT8	bRegOffset;
+	MCDRV_DIO_INFO	sDioInfo;
+
+	if(ePort == eMCDRV_DIO_0_AA)
+	{
+		bRegOffset	= 0;
+	}
+	else if(ePort == eMCDRV_DIO_1_AA)
+	{
+		bRegOffset	= MCI_AA_DIMODE1 - MCI_AA_DIMODE0;
+	}
+	else if(ePort == eMCDRV_DIO_2_AA)
+	{
+		bRegOffset	= MCI_AA_DIMODE2 - MCI_AA_DIMODE0;
+	}
+	else
+	{
+		return 0;
+	}
+
+	McResCtrl_GetDioInfo_AA(&sDioInfo);
+
+	if(sDioInfo.asPortInfo[ePort].sDioCommon.bInterface != McResCtrl_GetRegVal_AA(MCDRV_PACKET_REGTYPE_B_MIXER_AA, MCI_AA_DIMODE0+bRegOffset))
+	{
+		return 1;
+	}
+
+	bReg	= (sDioInfo.asPortInfo[ePort].sDioCommon.bAutoFs << 7)
+			| (sDioInfo.asPortInfo[ePort].sDioCommon.bBckFs << 4)
+			| sDioInfo.asPortInfo[ePort].sDioCommon.bFs;
+	if(bReg != McResCtrl_GetRegVal_AA(MCDRV_PACKET_REGTYPE_B_MIXER_AA, MCI_AA_DI_FS0+bRegOffset))
+	{
+		return 1;
+	}
+
+	bReg	= McResCtrl_GetRegVal_AA(MCDRV_PACKET_REGTYPE_B_MIXER_AA, MCI_AA_DI0_SRC+bRegOffset);
+	if(sDioInfo.asPortInfo[ePort].sDioCommon.bAutoFs == 0
+	&& sDioInfo.asPortInfo[ePort].sDioCommon.bMasterSlave == MCDRV_DIO_SLAVE)
+	{
+		bReg |= MCB_AA_DICOMMON_SRC_RATE_SET;
+	}
+	if(bReg != McResCtrl_GetRegVal_AA(MCDRV_PACKET_REGTYPE_B_MIXER_AA, MCI_AA_DI0_SRC+bRegOffset))
+	{
+		return 1;
+	}
+
+	if(sDioInfo.asPortInfo[ePort].sDioCommon.bInterface == MCDRV_DIO_PCM)
+	{
+		bReg	= (sDioInfo.asPortInfo[ePort].sDioCommon.bPcmHizTim << 7)
+				| (sDioInfo.asPortInfo[ePort].sDioCommon.bPcmClkDown << 6)
+				| (sDioInfo.asPortInfo[ePort].sDioCommon.bPcmFrame << 5)
+				| (sDioInfo.asPortInfo[ePort].sDioCommon.bPcmHighPeriod);
+		if(bReg != McResCtrl_GetRegVal_AA(MCDRV_PACKET_REGTYPE_B_MIXER_AA, MCI_AA_HIZ_REDGE0+bRegOffset))
+		{
+			return 1;
+		}
+	}
+	return 0;
+}
+
+/****************************************************************************
+ *	IsModifiedDIODIR
+ *
+ *	Description:
+ *			Is modified DigitalIO DIR.
+ *	Arguments:
+ *			ePort		port number
+ *	Return:
+ *			0:not modified/1:modified
+ *
+ ****************************************************************************/
+static UINT8	IsModifiedDIODIR
+(
+	MCDRV_DIO_PORT_NO_AA	ePort
+)
+{
+	UINT8	bReg;
+	UINT8	bRegOffset;
+	MCDRV_DIO_INFO	sDioInfo;
+
+	if(ePort == eMCDRV_DIO_0_AA)
+	{
+		bRegOffset	= 0;
+	}
+	else if(ePort == eMCDRV_DIO_1_AA)
+	{
+		bRegOffset	= MCI_AA_DIMODE1 - MCI_AA_DIMODE0;
+	}
+	else if(ePort == eMCDRV_DIO_2_AA)
+	{
+		bRegOffset	= MCI_AA_DIMODE2 - MCI_AA_DIMODE0;
+	}
+	else
+	{
+		return 0;
+	}
+
+	McResCtrl_GetDioInfo_AA(&sDioInfo);
+
+	bReg	= (UINT8)(sDioInfo.asPortInfo[ePort].sDir.wSrcRate>>8);
+	if(bReg != McResCtrl_GetRegVal_AA(MCDRV_PACKET_REGTYPE_B_MIXER_AA, MCI_AA_DIRSRC_RATE0_MSB+bRegOffset))
+	{
+		return 1;
+	}
+
+	bReg	= (UINT8)sDioInfo.asPortInfo[ePort].sDir.wSrcRate;
+	if(bReg != McResCtrl_GetRegVal_AA(MCDRV_PACKET_REGTYPE_B_MIXER_AA, MCI_AA_DIRSRC_RATE0_LSB+bRegOffset))
+	{
+		return 1;
+	}
+
+	if(sDioInfo.asPortInfo[ePort].sDioCommon.bInterface == MCDRV_DIO_DA)
+	{
+		bReg	= (sDioInfo.asPortInfo[ePort].sDit.sDaFormat.bMode << 6)
+				| (sDioInfo.asPortInfo[ePort].sDit.sDaFormat.bBitSel << 4)
+				| (sDioInfo.asPortInfo[ePort].sDir.sDaFormat.bMode << 2)
+				| (sDioInfo.asPortInfo[ePort].sDir.sDaFormat.bBitSel);
+		if(bReg != McResCtrl_GetRegVal_AA(MCDRV_PACKET_REGTYPE_B_MIXER_AA, MCI_AA_DIX0_FMT+bRegOffset))
+		{
+			return 1;
+		}
+		/*	DIR*_CH	*/
+		bReg	= (sDioInfo.asPortInfo[ePort].sDir.abSlot[1] << 4) | (sDioInfo.asPortInfo[ePort].sDir.abSlot[0]);
+		if(bReg != McResCtrl_GetRegVal_AA(MCDRV_PACKET_REGTYPE_B_MIXER_AA, MCI_AA_DIR0_CH+bRegOffset))
+		{
+			return 1;
+		}
+	}
+	else
+	{
+		/*	PCM_MONO_RX*, PCM_EXTEND_RX*, PCM_LSBON_RX*, PCM_LAW_RX*, PCM_BIT_RX*	*/
+		bReg	= (sDioInfo.asPortInfo[ePort].sDir.sPcmFormat.bMono << 7)
+				| (sDioInfo.asPortInfo[ePort].sDir.sPcmFormat.bOrder << 4)
+				| (sDioInfo.asPortInfo[ePort].sDir.sPcmFormat.bLaw << 2)
+				| (sDioInfo.asPortInfo[ePort].sDir.sPcmFormat.bBitSel);
+		if(bReg != McResCtrl_GetRegVal_AA(MCDRV_PACKET_REGTYPE_B_MIXER_AA, MCI_AA_PCM_RX0+bRegOffset))
+		{
+			return 1;
+		}
+		/*	PCM_CH1_RX*, PCM_CH0_RX*	*/
+		bReg	= (sDioInfo.asPortInfo[ePort].sDir.abSlot[1] << 4) | (sDioInfo.asPortInfo[ePort].sDir.abSlot[0]);
+		if(bReg != McResCtrl_GetRegVal_AA(MCDRV_PACKET_REGTYPE_B_MIXER_AA, MCI_AA_PCM_SLOT_RX0+bRegOffset))
+		{
+			return 1;
+		}
+	}
+	return 0;
+}
+
+/****************************************************************************
+ *	IsModifiedDIODIT
+ *
+ *	Description:
+ *			Is modified DigitalIO DIT.
+ *	Arguments:
+ *			ePort		port number
+ *	Return:
+ *			0:not modified/1:modified
+ *
+ ****************************************************************************/
+static UINT8	IsModifiedDIODIT
+(
+	MCDRV_DIO_PORT_NO_AA	ePort
+)
+{
+	UINT8	bReg;
+	UINT8	bRegOffset;
+	MCDRV_DIO_INFO	sDioInfo;
+
+	if(ePort == eMCDRV_DIO_0_AA)
+	{
+		bRegOffset	= 0;
+	}
+	else if(ePort == eMCDRV_DIO_1_AA)
+	{
+		bRegOffset	= MCI_AA_DIMODE1 - MCI_AA_DIMODE0;
+	}
+	else if(ePort == eMCDRV_DIO_2_AA)
+	{
+		bRegOffset	= MCI_AA_DIMODE2 - MCI_AA_DIMODE0;
+	}
+	else
+	{
+		return 0;
+	}
+
+	McResCtrl_GetDioInfo_AA(&sDioInfo);
+
+	bReg	= (UINT8)(sDioInfo.asPortInfo[ePort].sDit.wSrcRate>>8);
+	if(bReg != McResCtrl_GetRegVal_AA(MCDRV_PACKET_REGTYPE_B_MIXER_AA, MCI_AA_DITSRC_RATE0_MSB+bRegOffset))
+	{
+		return 1;
+	}
+	bReg	= (UINT8)sDioInfo.asPortInfo[ePort].sDit.wSrcRate;
+	if(bReg != McResCtrl_GetRegVal_AA(MCDRV_PACKET_REGTYPE_B_MIXER_AA, MCI_AA_DITSRC_RATE0_LSB+bRegOffset))
+	{
+		return 1;
+	}
+
+	if(sDioInfo.asPortInfo[ePort].sDioCommon.bInterface == MCDRV_DIO_DA)
+	{
+		/*	DIT*_FMT, DIT*_BIT, DIR*_FMT, DIR*_BIT	*/
+		bReg	= (sDioInfo.asPortInfo[ePort].sDit.sDaFormat.bMode << 6)
+				| (sDioInfo.asPortInfo[ePort].sDit.sDaFormat.bBitSel << 4)
+				| (sDioInfo.asPortInfo[ePort].sDir.sDaFormat.bMode << 2)
+				| (sDioInfo.asPortInfo[ePort].sDir.sDaFormat.bBitSel);
+		if(bReg != McResCtrl_GetRegVal_AA(MCDRV_PACKET_REGTYPE_B_MIXER_AA, MCI_AA_DIX0_FMT+bRegOffset))
+		{
+			return 1;
+		}
+
+		/*	DIT*_SLOT	*/
+		bReg	= (sDioInfo.asPortInfo[ePort].sDit.abSlot[1] << 4) | (sDioInfo.asPortInfo[ePort].sDit.abSlot[0]);
+		if(bReg != McResCtrl_GetRegVal_AA(MCDRV_PACKET_REGTYPE_B_MIXER_AA, MCI_AA_DIT0_SLOT+bRegOffset))
+		{
+			return 1;
+		}
+	}
+	else
+	{
+		/*	PCM_MONO_TX*, PCM_EXTEND_TX*, PCM_LSBON_TX*, PCM_LAW_TX*, PCM_BIT_TX*	*/
+		bReg	= (sDioInfo.asPortInfo[ePort].sDit.sPcmFormat.bMono << 7)
+				| (sDioInfo.asPortInfo[ePort].sDit.sPcmFormat.bOrder << 4)
+				| (sDioInfo.asPortInfo[ePort].sDit.sPcmFormat.bLaw << 2)
+				| (sDioInfo.asPortInfo[ePort].sDit.sPcmFormat.bBitSel);
+		if(bReg != McResCtrl_GetRegVal_AA(MCDRV_PACKET_REGTYPE_B_MIXER_AA, MCI_AA_PCM_TX0+bRegOffset))
+		{
+			return 1;
+		}
+
+		/*	PCM_CH1_TX*, PCM_CH0_TX*	*/
+		bReg	= (sDioInfo.asPortInfo[ePort].sDit.abSlot[1] << 4) | (sDioInfo.asPortInfo[ePort].sDit.abSlot[0]);
+		if(bReg != McResCtrl_GetRegVal_AA(MCDRV_PACKET_REGTYPE_B_MIXER_AA, MCI_AA_PCM_SLOT_TX0+bRegOffset))
+		{
+			return 1;
+		}
+	}
+	return 0;
+}
+
+/****************************************************************************
+ *	AddDIOCommon
+ *
+ *	Description:
+ *			Add DigitalI0 Common setup packet.
+ *	Arguments:
+ *			ePort		port number
+ *	Return:
+ *			none
+ *
+ ****************************************************************************/
+static void	AddDIOCommon
+(
+	MCDRV_DIO_PORT_NO_AA	ePort
+)
+{
+	UINT8	bReg;
+	UINT8	bRegOffset;
+	MCDRV_DIO_INFO	sDioInfo;
+
+	if(ePort == eMCDRV_DIO_0_AA)
+	{
+		bRegOffset	= 0;
+	}
+	else if(ePort == eMCDRV_DIO_1_AA)
+	{
+		bRegOffset	= MCI_AA_DIMODE1 - MCI_AA_DIMODE0;
+	}
+	else if(ePort == eMCDRV_DIO_2_AA)
+	{
+		bRegOffset	= MCI_AA_DIMODE2 - MCI_AA_DIMODE0;
+	}
+	else
+	{
+		return;
+	}
+
+	McResCtrl_GetDioInfo_AA(&sDioInfo);
+
+	/*	DIMODE*	*/
+	if(sDioInfo.asPortInfo[ePort].sDioCommon.bInterface != McResCtrl_GetRegVal_AA(MCDRV_PACKET_REGTYPE_B_MIXER_AA, MCI_AA_DIMODE0+bRegOffset))
+	{
+		McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_WRITE_AA | MCDRV_PACKET_REGTYPE_B_MIXER_AA | (UINT32)(MCI_AA_DIMODE0+bRegOffset),
+							sDioInfo.asPortInfo[ePort].sDioCommon.bInterface);
+	}
+
+	/*	DIAUTO_FS*, DIBCK*, DIFS*	*/
+	bReg	= (sDioInfo.asPortInfo[ePort].sDioCommon.bAutoFs << 7)
+			| (sDioInfo.asPortInfo[ePort].sDioCommon.bBckFs << 4)
+			| sDioInfo.asPortInfo[ePort].sDioCommon.bFs;
+	if(bReg != McResCtrl_GetRegVal_AA(MCDRV_PACKET_REGTYPE_B_MIXER_AA, MCI_AA_DI_FS0+bRegOffset))
+	{
+		McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_WRITE_AA | MCDRV_PACKET_REGTYPE_B_MIXER_AA | (UINT32)(MCI_AA_DI_FS0+bRegOffset), bReg);
+	}
+
+	/*	DI*_SRCRATE_SET	*/
+	bReg	= McResCtrl_GetRegVal_AA(MCDRV_PACKET_REGTYPE_B_MIXER_AA, MCI_AA_DI0_SRC+bRegOffset);
+	if(sDioInfo.asPortInfo[ePort].sDioCommon.bAutoFs == 0
+	&& sDioInfo.asPortInfo[ePort].sDioCommon.bMasterSlave == MCDRV_DIO_SLAVE)
+	{
+		bReg |= MCB_AA_DICOMMON_SRC_RATE_SET;
+	}
+	else
+	{
+		bReg &= (UINT8)~MCB_AA_DICOMMON_SRC_RATE_SET;
+	}
+	if(bReg != McResCtrl_GetRegVal_AA(MCDRV_PACKET_REGTYPE_B_MIXER_AA, MCI_AA_DI0_SRC+bRegOffset))
+	{
+		McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_WRITE_AA | MCDRV_PACKET_REGTYPE_B_MIXER_AA | (UINT32)(MCI_AA_DI0_SRC+bRegOffset), bReg);
+	}
+
+	/*	HIZ_REDGE*, PCM_CLKDOWN*, PCM_FRAME*, PCM_HPERIOD*	*/
+	if(sDioInfo.asPortInfo[ePort].sDioCommon.bInterface == MCDRV_DIO_PCM)
+	{
+		bReg	= (sDioInfo.asPortInfo[ePort].sDioCommon.bPcmHizTim << 7)
+				| (sDioInfo.asPortInfo[ePort].sDioCommon.bPcmClkDown << 6)
+				| (sDioInfo.asPortInfo[ePort].sDioCommon.bPcmFrame << 5)
+				| (sDioInfo.asPortInfo[ePort].sDioCommon.bPcmHighPeriod);
+		if(bReg != McResCtrl_GetRegVal_AA(MCDRV_PACKET_REGTYPE_B_MIXER_AA, MCI_AA_HIZ_REDGE0+bRegOffset))
+		{
+			McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_WRITE_AA | MCDRV_PACKET_REGTYPE_B_MIXER_AA | (UINT32)(MCI_AA_HIZ_REDGE0+bRegOffset), bReg);
+		}
+	}
+}
+
+/****************************************************************************
+ *	AddDIODIR
+ *
+ *	Description:
+ *			Add DigitalI0 DIR setup packet.
+ *	Arguments:
+ *			ePort		port number
+ *	Return:
+ *			none
+ *
+ ****************************************************************************/
+static void	AddDIODIR
+(
+	MCDRV_DIO_PORT_NO_AA	ePort
+)
+{
+	UINT8	bReg;
+	UINT8	bRegOffset;
+	UINT16	wSrcRate;
+	MCDRV_DIO_INFO	sDioInfo;
+
+	if(ePort == eMCDRV_DIO_0_AA)
+	{
+		bRegOffset	= 0;
+	}
+	else if(ePort == eMCDRV_DIO_1_AA)
+	{
+		bRegOffset	= MCI_AA_DIMODE1 - MCI_AA_DIMODE0;
+	}
+	else if(ePort == eMCDRV_DIO_2_AA)
+	{
+		bRegOffset	= MCI_AA_DIMODE2 - MCI_AA_DIMODE0;
+	}
+	else
+	{
+		return;
+	}
+
+	McResCtrl_GetDioInfo_AA(&sDioInfo);
+
+	/*	DIRSRC_RATE*	*/
+	wSrcRate	= sDioInfo.asPortInfo[ePort].sDir.wSrcRate;
+	if(wSrcRate == 0)
+	{
+		switch(sDioInfo.asPortInfo[ePort].sDioCommon.bFs)
+		{
+		case MCDRV_FS_48000:
+			wSrcRate	= MCDRV_DIR_SRCRATE_48000_AA;
+			break;
+		case MCDRV_FS_44100:
+			wSrcRate	= MCDRV_DIR_SRCRATE_44100_AA;
+			break;
+		case MCDRV_FS_32000:
+			wSrcRate	= MCDRV_DIR_SRCRATE_32000_AA;
+			break;
+		case MCDRV_FS_24000:
+			wSrcRate	= MCDRV_DIR_SRCRATE_24000_AA;
+			break;
+		case MCDRV_FS_22050:
+			wSrcRate	= MCDRV_DIR_SRCRATE_22050_AA;
+			break;
+		case MCDRV_FS_16000:
+			wSrcRate	= MCDRV_DIR_SRCRATE_16000_AA;
+			break;
+		case MCDRV_FS_12000:
+			wSrcRate	= MCDRV_DIR_SRCRATE_12000_AA;
+			break;
+		case MCDRV_FS_11025:
+			wSrcRate	= MCDRV_DIR_SRCRATE_11025_AA;
+			break;
+		case MCDRV_FS_8000:
+			wSrcRate	= MCDRV_DIR_SRCRATE_8000_AA;
+			break;
+		default:
+			/* unreachable */
+			wSrcRate = 0;
+			break;
+		}
+	}
+	bReg	= (UINT8)(wSrcRate>>8);
+	if(bReg != McResCtrl_GetRegVal_AA(MCDRV_PACKET_REGTYPE_B_MIXER_AA, MCI_AA_DIRSRC_RATE0_MSB+bRegOffset))
+	{
+		McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_WRITE_AA | MCDRV_PACKET_REGTYPE_B_MIXER_AA | (UINT32)(MCI_AA_DIRSRC_RATE0_MSB+bRegOffset), bReg);
+	}
+	bReg	= (UINT8)wSrcRate;
+	if(bReg != McResCtrl_GetRegVal_AA(MCDRV_PACKET_REGTYPE_B_MIXER_AA, MCI_AA_DIRSRC_RATE0_LSB+bRegOffset))
+	{
+		McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_WRITE_AA | MCDRV_PACKET_REGTYPE_B_MIXER_AA | (UINT32)(MCI_AA_DIRSRC_RATE0_LSB+bRegOffset), bReg);
+	}
+
+	/*	DIT*_FMT, DIT*_BIT, DIR*_FMT, DIR*_BIT	*/
+	if(sDioInfo.asPortInfo[ePort].sDioCommon.bInterface == MCDRV_DIO_DA)
+	{
+		bReg	= (sDioInfo.asPortInfo[ePort].sDit.sDaFormat.bMode << 6)
+				| (sDioInfo.asPortInfo[ePort].sDit.sDaFormat.bBitSel << 4)
+				| (sDioInfo.asPortInfo[ePort].sDir.sDaFormat.bMode << 2)
+				| (sDioInfo.asPortInfo[ePort].sDir.sDaFormat.bBitSel);
+		if(bReg != McResCtrl_GetRegVal_AA(MCDRV_PACKET_REGTYPE_B_MIXER_AA, MCI_AA_DIX0_FMT+bRegOffset))
+		{
+			McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_WRITE_AA | MCDRV_PACKET_REGTYPE_B_MIXER_AA | (UINT32)(MCI_AA_DIX0_FMT+bRegOffset), bReg);
+		}
+		/*	DIR*_CH	*/
+		bReg	= (sDioInfo.asPortInfo[ePort].sDir.abSlot[1] << 4) | (sDioInfo.asPortInfo[ePort].sDir.abSlot[0]);
+		if(bReg != McResCtrl_GetRegVal_AA(MCDRV_PACKET_REGTYPE_B_MIXER_AA, MCI_AA_DIR0_CH+bRegOffset))
+		{
+			McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_WRITE_AA | MCDRV_PACKET_REGTYPE_B_MIXER_AA | (UINT32)(MCI_AA_DIR0_CH+bRegOffset), bReg);
+		}
+	}
+	else
+	{
+		/*	PCM_MONO_RX*, PCM_EXTEND_RX*, PCM_LSBON_RX*, PCM_LAW_RX*, PCM_BIT_RX*	*/
+		bReg	= (sDioInfo.asPortInfo[ePort].sDir.sPcmFormat.bMono << 7)
+				| (sDioInfo.asPortInfo[ePort].sDir.sPcmFormat.bOrder << 4)
+				| (sDioInfo.asPortInfo[ePort].sDir.sPcmFormat.bLaw << 2)
+				| (sDioInfo.asPortInfo[ePort].sDir.sPcmFormat.bBitSel);
+		if(bReg != McResCtrl_GetRegVal_AA(MCDRV_PACKET_REGTYPE_B_MIXER_AA, MCI_AA_PCM_RX0+bRegOffset))
+		{
+			McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_WRITE_AA | MCDRV_PACKET_REGTYPE_B_MIXER_AA | (UINT32)(MCI_AA_PCM_RX0+bRegOffset), bReg);
+		}
+		/*	PCM_CH1_RX*, PCM_CH0_RX*	*/
+		bReg	= (sDioInfo.asPortInfo[ePort].sDir.abSlot[1] << 4) | (sDioInfo.asPortInfo[ePort].sDir.abSlot[0]);
+		if(bReg != McResCtrl_GetRegVal_AA(MCDRV_PACKET_REGTYPE_B_MIXER_AA, MCI_AA_PCM_SLOT_RX0+bRegOffset))
+		{
+			McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_WRITE_AA | MCDRV_PACKET_REGTYPE_B_MIXER_AA | (UINT32)(MCI_AA_PCM_SLOT_RX0+bRegOffset), bReg);
+		}
+	}
+}
+
+/****************************************************************************
+ *	AddDIODIT
+ *
+ *	Description:
+ *			Add DigitalI0 DIT setup packet.
+ *	Arguments:
+ *			ePort		port number
+ *	Return:
+ *			none
+ *
+ ****************************************************************************/
+static void	AddDIODIT
+(
+	MCDRV_DIO_PORT_NO_AA	ePort
+)
+{
+	UINT8	bReg;
+	UINT8	bRegOffset;
+	UINT16	wSrcRate;
+	MCDRV_DIO_INFO	sDioInfo;
+
+	if(ePort == eMCDRV_DIO_0_AA)
+	{
+		bRegOffset	= 0;
+	}
+	else if(ePort == eMCDRV_DIO_1_AA)
+	{
+		bRegOffset	= MCI_AA_DIMODE1 - MCI_AA_DIMODE0;
+	}
+	else if(ePort == eMCDRV_DIO_2_AA)
+	{
+		bRegOffset	= MCI_AA_DIMODE2 - MCI_AA_DIMODE0;
+	}
+	else
+	{
+		return;
+	}
+
+	McResCtrl_GetDioInfo_AA(&sDioInfo);
+
+	wSrcRate	= sDioInfo.asPortInfo[ePort].sDit.wSrcRate;
+	if(wSrcRate == 0)
+	{
+		switch(sDioInfo.asPortInfo[ePort].sDioCommon.bFs)
+		{
+		case MCDRV_FS_48000:
+			wSrcRate	= MCDRV_DIT_SRCRATE_48000_AA;
+			break;
+		case MCDRV_FS_44100:
+			wSrcRate	= MCDRV_DIT_SRCRATE_44100_AA;
+			break;
+		case MCDRV_FS_32000:
+			wSrcRate	= MCDRV_DIT_SRCRATE_32000_AA;
+			break;
+		case MCDRV_FS_24000:
+			wSrcRate	= MCDRV_DIT_SRCRATE_24000_AA;
+			break;
+		case MCDRV_FS_22050:
+			wSrcRate	= MCDRV_DIT_SRCRATE_22050_AA;
+			break;
+		case MCDRV_FS_16000:
+			wSrcRate	= MCDRV_DIT_SRCRATE_16000_AA;
+			break;
+		case MCDRV_FS_12000:
+			wSrcRate	= MCDRV_DIT_SRCRATE_12000_AA;
+			break;
+		case MCDRV_FS_11025:
+			wSrcRate	= MCDRV_DIT_SRCRATE_11025_AA;
+			break;
+		case MCDRV_FS_8000:
+			wSrcRate	= MCDRV_DIT_SRCRATE_8000_AA;
+			break;
+		default:
+			/* unreachable */
+			wSrcRate = 0;
+			break;
+		}
+	}
+	/*	DITSRC_RATE*	*/
+	bReg	= (UINT8)(wSrcRate>>8);
+	if(bReg != McResCtrl_GetRegVal_AA(MCDRV_PACKET_REGTYPE_B_MIXER_AA, MCI_AA_DITSRC_RATE0_MSB+bRegOffset))
+	{
+		McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_WRITE_AA | MCDRV_PACKET_REGTYPE_B_MIXER_AA | (UINT32)(MCI_AA_DITSRC_RATE0_MSB+bRegOffset), bReg);
+	}
+	bReg	= (UINT8)wSrcRate;
+	if(bReg != McResCtrl_GetRegVal_AA(MCDRV_PACKET_REGTYPE_B_MIXER_AA, MCI_AA_DITSRC_RATE0_LSB+bRegOffset))
+	{
+		McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_WRITE_AA | MCDRV_PACKET_REGTYPE_B_MIXER_AA | (UINT32)(MCI_AA_DITSRC_RATE0_LSB+bRegOffset), bReg);
+	}
+
+	if(sDioInfo.asPortInfo[ePort].sDioCommon.bInterface == MCDRV_DIO_DA)
+	{
+		/*	DIT*_FMT, DIT*_BIT, DIR*_FMT, DIR*_BIT	*/
+		bReg	= (sDioInfo.asPortInfo[ePort].sDit.sDaFormat.bMode << 6)
+				| (sDioInfo.asPortInfo[ePort].sDit.sDaFormat.bBitSel << 4)
+				| (sDioInfo.asPortInfo[ePort].sDir.sDaFormat.bMode << 2)
+				| (sDioInfo.asPortInfo[ePort].sDir.sDaFormat.bBitSel);
+		if(bReg != McResCtrl_GetRegVal_AA(MCDRV_PACKET_REGTYPE_B_MIXER_AA, MCI_AA_DIX0_FMT+bRegOffset))
+		{
+			McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_WRITE_AA | MCDRV_PACKET_REGTYPE_B_MIXER_AA | (UINT32)(MCI_AA_DIX0_FMT+bRegOffset), bReg);
+		}
+
+		/*	DIT*_SLOT	*/
+		bReg	= (sDioInfo.asPortInfo[ePort].sDit.abSlot[1] << 4) | (sDioInfo.asPortInfo[ePort].sDit.abSlot[0]);
+		if(bReg != McResCtrl_GetRegVal_AA(MCDRV_PACKET_REGTYPE_B_MIXER_AA, MCI_AA_DIT0_SLOT+bRegOffset))
+		{
+			McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_WRITE_AA | MCDRV_PACKET_REGTYPE_B_MIXER_AA | (UINT32)(MCI_AA_DIT0_SLOT+bRegOffset), bReg);
+		}
+	}
+	else
+	{
+		/*	PCM_MONO_TX*, PCM_EXTEND_TX*, PCM_LSBON_TX*, PCM_LAW_TX*, PCM_BIT_TX*	*/
+		bReg	= (sDioInfo.asPortInfo[ePort].sDit.sPcmFormat.bMono << 7)
+				| (sDioInfo.asPortInfo[ePort].sDit.sPcmFormat.bOrder << 4)
+				| (sDioInfo.asPortInfo[ePort].sDit.sPcmFormat.bLaw << 2)
+				| (sDioInfo.asPortInfo[ePort].sDit.sPcmFormat.bBitSel);
+		if(bReg != McResCtrl_GetRegVal_AA(MCDRV_PACKET_REGTYPE_B_MIXER_AA, MCI_AA_PCM_TX0+bRegOffset))
+		{
+			McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_WRITE_AA | MCDRV_PACKET_REGTYPE_B_MIXER_AA | (UINT32)(MCI_AA_PCM_TX0+bRegOffset), bReg);
+		}
+
+		/*	PCM_CH1_TX*, PCM_CH0_TX*	*/
+		bReg	= (sDioInfo.asPortInfo[ePort].sDit.abSlot[1] << 4) | (sDioInfo.asPortInfo[ePort].sDit.abSlot[0]);
+		if(bReg != McResCtrl_GetRegVal_AA(MCDRV_PACKET_REGTYPE_B_MIXER_AA, MCI_AA_PCM_SLOT_TX0+bRegOffset))
+		{
+			McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_WRITE_AA | MCDRV_PACKET_REGTYPE_B_MIXER_AA | (UINT32)(MCI_AA_PCM_SLOT_TX0+bRegOffset), bReg);
+		}
+	}
+}
+
+/****************************************************************************
+ *	McPacket_AddDAC_AA
+ *
+ *	Description:
+ *			Add DAC setup packet.
+ *	Arguments:
+ *			dUpdateInfo	update information
+ *	Return:
+ *			MCDRV_SUCCESS
+ *			MCDRV_ERROR_RESOURCEOVER
+ *			MCDRV_ERROR_TIMEOUT
+ *
+ ****************************************************************************/
+SINT32	McPacket_AddDAC_AA
+(
+	UINT32			dUpdateInfo
+)
+{
+	SINT32	sdRet	= MCDRV_SUCCESS;
+	MCDRV_POWER_INFO_AA	sPowerInfo;
+	MCDRV_POWER_UPDATE_AA	sPowerUpdate;
+	MCDRV_DAC_INFO		sDacInfo;
+	UINT8	bReg;
+
+	McResCtrl_GetDacInfo_AA(&sDacInfo);
+
+	if((dUpdateInfo & MCDRV_DAC_MSWP_UPDATE_FLAG) != (UINT32)0 || (dUpdateInfo & MCDRV_DAC_VSWP_UPDATE_FLAG) != (UINT32)0)
+	{
+		bReg	= (sDacInfo.bMasterSwap<<4)|sDacInfo.bVoiceSwap;
+		if(bReg == McResCtrl_GetRegVal_AA(MCDRV_PACKET_REGTYPE_B_MIXER_AA, MCI_AA_SWP))
+		{
+			dUpdateInfo	&= ~(MCDRV_DAC_MSWP_UPDATE_FLAG|MCDRV_DAC_VSWP_UPDATE_FLAG);
+		}
+	}
+	if((dUpdateInfo & MCDRV_DAC_HPF_UPDATE_FLAG) != (UINT32)0)
+	{
+		if(sDacInfo.bDcCut == McResCtrl_GetRegVal_AA(MCDRV_PACKET_REGTYPE_B_CODEC_AA, MCI_AA_DCCUTOFF))
+		{
+			dUpdateInfo	&= ~(MCDRV_DAC_HPF_UPDATE_FLAG);
+		}
+	}
+	if(dUpdateInfo == (UINT32)0)
+	{
+		return sdRet;
+	}
+
+	McResCtrl_GetCurPowerInfo_AA(&sPowerInfo);
+	sdRet	= PowerUpDig(MCDRV_DPB_UP_AA);
+	if(sdRet != MCDRV_SUCCESS)
+	{
+		return sdRet;
+	}
+
+	if((dUpdateInfo & MCDRV_DAC_MSWP_UPDATE_FLAG) != (UINT32)0 || (dUpdateInfo & MCDRV_DAC_VSWP_UPDATE_FLAG) != (UINT32)0)
+	{
+		bReg	= (sDacInfo.bMasterSwap<<4)|sDacInfo.bVoiceSwap;
+		McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_WRITE_AA | MCDRV_PACKET_REGTYPE_B_MIXER_AA | MCI_AA_SWP, bReg);
+	}
+	if((dUpdateInfo & MCDRV_DAC_HPF_UPDATE_FLAG) != (UINT32)0)
+	{
+		McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_WRITE_AA | MCDRV_PACKET_REGTYPE_B_CODEC_AA | MCI_AA_DCCUTOFF, sDacInfo.bDcCut);
+	}
+
+	/*	unused path power down	*/
+	sPowerUpdate.dDigital		= MCDRV_POWUPDATE_DIGITAL_ALL_AA;
+	sPowerUpdate.abAnalog[0]	=
+	sPowerUpdate.abAnalog[1]	=
+	sPowerUpdate.abAnalog[2]	=
+	sPowerUpdate.abAnalog[3]	=
+	sPowerUpdate.abAnalog[4]	= 0;
+	return McPacket_AddPowerDown_AA(&sPowerInfo, &sPowerUpdate);
+}
+
+/****************************************************************************
+ *	McPacket_AddADC_AA
+ *
+ *	Description:
+ *			Add ADC setup packet.
+ *	Arguments:
+ *			dUpdateInfo	update information
+ *	Return:
+ *			MCDRV_SUCCESS
+ *			MCDRV_ERROR_RESOURCEOVER
+ *			MCDRV_ERROR_TIMEOUT
+ *
+ ****************************************************************************/
+SINT32	McPacket_AddADC_AA
+(
+	UINT32			dUpdateInfo
+)
+{
+	SINT32	sdRet	= MCDRV_SUCCESS;
+	UINT8	bReg;
+	MCDRV_POWER_INFO_AA	sPowerInfo;
+	MCDRV_POWER_UPDATE_AA	sPowerUpdate;
+	MCDRV_ADC_INFO		sAdcInfo;
+
+	McResCtrl_GetAdcInfo_AA(&sAdcInfo);
+
+	if((dUpdateInfo & MCDRV_ADCADJ_UPDATE_FLAG) != (UINT32)0 || (dUpdateInfo & MCDRV_ADCAGC_UPDATE_FLAG) != (UINT32)0)
+	{
+		bReg	= (sAdcInfo.bAgcOn<<2)|sAdcInfo.bAgcAdjust;
+		if(bReg == McResCtrl_GetRegVal_AA(MCDRV_PACKET_REGTYPE_B_CODEC_AA, MCI_AA_AD_AGC))
+		{
+			dUpdateInfo	&= ~(MCDRV_ADCADJ_UPDATE_FLAG|MCDRV_ADCAGC_UPDATE_FLAG);
+		}
+	}
+	if((dUpdateInfo & MCDRV_ADCMONO_UPDATE_FLAG) != (UINT32)0)
+	{
+		bReg	= (McResCtrl_GetRegVal_AA(MCDRV_PACKET_REGTYPE_B_CODEC_AA, MCI_AA_AD_START) & MCB_AA_AD_START) | (sAdcInfo.bMono << 1);
+		if(bReg == McResCtrl_GetRegVal_AA(MCDRV_PACKET_REGTYPE_B_CODEC_AA, MCI_AA_AD_START))
+		{
+			dUpdateInfo	&= ~(MCDRV_ADCMONO_UPDATE_FLAG);
+		}
+	}
+
+	if(dUpdateInfo == (UINT32)0)
+	{
+		return sdRet;
+	}
+
+	McResCtrl_GetCurPowerInfo_AA(&sPowerInfo);
+	sdRet	= PowerUpDig(MCDRV_DPB_UP_AA);
+	if(sdRet != MCDRV_SUCCESS)
+	{
+		return sdRet;
+	}
+
+	if((dUpdateInfo & MCDRV_ADCADJ_UPDATE_FLAG) != (UINT32)0 || (dUpdateInfo & MCDRV_ADCAGC_UPDATE_FLAG) != (UINT32)0)
+	{
+		bReg	= (sAdcInfo.bAgcOn<<2)|sAdcInfo.bAgcAdjust;
+		if(bReg != McResCtrl_GetRegVal_AA(MCDRV_PACKET_REGTYPE_B_CODEC_AA, MCI_AA_AD_AGC))
+		{
+			AddStopADC();
+			sdRet	= McDevIf_ExecutePacket_AA();
+			if(MCDRV_SUCCESS != sdRet)
+			{
+				return sdRet;
+			}
+		}
+		McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_WRITE_AA | MCDRV_PACKET_REGTYPE_B_CODEC_AA | MCI_AA_AD_AGC, bReg);
+	}
+	if((dUpdateInfo & MCDRV_ADCMONO_UPDATE_FLAG) != (UINT32)0)
+	{
+		bReg	= (McResCtrl_GetRegVal_AA(MCDRV_PACKET_REGTYPE_B_CODEC_AA, MCI_AA_AD_START) & MCB_AA_AD_START) | (sAdcInfo.bMono << 1);
+		if(bReg != McResCtrl_GetRegVal_AA(MCDRV_PACKET_REGTYPE_B_CODEC_AA, MCI_AA_AD_START))
+		{
+			AddStopADC();
+			sdRet	= McDevIf_ExecutePacket_AA();
+			if(MCDRV_SUCCESS != sdRet)
+			{
+				return sdRet;
+			}
+		}
+		McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_WRITE_AA | MCDRV_PACKET_REGTYPE_B_CODEC_AA | MCI_AA_AD_START, (sAdcInfo.bMono << 1));
+	}
+
+	/*	unused path power down	*/
+	sPowerUpdate.dDigital		= MCDRV_POWUPDATE_DIGITAL_ALL_AA;
+	sPowerUpdate.abAnalog[0]	=
+	sPowerUpdate.abAnalog[1]	=
+	sPowerUpdate.abAnalog[2]	=
+	sPowerUpdate.abAnalog[3]	=
+	sPowerUpdate.abAnalog[4]	= 0;
+	sdRet	= McPacket_AddPowerDown_AA(&sPowerInfo, &sPowerUpdate);
+	if(sdRet != MCDRV_SUCCESS)
+	{
+		return sdRet;
+	}
+	return McPacket_AddStart_AA();
+}
+
+/****************************************************************************
+ *	McPacket_AddSP_AA
+ *
+ *	Description:
+ *			Add SP setup packet.
+ *	Arguments:
+ *			none
+ *	Return:
+ *			MCDRV_SUCCESS
+ *			MCDRV_ERROR_RESOURCEOVER
+ *
+ ****************************************************************************/
+SINT32	McPacket_AddSP_AA
+(
+	void
+)
+{
+	MCDRV_SP_INFO	sSpInfo;
+	UINT8	bReg	= McResCtrl_GetRegVal_AA(MCDRV_PACKET_REGTYPE_B_ANA_AA, MCI_AA_SP_MODE) & (UINT8)~MCB_AA_SP_SWAP;
+
+	McResCtrl_GetSpInfo_AA(&sSpInfo);
+
+	McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_WRITE_AA | MCDRV_PACKET_REGTYPE_B_ANA_AA | MCI_AA_SP_MODE, bReg|sSpInfo.bSwap);
+	return MCDRV_SUCCESS;
+}
+
+/****************************************************************************
+ *	McPacket_AddDNG_AA
+ *
+ *	Description:
+ *			Add Digital Noise Gate setup packet.
+ *	Arguments:
+ *			dUpdateInfo	update information
+ *	Return:
+ *			MCDRV_SUCCESS
+ *			MCDRV_ERROR_RESOURCEOVER
+ *			MCDRV_ERROR_TIMEOUT
+ *
+ ****************************************************************************/
+SINT32	McPacket_AddDNG_AA
+(
+	UINT32			dUpdateInfo
+)
+{
+	SINT32	sdRet	= MCDRV_SUCCESS;
+	MCDRV_POWER_INFO_AA	sCurPowerInfo;
+	MCDRV_POWER_INFO_AA	sPowerInfo;
+	MCDRV_POWER_UPDATE_AA	sPowerUpdate;
+	MCDRV_DNG_INFO		sDngInfo;
+	UINT8	bReg;
+
+	McResCtrl_GetDngInfo_AA(&sDngInfo);
+
+	if((dUpdateInfo & MCDRV_DNGREL_HP_UPDATE_FLAG) != (UINT32)0 || (dUpdateInfo & MCDRV_DNGATK_HP_UPDATE_FLAG) != (UINT32)0)
+	{
+		bReg	= (sDngInfo.abRelease[0]<<4)|sDngInfo.abAttack[0];
+		if(bReg == McResCtrl_GetRegVal_AA(MCDRV_PACKET_REGTYPE_B_ANA_AA, MCI_AA_DNGATRT))
+		{
+			dUpdateInfo	&= ~(MCDRV_DNGREL_HP_UPDATE_FLAG|MCDRV_DNGATK_HP_UPDATE_FLAG);
+		}
+	}
+	if((dUpdateInfo & MCDRV_DNGSW_HP_UPDATE_FLAG) != (UINT32)0
+	|| (dUpdateInfo & MCDRV_DNGTHRES_HP_UPDATE_FLAG) != (UINT32)0
+	|| (dUpdateInfo & MCDRV_DNGHOLD_HP_UPDATE_FLAG) != (UINT32)0)
+	{
+		bReg	= (sDngInfo.abThreshold[0]<<4)|(sDngInfo.abHold[0]<<1)|sDngInfo.abOnOff[0];
+		if(bReg == McResCtrl_GetRegVal_AA(MCDRV_PACKET_REGTYPE_B_ANA_AA, MCI_AA_DNGON))
+		{
+			dUpdateInfo	&= ~(MCDRV_DNGSW_HP_UPDATE_FLAG|MCDRV_DNGTHRES_HP_UPDATE_FLAG|MCDRV_DNGHOLD_HP_UPDATE_FLAG);
+		}
+	}
+	if(dUpdateInfo == (UINT32)0)
+	{
+		return sdRet;
+	}
+
+	McResCtrl_GetCurPowerInfo_AA(&sCurPowerInfo);
+	sPowerInfo	= sCurPowerInfo;
+	sPowerInfo.dDigital	&= ~MCDRV_POWINFO_DIGITAL_DP0_AA;
+	sPowerInfo.dDigital	&= ~MCDRV_POWINFO_DIGITAL_DP1_AA;
+	sPowerInfo.dDigital	&= ~MCDRV_POWINFO_DIGITAL_DP2_AA;
+	sPowerInfo.dDigital	&= ~MCDRV_POWINFO_DIGITAL_PLLRST0_AA;
+	sPowerUpdate.dDigital	= MCDRV_POWUPDATE_DIGITAL_ALL_AA;
+	if((dUpdateInfo & MCDRV_DNGREL_HP_UPDATE_FLAG) != (UINT32)0 || (dUpdateInfo & MCDRV_DNGATK_HP_UPDATE_FLAG) != (UINT32)0)
+	{
+		sPowerInfo.abAnalog[0]	&= (UINT8)~MCB_AA_PWM_VR;
+		sPowerUpdate.abAnalog[0]	= (UINT8)MCDRV_POWUPDATE_ANALOG0_ALL_AA;
+		sPowerUpdate.abAnalog[1]	=
+		sPowerUpdate.abAnalog[2]	=
+		sPowerUpdate.abAnalog[3]	=
+		sPowerUpdate.abAnalog[4]	= 0;
+	}
+	sdRet	= McPacket_AddPowerUp_AA(&sPowerInfo, &sPowerUpdate);
+	if(MCDRV_SUCCESS != sdRet)
+	{
+		return sdRet;
+	}
+	sdRet	= McDevIf_ExecutePacket_AA();
+	if(MCDRV_SUCCESS != sdRet)
+	{
+		return sdRet;
+	}
+	sdRet	= McDevIf_ExecutePacket_AA();
+	if(MCDRV_SUCCESS != sdRet)
+	{
+		return sdRet;
+	}
+
+	if((dUpdateInfo & MCDRV_DNGREL_HP_UPDATE_FLAG) != (UINT32)0 || (dUpdateInfo & MCDRV_DNGATK_HP_UPDATE_FLAG) != (UINT32)0)
+	{
+		bReg	= (sDngInfo.abRelease[0]<<4)|sDngInfo.abAttack[0];
+		McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_WRITE_AA | MCDRV_PACKET_REGTYPE_B_ANA_AA | MCI_AA_DNGATRT, bReg);
+	}
+	if((dUpdateInfo & MCDRV_DNGSW_HP_UPDATE_FLAG) != (UINT32)0
+	|| (dUpdateInfo & MCDRV_DNGTHRES_HP_UPDATE_FLAG) != (UINT32)0
+	|| (dUpdateInfo & MCDRV_DNGHOLD_HP_UPDATE_FLAG) != (UINT32)0)
+	{
+		bReg	= (sDngInfo.abThreshold[0]<<4)|(sDngInfo.abHold[0]<<1)|sDngInfo.abOnOff[0];
+		McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_WRITE_AA | MCDRV_PACKET_REGTYPE_B_ANA_AA | MCI_AA_DNGON, bReg);
+	}
+
+	/*	restore power	*/
+	return McPacket_AddPowerDown_AA(&sCurPowerInfo, &sPowerUpdate);
+}
+
+/****************************************************************************
+ *	McPacket_AddAE_AA
+ *
+ *	Description:
+ *			Add Audio Engine setup packet.
+ *	Arguments:
+ *			dUpdateInfo	update information
+ *	Return:
+ *			MCDRV_SUCCESS
+ *			MCDRV_ERROR_RESOURCEOVER
+ *			MCDRV_ERROR_TIMEOUT
+ *
+ ****************************************************************************/
+SINT32	McPacket_AddAE_AA
+(
+	UINT32	dUpdateInfo
+)
+{
+	SINT32	sdRet	= MCDRV_SUCCESS;
+	UINT8	bReg;
+	UINT8	i;
+	UINT32	dXFadeParam	= 0;
+	MCDRV_AE_INFO	sAeInfo;
+	MCDRV_PATH_INFO	sPathInfo;
+	MCDRV_POWER_INFO_AA	sPowerInfo;
+	MCDRV_POWER_UPDATE_AA	sPowerUpdate;
+
+	McResCtrl_GetPathInfo_AA(&sPathInfo);
+	McResCtrl_GetAeInfo_AA(&sAeInfo);
+
+	if(McResCtrl_IsDstUsed_AA(eMCDRV_DST_AE_AA, eMCDRV_DST_CH0_AA) == 1)
+	{/*	AE is used	*/
+		bReg	= McResCtrl_GetRegVal_AA(MCDRV_PACKET_REGTYPE_A_AA, MCI_AA_BDSP_ST);
+		if(McDevProf_IsValid(eMCDRV_FUNC_DBEX) == 1)
+		{
+			if((dUpdateInfo & MCDRV_AEUPDATE_FLAG_BEXWIDE_ONOFF) != (UINT32)0)
+			{
+				if(((sAeInfo.bOnOff & MCDRV_BEXWIDE_ON) != 0 && (bReg & MCB_AA_DBEXON) != 0)
+				|| ((sAeInfo.bOnOff & MCDRV_BEXWIDE_ON) == 0 && (bReg & MCB_AA_DBEXON) == 0))
+				{
+					dUpdateInfo	&= ~MCDRV_AEUPDATE_FLAG_BEXWIDE_ONOFF;
+				}
+			}
+		}
+		if((dUpdateInfo & MCDRV_AEUPDATE_FLAG_DRC_ONOFF) != (UINT32)0)
+		{
+			if(((sAeInfo.bOnOff & MCDRV_DRC_ON) != 0 && (bReg & MCB_AA_DRCON) != 0)
+			|| ((sAeInfo.bOnOff & MCDRV_DRC_ON) == 0 && (bReg & MCB_AA_DRCON) == 0))
+			{
+				dUpdateInfo	&= ~MCDRV_AEUPDATE_FLAG_DRC_ONOFF;
+			}
+		}
+		if((dUpdateInfo & MCDRV_AEUPDATE_FLAG_EQ5_ONOFF) != (UINT32)0)
+		{
+			if(((sAeInfo.bOnOff & MCDRV_EQ5_ON) != 0 && (bReg & MCB_AA_EQ5ON) != 0)
+			|| ((sAeInfo.bOnOff & MCDRV_EQ5_ON) == 0 && (bReg & MCB_AA_EQ5ON) == 0))
+			{
+				dUpdateInfo	&= ~MCDRV_AEUPDATE_FLAG_EQ5_ONOFF;
+			}
+		}
+		if((dUpdateInfo & MCDRV_AEUPDATE_FLAG_EQ3_ONOFF) != (UINT32)0)
+		{
+			if(((sAeInfo.bOnOff & MCDRV_EQ3_ON) != 0 && (bReg & MCB_AA_EQ3ON) != 0)
+			|| ((sAeInfo.bOnOff & MCDRV_EQ3_ON) == 0 && (bReg & MCB_AA_EQ3ON) == 0))
+			{
+				dUpdateInfo	&= ~MCDRV_AEUPDATE_FLAG_EQ3_ONOFF;
+			}
+		}
+		if(dUpdateInfo == (UINT32)0)
+		{
+			return sdRet;
+		}
+
+		/*	on/off setting or param changed	*/
+		if((dUpdateInfo & MCDRV_AEUPDATE_FLAG_EQ5) != (UINT32)0
+		|| (dUpdateInfo & MCDRV_AEUPDATE_FLAG_EQ3) != (UINT32)0
+		|| (dUpdateInfo & MCDRV_AEUPDATE_FLAG_BEX) != (UINT32)0
+		|| (dUpdateInfo & MCDRV_AEUPDATE_FLAG_WIDE) != (UINT32)0
+		|| (dUpdateInfo & MCDRV_AEUPDATE_FLAG_DRC) != (UINT32)0
+		|| (dUpdateInfo & MCDRV_AEUPDATE_FLAG_BEXWIDE_ONOFF) != (UINT32)0
+		|| (dUpdateInfo & MCDRV_AEUPDATE_FLAG_DRC_ONOFF) != (UINT32)0
+		|| (dUpdateInfo & MCDRV_AEUPDATE_FLAG_EQ5_ONOFF) != (UINT32)0
+		|| (dUpdateInfo & MCDRV_AEUPDATE_FLAG_EQ3_ONOFF) != (UINT32)0)
+		{
+			dXFadeParam	= McResCtrl_GetRegVal_AA(MCDRV_PACKET_REGTYPE_B_MIXER_AA, MCI_AA_DAC_INS);
+			dXFadeParam	<<= 8;
+			dXFadeParam	|= McResCtrl_GetRegVal_AA(MCDRV_PACKET_REGTYPE_B_MIXER_AA, MCI_AA_INS);
+			McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_WRITE_AA | MCDRV_PACKET_REGTYPE_B_MIXER_AA | (UINT32)MCI_AA_DAC_INS, 0);
+			McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_WRITE_AA | MCDRV_PACKET_REGTYPE_B_MIXER_AA | (UINT32)MCI_AA_INS, 0);
+		}
+		sdRet	= McDevIf_ExecutePacket_AA();
+		if(sdRet != MCDRV_SUCCESS)
+		{
+			return sdRet;
+		}
+
+		/*	wait xfade complete	*/
+		if(dXFadeParam != (UINT32)0)
+		{
+			McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_EVTWAIT_AA | MCDRV_EVT_INSFLG_AA | dXFadeParam, 0);
+			bReg	= McResCtrl_GetRegVal_AA(MCDRV_PACKET_REGTYPE_A_AA, MCI_AA_BDSP_ST);
+			if((dUpdateInfo & MCDRV_AEUPDATE_FLAG_EQ5) != (UINT32)0)
+			{
+				bReg	&= (UINT8)~MCB_AA_EQ5ON;
+			}
+			if((dUpdateInfo & MCDRV_AEUPDATE_FLAG_EQ3) != (UINT32)0)
+			{
+				bReg	&= (UINT8)~MCB_AA_EQ3ON;
+			}
+			McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_WRITE_AA | MCDRV_PACKET_REGTYPE_A_AA | (UINT32)MCI_AA_BDSP_ST, bReg);
+		}
+
+		bReg	= McResCtrl_GetRegVal_AA(MCDRV_PACKET_REGTYPE_A_AA, MCI_AA_BDSP_ST);
+		if((bReg & MCB_AA_BDSP_ST) == MCB_AA_BDSP_ST)
+		{
+			/*	Stop BDSP	*/
+			McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_WRITE_AA | MCDRV_PACKET_REGTYPE_A_AA | (UINT32)MCI_AA_BDSP_ST, 0);
+			/*	Reset TRAM	*/
+			McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_WRITE_AA | MCDRV_PACKET_REGTYPE_A_AA | (UINT32)MCI_AA_BDSP_RST, MCB_AA_TRAM_RST);
+			McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_WRITE_AA | MCDRV_PACKET_REGTYPE_A_AA | (UINT32)MCI_AA_BDSP_RST, 0);
+		}
+	}
+
+	if((dUpdateInfo & MCDRV_AEUPDATE_FLAG_DRC) != (UINT32)0)
+	{
+		McResCtrl_GetPowerInfo_AA(&sPowerInfo);
+		sPowerInfo.dDigital	&= ~MCDRV_POWINFO_DIGITAL_DP0_AA;
+		sPowerInfo.dDigital	&= ~MCDRV_POWINFO_DIGITAL_DP1_AA;
+		sPowerInfo.dDigital	&= ~MCDRV_POWINFO_DIGITAL_DP2_AA;
+		sPowerInfo.dDigital	&= ~MCDRV_POWINFO_DIGITAL_DPBDSP_AA;
+		sPowerInfo.dDigital	&= ~MCDRV_POWINFO_DIGITAL_PLLRST0_AA;
+		sPowerUpdate.dDigital	= MCDRV_POWUPDATE_DIGITAL_ALL_AA;
+		sPowerUpdate.abAnalog[0]	=
+		sPowerUpdate.abAnalog[1]	=
+		sPowerUpdate.abAnalog[2]	=
+		sPowerUpdate.abAnalog[3]	=
+		sPowerUpdate.abAnalog[4]	= 0;
+		sdRet	= McPacket_AddPowerUp_AA(&sPowerInfo, &sPowerUpdate);
+		if(MCDRV_SUCCESS != sdRet)
+		{
+			return sdRet;
+		}
+		sdRet	= McDevIf_ExecutePacket_AA();
+		if(MCDRV_SUCCESS != sdRet)
+		{
+			return sdRet;
+		}
+		McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_FORCE_WRITE_AA | MCDRV_PACKET_REGTYPE_A_AA | (UINT32)MCI_AA_BDSP_ADR, 0);
+		sdRet	= McDevIf_ExecutePacket_AA();
+		if(MCDRV_SUCCESS != sdRet)
+		{
+			return sdRet;
+		}
+		McDevIf_AddPacketRepeat_AA(MCDRV_PACKET_TYPE_FORCE_WRITE_AA | MCDRV_PACKET_REGTYPE_A_AA | (UINT32)MCI_AA_BDSP_WINDOW, sAeInfo.abDrc, DRC_PARAM_SIZE);
+	}
+
+	if((dUpdateInfo & MCDRV_AEUPDATE_FLAG_EQ5) != (UINT32)0)
+	{
+		for(i = 0; i < EQ5_PARAM_SIZE; i++)
+		{
+			McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_FORCE_WRITE_AA | MCDRV_PACKET_REGTYPE_B_AE_AA | (UINT32)(MCI_AA_BAND0_CEQ0+i), sAeInfo.abEq5[i]);
+		}
+	}
+	if((dUpdateInfo & MCDRV_AEUPDATE_FLAG_EQ3) != (UINT32)0)
+	{
+		if(McDevProf_IsValid(eMCDRV_FUNC_HWADJ) == 1)
+		{
+			for(i = 0; i < 15; i++)
+			{
+				McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_FORCE_WRITE_AA | MCDRV_PACKET_REGTYPE_B_AE_AA | (UINT32)(MCI_AA_BAND5_CEQ0+i), sAeInfo.abEq3[i]);
+			}
+		}
+		else
+		{
+			for(i = 0; i < EQ3_PARAM_SIZE; i++)
+			{
+				McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_FORCE_WRITE_AA | MCDRV_PACKET_REGTYPE_B_AE_AA | (UINT32)(MCI_AA_BAND5_CEQ0+i), sAeInfo.abEq3[i]);
+			}
+		}
+	}
+
+	return sdRet;
+}
+
+/****************************************************************************
+ *	McPacket_AddPDM_AA
+ *
+ *	Description:
+ *			Add PDM setup packet.
+ *	Arguments:
+ *			dUpdateInfo	update information
+ *	Return:
+ *			MCDRV_SUCCESS
+ *			MCDRV_ERROR_RESOURCEOVER
+ *			MCDRV_ERROR_TIMEOUT
+ *
+ ****************************************************************************/
+SINT32	McPacket_AddPDM_AA
+(
+	UINT32			dUpdateInfo
+)
+{
+	SINT32				sdRet		= MCDRV_SUCCESS;
+	UINT8				bReg;
+	MCDRV_POWER_INFO_AA	sPowerInfo;
+	MCDRV_POWER_UPDATE_AA	sPowerUpdate;
+	MCDRV_PDM_INFO		sPdmInfo;
+
+	McResCtrl_GetPdmInfo_AA(&sPdmInfo);
+	if((dUpdateInfo & MCDRV_PDMADJ_UPDATE_FLAG) != (UINT32)0 || (dUpdateInfo & MCDRV_PDMAGC_UPDATE_FLAG) != (UINT32)0)
+	{
+		bReg	= (sPdmInfo.bAgcOn<<2)|sPdmInfo.bAgcAdjust;
+		if(bReg == McResCtrl_GetRegVal_AA(MCDRV_PACKET_REGTYPE_B_MIXER_AA, MCI_AA_PDM_AGC))
+		{
+			dUpdateInfo &= ~(MCDRV_PDMADJ_UPDATE_FLAG|MCDRV_PDMAGC_UPDATE_FLAG);
+		}
+	}
+	if((dUpdateInfo & MCDRV_PDMMONO_UPDATE_FLAG) != (UINT32)0)
+	{
+		bReg	= McResCtrl_GetRegVal_AA(MCDRV_PACKET_REGTYPE_B_MIXER_AA, MCI_AA_PDM_START) & (UINT8)MCB_AA_PDM_MN;
+		if((sPdmInfo.bMono<<1) == bReg)
+		{
+			dUpdateInfo &= ~(MCDRV_PDMMONO_UPDATE_FLAG);
+		}
+	}
+	if((dUpdateInfo & MCDRV_PDMCLK_UPDATE_FLAG) != (UINT32)0
+	|| (dUpdateInfo & MCDRV_PDMEDGE_UPDATE_FLAG) != (UINT32)0
+	|| (dUpdateInfo & MCDRV_PDMWAIT_UPDATE_FLAG) != (UINT32)0
+	|| (dUpdateInfo & MCDRV_PDMSEL_UPDATE_FLAG) != (UINT32)0)
+	{
+		bReg	= (sPdmInfo.bPdmWait<<5) | (sPdmInfo.bPdmEdge<<4) | (sPdmInfo.bPdmSel<<2) | sPdmInfo.bClk;
+		if(bReg == McResCtrl_GetRegVal_AA(MCDRV_PACKET_REGTYPE_B_MIXER_AA, MCI_AA_PDM_STWAIT))
+		{
+			dUpdateInfo &= ~(MCDRV_PDMCLK_UPDATE_FLAG|MCDRV_PDMEDGE_UPDATE_FLAG|MCDRV_PDMWAIT_UPDATE_FLAG|MCDRV_PDMSEL_UPDATE_FLAG);
+		}
+	}
+	if(dUpdateInfo == (UINT32)0)
+	{
+		return MCDRV_SUCCESS;
+	}
+
+	McResCtrl_GetCurPowerInfo_AA(&sPowerInfo);
+	sdRet	= PowerUpDig(MCDRV_DPB_UP_AA);
+	if(sdRet != MCDRV_SUCCESS)
+	{
+		return sdRet;
+	}
+
+	if((dUpdateInfo & MCDRV_PDMADJ_UPDATE_FLAG) != (UINT32)0 || (dUpdateInfo & MCDRV_PDMAGC_UPDATE_FLAG) != (UINT32)0)
+	{
+		bReg	= (sPdmInfo.bAgcOn<<2)|sPdmInfo.bAgcAdjust;
+		if(bReg != McResCtrl_GetRegVal_AA(MCDRV_PACKET_REGTYPE_B_MIXER_AA, MCI_AA_PDM_AGC))
+		{
+			AddStopPDM();
+			sdRet	= McDevIf_ExecutePacket_AA();
+			if(MCDRV_SUCCESS != sdRet)
+			{
+				return sdRet;
+			}
+		}
+		McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_WRITE_AA | MCDRV_PACKET_REGTYPE_B_MIXER_AA | MCI_AA_PDM_AGC, bReg);
+	}
+	if((dUpdateInfo & MCDRV_PDMMONO_UPDATE_FLAG) != (UINT32)0)
+	{
+		bReg	= (McResCtrl_GetRegVal_AA(MCDRV_PACKET_REGTYPE_B_MIXER_AA, MCI_AA_PDM_START) & (UINT8)~MCB_AA_PDM_MN) | (sPdmInfo.bMono<<1);
+		if(bReg != McResCtrl_GetRegVal_AA(MCDRV_PACKET_REGTYPE_B_MIXER_AA, MCI_AA_PDM_START))
+		{
+			AddStopPDM();
+			sdRet	= McDevIf_ExecutePacket_AA();
+			if(MCDRV_SUCCESS != sdRet)
+			{
+				return sdRet;
+			}
+			McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_WRITE_AA | MCDRV_PACKET_REGTYPE_B_MIXER_AA | MCI_AA_PDM_START, (sPdmInfo.bMono<<1));
+		}
+	}
+	if((dUpdateInfo & MCDRV_PDMCLK_UPDATE_FLAG) != (UINT32)0
+	|| (dUpdateInfo & MCDRV_PDMEDGE_UPDATE_FLAG) != (UINT32)0
+	|| (dUpdateInfo & MCDRV_PDMWAIT_UPDATE_FLAG) != (UINT32)0
+	|| (dUpdateInfo & MCDRV_PDMSEL_UPDATE_FLAG) != (UINT32)0)
+	{
+		bReg	= (sPdmInfo.bPdmWait<<5) | (sPdmInfo.bPdmEdge<<4) | (sPdmInfo.bPdmSel<<2) | sPdmInfo.bClk;
+		McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_WRITE_AA | MCDRV_PACKET_REGTYPE_B_MIXER_AA | MCI_AA_PDM_STWAIT, bReg);
+	}
+
+	/*	unused path power down	*/
+	sPowerUpdate.dDigital		= MCDRV_POWUPDATE_DIGITAL_ALL_AA;
+	sPowerUpdate.abAnalog[0]	=
+	sPowerUpdate.abAnalog[1]	=
+	sPowerUpdate.abAnalog[2]	=
+	sPowerUpdate.abAnalog[3]	=
+	sPowerUpdate.abAnalog[4]	= 0;
+	sdRet	= McPacket_AddPowerDown_AA(&sPowerInfo, &sPowerUpdate);
+	if(sdRet != MCDRV_SUCCESS)
+	{
+		return sdRet;
+	}
+	return McPacket_AddStart_AA();
+}
+
+/****************************************************************************
+ *	McPacket_AddGPMode_AA
+ *
+ *	Description:
+ *			Add GP mode setup packet.
+ *	Arguments:
+ *			none
+ *	Return:
+ *			MCDRV_SUCCESS
+ *			MCDRV_ERROR_RESOURCEOVER
+ *
+ ****************************************************************************/
+SINT32	McPacket_AddGPMode_AA
+(
+	void
+)
+{
+	UINT8	abReg[2];
+	MCDRV_INIT_INFO	sInitInfo;
+	MCDRV_GP_MODE	sGPMode;
+
+	McResCtrl_GetInitInfo_AA(&sInitInfo);
+	McResCtrl_GetGPMode_AA(&sGPMode);
+
+	abReg[0]	= McResCtrl_GetRegVal_AA(MCDRV_PACKET_REGTYPE_B_BASE_AA, MCI_AA_PA_MSK);
+	abReg[1]	= McResCtrl_GetRegVal_AA(MCDRV_PACKET_REGTYPE_B_BASE_AA, MCI_AA_PA_MSK_1);
+
+	if(sInitInfo.bPad0Func == MCDRV_PAD_GPIO)
+	{
+		if(sGPMode.abGpDdr[0] == MCDRV_GPDDR_IN)
+		{
+			abReg[1]	&= (UINT8)~MCB_AA_PA0_DDR;
+		}
+		else
+		{
+			abReg[1]	|= MCB_AA_PA0_DDR;
+		}
+	}
+	if(sInitInfo.bPad1Func == MCDRV_PAD_GPIO)
+	{
+		if(sGPMode.abGpDdr[1] == MCDRV_GPDDR_IN)
+		{
+			abReg[1]	&= (UINT8)~MCB_AA_PA1_DDR;
+		}
+		else
+		{
+			abReg[1]	|= MCB_AA_PA1_DDR;
+		}
+	}
+/*
+	if(sInitInfo.bPad2Func == MCDRV_PAD_GPIO)
+	{
+		if(sGPMode.abGpDdr[2] == MCDRV_GPDDR_IN)
+		{
+			abReg[0]	&= (UINT8)~MCB_AA_PA2_DDR;
+		}
+		else
+		{
+			abReg[0]	|= MCB_AA_PA2_DDR;
+		}
+	}
+*/
+	McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_WRITE_AA | MCDRV_PACKET_REGTYPE_B_BASE_AA | MCI_AA_PA_MSK, abReg[0]);
+	McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_WRITE_AA | MCDRV_PACKET_REGTYPE_B_BASE_AA | MCI_AA_PA_MSK_1, abReg[1]);
+
+	return MCDRV_SUCCESS;
+}
+
+/****************************************************************************
+ *	McPacket_AddGPMask_AA
+ *
+ *	Description:
+ *			Add GP mask setup packet.
+ *	Arguments:
+ *			dPadNo		PAD number
+ *	Return:
+ *			MCDRV_SUCCESS
+ *			MCDRV_ERROR_RESOURCEOVER
+ *
+ ****************************************************************************/
+SINT32	McPacket_AddGPMask_AA
+(
+	UINT32	dPadNo
+)
+{
+	UINT8	bReg;
+	MCDRV_INIT_INFO	sInitInfo;
+	MCDRV_GP_MODE	sGPMode;
+	UINT8	abMask[GPIO_PAD_NUM];
+
+	McResCtrl_GetInitInfo_AA(&sInitInfo);
+	McResCtrl_GetGPMode_AA(&sGPMode);
+	McResCtrl_GetGPMask_AA(abMask);
+
+	if(dPadNo == MCDRV_GP_PAD0)
+	{
+		if(sInitInfo.bPad0Func == MCDRV_PAD_GPIO && sGPMode.abGpDdr[0] == MCDRV_GPDDR_IN)
+		{
+			bReg	= McResCtrl_GetRegVal_AA(MCDRV_PACKET_REGTYPE_B_BASE_AA, MCI_AA_PA_MSK_1);
+			if(abMask[0] == MCDRV_GPMASK_OFF)
+			{
+				bReg	&= (UINT8)~MCB_AA_PA0_MSK;
+			}
+			else
+			{
+				bReg	|= MCB_AA_PA0_MSK;
+			}
+			McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_WRITE_AA | MCDRV_PACKET_REGTYPE_B_BASE_AA | MCI_AA_PA_MSK_1, bReg);
+		}
+	}
+	else if(dPadNo == MCDRV_GP_PAD1)
+	{
+		if(sInitInfo.bPad1Func == MCDRV_PAD_GPIO && sGPMode.abGpDdr[1] == MCDRV_GPDDR_IN)
+		{
+			bReg	= McResCtrl_GetRegVal_AA(MCDRV_PACKET_REGTYPE_B_BASE_AA, MCI_AA_PA_MSK_1);
+			if(abMask[1] == MCDRV_GPMASK_OFF)
+			{
+				bReg	&= (UINT8)~MCB_AA_PA1_MSK;
+			}
+			else
+			{
+				bReg	|= MCB_AA_PA1_MSK;
+			}
+			McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_WRITE_AA | MCDRV_PACKET_REGTYPE_B_BASE_AA | MCI_AA_PA_MSK_1, bReg);
+		}
+	}
+/*
+	else if(dPadNo == MCDRV_GP_PAD2)
+	{
+		if(sInitInfo.bPad2Func == MCDRV_PAD_GPIO && sGPMode.abGpDdr[2] == MCDRV_GPDDR_IN)
+		{
+			bReg	= McResCtrl_GetRegVal_AA(MCDRV_PACKET_REGTYPE_B_BASE_AA, MCI_AA_PA_MSK);
+			if(abMask[2] == MCDRV_GPMASK_OFF)
+			{
+				bReg	&= (UINT8)~MCB_AA_PA2_MSK;
+			}
+			else
+			{
+				bReg	|= MCB_AA_PA2_MSK;
+			}
+			McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_WRITE_AA | MCDRV_PACKET_REGTYPE_B_BASE_AA | MCI_AA_PA_MSK, bReg);
+		}
+	}
+*/
+	return MCDRV_SUCCESS;
+}
+
+/****************************************************************************
+ *	McPacket_AddGPSet_AA
+ *
+ *	Description:
+ *			Add GPIO output packet.
+ *	Arguments:
+ *			bGpio		pin state setting
+ *			dPadNo		PAD number
+ *	Return:
+ *			MCDRV_SUCCESS
+ *			MCDRV_ERROR_RESOURCEOVER
+ *
+ ****************************************************************************/
+SINT32	McPacket_AddGPSet_AA
+(
+	UINT8	bGpio,
+	UINT32	dPadNo
+)
+{
+	UINT8	bReg	= McResCtrl_GetRegVal_AA(MCDRV_PACKET_REGTYPE_B_BASE_AA, MCI_AA_PA_SCU_PA);
+
+	if(dPadNo == MCDRV_GP_PAD0)
+	{
+		if(bGpio == MCDRV_GP_LOW)
+		{
+			bReg	&= (UINT8)~MCB_AA_PA_SCU_PA0;
+		}
+		else if(bGpio == MCDRV_GP_HIGH)
+		{
+			bReg	|= MCB_AA_PA_SCU_PA0;
+		}
+	}
+	else if(dPadNo == MCDRV_GP_PAD1)
+	{
+		if(bGpio == MCDRV_GP_LOW)
+		{
+			bReg	&= (UINT8)~MCB_AA_PA_SCU_PA1;
+		}
+		else if(bGpio == MCDRV_GP_HIGH)
+		{
+			bReg	|= MCB_AA_PA_SCU_PA1;
+		}
+	}
+/*
+	else if(dPadNo == MCDRV_GP_PAD2)
+	{
+		if(bGpio == MCDRV_GP_LOW)
+		{
+			bReg	&= (UINT8)~MCB_AA_PA_SCU_PA2;
+		}
+		else if(bGpio == MCDRV_GP_HIGH)
+		{
+			bReg	|= MCB_AA_PA_SCU_PA2;
+		}
+	}
+*/
+	McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_WRITE_AA | MCDRV_PACKET_REGTYPE_B_BASE_AA | MCI_AA_PA_SCU_PA, bReg);
+
+	return MCDRV_SUCCESS;
+}
+
+
+/****************************************************************************
+ *	PowerUpDig
+ *
+ *	Description:
+ *			Digital power up.
+ *	Arguments:
+ *			bDPBUp		1:DPB power up
+ *	Return:
+ *			MCDRV_SUCCESS
+ *			MCDRV_ERROR_RESOURCEOVER
+ *			MCDRV_ERROR_TIMEOUT
+ *
+ ****************************************************************************/
+static SINT32	PowerUpDig
+(
+	UINT8	bDPBUp
+)
+{
+	SINT32	sdRet	= MCDRV_SUCCESS;
+	MCDRV_POWER_INFO_AA	sPowerInfo;
+	MCDRV_POWER_UPDATE_AA	sPowerUpdate;
+
+	McResCtrl_GetCurPowerInfo_AA(&sPowerInfo);
+	sPowerInfo.dDigital	&= ~MCDRV_POWINFO_DIGITAL_DP0_AA;
+	sPowerInfo.dDigital	&= ~MCDRV_POWINFO_DIGITAL_DP1_AA;
+	sPowerInfo.dDigital	&= ~MCDRV_POWINFO_DIGITAL_DP2_AA;
+	sPowerInfo.dDigital	&= ~MCDRV_POWINFO_DIGITAL_PLLRST0_AA;
+	if(bDPBUp == MCDRV_DPB_UP_AA)
+	{
+		sPowerInfo.dDigital	&= ~MCDRV_POWINFO_DIGITAL_DPB_AA;
+	}
+	sPowerUpdate.dDigital	= MCDRV_POWUPDATE_DIGITAL_ALL_AA;
+	sdRet	= McPacket_AddPowerUp_AA(&sPowerInfo, &sPowerUpdate);
+	if(MCDRV_SUCCESS != sdRet)
+	{
+		return sdRet;
+	}
+
+	return McDevIf_ExecutePacket_AA();
+}
+
+/****************************************************************************
+ *	GetMaxWait
+ *
+ *	Description:
+ *			Get maximum wait time.
+ *	Arguments:
+ *			bRegChange	analog power management register update information
+ *	Return:
+ *			wait time
+ *
+ ****************************************************************************/
+static UINT32	GetMaxWait
+(
+	UINT8	bRegChange
+)
+{
+	UINT32	dWaitTimeMax	= 0;
+	MCDRV_INIT_INFO	sInitInfo;
+
+	McResCtrl_GetInitInfo_AA(&sInitInfo);
+
+	if((bRegChange & MCB_AA_PWM_LI) != 0)
+	{
+		if(sInitInfo.sWaitTime.dLine1Cin > dWaitTimeMax)
+		{
+			dWaitTimeMax	= sInitInfo.sWaitTime.dLine1Cin;
+		}
+	}
+	if((bRegChange & MCB_AA_PWM_MB1) != 0 || (bRegChange & MCB_AA_PWM_MC1) != 0)
+	{
+		if(sInitInfo.sWaitTime.dMic1Cin > dWaitTimeMax)
+		{
+			dWaitTimeMax	= sInitInfo.sWaitTime.dMic1Cin;
+		}
+	}
+	if((bRegChange & MCB_AA_PWM_MB2) != 0 || (bRegChange & MCB_AA_PWM_MC2) != 0)
+	{
+		if(sInitInfo.sWaitTime.dMic2Cin > dWaitTimeMax)
+		{
+			dWaitTimeMax	= sInitInfo.sWaitTime.dMic2Cin;
+		}
+	}
+	if((bRegChange & MCB_AA_PWM_MB3) != 0 || (bRegChange & MCB_AA_PWM_MC3) != 0)
+	{
+		if(sInitInfo.sWaitTime.dMic3Cin > dWaitTimeMax)
+		{
+			dWaitTimeMax	= sInitInfo.sWaitTime.dMic3Cin;
+		}
+	}
+
+	return dWaitTimeMax;
+}
+
+/*******************************/
+
+#define	MCDRV_MAX_WAIT_TIME_AA	(0x0FFFFFFFUL)
+
+static SINT32	init					(const MCDRV_INIT_INFO* psInitInfo);
+static SINT32	term					(void);
+
+static SINT32	read_reg				(MCDRV_REG_INFO* psRegInfo);
+static SINT32	write_reg				(const MCDRV_REG_INFO* psRegInfo);
+
+static SINT32	update_clock			(const MCDRV_CLOCK_INFO* psClockInfo);
+
+static SINT32	get_path				(MCDRV_PATH_INFO* psPathInfo);
+static SINT32	set_path				(const MCDRV_PATH_INFO* psPathInfo);
+
+static SINT32	get_volume				(MCDRV_VOL_INFO* psVolInfo);
+static SINT32	set_volume				(const MCDRV_VOL_INFO *psVolInfo);
+
+static SINT32	get_digitalio			(MCDRV_DIO_INFO* psDioInfo);
+static SINT32	set_digitalio			(const MCDRV_DIO_INFO* psDioInfo, UINT32 dUpdateInfo);
+
+static SINT32	get_dac					(MCDRV_DAC_INFO* psDacInfo);
+static SINT32	set_dac					(const MCDRV_DAC_INFO* psDacInfo, UINT32 dUpdateInfo);
+
+static SINT32	get_adc					(MCDRV_ADC_INFO* psAdcInfo);
+static SINT32	set_adc					(const MCDRV_ADC_INFO* psAdcInfo, UINT32 dUpdateInfo);
+
+static SINT32	get_sp					(MCDRV_SP_INFO* psSpInfo);
+static SINT32	set_sp					(const MCDRV_SP_INFO* psSpInfo);
+
+static SINT32	get_dng					(MCDRV_DNG_INFO* psDngInfo);
+static SINT32	set_dng					(const MCDRV_DNG_INFO* psDngInfo, UINT32 dUpdateInfo);
+
+static SINT32	set_ae					(const MCDRV_AE_INFO* psAeInfo, UINT32 dUpdateInfo);
+
+static SINT32	get_pdm					(MCDRV_PDM_INFO* psPdmInfo);
+static SINT32	set_pdm					(const MCDRV_PDM_INFO* psPdmInfo, UINT32 dUpdateInfo);
+
+static SINT32	config_gp				(const MCDRV_GP_MODE* psGpMode);
+static SINT32	mask_gp					(UINT8* pbMask, UINT32 dPadNo);
+static SINT32	getset_gp				(UINT8* pbGpio, UINT32 dPadNo);
+
+static SINT32	ValidateInitParam		(const MCDRV_INIT_INFO* psInitInfo);
+static SINT32	ValidateClockParam		(const MCDRV_CLOCK_INFO* psClockInfo);
+static SINT32	ValidateReadRegParam	(const MCDRV_REG_INFO* psRegInfo);
+static SINT32	ValidateWriteRegParam	(const MCDRV_REG_INFO* psRegInfo);
+static SINT32	ValidatePathParam		(const MCDRV_PATH_INFO* psPathInfo);
+static SINT32	ValidateDioParam		(const MCDRV_DIO_INFO* psDioInfo, UINT32 dUpdateInfo);
+static SINT32	CheckDIOCommon			(const MCDRV_DIO_INFO*	psDioInfo, UINT8 bPort);
+static SINT32	CheckDIODIR				(const MCDRV_DIO_INFO*	psDioInfo, UINT8 bPort, UINT8 bInterface);
+static SINT32	CheckDIODIT				(const MCDRV_DIO_INFO*	psDioInfo, UINT8 bPort, UINT8 bInterface);
+
+static SINT32	SetVol					(UINT32 dUpdate, MCDRV_VOLUPDATE_MODE_AA eMode);
+static	SINT32	PreUpdatePath			(void);
+
+static UINT8	abHwAdjParam_Thru[60] =
+{
+	0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+	0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
+};
+static UINT8	abHwAdjParam_Rec8[60] =
+{
+	0x10,0x07,0x79,0xEA,0xEB,0xAA,0xE3,0xBE,0xD3,0x9D,
+	0x80,0xF4,0x0F,0x46,0x5C,0xEE,0x26,0x04,0x1C,0x41,
+	0x2C,0x62,0x7F,0x0E,0xF0,0xB2,0x29,0x26,0xEE,0x56,
+	0x10,0x00,0xCD,0x1A,0xC6,0x9C,0xE2,0x35,0xC9,0x28,
+	0x8C,0x62,0x0F,0x74,0xD1,0x4A,0x2F,0x16,0x1D,0xCA,
+	0x36,0xD7,0x73,0xA0,0xF0,0x8A,0x61,0x9B,0x0A,0x50
+};
+static UINT8	abHwAdjParam_Rec44[60] =
+{
+	0x10,0x83,0x6A,0x3F,0x68,0x46,0x19,0x89,0xC7,0xB0,
+	0x55,0x42,0x0C,0xFF,0x7A,0xAB,0x42,0x3A,0xE6,0x76,
+	0x38,0x4F,0xAA,0xC0,0xF2,0x7D,0x1B,0x15,0x55,0x82,
+	0x10,0x69,0xF3,0x99,0x9D,0x9E,0x08,0x63,0x05,0xAA,
+	0x11,0xB8,0xFB,0x72,0x65,0x70,0x71,0x56,0xF7,0x7F,
+	0x4C,0x6D,0x22,0xCA,0x04,0x41,0x54,0xDE,0xBC,0x90
+};
+static UINT8	abHwAdjParam_Rec48[60] =
+{
+	0x10,0x58,0xEB,0x76,0xA5,0x22,0x19,0x40,0x9A,0xF9,
+	0x6A,0x26,0x0C,0xCF,0xC3,0x76,0x0C,0x38,0xE6,0xBF,
+	0x65,0x06,0x95,0xDC,0xF2,0xD7,0x51,0x13,0x4E,0xA6,
+	0x10,0x46,0x7F,0x35,0x83,0x86,0x08,0x50,0xE8,0x01,
+	0xBD,0x14,0xFB,0x7C,0x3B,0x31,0x2A,0xD4,0xF7,0x9B,
+	0x3F,0xDC,0xC7,0xC8,0x04,0x51,0x1D,0xBA,0xCC,0xCC
+};
+static UINT8	abHwAdjParam_Play8[60] =
+{
+	0x10,0x17,0xAE,0x9C,0x5E,0x76,0xE4,0x96,0x5C,0x5C,
+	0xE7,0x7E,0x0F,0x53,0x7E,0x85,0xBC,0xD0,0x1B,0x69,
+	0xA3,0xA3,0x18,0x84,0xF0,0x94,0xD2,0xDD,0xE4,0xBC,
+	0x10,0x11,0x1E,0x9A,0xB6,0xCE,0xE4,0x2A,0x1A,0xE5,
+	0x81,0x80,0x0F,0x62,0xDA,0x03,0x5A,0xB4,0x1B,0xD5,
+	0xE5,0x1A,0x7E,0x82,0xF0,0x8C,0x07,0x61,0xEE,0x80
+};
+static UINT8	abHwAdjParam_Play44[60] =
+{
+	0x10,0x6D,0x19,0x4D,0xE6,0xFA,0x19,0x7A,0xF7,0x6F,
+	0x4E,0x18,0x0D,0x04,0xAD,0x61,0x04,0xD2,0xE6,0x85,
+	0x08,0x90,0xB1,0xEA,0xF2,0x8E,0x39,0x51,0x14,0x36,
+	0x10,0xA7,0x40,0x2A,0x76,0x8E,0x0B,0xEA,0x7D,0x17,
+	0x6A,0x44,0xFE,0x5D,0xCE,0x5E,0x8C,0x5A,0xF3,0xE6,
+	0x41,0x04,0x5A,0x44,0x01,0x2A,0x33,0x5B,0x38,0x94
+};
+static UINT8	abHwAdjParam_Play48[60] =
+{
+	0x0F,0x90,0xBD,0x36,0x47,0x08,0x15,0x62,0x68,0x36,
+	0xFC,0x2A,0x09,0x20,0x8F,0xCB,0xCD,0x52,0xEA,0x9D,
+	0x97,0xC9,0x03,0xD8,0xF7,0x4E,0xB2,0xFD,0xEB,0xA8,
+	0x11,0xB9,0x89,0xB8,0x89,0x34,0x10,0x0F,0xDD,0x08,
+	0xCB,0x38,0x03,0xA3,0x87,0xD1,0x51,0x14,0xEF,0x0F,
+	0x12,0xEC,0x91,0xA2,0xFB,0x83,0xFE,0x80,0xC8,0xE2
+};
+
+/****************************************************************************
+ *	init
+ *
+ *	Description:
+ *			Initialize.
+ *	Arguments:
+ *			psInitInfo	initialize information
+ *	Return:
+ *			MCDRV_SUCCESS
+ *			MCDRV_ERROR_ARGUMENT
+ *			MCDRV_ERROR_STATE
+ *
+ ****************************************************************************/
+static	SINT32	init
+(
+	const MCDRV_INIT_INFO	*psInitInfo
+)
+{
+	SINT32	sdRet;
+	UINT8	bReg;
+
+	if(NULL == psInitInfo)
+	{
+		return MCDRV_ERROR_ARGUMENT;
+	}
+
+	if(eMCDRV_STATE_NOTINIT_AA != McResCtrl_GetState_AA())
+	{
+		return MCDRV_ERROR_STATE;
+	}
+
+	McSrv_SystemInit();
+	McSrv_Lock();
+
+	bReg	= McSrv_ReadI2C(McDevProf_GetSlaveAddr(eMCDRV_SLAVE_ADDR_DIG), (UINT32)MCI_AA_HW_ID);
+	sdRet	= McResCtrl_SetHwId_AA(bReg);
+	if(sdRet == MCDRV_SUCCESS)
+	{
+		sdRet	= ValidateInitParam(psInitInfo);
+	}
+
+	if(sdRet == MCDRV_SUCCESS)
+	{
+		McResCtrl_Init_AA(psInitInfo);
+		sdRet	= McDevIf_AllocPacketBuf_AA();
+	}
+
+	if(sdRet == MCDRV_SUCCESS)
+	{
+		sdRet	= McPacket_AddInit_AA(psInitInfo);
+	}
+
+	if(sdRet == MCDRV_SUCCESS)
+	{
+		sdRet	= McDevIf_ExecutePacket_AA();
+	}
+
+	if(sdRet == MCDRV_SUCCESS)
+	{
+		McResCtrl_UpdateState_AA(eMCDRV_STATE_READY_AA);
+	}
+	else
+	{
+		McDevIf_ReleasePacketBuf_AA();
+	}
+
+	McSrv_Unlock();
+
+	if(sdRet != MCDRV_SUCCESS)
+	{
+		McSrv_SystemTerm();
+	}
+
+	return sdRet;
+}
+
+/****************************************************************************
+ *	term
+ *
+ *	Description:
+ *			Terminate.
+ *	Arguments:
+ *			none
+ *	Return:
+ *			MCDRV_SUCCESS
+ *			MCDRV_ERROR_STATE
+ *
+ ****************************************************************************/
+static	SINT32	term
+(
+	void
+)
+{
+	SINT32	sdRet	= MCDRV_SUCCESS;
+	UINT8	bCh, bSrcIdx;
+	UINT8	abOnOff[SOURCE_BLOCK_NUM];
+	MCDRV_PATH_INFO		sPathInfo;
+	MCDRV_POWER_INFO_AA	sPowerInfo;
+	MCDRV_POWER_UPDATE_AA	sPowerUpdate;
+
+	if(eMCDRV_STATE_READY_AA != McResCtrl_GetState_AA())
+	{
+		return MCDRV_ERROR_STATE;
+	}
+
+	McSrv_Lock();
+
+	abOnOff[0]	= (MCDRV_SRC0_MIC1_OFF|MCDRV_SRC0_MIC2_OFF|MCDRV_SRC0_MIC3_OFF);
+	abOnOff[1]	= (MCDRV_SRC1_LINE1_L_OFF|MCDRV_SRC1_LINE1_R_OFF|MCDRV_SRC1_LINE1_M_OFF);
+	abOnOff[2]	= (MCDRV_SRC2_LINE2_L_OFF|MCDRV_SRC2_LINE2_R_OFF|MCDRV_SRC2_LINE2_M_OFF);
+	abOnOff[3]	= (MCDRV_SRC3_DIR0_OFF|MCDRV_SRC3_DIR1_OFF|MCDRV_SRC3_DIR2_OFF|MCDRV_SRC3_DIR2_DIRECT_OFF);
+	abOnOff[4]	= (MCDRV_SRC4_DTMF_OFF|MCDRV_SRC4_PDM_OFF|MCDRV_SRC4_ADC0_OFF|MCDRV_SRC4_ADC1_OFF);
+	abOnOff[5]	= (MCDRV_SRC5_DAC_L_OFF|MCDRV_SRC5_DAC_R_OFF|MCDRV_SRC5_DAC_M_OFF);
+	abOnOff[6]	= (MCDRV_SRC6_MIX_OFF|MCDRV_SRC6_AE_OFF|MCDRV_SRC6_CDSP_OFF|MCDRV_SRC6_CDSP_DIRECT_OFF);
+
+	for(bSrcIdx = 0; bSrcIdx < SOURCE_BLOCK_NUM; bSrcIdx++)
+	{
+		for(bCh = 0; bCh < HP_PATH_CHANNELS; bCh++)
+		{
+			sPathInfo.asHpOut[bCh].abSrcOnOff[bSrcIdx]	= abOnOff[bSrcIdx];
+		}
+		for(bCh = 0; bCh < SP_PATH_CHANNELS; bCh++)
+		{
+			sPathInfo.asSpOut[bCh].abSrcOnOff[bSrcIdx]	= abOnOff[bSrcIdx];
+		}
+		for(bCh = 0; bCh < RC_PATH_CHANNELS; bCh++)
+		{
+			sPathInfo.asRcOut[bCh].abSrcOnOff[bSrcIdx]	= abOnOff[bSrcIdx];
+		}
+		for(bCh = 0; bCh < LOUT1_PATH_CHANNELS; bCh++)
+		{
+			sPathInfo.asLout1[bCh].abSrcOnOff[bSrcIdx]	= abOnOff[bSrcIdx];
+		}
+		for(bCh = 0; bCh < LOUT2_PATH_CHANNELS; bCh++)
+		{
+			sPathInfo.asLout2[bCh].abSrcOnOff[bSrcIdx]	= abOnOff[bSrcIdx];
+		}
+		for(bCh = 0; bCh < PEAK_PATH_CHANNELS; bCh++)
+		{
+			sPathInfo.asPeak[bCh].abSrcOnOff[bSrcIdx]	= abOnOff[bSrcIdx];
+		}
+		for(bCh = 0; bCh < DIT0_PATH_CHANNELS; bCh++)
+		{
+			sPathInfo.asDit0[bCh].abSrcOnOff[bSrcIdx]	= abOnOff[bSrcIdx];
+		}
+		for(bCh = 0; bCh < DIT1_PATH_CHANNELS; bCh++)
+		{
+			sPathInfo.asDit1[bCh].abSrcOnOff[bSrcIdx]	= abOnOff[bSrcIdx];
+		}
+		for(bCh = 0; bCh < DIT2_PATH_CHANNELS; bCh++)
+		{
+			sPathInfo.asDit2[bCh].abSrcOnOff[bSrcIdx]	= abOnOff[bSrcIdx];
+		}
+		for(bCh = 0; bCh < DAC_PATH_CHANNELS; bCh++)
+		{
+			sPathInfo.asDac[bCh].abSrcOnOff[bSrcIdx]	= abOnOff[bSrcIdx];
+		}
+		for(bCh = 0; bCh < AE_PATH_CHANNELS; bCh++)
+		{
+			sPathInfo.asAe[bCh].abSrcOnOff[bSrcIdx]		= abOnOff[bSrcIdx];
+		}
+		for(bCh = 0; bCh < CDSP_PATH_CHANNELS; bCh++)
+		{
+			sPathInfo.asCdsp[bCh].abSrcOnOff[bSrcIdx]	= abOnOff[bSrcIdx];
+		}
+		for(bCh = 0; bCh < ADC0_PATH_CHANNELS; bCh++)
+		{
+			sPathInfo.asAdc0[bCh].abSrcOnOff[bSrcIdx]	= abOnOff[bSrcIdx];
+		}
+		for(bCh = 0; bCh < ADC1_PATH_CHANNELS; bCh++)
+		{
+			sPathInfo.asAdc1[bCh].abSrcOnOff[bSrcIdx]	= abOnOff[bSrcIdx];
+		}
+		for(bCh = 0; bCh < MIX_PATH_CHANNELS; bCh++)
+		{
+			sPathInfo.asMix[bCh].abSrcOnOff[bSrcIdx]	= abOnOff[bSrcIdx];
+		}
+		for(bCh = 0; bCh < BIAS_PATH_CHANNELS; bCh++)
+		{
+			sPathInfo.asBias[bCh].abSrcOnOff[bSrcIdx]	= abOnOff[bSrcIdx];
+		}
+	}
+	sdRet	= set_path(&sPathInfo);
+	if(sdRet == MCDRV_SUCCESS)
+	{
+		sPowerInfo.dDigital			= (MCDRV_POWINFO_DIGITAL_DP0_AA
+									  |MCDRV_POWINFO_DIGITAL_DP1_AA
+									  |MCDRV_POWINFO_DIGITAL_DP2_AA
+									  |MCDRV_POWINFO_DIGITAL_DPB_AA
+									  |MCDRV_POWINFO_DIGITAL_DPDI0_AA
+									  |MCDRV_POWINFO_DIGITAL_DPDI1_AA
+									  |MCDRV_POWINFO_DIGITAL_DPDI2_AA
+									  |MCDRV_POWINFO_DIGITAL_DPPDM_AA
+									  |MCDRV_POWINFO_DIGITAL_DPBDSP_AA
+									  |MCDRV_POWINFO_DIGITAL_DPADIF_AA
+									  |MCDRV_POWINFO_DIGITAL_PLLRST0_AA);
+		sPowerInfo.abAnalog[0]		=
+		sPowerInfo.abAnalog[1]		=
+		sPowerInfo.abAnalog[2]		=
+		sPowerInfo.abAnalog[3]		=
+		sPowerInfo.abAnalog[4]		= (UINT8)0xFF;
+		sPowerUpdate.dDigital		= MCDRV_POWUPDATE_DIGITAL_ALL_AA;
+		sPowerUpdate.abAnalog[0]	= (UINT8)MCDRV_POWUPDATE_ANALOG0_ALL_AA;
+		sPowerUpdate.abAnalog[1]	= (UINT8)MCDRV_POWUPDATE_ANALOG1_ALL_AA;
+		sPowerUpdate.abAnalog[2]	= (UINT8)MCDRV_POWUPDATE_ANALOG2_ALL_AA;
+		sPowerUpdate.abAnalog[3]	= (UINT8)MCDRV_POWUPDATE_ANALOG3_ALL_AA;
+		sPowerUpdate.abAnalog[4]	= (UINT8)MCDRV_POWUPDATE_ANALOG4_ALL_AA;
+		sdRet	= McPacket_AddPowerDown_AA(&sPowerInfo, &sPowerUpdate);
+	}
+	if(sdRet == MCDRV_SUCCESS)
+	{
+		sdRet	= McDevIf_ExecutePacket_AA();
+	}
+
+	McDevIf_ReleasePacketBuf_AA();
+
+	McResCtrl_UpdateState_AA(eMCDRV_STATE_NOTINIT_AA);
+
+	McSrv_Unlock();
+
+	McSrv_SystemTerm();
+
+	return sdRet;
+}
+
+/****************************************************************************
+ *	read_reg
+ *
+ *	Description:
+ *			read register.
+ *	Arguments:
+ *			psRegInfo	register information
+ *	Return:
+ *			MCDRV_SUCCESS
+ *			MCDRV_ERROR_STATE
+ *			MCDRV_ERROR_ARGUMENT
+ *
+ ****************************************************************************/
+static	SINT32	read_reg
+(
+	MCDRV_REG_INFO*	psRegInfo
+)
+{
+	SINT32	sdRet	= MCDRV_SUCCESS;
+	UINT8	bSlaveAddr;
+	UINT8	bAddr;
+	UINT8	abData[2];
+	MCDRV_POWER_INFO_AA	sPowerInfo;
+	MCDRV_POWER_INFO_AA	sCurPowerInfo;
+	MCDRV_POWER_UPDATE_AA	sPowerUpdate;
+
+	if(NULL == psRegInfo)
+	{
+		return MCDRV_ERROR_ARGUMENT;
+	}
+
+	if(eMCDRV_STATE_NOTINIT_AA == McResCtrl_GetState_AA())
+	{
+		return MCDRV_ERROR_STATE;
+	}
+
+	sdRet	= ValidateReadRegParam(psRegInfo);
+	if(sdRet != MCDRV_SUCCESS)
+	{
+		return sdRet;
+	}
+
+	/*	get current power info	*/
+	McResCtrl_GetCurPowerInfo_AA(&sCurPowerInfo);
+
+	/*	power up	*/
+	McResCtrl_GetPowerInfoRegAccess_AA(psRegInfo, &sPowerInfo);
+	sPowerUpdate.dDigital		= MCDRV_POWUPDATE_DIGITAL_ALL_AA;
+	sPowerUpdate.abAnalog[0]	= (UINT8)MCDRV_POWUPDATE_ANALOG0_ALL_AA;
+	sPowerUpdate.abAnalog[1]	= (UINT8)MCDRV_POWUPDATE_ANALOG1_ALL_AA;
+	sPowerUpdate.abAnalog[2]	= (UINT8)MCDRV_POWUPDATE_ANALOG2_ALL_AA;
+	sPowerUpdate.abAnalog[3]	= (UINT8)MCDRV_POWUPDATE_ANALOG3_ALL_AA;
+	sPowerUpdate.abAnalog[4]	= (UINT8)MCDRV_POWUPDATE_ANALOG4_ALL_AA;
+	sdRet	= McPacket_AddPowerUp_AA(&sPowerInfo, &sPowerUpdate);
+	if(MCDRV_SUCCESS != sdRet)
+	{
+		return sdRet;
+	}
+	sdRet	= McDevIf_ExecutePacket_AA();
+	if(MCDRV_SUCCESS != sdRet)
+	{
+		return sdRet;
+	}
+
+	bAddr	= psRegInfo->bAddress;
+
+	if(psRegInfo->bRegType == MCDRV_REGTYPE_A)
+	{
+		bSlaveAddr	= McDevProf_GetSlaveAddr(eMCDRV_SLAVE_ADDR_DIG);
+	}
+	else
+	{
+		switch(psRegInfo->bRegType)
+		{
+		case	MCDRV_REGTYPE_B_BASE:
+			bSlaveAddr	= McDevProf_GetSlaveAddr(eMCDRV_SLAVE_ADDR_DIG);
+			abData[0]	= MCI_AA_BASE_ADR<<1;
+			abData[1]	= bAddr;
+			McSrv_WriteI2C(bSlaveAddr, abData, 2);
+			bAddr	= MCI_AA_BASE_WINDOW;
+			break;
+
+		case	MCDRV_REGTYPE_B_MIXER:
+			bSlaveAddr	= McDevProf_GetSlaveAddr(eMCDRV_SLAVE_ADDR_DIG);
+			abData[0]	= MCI_AA_MIX_ADR<<1;
+			abData[1]	= bAddr;
+			McSrv_WriteI2C(bSlaveAddr, abData, 2);
+			bAddr	= MCI_AA_MIX_WINDOW;
+			break;
+
+		case	MCDRV_REGTYPE_B_AE:
+			bSlaveAddr	= McDevProf_GetSlaveAddr(eMCDRV_SLAVE_ADDR_DIG);
+			abData[0]	= MCI_AA_AE_ADR<<1;
+			abData[1]	= bAddr;
+			McSrv_WriteI2C(bSlaveAddr, abData, 2);
+			bAddr	= MCI_AA_AE_WINDOW;
+			break;
+
+		case	MCDRV_REGTYPE_B_CDSP:
+			bSlaveAddr	= McDevProf_GetSlaveAddr(eMCDRV_SLAVE_ADDR_DIG);
+			abData[0]	= MCI_AA_CDSP_ADR<<1;
+			abData[1]	= bAddr;
+			McSrv_WriteI2C(bSlaveAddr, abData, 2);
+			bAddr	= MCI_AA_CDSP_WINDOW;
+			break;
+
+		case	MCDRV_REGTYPE_B_CODEC:
+			bSlaveAddr	= McDevProf_GetSlaveAddr(eMCDRV_SLAVE_ADDR_DIG);
+			abData[0]	= MCI_AA_CD_ADR<<1;
+			abData[1]	= bAddr;
+			McSrv_WriteI2C(bSlaveAddr, abData, 2);
+			bAddr	= MCI_AA_CD_WINDOW;
+			break;
+
+		case	MCDRV_REGTYPE_B_ANALOG:
+			bSlaveAddr	= McDevProf_GetSlaveAddr(eMCDRV_SLAVE_ADDR_ANA);
+			abData[0]	= MCI_AA_ANA_ADR<<1;
+			abData[1]	= bAddr;
+			McSrv_WriteI2C(bSlaveAddr, abData, 2);
+			bAddr	= MCI_AA_ANA_WINDOW;
+			break;
+
+		default:
+			return MCDRV_ERROR_ARGUMENT;
+		}
+	}
+
+	/*	read register	*/
+	psRegInfo->bData	= McSrv_ReadI2C(bSlaveAddr, bAddr);
+
+	/*	restore power	*/
+	sdRet	= McPacket_AddPowerDown_AA(&sCurPowerInfo, &sPowerUpdate);
+	if(MCDRV_SUCCESS != sdRet)
+	{
+		return sdRet;
+	}
+	return McDevIf_ExecutePacket_AA();
+}
+
+/****************************************************************************
+ *	write_reg
+ *
+ *	Description:
+ *			Write register.
+ *	Arguments:
+ *			psWR	register information
+ *	Return:
+ *			MCDRV_SUCCESS
+ *			MCDRV_ERROR_STATE
+ *			MCDRV_ERROR_ARGUMENT
+ *			MCDRV_ERROR_RESOURCEOVER
+ *
+ ****************************************************************************/
+static	SINT32	write_reg
+(
+	const MCDRV_REG_INFO*	psRegInfo
+)
+{
+	SINT32	sdRet	= MCDRV_SUCCESS;
+	MCDRV_POWER_INFO_AA	sPowerInfo;
+	MCDRV_POWER_INFO_AA	sCurPowerInfo;
+	MCDRV_POWER_UPDATE_AA	sPowerUpdate;
+
+	if(NULL == psRegInfo)
+	{
+		return MCDRV_ERROR_ARGUMENT;
+	}
+
+	if(eMCDRV_STATE_NOTINIT_AA == McResCtrl_GetState_AA())
+	{
+		return MCDRV_ERROR_STATE;
+	}
+
+	sdRet	= ValidateWriteRegParam(psRegInfo);
+	if(sdRet != MCDRV_SUCCESS)
+	{
+		return sdRet;
+	}
+
+	/*	get current power info	*/
+	McResCtrl_GetCurPowerInfo_AA(&sCurPowerInfo);
+
+	/*	power up	*/
+	McResCtrl_GetPowerInfoRegAccess_AA(psRegInfo, &sPowerInfo);
+	sPowerUpdate.dDigital		= MCDRV_POWUPDATE_DIGITAL_ALL_AA;
+	sPowerUpdate.abAnalog[0]	= (UINT8)MCDRV_POWUPDATE_ANALOG0_ALL_AA;
+	sPowerUpdate.abAnalog[1]	= (UINT8)MCDRV_POWUPDATE_ANALOG1_ALL_AA;
+	sPowerUpdate.abAnalog[2]	= (UINT8)MCDRV_POWUPDATE_ANALOG2_ALL_AA;
+	sPowerUpdate.abAnalog[3]	= (UINT8)MCDRV_POWUPDATE_ANALOG3_ALL_AA;
+	sPowerUpdate.abAnalog[4]	= (UINT8)MCDRV_POWUPDATE_ANALOG4_ALL_AA;
+	sdRet	= McPacket_AddPowerUp_AA(&sPowerInfo, &sPowerUpdate);
+	if(MCDRV_SUCCESS != sdRet)
+	{
+		return sdRet;
+	}
+
+	switch(psRegInfo->bRegType)
+	{
+	case	MCDRV_REGTYPE_A:
+		McDevIf_AddPacket_AA((MCDRV_PACKET_TYPE_FORCE_WRITE_AA | MCDRV_PACKET_REGTYPE_A_AA | psRegInfo->bAddress), psRegInfo->bData);
+		break;
+
+	case	MCDRV_REGTYPE_B_BASE:
+		McDevIf_AddPacket_AA((MCDRV_PACKET_TYPE_FORCE_WRITE_AA | MCDRV_PACKET_REGTYPE_B_BASE_AA | psRegInfo->bAddress), psRegInfo->bData);
+		break;
+
+	case	MCDRV_REGTYPE_B_MIXER:
+		McDevIf_AddPacket_AA((MCDRV_PACKET_TYPE_FORCE_WRITE_AA | MCDRV_PACKET_REGTYPE_B_MIXER_AA | psRegInfo->bAddress), psRegInfo->bData);
+		break;
+
+	case	MCDRV_REGTYPE_B_AE:
+		McDevIf_AddPacket_AA((MCDRV_PACKET_TYPE_FORCE_WRITE_AA | MCDRV_PACKET_REGTYPE_B_AE_AA | psRegInfo->bAddress), psRegInfo->bData);
+		break;
+
+	case	MCDRV_REGTYPE_B_CDSP:
+		McDevIf_AddPacket_AA((MCDRV_PACKET_TYPE_FORCE_WRITE_AA | MCDRV_PACKET_REGTYPE_B_CDSP_AA | psRegInfo->bAddress), psRegInfo->bData);
+		break;
+
+	case	MCDRV_REGTYPE_B_CODEC:
+		McDevIf_AddPacket_AA((MCDRV_PACKET_TYPE_FORCE_WRITE_AA | MCDRV_PACKET_REGTYPE_B_CODEC_AA | psRegInfo->bAddress), psRegInfo->bData);
+		break;
+
+	case	MCDRV_REGTYPE_B_ANALOG:
+		McDevIf_AddPacket_AA((MCDRV_PACKET_TYPE_FORCE_WRITE_AA | MCDRV_PACKET_REGTYPE_B_ANA_AA | psRegInfo->bAddress), psRegInfo->bData);
+		break;
+
+	default:
+		return MCDRV_ERROR_ARGUMENT;
+	}
+
+	sdRet	= McDevIf_ExecutePacket_AA();
+	if(MCDRV_SUCCESS != sdRet)
+	{
+		return sdRet;
+	}
+
+	/*	restore power	*/
+	if(psRegInfo->bRegType == MCDRV_REGTYPE_B_BASE)
+	{
+		if(psRegInfo->bAddress == MCI_AA_PWM_DIGITAL)
+		{
+			if((psRegInfo->bData & MCB_AA_PWM_DP0) == 0)
+			{
+				sCurPowerInfo.dDigital &= ~MCDRV_POWINFO_DIGITAL_DP0_AA;
+			}
+			if((psRegInfo->bData & MCB_AA_PWM_DP1) == 0)
+			{
+				sCurPowerInfo.dDigital &= ~MCDRV_POWINFO_DIGITAL_DP1_AA;
+			}
+			if((psRegInfo->bData & MCB_AA_PWM_DP2) == 0)
+			{
+				sCurPowerInfo.dDigital &= ~MCDRV_POWINFO_DIGITAL_DP2_AA;
+			}
+		}
+		else if(psRegInfo->bAddress == MCI_AA_PWM_DIGITAL_1)
+		{
+			if((psRegInfo->bData & MCB_AA_PWM_DPB) == 0)
+			{
+				sCurPowerInfo.dDigital &= ~MCDRV_POWINFO_DIGITAL_DPB_AA;
+			}
+			if((psRegInfo->bData & MCB_AA_PWM_DPDI0) == 0)
+			{
+				sCurPowerInfo.dDigital &= ~MCDRV_POWINFO_DIGITAL_DPDI0_AA;
+			}
+			if((psRegInfo->bData & MCB_AA_PWM_DPDI1) == 0)
+			{
+				sCurPowerInfo.dDigital &= ~MCDRV_POWINFO_DIGITAL_DPDI1_AA;
+			}
+			if((psRegInfo->bData & MCB_AA_PWM_DPDI2) == 0)
+			{
+				sCurPowerInfo.dDigital &= ~MCDRV_POWINFO_DIGITAL_DPDI2_AA;
+			}
+			if((psRegInfo->bData & MCB_AA_PWM_DPPDM) == 0)
+			{
+				sCurPowerInfo.dDigital &= ~MCDRV_POWINFO_DIGITAL_DPPDM_AA;
+			}
+		}
+		else if(psRegInfo->bAddress == MCI_AA_PWM_DIGITAL_BDSP)
+		{
+			if((psRegInfo->bData & MCB_AA_PWM_DPBDSP) == 0)
+			{
+				sCurPowerInfo.dDigital &= ~MCDRV_POWINFO_DIGITAL_DPBDSP_AA;
+			}
+		}
+		else if(psRegInfo->bAddress == MCI_AA_PLL_RST)
+		{
+			if((psRegInfo->bData & MCB_AA_PLLRST0) == 0)
+			{
+				sCurPowerInfo.dDigital &= ~MCDRV_POWINFO_DIGITAL_PLLRST0_AA;
+			}
+		}
+	}
+	else if(psRegInfo->bRegType == MCDRV_REGTYPE_B_CODEC)
+	{
+		if(psRegInfo->bAddress == MCI_AA_DPADIF)
+		{
+			if((psRegInfo->bData & MCB_AA_DPADIF) == 0)
+			{
+				sCurPowerInfo.dDigital &= ~MCDRV_POWINFO_DIGITAL_DPADIF_AA;
+			}
+		}
+	}
+	else if(psRegInfo->bRegType == MCDRV_REGTYPE_B_ANALOG)
+	{
+		if(psRegInfo->bAddress == MCI_AA_PWM_ANALOG_0)
+		{
+			sCurPowerInfo.abAnalog[0]	= psRegInfo->bData;
+		}
+		else if(psRegInfo->bAddress == MCI_AA_PWM_ANALOG_1)
+		{
+			sCurPowerInfo.abAnalog[1]	= psRegInfo->bData;
+		}
+		else if(psRegInfo->bAddress == MCI_AA_PWM_ANALOG_2)
+		{
+			sCurPowerInfo.abAnalog[2]	= psRegInfo->bData;
+		}
+		else if(psRegInfo->bAddress == MCI_AA_PWM_ANALOG_3)
+		{
+			sCurPowerInfo.abAnalog[3]	= psRegInfo->bData;
+		}
+		else if(psRegInfo->bAddress == MCI_AA_PWM_ANALOG_4)
+		{
+			sCurPowerInfo.abAnalog[4]	= psRegInfo->bData;
+		}
+	}
+
+	sdRet	= McPacket_AddPowerDown_AA(&sCurPowerInfo, &sPowerUpdate);
+	if(MCDRV_SUCCESS != sdRet)
+	{
+		return sdRet;
+	}
+	return McDevIf_ExecutePacket_AA();
+}
+
+/****************************************************************************
+ *	update_clock
+ *
+ *	Description:
+ *			Update clock info.
+ *	Arguments:
+ *			psClockInfo	clock info
+ *	Return:
+ *			MCDRV_SUCCESS
+ *			MCDRV_ERROR_ARGUMENT
+ *			MCDRV_ERROR_STATE
+ *
+ ****************************************************************************/
+static	SINT32	update_clock
+(
+	const MCDRV_CLOCK_INFO*	psClockInfo
+)
+{
+	SINT32			sdRet	= MCDRV_SUCCESS;
+	MCDRV_STATE_AA		eState	= McResCtrl_GetState_AA();
+	MCDRV_INIT_INFO	sInitInfo;
+
+	if(NULL == psClockInfo)
+	{
+		return MCDRV_ERROR_ARGUMENT;
+	}
+
+	if(eMCDRV_STATE_NOTINIT_AA == eState)
+	{
+		return MCDRV_ERROR_STATE;
+	}
+
+	McResCtrl_GetInitInfo_AA(&sInitInfo);
+	if((sInitInfo.bPowerMode & MCDRV_POWMODE_CLKON) != 0)
+	{
+		return MCDRV_ERROR_ARGUMENT;
+	}
+
+	sdRet	= ValidateClockParam(psClockInfo);
+	if(MCDRV_SUCCESS != sdRet)
+	{
+		return sdRet;
+	}
+
+	McResCtrl_SetClockInfo_AA(psClockInfo);
+	return sdRet;
+}
+
+/****************************************************************************
+ *	get_path
+ *
+ *	Description:
+ *			Get current path setting.
+ *	Arguments:
+ *			psPathInfo	path information
+ *	Return:
+ *			MCDRV_SUCCESS
+ *			MCDRV_ERROR_STATE
+ *
+ ****************************************************************************/
+static	SINT32	get_path
+(
+	MCDRV_PATH_INFO*	psPathInfo
+)
+{
+	if(NULL == psPathInfo)
+	{
+		return MCDRV_ERROR_ARGUMENT;
+	}
+
+	if(eMCDRV_STATE_NOTINIT_AA == McResCtrl_GetState_AA())
+	{
+		return MCDRV_ERROR_STATE;
+	}
+
+	McResCtrl_GetPathInfoVirtual_AA(psPathInfo);
+
+	return MCDRV_SUCCESS;
+}
+
+/****************************************************************************
+ *	set_path
+ *
+ *	Description:
+ *			Set path.
+ *	Arguments:
+ *			psPathInfo	path information
+ *	Return:
+ *			MCDRV_SUCCESS
+ *			MCDRV_ERROR_ARGUMENT
+ *			MCDRV_ERROR_STATE
+ *
+ ****************************************************************************/
+static	SINT32	set_path
+(
+	const MCDRV_PATH_INFO*	psPathInfo
+)
+{
+	SINT32			sdRet	= MCDRV_SUCCESS;
+	UINT32			dXFadeParam	= 0;
+	MCDRV_STATE_AA		eState	= McResCtrl_GetState_AA();
+	MCDRV_POWER_INFO_AA	sPowerInfo;
+	MCDRV_POWER_UPDATE_AA	sPowerUpdate;
+	MCDRV_HWADJ			eHwAdj;
+	UINT8				*pbHwAdjParam;
+	UINT8				bReg;
+	UINT8				i;
+
+	if(NULL == psPathInfo)
+	{
+		return MCDRV_ERROR_ARGUMENT;
+	}
+
+	if(eMCDRV_STATE_NOTINIT_AA == eState)
+	{
+		return MCDRV_ERROR_STATE;
+	}
+
+	sdRet	= ValidatePathParam(psPathInfo);
+	if(MCDRV_SUCCESS != sdRet)
+	{
+		return sdRet;
+	}
+
+	McResCtrl_SetPathInfo_AA(psPathInfo);
+
+	/*	unused analog out volume mute	*/
+	sdRet	= SetVol(MCDRV_VOLUPDATE_ANAOUT_ALL_AA, eMCDRV_VOLUPDATE_MUTE_AA);
+	if(MCDRV_SUCCESS != sdRet)
+	{
+		return sdRet;
+	}
+
+	/*	DAC/DIT* mute	*/
+	sdRet	= PreUpdatePath();
+	if(MCDRV_SUCCESS != sdRet)
+	{
+		return sdRet;
+	}
+
+	/*	unused volume mute	*/
+	sdRet	= SetVol(MCDRV_VOLUPDATE_ALL_AA&~MCDRV_VOLUPDATE_ANAOUT_ALL_AA, eMCDRV_VOLUPDATE_MUTE_AA);
+	if(MCDRV_SUCCESS != sdRet)
+	{
+		return sdRet;
+	}
+
+	/*	stop unused path	*/
+	sdRet	= McPacket_AddStop_AA();
+	if(MCDRV_SUCCESS != sdRet)
+	{
+		return sdRet;
+	}
+	sdRet	= McDevIf_ExecutePacket_AA();
+	if(MCDRV_SUCCESS != sdRet)
+	{
+		return sdRet;
+	}
+
+	if(McDevProf_IsValid(eMCDRV_FUNC_HWADJ) == 1)
+	{
+		eHwAdj = McResCtrl_ConfigHwAdj_AA();
+
+		if(eHwAdj != eMCDRV_HWADJ_NOCHANGE)
+		{
+			switch(eHwAdj)
+			{
+			case	eMCDRV_HWADJ_REC8:
+				pbHwAdjParam = abHwAdjParam_Rec8;
+				break;
+			case	eMCDRV_HWADJ_REC44:
+				pbHwAdjParam = abHwAdjParam_Rec44;
+				break;
+			case	eMCDRV_HWADJ_REC48:
+				pbHwAdjParam = abHwAdjParam_Rec48;
+				break;
+			case	eMCDRV_HWADJ_PLAY8:
+				pbHwAdjParam = abHwAdjParam_Play8;
+				break;
+			case	eMCDRV_HWADJ_PLAY44:
+				pbHwAdjParam = abHwAdjParam_Play44;
+				break;
+			case	eMCDRV_HWADJ_PLAY48:
+				pbHwAdjParam = abHwAdjParam_Play48;
+				break;
+			default:
+				pbHwAdjParam = abHwAdjParam_Thru;
+				break;
+			}
+
+			dXFadeParam	= McResCtrl_GetRegVal_AA(MCDRV_PACKET_REGTYPE_B_MIXER_AA, MCI_AA_DAC_INS);
+			dXFadeParam	<<= 8;
+			dXFadeParam	|= McResCtrl_GetRegVal_AA(MCDRV_PACKET_REGTYPE_B_MIXER_AA, MCI_AA_INS);
+			McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_WRITE_AA | MCDRV_PACKET_REGTYPE_B_MIXER_AA | (UINT32)MCI_AA_DAC_INS, 0);
+			McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_WRITE_AA | MCDRV_PACKET_REGTYPE_B_MIXER_AA | (UINT32)MCI_AA_INS, 0);
+			sdRet	= McDevIf_ExecutePacket_AA();
+			if(sdRet != MCDRV_SUCCESS)
+			{
+				return sdRet;
+			}
+
+			/*	wait xfade complete	*/
+			if(dXFadeParam != (UINT32)0)
+			{
+				McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_EVTWAIT_AA | MCDRV_EVT_INSFLG_AA | dXFadeParam, 0);
+				bReg	= McResCtrl_GetRegVal_AA(MCDRV_PACKET_REGTYPE_A_AA, MCI_AA_BDSP_ST);
+				bReg	&= (UINT8)~MCB_AA_EQ3ON;
+				McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_WRITE_AA | MCDRV_PACKET_REGTYPE_A_AA | (UINT32)MCI_AA_BDSP_ST, bReg);
+			}
+
+			for(i = 0; i < 60; i++)
+			{
+				McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_FORCE_WRITE_AA | MCDRV_PACKET_REGTYPE_B_AE_AA | (UINT32)(MCI_AA_BAND6H_CEQ0+i), pbHwAdjParam[i]);
+			}
+
+			sdRet	= McDevIf_ExecutePacket_AA();
+			if(MCDRV_SUCCESS != sdRet)
+			{
+				return sdRet;
+			}
+		}
+	}
+
+	McResCtrl_GetPowerInfo_AA(&sPowerInfo);
+
+	/*	used path power up	*/
+	sPowerUpdate.dDigital		= MCDRV_POWUPDATE_DIGITAL_ALL_AA;
+	sPowerUpdate.abAnalog[0]	= (UINT8)MCDRV_POWUPDATE_ANALOG0_ALL_AA;
+	sPowerUpdate.abAnalog[1]	= (UINT8)MCDRV_POWUPDATE_ANALOG1_ALL_AA;
+	sPowerUpdate.abAnalog[2]	= (UINT8)MCDRV_POWUPDATE_ANALOG2_ALL_AA;
+	sPowerUpdate.abAnalog[3]	= (UINT8)MCDRV_POWUPDATE_ANALOG3_ALL_AA;
+	sPowerUpdate.abAnalog[4]	= (UINT8)MCDRV_POWUPDATE_ANALOG4_ALL_AA;
+	sdRet	= McPacket_AddPowerUp_AA(&sPowerInfo, &sPowerUpdate);
+	if(MCDRV_SUCCESS != sdRet)
+	{
+		return sdRet;
+	}
+	sdRet	= McDevIf_ExecutePacket_AA();
+	if(MCDRV_SUCCESS != sdRet)
+	{
+		return sdRet;
+	}
+
+	/*	set digital mixer	*/
+	sdRet	= McPacket_AddPathSet_AA();
+	if(MCDRV_SUCCESS != sdRet)
+	{
+		return sdRet;
+	}
+	sdRet	= McDevIf_ExecutePacket_AA();
+	if(MCDRV_SUCCESS != sdRet)
+	{
+		return sdRet;
+	}
+
+	/*	set analog mixer	*/
+	sdRet	= McPacket_AddMixSet_AA();
+	if(MCDRV_SUCCESS != sdRet)
+	{
+		return sdRet;
+	}
+	sdRet	= McDevIf_ExecutePacket_AA();
+	if(MCDRV_SUCCESS != sdRet)
+	{
+		return sdRet;
+	}
+
+	/*	unused path power down	*/
+	sPowerUpdate.dDigital		= MCDRV_POWUPDATE_DIGITAL_ALL_AA;
+	if(McDevProf_IsValid(eMCDRV_FUNC_HWADJ) == 1)
+	{
+		sPowerUpdate.abAnalog[0]	= 0;
+		sPowerUpdate.abAnalog[1]	= 0xCF;
+	}
+	else
+	{
+		sPowerUpdate.abAnalog[0]	= (UINT8)MCDRV_POWUPDATE_ANALOG0_ALL_AA;
+		sPowerUpdate.abAnalog[1]	= (UINT8)MCDRV_POWUPDATE_ANALOG1_ALL_AA;
+	}
+	sPowerUpdate.abAnalog[2]	= (UINT8)MCDRV_POWUPDATE_ANALOG2_ALL_AA;
+	sPowerUpdate.abAnalog[3]	= (UINT8)MCDRV_POWUPDATE_ANALOG3_ALL_AA;
+	sPowerUpdate.abAnalog[4]	= (UINT8)MCDRV_POWUPDATE_ANALOG4_ALL_AA;
+	sdRet	= McPacket_AddPowerDown_AA(&sPowerInfo, &sPowerUpdate);
+	if(MCDRV_SUCCESS != sdRet)
+	{
+		return sdRet;
+	}
+	sdRet	= McDevIf_ExecutePacket_AA();
+	if(MCDRV_SUCCESS != sdRet)
+	{
+		return sdRet;
+	}
+
+	/*	start	*/
+	sdRet	= McPacket_AddStart_AA();
+	if(MCDRV_SUCCESS != sdRet)
+	{
+		return sdRet;
+	}
+	sdRet	= McDevIf_ExecutePacket_AA();
+	if(MCDRV_SUCCESS != sdRet)
+	{
+		return sdRet;
+	}
+
+	/*	set volume	*/
+	sdRet	= SetVol(MCDRV_VOLUPDATE_ALL_AA&~MCDRV_VOLUPDATE_ANAOUT_ALL_AA, eMCDRV_VOLUPDATE_ALL_AA);
+	if(MCDRV_SUCCESS != sdRet)
+	{
+		return sdRet;
+	}
+	return SetVol(MCDRV_VOLUPDATE_ANAOUT_ALL_AA, eMCDRV_VOLUPDATE_ALL_AA);
+}
+
+/****************************************************************************
+ *	get_volume
+ *
+ *	Description:
+ *			Get current volume setting.
+ *	Arguments:
+ *			psVolInfo	volume information
+ *	Return:
+ *			MCDRV_SUCCESS
+ *			MCDRV_ERROR_ARGUMENT
+ *
+ ****************************************************************************/
+static	SINT32	get_volume
+(
+	MCDRV_VOL_INFO*	psVolInfo
+)
+{
+	if(NULL == psVolInfo)
+	{
+		return MCDRV_ERROR_ARGUMENT;
+	}
+
+	if(eMCDRV_STATE_NOTINIT_AA == McResCtrl_GetState_AA())
+	{
+		return MCDRV_ERROR_STATE;
+	}
+
+	McResCtrl_GetVolInfo_AA(psVolInfo);
+
+	return MCDRV_SUCCESS;
+}
+
+/****************************************************************************
+ *	set_volume
+ *
+ *	Description:
+ *			Set volume.
+ *	Arguments:
+ *			psVolInfo	volume update information
+ *	Return:
+ *			MCDRV_SUCCESS
+ *			MCDRV_ERROR_ARGUMENT
+ *
+ ****************************************************************************/
+static	SINT32	set_volume
+(
+	const MCDRV_VOL_INFO*	psVolInfo
+)
+{
+	MCDRV_STATE_AA	eState	= McResCtrl_GetState_AA();
+
+	if(NULL == psVolInfo)
+	{
+		return MCDRV_ERROR_ARGUMENT;
+	}
+
+	if(eMCDRV_STATE_NOTINIT_AA == eState)
+	{
+		return MCDRV_ERROR_STATE;
+	}
+
+	McResCtrl_SetVolInfo_AA(psVolInfo);
+
+	return SetVol(MCDRV_VOLUPDATE_ALL_AA, eMCDRV_VOLUPDATE_ALL_AA);
+}
+
+/****************************************************************************
+ *	get_digitalio
+ *
+ *	Description:
+ *			Get current digital IO setting.
+ *	Arguments:
+ *			psDioInfo	digital IO information
+ *	Return:
+ *			MCDRV_SUCCESS
+ *			MCDRV_ERROR_STATE
+ *
+ ****************************************************************************/
+static	SINT32	get_digitalio
+(
+	MCDRV_DIO_INFO*	psDioInfo
+)
+{
+	if(NULL == psDioInfo)
+	{
+		return MCDRV_ERROR_ARGUMENT;
+	}
+
+	if(eMCDRV_STATE_NOTINIT_AA == McResCtrl_GetState_AA())
+	{
+		return MCDRV_ERROR_STATE;
+	}
+
+	McResCtrl_GetDioInfo_AA(psDioInfo);
+
+	return MCDRV_SUCCESS;
+}
+
+/****************************************************************************
+ *	set_digitalio
+ *
+ *	Description:
+ *			Update digital IO configuration.
+ *	Arguments:
+ *			psDioInfo	digital IO configuration
+ *			dUpdateInfo	update information
+ *	Return:
+ *			MCDRV_SUCCESS
+ *			MCDRV_ERROR_ARGUMENT
+ *			MCDRV_ERROR_STATE
+ *
+ ****************************************************************************/
+static	SINT32	set_digitalio
+(
+	const MCDRV_DIO_INFO*	psDioInfo,
+	UINT32					dUpdateInfo
+)
+{
+	SINT32		sdRet	= MCDRV_SUCCESS;
+	MCDRV_STATE_AA	eState	= McResCtrl_GetState_AA();
+
+	if(NULL == psDioInfo)
+	{
+		return MCDRV_ERROR_ARGUMENT;
+	}
+
+	if(eMCDRV_STATE_NOTINIT_AA == eState)
+	{
+		return MCDRV_ERROR_STATE;
+	}
+
+	sdRet	= ValidateDioParam(psDioInfo, dUpdateInfo);
+	if(MCDRV_SUCCESS != sdRet)
+	{
+		return sdRet;
+	}
+
+	McResCtrl_SetDioInfo_AA(psDioInfo, dUpdateInfo);
+
+	sdRet	= McPacket_AddDigitalIO_AA(dUpdateInfo);
+	if(MCDRV_SUCCESS != sdRet)
+	{
+		return sdRet;
+	}
+	return McDevIf_ExecutePacket_AA();
+}
+
+/****************************************************************************
+ *	get_dac
+ *
+ *	Description:
+ *			Get current DAC setting.
+ *	Arguments:
+ *			psDacInfo	DAC information
+ *	Return:
+ *			MCDRV_SUCCESS
+ *			MCDRV_ERROR_STATE
+ *
+ ****************************************************************************/
+static	SINT32	get_dac
+(
+	MCDRV_DAC_INFO*	psDacInfo
+)
+{
+	if(NULL == psDacInfo)
+	{
+		return MCDRV_ERROR_ARGUMENT;
+	}
+
+	if(eMCDRV_STATE_NOTINIT_AA == McResCtrl_GetState_AA())
+	{
+		return MCDRV_ERROR_STATE;
+	}
+
+	McResCtrl_GetDacInfo_AA(psDacInfo);
+
+	return MCDRV_SUCCESS;
+}
+
+/****************************************************************************
+ *	set_dac
+ *
+ *	Description:
+ *			Update DAC configuration.
+ *	Arguments:
+ *			psDacInfo	DAC configuration
+ *			dUpdateInfo	update information
+ *	Return:
+ *			MCDRV_SUCCESS
+ *			MCDRV_ERROR_ARGUMENT
+ *			MCDRV_ERROR_STATE
+ *
+ ****************************************************************************/
+static	SINT32	set_dac
+(
+	const MCDRV_DAC_INFO*	psDacInfo,
+	UINT32					dUpdateInfo
+)
+{
+	SINT32		sdRet	= MCDRV_SUCCESS;
+	MCDRV_STATE_AA	eState	= McResCtrl_GetState_AA();
+
+	if(NULL == psDacInfo)
+	{
+		return MCDRV_ERROR_ARGUMENT;
+	}
+
+	if(eMCDRV_STATE_NOTINIT_AA == eState)
+	{
+		return MCDRV_ERROR_STATE;
+	}
+
+	McResCtrl_SetDacInfo_AA(psDacInfo, dUpdateInfo);
+
+	sdRet	= McPacket_AddDAC_AA(dUpdateInfo);
+	if(MCDRV_SUCCESS != sdRet)
+	{
+		return sdRet;
+	}
+	return McDevIf_ExecutePacket_AA();
+}
+
+/****************************************************************************
+ *	get_adc
+ *
+ *	Description:
+ *			Get current ADC setting.
+ *	Arguments:
+ *			psAdcInfo	ADC information
+ *	Return:
+ *			MCDRV_SUCCESS
+ *			MCDRV_ERROR_STATE
+ *
+ ****************************************************************************/
+static	SINT32	get_adc
+(
+	MCDRV_ADC_INFO*	psAdcInfo
+)
+{
+	if(NULL == psAdcInfo)
+	{
+		return MCDRV_ERROR_ARGUMENT;
+	}
+
+	if(eMCDRV_STATE_NOTINIT_AA == McResCtrl_GetState_AA())
+	{
+		return MCDRV_ERROR_STATE;
+	}
+
+	McResCtrl_GetAdcInfo_AA(psAdcInfo);
+
+	return MCDRV_SUCCESS;
+}
+
+/****************************************************************************
+ *	set_adc
+ *
+ *	Description:
+ *			Update ADC configuration.
+ *	Arguments:
+ *			psAdcInfo	ADC configuration
+ *			dUpdateInfo	update information
+ *	Return:
+ *			MCDRV_SUCCESS
+ *			MCDRV_ERROR_ARGUMENT
+ *			MCDRV_ERROR_STATE
+ *
+ ****************************************************************************/
+static	SINT32	set_adc
+(
+	const MCDRV_ADC_INFO*	psAdcInfo,
+	UINT32					dUpdateInfo
+)
+{
+	SINT32		sdRet	= MCDRV_SUCCESS;
+	MCDRV_STATE_AA	eState	= McResCtrl_GetState_AA();
+
+	if(NULL == psAdcInfo)
+	{
+		return MCDRV_ERROR_ARGUMENT;
+	}
+
+	if(eMCDRV_STATE_NOTINIT_AA == eState)
+	{
+		return MCDRV_ERROR_STATE;
+	}
+
+	McResCtrl_SetAdcInfo_AA(psAdcInfo, dUpdateInfo);
+
+	sdRet	= McPacket_AddADC_AA(dUpdateInfo);
+	if(MCDRV_SUCCESS != sdRet)
+	{
+		return sdRet;
+	}
+	return McDevIf_ExecutePacket_AA();
+}
+
+/****************************************************************************
+ *	get_sp
+ *
+ *	Description:
+ *			Get current SP setting.
+ *	Arguments:
+ *			psSpInfo	SP information
+ *	Return:
+ *			MCDRV_SUCCESS
+ *			MCDRV_ERROR_STATE
+ *
+ ****************************************************************************/
+static	SINT32	get_sp
+(
+	MCDRV_SP_INFO*	psSpInfo
+)
+{
+	if(NULL == psSpInfo)
+	{
+		return MCDRV_ERROR_ARGUMENT;
+	}
+
+	if(eMCDRV_STATE_NOTINIT_AA == McResCtrl_GetState_AA())
+	{
+		return MCDRV_ERROR_STATE;
+	}
+
+	McResCtrl_GetSpInfo_AA(psSpInfo);
+
+	return MCDRV_SUCCESS;
+}
+
+/****************************************************************************
+ *	set_sp
+ *
+ *	Description:
+ *			Update SP configuration.
+ *	Arguments:
+ *			psSpInfo	SP configuration
+ *	Return:
+ *			MCDRV_SUCCESS
+ *			MCDRV_ERROR_ARGUMENT
+ *			MCDRV_ERROR_STATE
+ *
+ ****************************************************************************/
+static	SINT32	set_sp
+(
+	const MCDRV_SP_INFO*	psSpInfo
+)
+{
+	SINT32		sdRet	= MCDRV_SUCCESS;
+	MCDRV_STATE_AA	eState	= McResCtrl_GetState_AA();
+
+	if(NULL == psSpInfo)
+	{
+		return MCDRV_ERROR_ARGUMENT;
+	}
+
+	if(eMCDRV_STATE_NOTINIT_AA == eState)
+	{
+		return MCDRV_ERROR_STATE;
+	}
+
+	McResCtrl_SetSpInfo_AA(psSpInfo);
+
+	sdRet	= McPacket_AddSP_AA();
+	if(MCDRV_SUCCESS != sdRet)
+	{
+		return sdRet;
+	}
+	return McDevIf_ExecutePacket_AA();
+}
+
+/****************************************************************************
+ *	get_dng
+ *
+ *	Description:
+ *			Get current Digital Noise Gate setting.
+ *	Arguments:
+ *			psDngInfo	DNG information
+ *	Return:
+ *			MCDRV_SUCCESS
+ *			MCDRV_ERROR_STATE
+ *
+ ****************************************************************************/
+static	SINT32	get_dng
+(
+	MCDRV_DNG_INFO*	psDngInfo
+)
+{
+	if(NULL == psDngInfo)
+	{
+		return MCDRV_ERROR_ARGUMENT;
+	}
+
+	if(eMCDRV_STATE_NOTINIT_AA == McResCtrl_GetState_AA())
+	{
+		return MCDRV_ERROR_STATE;
+	}
+
+	McResCtrl_GetDngInfo_AA(psDngInfo);
+
+	return MCDRV_SUCCESS;
+}
+
+/****************************************************************************
+ *	set_dng
+ *
+ *	Description:
+ *			Update Digital Noise Gate configuration.
+ *	Arguments:
+ *			psDngInfo	DNG configuration
+ *			dUpdateInfo	update information
+ *	Return:
+ *			MCDRV_SUCCESS
+ *			MCDRV_ERROR_ARGUMENT
+ *			MCDRV_ERROR_STATE
+ *
+ ****************************************************************************/
+static	SINT32	set_dng
+(
+	const MCDRV_DNG_INFO*	psDngInfo,
+	UINT32					dUpdateInfo
+)
+{
+	SINT32		sdRet	= MCDRV_SUCCESS;
+	MCDRV_STATE_AA	eState	= McResCtrl_GetState_AA();
+
+	if(NULL == psDngInfo)
+	{
+		return MCDRV_ERROR_ARGUMENT;
+	}
+
+	if(eMCDRV_STATE_NOTINIT_AA == eState)
+	{
+		return MCDRV_ERROR_STATE;
+	}
+
+	McResCtrl_SetDngInfo_AA(psDngInfo, dUpdateInfo);
+
+	sdRet	= McPacket_AddDNG_AA(dUpdateInfo);
+	if(MCDRV_SUCCESS != sdRet)
+	{
+		return sdRet;
+	}
+	return McDevIf_ExecutePacket_AA();
+}
+
+/****************************************************************************
+ *	set_ae
+ *
+ *	Description:
+ *			Update Audio Engine configuration.
+ *	Arguments:
+ *			psAeInfo	AE configuration
+ *			dUpdateInfo	update information
+ *	Return:
+ *			MCDRV_SUCCESS
+ *			MCDRV_ERROR_ARGUMENT
+ *			MCDRV_ERROR_STATE
+ *
+ ****************************************************************************/
+static	SINT32	set_ae
+(
+	const MCDRV_AE_INFO*	psAeInfo,
+	UINT32					dUpdateInfo
+)
+{
+	SINT32		sdRet	= MCDRV_SUCCESS;
+	MCDRV_STATE_AA	eState	= McResCtrl_GetState_AA();
+	MCDRV_PATH_INFO	sPathInfo;
+
+	if(NULL == psAeInfo)
+	{
+		return MCDRV_ERROR_ARGUMENT;
+	}
+
+	if(eMCDRV_STATE_NOTINIT_AA == eState)
+	{
+		return MCDRV_ERROR_STATE;
+	}
+
+	McResCtrl_SetAeInfo_AA(psAeInfo, dUpdateInfo);
+
+	sdRet	= McPacket_AddAE_AA(dUpdateInfo);
+	if(MCDRV_SUCCESS != sdRet)
+	{
+		return sdRet;
+	}
+	sdRet	= McDevIf_ExecutePacket_AA();
+	if(MCDRV_SUCCESS != sdRet)
+	{
+		return sdRet;
+	}
+
+	McResCtrl_GetPathInfoVirtual_AA(&sPathInfo);
+	return	set_path(&sPathInfo);
+}
+
+/****************************************************************************
+ *	get_pdm
+ *
+ *	Description:
+ *			Get current PDM setting.
+ *	Arguments:
+ *			psPdmInfo	PDM information
+ *	Return:
+ *			MCDRV_SUCCESS
+ *			MCDRV_ERROR_STATE
+ *
+ ****************************************************************************/
+static	SINT32	get_pdm
+(
+	MCDRV_PDM_INFO*	psPdmInfo
+)
+{
+	if(NULL == psPdmInfo)
+	{
+		return MCDRV_ERROR_ARGUMENT;
+	}
+
+	if(eMCDRV_STATE_NOTINIT_AA == McResCtrl_GetState_AA())
+	{
+		return MCDRV_ERROR_STATE;
+	}
+
+	McResCtrl_GetPdmInfo_AA(psPdmInfo);
+
+	return MCDRV_SUCCESS;
+}
+
+/****************************************************************************
+ *	set_pdm
+ *
+ *	Description:
+ *			Update PDM configuration.
+ *	Arguments:
+ *			psPdmInfo	PDM configuration
+ *			dUpdateInfo	update information
+ *	Return:
+ *			MCDRV_SUCCESS
+ *			MCDRV_ERROR_ARGUMENT
+ *			MCDRV_ERROR_STATE
+ *
+ ****************************************************************************/
+static	SINT32	set_pdm
+(
+	const MCDRV_PDM_INFO*	psPdmInfo,
+	UINT32					dUpdateInfo
+)
+{
+	SINT32		sdRet	= MCDRV_SUCCESS;
+	MCDRV_STATE_AA	eState	= McResCtrl_GetState_AA();
+
+	if(NULL == psPdmInfo)
+	{
+		return MCDRV_ERROR_ARGUMENT;
+	}
+
+	if(eMCDRV_STATE_NOTINIT_AA == eState)
+	{
+		return MCDRV_ERROR_STATE;
+	}
+
+	McResCtrl_SetPdmInfo_AA(psPdmInfo, dUpdateInfo);
+
+	sdRet	= McPacket_AddPDM_AA(dUpdateInfo);
+	if(MCDRV_SUCCESS != sdRet)
+	{
+		return sdRet;
+	}
+	return McDevIf_ExecutePacket_AA();
+}
+
+/****************************************************************************
+ *	config_gp
+ *
+ *	Description:
+ *			Set GPIO mode.
+ *	Arguments:
+ *			psGpMode	GPIO mode information
+ *	Return:
+ *			MCDRV_SUCCESS
+ *			MCDRV_ERROR_ARGUMENT
+ *			MCDRV_ERROR_STATE
+*
+ ****************************************************************************/
+static	SINT32	config_gp
+(
+	const MCDRV_GP_MODE*	psGpMode
+)
+{
+	SINT32		sdRet	= MCDRV_SUCCESS;
+	MCDRV_STATE_AA	eState	= McResCtrl_GetState_AA();
+
+	if(NULL == psGpMode)
+	{
+		return MCDRV_ERROR_ARGUMENT;
+	}
+
+	if(eMCDRV_STATE_NOTINIT_AA == eState)
+	{
+		return MCDRV_ERROR_STATE;
+	}
+
+	McResCtrl_SetGPMode_AA(psGpMode);
+
+	sdRet	= McPacket_AddGPMode_AA();
+	if(MCDRV_SUCCESS != sdRet)
+	{
+		return sdRet;
+	}
+	return McDevIf_ExecutePacket_AA();
+}
+
+/****************************************************************************
+ *	mask_gp
+ *
+ *	Description:
+ *			Set GPIO input mask.
+ *	Arguments:
+ *			pbMask	mask setting
+ *			dPadNo	PAD number
+ *	Return:
+ *			MCDRV_SUCCESS
+ *			MCDRV_ERROR_ARGUMENT
+ *			MCDRV_ERROR_STATE
+ *			MCDRV_ERROR
+*
+ ****************************************************************************/
+static	SINT32	mask_gp
+(
+	UINT8*	pbMask,
+	UINT32	dPadNo
+)
+{
+	SINT32		sdRet	= MCDRV_SUCCESS;
+	MCDRV_STATE_AA	eState	= McResCtrl_GetState_AA();
+	MCDRV_INIT_INFO	sInitInfo;
+	MCDRV_GP_MODE	sGPMode;
+
+	if(NULL == pbMask)
+	{
+		return MCDRV_ERROR_ARGUMENT;
+	}
+
+	if(eMCDRV_STATE_NOTINIT_AA == eState)
+	{
+		return MCDRV_ERROR_STATE;
+	}
+
+	McResCtrl_GetInitInfo_AA(&sInitInfo);
+	McResCtrl_GetGPMode_AA(&sGPMode);
+
+	if(dPadNo == MCDRV_GP_PAD0)
+	{
+		if(sInitInfo.bPad0Func == MCDRV_PAD_GPIO && sGPMode.abGpDdr[dPadNo] == MCDRV_GPDDR_OUT)
+		{
+			return MCDRV_ERROR;
+		}
+	}
+	else if(dPadNo == MCDRV_GP_PAD1)
+	{
+		if(sInitInfo.bPad1Func == MCDRV_PAD_GPIO && sGPMode.abGpDdr[dPadNo] == MCDRV_GPDDR_OUT)
+		{
+			return MCDRV_ERROR;
+		}
+	}
+/*
+	else if(dPadNo == MCDRV_GP_PAD2)
+	{
+		if(sInitInfo.bPad2Func == MCDRV_PAD_GPIO && sGPMode.abGpDdr[dPadNo] == MCDRV_GPDDR_OUT)
+		{
+			return MCDRV_ERROR;
+		}
+	}
+*/
+	McResCtrl_SetGPMask_AA(*pbMask, dPadNo);
+
+	sdRet	= McPacket_AddGPMask_AA(dPadNo);
+	if(sdRet != MCDRV_SUCCESS)
+	{
+		return sdRet;
+	}
+	return McDevIf_ExecutePacket_AA();
+}
+
+/****************************************************************************
+ *	getset_gp
+ *
+ *	Description:
+ *			Set or get state of GPIO pin.
+ *	Arguments:
+ *			pbGpio	pin state
+ *			dPadNo	PAD number
+ *	Return:
+ *			MCDRV_SUCCESS
+ *			MCDRV_ERROR_ARGUMENT
+*
+ ****************************************************************************/
+static	SINT32	getset_gp
+(
+	UINT8*	pbGpio,
+	UINT32	dPadNo
+)
+{
+	SINT32			sdRet	= MCDRV_SUCCESS;
+	UINT8			bSlaveAddr;
+	UINT8			abData[2];
+	UINT8			bRegData;
+	MCDRV_STATE_AA		eState	= McResCtrl_GetState_AA();
+	MCDRV_INIT_INFO	sInitInfo;
+	MCDRV_GP_MODE	sGPMode;
+
+	if(NULL == pbGpio)
+	{
+		return MCDRV_ERROR_ARGUMENT;
+	}
+
+	if(eMCDRV_STATE_NOTINIT_AA == eState)
+	{
+		return MCDRV_ERROR_STATE;
+	}
+
+	McResCtrl_GetInitInfo_AA(&sInitInfo);
+	McResCtrl_GetGPMode_AA(&sGPMode);
+
+	if((dPadNo == MCDRV_GP_PAD0 && sInitInfo.bPad0Func != MCDRV_PAD_GPIO)
+	|| (dPadNo == MCDRV_GP_PAD1 && sInitInfo.bPad1Func != MCDRV_PAD_GPIO)
+	/*|| (dPadNo == MCDRV_GP_PAD2 && sInitInfo.bPad2Func != MCDRV_PAD_GPIO)*/)
+	{
+		return MCDRV_ERROR;
+	}
+
+	if(dPadNo < GPIO_PAD_NUM)
+	{
+		if(sGPMode.abGpDdr[dPadNo] == MCDRV_GPDDR_IN)
+		{
+			bSlaveAddr	= McDevProf_GetSlaveAddr(eMCDRV_SLAVE_ADDR_DIG);
+			abData[0]	= MCI_AA_BASE_ADR<<1;
+			abData[1]	= MCI_AA_PA_SCU_PA;
+			McSrv_WriteI2C(bSlaveAddr, abData, 2);
+			bRegData	= McSrv_ReadI2C(bSlaveAddr, MCI_AA_BASE_WINDOW);
+			if(dPadNo == MCDRV_GP_PAD0)
+			{
+				*pbGpio	= bRegData & MCB_AA_PA_SCU_PA0;
+			}
+			else if(dPadNo == MCDRV_GP_PAD1)
+			{
+				*pbGpio	= (bRegData & MCB_AA_PA_SCU_PA1) >> 1;
+			}
+	/*
+			else if(dPadNo == MCDRV_GP_PAD2)
+			{
+				*pbGpio	= (bRegData & MCB_AA_PA_SCU_PA2) >> 2;
+			}
+	*/
+		}
+		else
+		{
+			sdRet	= McPacket_AddGPSet_AA(*pbGpio, dPadNo);
+			if(sdRet != MCDRV_SUCCESS)
+			{
+				return sdRet;
+			}
+			return McDevIf_ExecutePacket_AA();
+		}
+	}
+
+	return MCDRV_SUCCESS;
+}
+
+
+/****************************************************************************
+ *	ValidateInitParam
+ *
+ *	Description:
+ *			validate init parameters.
+ *	Arguments:
+ *			psInitInfo	initialize information
+ *	Return:
+ *			MCDRV_SUCCESS
+ *			MCDRV_ERROR_ARGUMENT
+ *
+ ****************************************************************************/
+static	SINT32	ValidateInitParam
+(
+	const MCDRV_INIT_INFO*	psInitInfo
+)
+{
+
+	if(MCDRV_CKSEL_CMOS != psInitInfo->bCkSel && 1/*MCDRV_CKSEL_TCXO*/ != psInitInfo->bCkSel)
+	{
+		return MCDRV_ERROR_ARGUMENT;
+	}
+	if(psInitInfo->bDivR0 == 0x00 || psInitInfo->bDivR0 > 0x7F)
+	{
+		return MCDRV_ERROR_ARGUMENT;
+	}
+	if(McDevProf_IsValid(eMCDRV_FUNC_DIVR1) == 1
+	&& (psInitInfo->bDivR1 == 0x00 || psInitInfo->bDivR1 > 0x7F))
+	{
+		return MCDRV_ERROR_ARGUMENT;
+	}
+	if(psInitInfo->bDivF0 == 0x00)
+	{
+		return MCDRV_ERROR_ARGUMENT;
+	}
+	if(McDevProf_IsValid(eMCDRV_FUNC_DIVF1) == 1 && psInitInfo->bDivF1 == 0x00)
+	{
+		return MCDRV_ERROR_ARGUMENT;
+	}
+	if(McDevProf_IsValid(eMCDRV_FUNC_RANGE) == 1
+	&& (psInitInfo->bRange0 > 0x07 || psInitInfo->bRange1 > 0x07))
+	{
+		return MCDRV_ERROR_ARGUMENT;
+	}
+	if(McDevProf_IsValid(eMCDRV_FUNC_BYPASS) == 1 && psInitInfo->bBypass > 0x03)
+	{
+		return MCDRV_ERROR_ARGUMENT;
+	}
+	if(MCDRV_DAHIZ_LOW != psInitInfo->bDioSdo0Hiz && MCDRV_DAHIZ_HIZ != psInitInfo->bDioSdo0Hiz)
+	{
+		return MCDRV_ERROR_ARGUMENT;
+	}
+	if(MCDRV_DAHIZ_LOW != psInitInfo->bDioSdo1Hiz && MCDRV_DAHIZ_HIZ != psInitInfo->bDioSdo1Hiz)
+	{
+		return MCDRV_ERROR_ARGUMENT;
+	}
+	if(MCDRV_DAHIZ_LOW != psInitInfo->bDioSdo2Hiz && MCDRV_DAHIZ_HIZ != psInitInfo->bDioSdo2Hiz)
+	{
+		return MCDRV_ERROR_ARGUMENT;
+	}
+	if(MCDRV_PCMHIZ_HIZ != psInitInfo->bPcmHiz && MCDRV_PCMHIZ_LOW != psInitInfo->bPcmHiz)
+	{
+		return MCDRV_ERROR_ARGUMENT;
+	}
+	if(MCDRV_DAHIZ_LOW != psInitInfo->bDioClk0Hiz && MCDRV_DAHIZ_HIZ != psInitInfo->bDioClk0Hiz)
+	{
+		return MCDRV_ERROR_ARGUMENT;
+	}
+	if(MCDRV_DAHIZ_LOW != psInitInfo->bDioClk1Hiz && MCDRV_DAHIZ_HIZ != psInitInfo->bDioClk1Hiz)
+	{
+		return MCDRV_ERROR_ARGUMENT;
+	}
+	if(MCDRV_DAHIZ_LOW != psInitInfo->bDioClk2Hiz && MCDRV_DAHIZ_HIZ != psInitInfo->bDioClk2Hiz)
+	{
+		return MCDRV_ERROR_ARGUMENT;
+	}
+	if(MCDRV_PCMHIZ_HIZ != psInitInfo->bPcmHiz && MCDRV_PCMHIZ_LOW != psInitInfo->bPcmHiz)
+	{
+		return MCDRV_ERROR_ARGUMENT;
+	}
+	if(MCDRV_LINE_STEREO != psInitInfo->bLineIn1Dif && MCDRV_LINE_DIF != psInitInfo->bLineIn1Dif)
+	{
+		return MCDRV_ERROR_ARGUMENT;
+	}
+	if(McDevProf_IsValid(eMCDRV_FUNC_LI2) == 1
+	&& MCDRV_LINE_STEREO != psInitInfo->bLineIn2Dif && MCDRV_LINE_DIF != psInitInfo->bLineIn2Dif)
+	{
+		return MCDRV_ERROR_ARGUMENT;
+	}
+	if(MCDRV_LINE_STEREO != psInitInfo->bLineOut1Dif && MCDRV_LINE_DIF != psInitInfo->bLineOut1Dif)
+	{
+		return MCDRV_ERROR_ARGUMENT;
+	}
+	if(MCDRV_LINE_STEREO != psInitInfo->bLineOut2Dif && MCDRV_LINE_DIF != psInitInfo->bLineOut2Dif)
+	{
+		return MCDRV_ERROR_ARGUMENT;
+	}
+	if(MCDRV_SPMN_ON != psInitInfo->bSpmn && MCDRV_SPMN_OFF != psInitInfo->bSpmn)
+	{
+		return MCDRV_ERROR_ARGUMENT;
+	}
+	if(MCDRV_MIC_DIF != psInitInfo->bMic1Sng && MCDRV_MIC_SINGLE != psInitInfo->bMic1Sng)
+	{
+		return MCDRV_ERROR_ARGUMENT;
+	}
+	if(MCDRV_MIC_DIF != psInitInfo->bMic2Sng && MCDRV_MIC_SINGLE != psInitInfo->bMic2Sng)
+	{
+		return MCDRV_ERROR_ARGUMENT;
+	}
+	if(MCDRV_MIC_DIF != psInitInfo->bMic3Sng && MCDRV_MIC_SINGLE != psInitInfo->bMic3Sng)
+	{
+		return MCDRV_ERROR_ARGUMENT;
+	}
+	if(MCDRV_POWMODE_NORMAL != psInitInfo->bPowerMode
+	&& MCDRV_POWMODE_CLKON != psInitInfo->bPowerMode
+	&& MCDRV_POWMODE_VREFON != psInitInfo->bPowerMode
+	&& MCDRV_POWMODE_CLKVREFON != psInitInfo->bPowerMode
+	&& MCDRV_POWMODE_FULL != psInitInfo->bPowerMode)
+	{
+		return MCDRV_ERROR_ARGUMENT;
+	}
+	if(MCDRV_SPHIZ_PULLDOWN != psInitInfo->bSpHiz && MCDRV_SPHIZ_HIZ != psInitInfo->bSpHiz)
+	{
+		return MCDRV_ERROR_ARGUMENT;
+	}
+	if(MCDRV_LDO_OFF != psInitInfo->bLdo && MCDRV_LDO_ON != psInitInfo->bLdo)
+	{
+		return MCDRV_ERROR_ARGUMENT;
+	}
+	if(MCDRV_PAD_GPIO != psInitInfo->bPad0Func
+	&& MCDRV_PAD_PDMCK != psInitInfo->bPad0Func && MCDRV_PAD_IRQ != psInitInfo->bPad0Func)
+	{
+		return MCDRV_ERROR_ARGUMENT;
+	}
+	if(McDevProf_IsValid(eMCDRV_FUNC_IRQ) != 1 && MCDRV_PAD_IRQ == psInitInfo->bPad0Func)
+	{
+		return MCDRV_ERROR_ARGUMENT;
+	}
+
+	if(MCDRV_PAD_GPIO != psInitInfo->bPad1Func
+	&& MCDRV_PAD_PDMDI != psInitInfo->bPad1Func && MCDRV_PAD_IRQ != psInitInfo->bPad1Func)
+	{
+		return MCDRV_ERROR_ARGUMENT;
+	}
+	if(McDevProf_IsValid(eMCDRV_FUNC_IRQ) != 1 && MCDRV_PAD_IRQ == psInitInfo->bPad1Func)
+	{
+		return MCDRV_ERROR_ARGUMENT;
+	}
+
+	if(McDevProf_IsValid(eMCDRV_FUNC_PAD2) == 1
+	&& MCDRV_PAD_GPIO != psInitInfo->bPad2Func
+	&& MCDRV_PAD_PDMDI != psInitInfo->bPad2Func
+	&& MCDRV_PAD_IRQ != psInitInfo->bPad2Func)
+	{
+		return MCDRV_ERROR_ARGUMENT;
+	}
+
+	if(MCDRV_OUTLEV_0 != psInitInfo->bAvddLev && MCDRV_OUTLEV_1 != psInitInfo->bAvddLev
+	&& MCDRV_OUTLEV_2 != psInitInfo->bAvddLev && MCDRV_OUTLEV_3 != psInitInfo->bAvddLev
+	&& MCDRV_OUTLEV_4 != psInitInfo->bAvddLev && MCDRV_OUTLEV_5 != psInitInfo->bAvddLev
+	&& MCDRV_OUTLEV_6 != psInitInfo->bAvddLev && MCDRV_OUTLEV_7 != psInitInfo->bAvddLev)
+	{
+		return MCDRV_ERROR_ARGUMENT;
+	}
+
+	if(MCDRV_OUTLEV_0 != psInitInfo->bVrefLev && MCDRV_OUTLEV_1 != psInitInfo->bVrefLev
+	&& MCDRV_OUTLEV_2 != psInitInfo->bVrefLev && MCDRV_OUTLEV_3 != psInitInfo->bVrefLev
+	&& MCDRV_OUTLEV_4 != psInitInfo->bVrefLev && MCDRV_OUTLEV_5 != psInitInfo->bVrefLev
+	&& MCDRV_OUTLEV_6 != psInitInfo->bVrefLev && MCDRV_OUTLEV_7 != psInitInfo->bVrefLev)
+	{
+		return MCDRV_ERROR_ARGUMENT;
+	}
+
+	if(MCDRV_DCLGAIN_0 != psInitInfo->bDclGain && MCDRV_DCLGAIN_6 != psInitInfo->bDclGain
+	&& MCDRV_DCLGAIN_12!= psInitInfo->bDclGain && MCDRV_DCLGAIN_18!= psInitInfo->bDclGain)
+	{
+		return MCDRV_ERROR_ARGUMENT;
+	}
+
+	if(MCDRV_DCLLIMIT_0 != psInitInfo->bDclLimit && MCDRV_DCLLIMIT_116 != psInitInfo->bDclLimit
+	&& MCDRV_DCLLIMIT_250 != psInitInfo->bDclLimit && MCDRV_DCLLIMIT_602 != psInitInfo->bDclLimit)
+	{
+		return MCDRV_ERROR_ARGUMENT;
+	}
+
+	if((MCDRV_MAX_WAIT_TIME_AA < psInitInfo->sWaitTime.dAdHpf)
+	|| (MCDRV_MAX_WAIT_TIME_AA < psInitInfo->sWaitTime.dMic1Cin)
+	|| (MCDRV_MAX_WAIT_TIME_AA < psInitInfo->sWaitTime.dMic2Cin)
+	|| (MCDRV_MAX_WAIT_TIME_AA < psInitInfo->sWaitTime.dMic3Cin)
+	|| (MCDRV_MAX_WAIT_TIME_AA < psInitInfo->sWaitTime.dLine1Cin)
+	|| (MCDRV_MAX_WAIT_TIME_AA < psInitInfo->sWaitTime.dLine2Cin)
+	|| (MCDRV_MAX_WAIT_TIME_AA < psInitInfo->sWaitTime.dVrefRdy1)
+	|| (MCDRV_MAX_WAIT_TIME_AA < psInitInfo->sWaitTime.dVrefRdy2)
+	|| (MCDRV_MAX_WAIT_TIME_AA < psInitInfo->sWaitTime.dHpRdy)
+	|| (MCDRV_MAX_WAIT_TIME_AA < psInitInfo->sWaitTime.dSpRdy)
+	|| (MCDRV_MAX_WAIT_TIME_AA < psInitInfo->sWaitTime.dPdm))
+	{
+		return MCDRV_ERROR_ARGUMENT;
+	}
+
+	return MCDRV_SUCCESS;
+}
+
+/****************************************************************************
+ *	ValidateClockParam
+ *
+ *	Description:
+ *			validate clock parameters.
+ *	Arguments:
+ *			psClockInfo	clock information
+ *	Return:
+ *			MCDRV_SUCCESS
+ *			MCDRV_ERROR_ARGUMENT
+ *
+ ****************************************************************************/
+static	SINT32	ValidateClockParam
+(
+	const MCDRV_CLOCK_INFO*	psClockInfo
+)
+{
+
+	if((MCDRV_CKSEL_CMOS != psClockInfo->bCkSel) && (1/*MCDRV_CKSEL_TCXO*/ != psClockInfo->bCkSel))
+	{
+		return MCDRV_ERROR_ARGUMENT;
+	}
+	if((psClockInfo->bDivR0 == 0x00) || (psClockInfo->bDivR0 > 0x7F))
+	{
+		return MCDRV_ERROR_ARGUMENT;
+	}
+	if((McDevProf_IsValid(eMCDRV_FUNC_DIVR1) == 1)
+	&& ((psClockInfo->bDivR1 == 0x00) || (psClockInfo->bDivR1 > 0x7F)))
+	{
+		return MCDRV_ERROR_ARGUMENT;
+	}
+	if(psClockInfo->bDivF0 == 0x00)
+	{
+		return MCDRV_ERROR_ARGUMENT;
+	}
+	if((McDevProf_IsValid(eMCDRV_FUNC_DIVF1) == 1) && (psClockInfo->bDivF1 == 0x00))
+	{
+		return MCDRV_ERROR_ARGUMENT;
+	}
+	if((McDevProf_IsValid(eMCDRV_FUNC_RANGE) == 1)
+	&& ((psClockInfo->bRange0 > 0x07) || (psClockInfo->bRange1 > 0x07)))
+	{
+		return MCDRV_ERROR_ARGUMENT;
+	}
+	if((McDevProf_IsValid(eMCDRV_FUNC_BYPASS) == 1) && (psClockInfo->bBypass > 0x03))
+	{
+		return MCDRV_ERROR_ARGUMENT;
+	}
+
+	return MCDRV_SUCCESS;
+}
+
+/****************************************************************************
+ *	ValidateReadRegParam
+ *
+ *	Description:
+ *			validate read reg parameter.
+ *	Arguments:
+ *			psRegInfo	register information
+ *	Return:
+ *			MCDRV_SUCCESS
+ *			MCDRV_ERROR_ARGUMENT
+ *
+ ****************************************************************************/
+static	SINT32	ValidateReadRegParam
+(
+	const MCDRV_REG_INFO*	psRegInfo
+)
+{
+
+	if((McResCtrl_GetRegAccess_AA(psRegInfo) & eMCDRV_READ_ONLY_AA) == 0)
+	{
+		return MCDRV_ERROR_ARGUMENT;
+	}
+
+	return MCDRV_SUCCESS;
+}
+
+/****************************************************************************
+ *	ValidateWriteRegParam
+ *
+ *	Description:
+ *			validate write reg parameter.
+ *	Arguments:
+ *			psRegInfo	register information
+ *	Return:
+ *			MCDRV_SUCCESS
+ *			MCDRV_ERROR_ARGUMENT
+ *
+ ****************************************************************************/
+static	SINT32	ValidateWriteRegParam
+(
+	const MCDRV_REG_INFO*	psRegInfo
+)
+{
+
+	if((McResCtrl_GetRegAccess_AA(psRegInfo) & eMCDRV_WRITE_ONLY_AA) == 0)
+	{
+		return MCDRV_ERROR_ARGUMENT;
+	}
+
+	return MCDRV_SUCCESS;
+}
+
+/****************************************************************************
+ *	ValidatePathParam
+ *
+ *	Description:
+ *			validate path parameters.
+ *	Arguments:
+ *			psPathInfo	path information
+ *	Return:
+ *			MCDRV_SUCCESS
+ *			MCDRV_ERROR_ARGUMENT
+ *
+ ****************************************************************************/
+static SINT32	ValidatePathParam(
+	const MCDRV_PATH_INFO*	psPathInfo
+)
+{
+	UINT8	bBlock;
+	UINT8	bCh;
+	UINT8	bPDMIsSrc	= 0;
+	UINT8	bADC0IsSrc	= 0;
+	MCDRV_PATH_INFO		sCurPathInfo;
+
+
+	McResCtrl_GetPathInfoVirtual_AA(&sCurPathInfo);
+	/*	set off to current path info	*/
+	for(bBlock = 0; bBlock < SOURCE_BLOCK_NUM; bBlock++)
+	{
+		for(bCh = 0; bCh < HP_PATH_CHANNELS; bCh++)
+		{
+			if((psPathInfo->asHpOut[bCh].abSrcOnOff[bBlock] & (0x03)) == 0x02)
+			{
+				sCurPathInfo.asHpOut[bCh].abSrcOnOff[bBlock]	&= (UINT8)~0x01;
+				sCurPathInfo.asHpOut[bCh].abSrcOnOff[bBlock]	|= 0x02;
+			}
+			if((psPathInfo->asHpOut[bCh].abSrcOnOff[bBlock] & (0x0C)) == 0x08)
+			{
+				sCurPathInfo.asHpOut[bCh].abSrcOnOff[bBlock]	&= (UINT8)~0x04;
+				sCurPathInfo.asHpOut[bCh].abSrcOnOff[bBlock]	|= 0x08;
+			}
+			if((psPathInfo->asHpOut[bCh].abSrcOnOff[bBlock] & (0x30)) == 0x20)
+			{
+				sCurPathInfo.asHpOut[bCh].abSrcOnOff[bBlock]	&= (UINT8)~0x10;
+				sCurPathInfo.asHpOut[bCh].abSrcOnOff[bBlock]	|= 0x20;
+			}
+			if((psPathInfo->asHpOut[bCh].abSrcOnOff[bBlock] & (0xC0)) == 0x80)
+			{
+				sCurPathInfo.asHpOut[bCh].abSrcOnOff[bBlock]	&= (UINT8)~0x40;
+				sCurPathInfo.asHpOut[bCh].abSrcOnOff[bBlock]	|= 0x80;
+			}
+		}
+		for(bCh = 0; bCh < SP_PATH_CHANNELS; bCh++)
+		{
+			if((psPathInfo->asSpOut[bCh].abSrcOnOff[bBlock] & (0x03)) == 0x02)
+			{
+				sCurPathInfo.asSpOut[bCh].abSrcOnOff[bBlock]	&= (UINT8)~0x01;
+				sCurPathInfo.asSpOut[bCh].abSrcOnOff[bBlock]	|= (UINT8)0x02;
+			}
+			if((psPathInfo->asSpOut[bCh].abSrcOnOff[bBlock] & (0x0C)) == 0x08)
+			{
+				sCurPathInfo.asSpOut[bCh].abSrcOnOff[bBlock]	&= (UINT8)~0x04;
+				sCurPathInfo.asSpOut[bCh].abSrcOnOff[bBlock]	|= (UINT8)0x08;
+			}
+			if((psPathInfo->asSpOut[bCh].abSrcOnOff[bBlock] & (0x30)) == 0x20)
+			{
+				sCurPathInfo.asSpOut[bCh].abSrcOnOff[bBlock]	&= (UINT8)~0x10;
+				sCurPathInfo.asSpOut[bCh].abSrcOnOff[bBlock]	|= (UINT8)0x20;
+			}
+			if((psPathInfo->asSpOut[bCh].abSrcOnOff[bBlock] & (0xC0)) == 0x80)
+			{
+				sCurPathInfo.asSpOut[bCh].abSrcOnOff[bBlock]	&= (UINT8)~0x40;
+				sCurPathInfo.asSpOut[bCh].abSrcOnOff[bBlock]	|= (UINT8)0x80;
+			}
+		}
+		for(bCh = 0; bCh < RC_PATH_CHANNELS; bCh++)
+		{
+			if((psPathInfo->asRcOut[bCh].abSrcOnOff[bBlock] & (0x03)) == 0x02)
+			{
+				sCurPathInfo.asRcOut[bCh].abSrcOnOff[bBlock]	&= (UINT8)~0x01;
+				sCurPathInfo.asRcOut[bCh].abSrcOnOff[bBlock]	|= (UINT8)0x02;
+			}
+			if((psPathInfo->asRcOut[bCh].abSrcOnOff[bBlock] & (0x0C)) == 0x08)
+			{
+				sCurPathInfo.asRcOut[bCh].abSrcOnOff[bBlock]	&= (UINT8)~0x04;
+				sCurPathInfo.asRcOut[bCh].abSrcOnOff[bBlock]	|= (UINT8)0x08;
+			}
+			if((psPathInfo->asRcOut[bCh].abSrcOnOff[bBlock] & (0x30)) == 0x20)
+			{
+				sCurPathInfo.asRcOut[bCh].abSrcOnOff[bBlock]	&= (UINT8)~0x10;
+				sCurPathInfo.asRcOut[bCh].abSrcOnOff[bBlock]	|= (UINT8)0x20;
+			}
+			if((psPathInfo->asRcOut[bCh].abSrcOnOff[bBlock] & (0xC0)) == 0x80)
+			{
+				sCurPathInfo.asRcOut[bCh].abSrcOnOff[bBlock]	&= (UINT8)~0x40;
+				sCurPathInfo.asRcOut[bCh].abSrcOnOff[bBlock]	|= (UINT8)0x80;
+			}
+		}
+		for(bCh = 0; bCh < LOUT1_PATH_CHANNELS; bCh++)
+		{
+			if((psPathInfo->asLout1[bCh].abSrcOnOff[bBlock] & (0x03)) == 0x02)
+			{
+				sCurPathInfo.asLout1[bCh].abSrcOnOff[bBlock]	&= (UINT8)~0x01;
+				sCurPathInfo.asLout1[bCh].abSrcOnOff[bBlock]	|= (UINT8)0x02;
+			}
+			if((psPathInfo->asLout1[bCh].abSrcOnOff[bBlock] & (0x0C)) == 0x08)
+			{
+				sCurPathInfo.asLout1[bCh].abSrcOnOff[bBlock]	&= (UINT8)~0x04;
+				sCurPathInfo.asLout1[bCh].abSrcOnOff[bBlock]	|= (UINT8)0x08;
+			}
+			if((psPathInfo->asLout1[bCh].abSrcOnOff[bBlock] & (0x30)) == 0x20)
+			{
+				sCurPathInfo.asLout1[bCh].abSrcOnOff[bBlock]	&= (UINT8)~0x10;
+				sCurPathInfo.asLout1[bCh].abSrcOnOff[bBlock]	|= (UINT8)0x20;
+			}
+			if((psPathInfo->asLout1[bCh].abSrcOnOff[bBlock] & (0xC0)) == 0x80)
+			{
+				sCurPathInfo.asLout1[bCh].abSrcOnOff[bBlock]	&= (UINT8)~0x40;
+				sCurPathInfo.asLout1[bCh].abSrcOnOff[bBlock]	|= (UINT8)0x80;
+			}
+		}
+		for(bCh = 0; bCh < LOUT2_PATH_CHANNELS; bCh++)
+		{
+			if((psPathInfo->asLout2[bCh].abSrcOnOff[bBlock] & (0x03)) == 0x02)
+			{
+				sCurPathInfo.asLout2[bCh].abSrcOnOff[bBlock]	&= (UINT8)~0x01;
+				sCurPathInfo.asLout2[bCh].abSrcOnOff[bBlock]	|= 0x02;
+			}
+			if((psPathInfo->asLout2[bCh].abSrcOnOff[bBlock] & (0x0C)) == 0x08)
+			{
+				sCurPathInfo.asLout2[bCh].abSrcOnOff[bBlock]	&= (UINT8)~0x04;
+				sCurPathInfo.asLout2[bCh].abSrcOnOff[bBlock]	|= 0x08;
+			}
+			if((psPathInfo->asLout2[bCh].abSrcOnOff[bBlock] & (0x30)) == 0x20)
+			{
+				sCurPathInfo.asLout2[bCh].abSrcOnOff[bBlock]	&= (UINT8)~0x10;
+				sCurPathInfo.asLout2[bCh].abSrcOnOff[bBlock]	|= 0x20;
+			}
+			if((psPathInfo->asLout2[bCh].abSrcOnOff[bBlock] & (0xC0)) == 0x80)
+			{
+				sCurPathInfo.asLout2[bCh].abSrcOnOff[bBlock]	&= (UINT8)~0x40;
+				sCurPathInfo.asLout2[bCh].abSrcOnOff[bBlock]	|= 0x80;
+			}
+		}
+		for(bCh = 0; bCh < DIT0_PATH_CHANNELS; bCh++)
+		{
+			if((psPathInfo->asDit0[bCh].abSrcOnOff[bBlock] & (0x03)) == 0x02)
+			{
+				sCurPathInfo.asDit0[bCh].abSrcOnOff[bBlock]	&= (UINT8)~0x01;
+				sCurPathInfo.asDit0[bCh].abSrcOnOff[bBlock]	|= 0x02;
+			}
+			if((psPathInfo->asDit0[bCh].abSrcOnOff[bBlock] & (0x0C)) == 0x08)
+			{
+				sCurPathInfo.asDit0[bCh].abSrcOnOff[bBlock]	&= (UINT8)~0x04;
+				sCurPathInfo.asDit0[bCh].abSrcOnOff[bBlock]	|= 0x08;
+			}
+			if((psPathInfo->asDit0[bCh].abSrcOnOff[bBlock] & (0x30)) == 0x20)
+			{
+				sCurPathInfo.asDit0[bCh].abSrcOnOff[bBlock]	&= (UINT8)~0x10;
+				sCurPathInfo.asDit0[bCh].abSrcOnOff[bBlock]	|= 0x20;
+			}
+			if((psPathInfo->asDit0[bCh].abSrcOnOff[bBlock] & (0xC0)) == 0x80)
+			{
+				sCurPathInfo.asDit0[bCh].abSrcOnOff[bBlock]	&= (UINT8)~0x40;
+				sCurPathInfo.asDit0[bCh].abSrcOnOff[bBlock]	|= 0x80;
+			}
+		}
+		for(bCh = 0; bCh < DIT1_PATH_CHANNELS; bCh++)
+		{
+			if((psPathInfo->asDit1[bCh].abSrcOnOff[bBlock] & (0x03)) == 0x02)
+			{
+				sCurPathInfo.asDit1[bCh].abSrcOnOff[bBlock]	&= (UINT8)~0x01;
+				sCurPathInfo.asDit1[bCh].abSrcOnOff[bBlock]	|= 0x02;
+			}
+			if((psPathInfo->asDit1[bCh].abSrcOnOff[bBlock] & (0x0C)) == 0x08)
+			{
+				sCurPathInfo.asDit1[bCh].abSrcOnOff[bBlock]	&= (UINT8)~0x04;
+				sCurPathInfo.asDit1[bCh].abSrcOnOff[bBlock]	|= 0x08;
+			}
+			if((psPathInfo->asDit1[bCh].abSrcOnOff[bBlock] & (0x30)) == 0x20)
+			{
+				sCurPathInfo.asDit1[bCh].abSrcOnOff[bBlock]	&= (UINT8)~0x10;
+				sCurPathInfo.asDit1[bCh].abSrcOnOff[bBlock]	|= 0x20;
+			}
+			if((psPathInfo->asDit1[bCh].abSrcOnOff[bBlock] & (0xC0)) == 0x80)
+			{
+				sCurPathInfo.asDit1[bCh].abSrcOnOff[bBlock]	&= (UINT8)~0x40;
+				sCurPathInfo.asDit1[bCh].abSrcOnOff[bBlock]	|= 0x80;
+			}
+		}
+		for(bCh = 0; bCh < DIT2_PATH_CHANNELS; bCh++)
+		{
+			if((psPathInfo->asDit2[bCh].abSrcOnOff[bBlock] & (0x03)) == 0x02)
+			{
+				sCurPathInfo.asDit2[bCh].abSrcOnOff[bBlock]	&= (UINT8)~0x01;
+				sCurPathInfo.asDit2[bCh].abSrcOnOff[bBlock]	|= 0x02;
+			}
+			if((psPathInfo->asDit2[bCh].abSrcOnOff[bBlock] & (0x0C)) == 0x08)
+			{
+				sCurPathInfo.asDit2[bCh].abSrcOnOff[bBlock]	&= (UINT8)~0x04;
+				sCurPathInfo.asDit2[bCh].abSrcOnOff[bBlock]	|= 0x08;
+			}
+			if((psPathInfo->asDit2[bCh].abSrcOnOff[bBlock] & (0x30)) == 0x20)
+			{
+				sCurPathInfo.asDit2[bCh].abSrcOnOff[bBlock]	&= (UINT8)~0x10;
+				sCurPathInfo.asDit2[bCh].abSrcOnOff[bBlock]	|= 0x20;
+			}
+			if((psPathInfo->asDit2[bCh].abSrcOnOff[bBlock] & (0xC0)) == 0x80)
+			{
+				sCurPathInfo.asDit2[bCh].abSrcOnOff[bBlock]	&= (UINT8)~0x40;
+				sCurPathInfo.asDit2[bCh].abSrcOnOff[bBlock]	|= 0x80;
+			}
+		}
+		for(bCh = 0; bCh < DAC_PATH_CHANNELS; bCh++)
+		{
+			if((psPathInfo->asDac[bCh].abSrcOnOff[bBlock] & (0x03)) == 0x02)
+			{
+				sCurPathInfo.asDac[bCh].abSrcOnOff[bBlock]	&= (UINT8)~0x01;
+				sCurPathInfo.asDac[bCh].abSrcOnOff[bBlock]	|= 0x02;
+			}
+			if((psPathInfo->asDac[bCh].abSrcOnOff[bBlock] & (0x0C)) == 0x08)
+			{
+				sCurPathInfo.asDac[bCh].abSrcOnOff[bBlock]	&= (UINT8)~0x04;
+				sCurPathInfo.asDac[bCh].abSrcOnOff[bBlock]	|= 0x08;
+			}
+			if((psPathInfo->asDac[bCh].abSrcOnOff[bBlock] & (0x30)) == 0x20)
+			{
+				sCurPathInfo.asDac[bCh].abSrcOnOff[bBlock]	&= (UINT8)~0x10;
+				sCurPathInfo.asDac[bCh].abSrcOnOff[bBlock]	|= 0x20;
+			}
+			if((psPathInfo->asDac[bCh].abSrcOnOff[bBlock] & (0xC0)) == 0x80)
+			{
+				sCurPathInfo.asDac[bCh].abSrcOnOff[bBlock]	&= (UINT8)~0x40;
+				sCurPathInfo.asDac[bCh].abSrcOnOff[bBlock]	|= 0x80;
+			}
+		}
+		for(bCh = 0; bCh < AE_PATH_CHANNELS; bCh++)
+		{
+			if((psPathInfo->asAe[bCh].abSrcOnOff[bBlock] & (0x03)) == 0x02)
+			{
+				sCurPathInfo.asAe[bCh].abSrcOnOff[bBlock]	&= (UINT8)~0x01;
+				sCurPathInfo.asAe[bCh].abSrcOnOff[bBlock]	|= 0x02;
+			}
+			if((psPathInfo->asAe[bCh].abSrcOnOff[bBlock] & (0x0C)) == 0x08)
+			{
+				sCurPathInfo.asAe[bCh].abSrcOnOff[bBlock]	&= (UINT8)~0x04;
+				sCurPathInfo.asAe[bCh].abSrcOnOff[bBlock]	|= 0x08;
+			}
+			if((psPathInfo->asAe[bCh].abSrcOnOff[bBlock] & (0x30)) == 0x20)
+			{
+				sCurPathInfo.asAe[bCh].abSrcOnOff[bBlock]	&= (UINT8)~0x10;
+				sCurPathInfo.asAe[bCh].abSrcOnOff[bBlock]	|= 0x20;
+			}
+			if((psPathInfo->asAe[bCh].abSrcOnOff[bBlock] & (0xC0)) == 0x80)
+			{
+				sCurPathInfo.asAe[bCh].abSrcOnOff[bBlock]	&= (UINT8)~0x40;
+				sCurPathInfo.asAe[bCh].abSrcOnOff[bBlock]	|= 0x80;
+			}
+		}
+		for(bCh = 0; bCh < ADC0_PATH_CHANNELS; bCh++)
+		{
+			if((psPathInfo->asAdc0[bCh].abSrcOnOff[bBlock] & (0x03)) == 0x02)
+			{
+				sCurPathInfo.asAdc0[bCh].abSrcOnOff[bBlock]	&= (UINT8)~0x01;
+				sCurPathInfo.asAdc0[bCh].abSrcOnOff[bBlock]	|= (UINT8)0x02;
+			}
+			if((psPathInfo->asAdc0[bCh].abSrcOnOff[bBlock] & (0x0C)) == 0x08)
+			{
+				sCurPathInfo.asAdc0[bCh].abSrcOnOff[bBlock]	&= (UINT8)~0x04;
+				sCurPathInfo.asAdc0[bCh].abSrcOnOff[bBlock]	|= (UINT8)0x08;
+			}
+			if((psPathInfo->asAdc0[bCh].abSrcOnOff[bBlock] & (0x30)) == 0x20)
+			{
+				sCurPathInfo.asAdc0[bCh].abSrcOnOff[bBlock]	&= (UINT8)~0x10;
+				sCurPathInfo.asAdc0[bCh].abSrcOnOff[bBlock]	|= (UINT8)0x20;
+			}
+			if((psPathInfo->asAdc0[bCh].abSrcOnOff[bBlock] & (0xC0)) == 0x80)
+			{
+				sCurPathInfo.asAdc0[bCh].abSrcOnOff[bBlock]	&= (UINT8)~0x40;
+				sCurPathInfo.asAdc0[bCh].abSrcOnOff[bBlock]	|= (UINT8)0x80;
+			}
+		}
+		for(bCh = 0; bCh < MIX_PATH_CHANNELS; bCh++)
+		{
+			if((psPathInfo->asMix[bCh].abSrcOnOff[bBlock] & (0x03)) == 0x02)
+			{
+				sCurPathInfo.asMix[bCh].abSrcOnOff[bBlock]	&= (UINT8)~0x01;
+				sCurPathInfo.asMix[bCh].abSrcOnOff[bBlock]	|= 0x02;
+			}
+			if((psPathInfo->asMix[bCh].abSrcOnOff[bBlock] & (0x0C)) == 0x08)
+			{
+				sCurPathInfo.asMix[bCh].abSrcOnOff[bBlock]	&= (UINT8)~0x04;
+				sCurPathInfo.asMix[bCh].abSrcOnOff[bBlock]	|= 0x08;
+			}
+			if((psPathInfo->asMix[bCh].abSrcOnOff[bBlock] & (0x30)) == 0x20)
+			{
+				sCurPathInfo.asMix[bCh].abSrcOnOff[bBlock]	&= (UINT8)~0x10;
+				sCurPathInfo.asMix[bCh].abSrcOnOff[bBlock]	|= 0x20;
+			}
+			if((psPathInfo->asMix[bCh].abSrcOnOff[bBlock] & (0xC0)) == 0x80)
+			{
+				sCurPathInfo.asMix[bCh].abSrcOnOff[bBlock]	&= (UINT8)~0x40;
+				sCurPathInfo.asMix[bCh].abSrcOnOff[bBlock]	|= 0x80;
+			}
+		}
+	}
+
+	if((sCurPathInfo.asDit0[0].abSrcOnOff[MCDRV_SRC_PDM_BLOCK] & MCDRV_SRC4_PDM_ON) == MCDRV_SRC4_PDM_ON
+	|| (sCurPathInfo.asDit1[0].abSrcOnOff[MCDRV_SRC_PDM_BLOCK] & MCDRV_SRC4_PDM_ON) == MCDRV_SRC4_PDM_ON
+	|| (sCurPathInfo.asDit2[0].abSrcOnOff[MCDRV_SRC_PDM_BLOCK] & MCDRV_SRC4_PDM_ON) == MCDRV_SRC4_PDM_ON
+	|| (sCurPathInfo.asDac[0].abSrcOnOff[MCDRV_SRC_PDM_BLOCK] & MCDRV_SRC4_PDM_ON) == MCDRV_SRC4_PDM_ON
+	|| (sCurPathInfo.asDac[1].abSrcOnOff[MCDRV_SRC_PDM_BLOCK] & MCDRV_SRC4_PDM_ON) == MCDRV_SRC4_PDM_ON
+	|| (sCurPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_PDM_BLOCK] & MCDRV_SRC4_PDM_ON) == MCDRV_SRC4_PDM_ON
+	|| (sCurPathInfo.asMix[0].abSrcOnOff[MCDRV_SRC_PDM_BLOCK] & MCDRV_SRC4_PDM_ON) == MCDRV_SRC4_PDM_ON)
+	{
+		bPDMIsSrc	= 1;
+	}
+	if((sCurPathInfo.asDit0[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK] & MCDRV_SRC4_ADC0_ON) == MCDRV_SRC4_ADC0_ON
+	|| (sCurPathInfo.asDit1[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK] & MCDRV_SRC4_ADC0_ON) == MCDRV_SRC4_ADC0_ON
+	|| (sCurPathInfo.asDit2[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK] & MCDRV_SRC4_ADC0_ON) == MCDRV_SRC4_ADC0_ON
+	|| (sCurPathInfo.asDac[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK] & MCDRV_SRC4_ADC0_ON) == MCDRV_SRC4_ADC0_ON
+	|| (sCurPathInfo.asDac[1].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK] & MCDRV_SRC4_ADC0_ON) == MCDRV_SRC4_ADC0_ON
+	|| (sCurPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK] & MCDRV_SRC4_ADC0_ON) == MCDRV_SRC4_ADC0_ON
+	|| (sCurPathInfo.asMix[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK] & MCDRV_SRC4_ADC0_ON) == MCDRV_SRC4_ADC0_ON)
+	{
+		bADC0IsSrc	= 1;
+	}
+
+	/*	HP	*/
+	if((psPathInfo->asHpOut[0].abSrcOnOff[MCDRV_SRC_LINE1_L_BLOCK] & (MCDRV_SRC1_LINE1_L_ON|MCDRV_SRC1_LINE1_L_OFF)) == MCDRV_SRC1_LINE1_L_ON)
+	{
+		if(((psPathInfo->asHpOut[0].abSrcOnOff[MCDRV_SRC_LINE1_M_BLOCK] & (MCDRV_SRC1_LINE1_M_ON|MCDRV_SRC1_LINE1_M_OFF)) == MCDRV_SRC1_LINE1_M_ON)
+		|| ((sCurPathInfo.asHpOut[0].abSrcOnOff[MCDRV_SRC_LINE1_M_BLOCK] & (MCDRV_SRC1_LINE1_M_ON|MCDRV_SRC1_LINE1_M_OFF)) == MCDRV_SRC1_LINE1_M_ON))
+		{
+			return MCDRV_ERROR_ARGUMENT;
+		}
+	}
+	if((psPathInfo->asHpOut[0].abSrcOnOff[MCDRV_SRC_LINE1_M_BLOCK] & (MCDRV_SRC1_LINE1_M_ON|MCDRV_SRC1_LINE1_M_OFF)) == MCDRV_SRC1_LINE1_M_ON)
+	{
+		if((sCurPathInfo.asHpOut[0].abSrcOnOff[MCDRV_SRC_LINE1_L_BLOCK] & (MCDRV_SRC1_LINE1_L_ON|MCDRV_SRC1_LINE1_L_OFF)) == MCDRV_SRC1_LINE1_L_ON)
+		{
+			return MCDRV_ERROR_ARGUMENT;
+		}
+	}
+	if((psPathInfo->asHpOut[0].abSrcOnOff[MCDRV_SRC_DAC_L_BLOCK] & (MCDRV_SRC5_DAC_L_ON|MCDRV_SRC5_DAC_L_OFF)) == MCDRV_SRC5_DAC_L_ON)
+	{
+		if(((psPathInfo->asHpOut[0].abSrcOnOff[MCDRV_SRC_DAC_M_BLOCK] & (MCDRV_SRC5_DAC_M_ON|MCDRV_SRC5_DAC_M_OFF)) == MCDRV_SRC5_DAC_M_ON)
+		|| ((sCurPathInfo.asHpOut[0].abSrcOnOff[MCDRV_SRC_DAC_M_BLOCK] & (MCDRV_SRC5_DAC_M_ON|MCDRV_SRC5_DAC_M_OFF)) == MCDRV_SRC5_DAC_M_ON))
+		{
+			return MCDRV_ERROR_ARGUMENT;
+		}
+	}
+	if((psPathInfo->asHpOut[0].abSrcOnOff[MCDRV_SRC_DAC_M_BLOCK] & (MCDRV_SRC5_DAC_M_ON|MCDRV_SRC5_DAC_M_OFF)) == MCDRV_SRC5_DAC_M_ON)
+	{
+		if((sCurPathInfo.asHpOut[0].abSrcOnOff[MCDRV_SRC_DAC_L_BLOCK] & (MCDRV_SRC5_DAC_L_ON|MCDRV_SRC5_DAC_L_OFF)) == MCDRV_SRC5_DAC_L_ON)
+		{
+			return MCDRV_ERROR_ARGUMENT;
+		}
+	}
+
+	/*	SP	*/
+	if((psPathInfo->asSpOut[0].abSrcOnOff[MCDRV_SRC_LINE1_L_BLOCK] & (MCDRV_SRC1_LINE1_L_ON|MCDRV_SRC1_LINE1_L_OFF)) == MCDRV_SRC1_LINE1_L_ON)
+	{
+		if(((psPathInfo->asSpOut[0].abSrcOnOff[MCDRV_SRC_LINE1_M_BLOCK] & (MCDRV_SRC1_LINE1_M_ON|MCDRV_SRC1_LINE1_M_OFF)) == MCDRV_SRC1_LINE1_M_ON)
+		|| ((sCurPathInfo.asSpOut[0].abSrcOnOff[MCDRV_SRC_LINE1_M_BLOCK] & (MCDRV_SRC1_LINE1_M_ON|MCDRV_SRC1_LINE1_M_OFF)) == MCDRV_SRC1_LINE1_M_ON))
+		{
+			return MCDRV_ERROR_ARGUMENT;
+		}
+	}
+	if((psPathInfo->asSpOut[0].abSrcOnOff[MCDRV_SRC_LINE1_M_BLOCK] & (MCDRV_SRC1_LINE1_M_ON|MCDRV_SRC1_LINE1_M_OFF)) == MCDRV_SRC1_LINE1_M_ON)
+	{
+		if((sCurPathInfo.asSpOut[0].abSrcOnOff[MCDRV_SRC_LINE1_L_BLOCK] & (MCDRV_SRC1_LINE1_L_ON|MCDRV_SRC1_LINE1_L_OFF)) == MCDRV_SRC1_LINE1_L_ON)
+		{
+			return MCDRV_ERROR_ARGUMENT;
+		}
+	}
+	if((psPathInfo->asSpOut[0].abSrcOnOff[MCDRV_SRC_DAC_L_BLOCK] & (MCDRV_SRC5_DAC_L_ON|MCDRV_SRC5_DAC_L_OFF)) == MCDRV_SRC5_DAC_L_ON)
+	{
+		if(((psPathInfo->asSpOut[0].abSrcOnOff[MCDRV_SRC_DAC_M_BLOCK] & (MCDRV_SRC5_DAC_M_ON|MCDRV_SRC5_DAC_M_OFF)) == MCDRV_SRC5_DAC_M_ON)
+		|| ((sCurPathInfo.asSpOut[0].abSrcOnOff[MCDRV_SRC_DAC_M_BLOCK] & (MCDRV_SRC5_DAC_M_ON|MCDRV_SRC5_DAC_M_OFF)) == MCDRV_SRC5_DAC_M_ON))
+		{
+			return MCDRV_ERROR_ARGUMENT;
+		}
+	}
+	if((psPathInfo->asSpOut[0].abSrcOnOff[MCDRV_SRC_DAC_M_BLOCK] & (MCDRV_SRC5_DAC_M_ON|MCDRV_SRC5_DAC_M_OFF)) == MCDRV_SRC5_DAC_M_ON)
+	{
+		if((sCurPathInfo.asSpOut[0].abSrcOnOff[MCDRV_SRC_DAC_L_BLOCK] & (MCDRV_SRC5_DAC_L_ON|MCDRV_SRC5_DAC_L_OFF)) == MCDRV_SRC5_DAC_L_ON)
+		{
+			return MCDRV_ERROR_ARGUMENT;
+		}
+	}
+	if((psPathInfo->asSpOut[1].abSrcOnOff[MCDRV_SRC_LINE1_R_BLOCK] & (MCDRV_SRC1_LINE1_R_ON|MCDRV_SRC1_LINE1_R_OFF)) == MCDRV_SRC1_LINE1_R_ON)
+	{
+		if(((psPathInfo->asSpOut[1].abSrcOnOff[MCDRV_SRC_LINE1_M_BLOCK] & (MCDRV_SRC1_LINE1_M_ON|MCDRV_SRC1_LINE1_M_OFF)) == MCDRV_SRC1_LINE1_M_ON)
+		|| ((sCurPathInfo.asSpOut[1].abSrcOnOff[MCDRV_SRC_LINE1_M_BLOCK] & (MCDRV_SRC1_LINE1_M_ON|MCDRV_SRC1_LINE1_M_OFF)) == MCDRV_SRC1_LINE1_M_ON))
+		{
+			return MCDRV_ERROR_ARGUMENT;
+		}
+	}
+	if((psPathInfo->asSpOut[1].abSrcOnOff[MCDRV_SRC_LINE1_M_BLOCK] & (MCDRV_SRC1_LINE1_M_ON|MCDRV_SRC1_LINE1_M_OFF)) == MCDRV_SRC1_LINE1_M_ON)
+	{
+		if((sCurPathInfo.asSpOut[1].abSrcOnOff[MCDRV_SRC_LINE1_R_BLOCK] & (MCDRV_SRC1_LINE1_R_ON|MCDRV_SRC1_LINE1_R_OFF)) == MCDRV_SRC1_LINE1_R_ON)
+		{
+			return MCDRV_ERROR_ARGUMENT;
+		}
+	}
+	if((psPathInfo->asSpOut[1].abSrcOnOff[MCDRV_SRC_DAC_R_BLOCK] & (MCDRV_SRC5_DAC_R_ON|MCDRV_SRC5_DAC_R_OFF)) == MCDRV_SRC5_DAC_R_ON)
+	{
+		if(((psPathInfo->asSpOut[1].abSrcOnOff[MCDRV_SRC_DAC_M_BLOCK] & (MCDRV_SRC5_DAC_M_ON|MCDRV_SRC5_DAC_M_OFF)) == MCDRV_SRC5_DAC_M_ON)
+		|| ((sCurPathInfo.asSpOut[1].abSrcOnOff[MCDRV_SRC_DAC_M_BLOCK] & (MCDRV_SRC5_DAC_M_ON|MCDRV_SRC5_DAC_M_OFF)) == MCDRV_SRC5_DAC_M_ON))
+		{
+			return MCDRV_ERROR_ARGUMENT;
+		}
+	}
+	if((psPathInfo->asSpOut[1].abSrcOnOff[MCDRV_SRC_DAC_M_BLOCK] & (MCDRV_SRC5_DAC_M_ON|MCDRV_SRC5_DAC_M_OFF)) == MCDRV_SRC5_DAC_M_ON)
+	{
+		if((sCurPathInfo.asSpOut[1].abSrcOnOff[MCDRV_SRC_DAC_R_BLOCK] & (MCDRV_SRC5_DAC_R_ON|MCDRV_SRC5_DAC_R_OFF)) == MCDRV_SRC5_DAC_R_ON)
+		{
+			return MCDRV_ERROR_ARGUMENT;
+		}
+	}
+
+	/*	RCV	*/
+
+	/*	LOUT1	*/
+	if((psPathInfo->asLout1[0].abSrcOnOff[MCDRV_SRC_LINE1_L_BLOCK] & (MCDRV_SRC1_LINE1_L_ON|MCDRV_SRC1_LINE1_L_OFF)) == MCDRV_SRC1_LINE1_L_ON)
+	{
+		if(((psPathInfo->asLout1[0].abSrcOnOff[MCDRV_SRC_LINE1_M_BLOCK] & (MCDRV_SRC1_LINE1_M_ON|MCDRV_SRC1_LINE1_M_OFF)) == MCDRV_SRC1_LINE1_M_ON)
+		|| ((sCurPathInfo.asLout1[0].abSrcOnOff[MCDRV_SRC_LINE1_M_BLOCK] & (MCDRV_SRC1_LINE1_M_ON|MCDRV_SRC1_LINE1_M_OFF)) == MCDRV_SRC1_LINE1_M_ON))
+		{
+			return MCDRV_ERROR_ARGUMENT;
+		}
+	}
+	if((psPathInfo->asLout1[0].abSrcOnOff[MCDRV_SRC_LINE1_M_BLOCK] & (MCDRV_SRC1_LINE1_M_ON|MCDRV_SRC1_LINE1_M_OFF)) == MCDRV_SRC1_LINE1_M_ON)
+	{
+		if((sCurPathInfo.asLout1[0].abSrcOnOff[MCDRV_SRC_LINE1_L_BLOCK] & (MCDRV_SRC1_LINE1_L_ON|MCDRV_SRC1_LINE1_L_OFF)) == MCDRV_SRC1_LINE1_L_ON)
+		{
+			return MCDRV_ERROR_ARGUMENT;
+		}
+	}
+	if((psPathInfo->asLout1[0].abSrcOnOff[MCDRV_SRC_DAC_L_BLOCK] & (MCDRV_SRC5_DAC_L_ON|MCDRV_SRC5_DAC_L_OFF)) == MCDRV_SRC5_DAC_L_ON)
+	{
+		if(((psPathInfo->asLout1[0].abSrcOnOff[MCDRV_SRC_DAC_M_BLOCK] & (MCDRV_SRC5_DAC_M_ON|MCDRV_SRC5_DAC_M_OFF)) == MCDRV_SRC5_DAC_M_ON)
+		|| ((sCurPathInfo.asLout1[0].abSrcOnOff[MCDRV_SRC_DAC_M_BLOCK] & (MCDRV_SRC5_DAC_M_ON|MCDRV_SRC5_DAC_M_OFF)) == MCDRV_SRC5_DAC_M_ON))
+		{
+			return MCDRV_ERROR_ARGUMENT;
+		}
+	}
+	if((psPathInfo->asLout1[0].abSrcOnOff[MCDRV_SRC_DAC_M_BLOCK] & (MCDRV_SRC5_DAC_M_ON|MCDRV_SRC5_DAC_M_OFF)) == MCDRV_SRC5_DAC_M_ON)
+	{
+		if((sCurPathInfo.asLout1[0].abSrcOnOff[MCDRV_SRC_DAC_L_BLOCK] & (MCDRV_SRC5_DAC_L_ON|MCDRV_SRC5_DAC_L_OFF)) == MCDRV_SRC5_DAC_L_ON)
+		{
+			return MCDRV_ERROR_ARGUMENT;
+		}
+	}
+
+	/*	LOUT2	*/
+	if((psPathInfo->asLout2[0].abSrcOnOff[MCDRV_SRC_LINE1_L_BLOCK] & (MCDRV_SRC1_LINE1_L_ON|MCDRV_SRC1_LINE1_L_OFF)) == MCDRV_SRC1_LINE1_L_ON)
+	{
+		if(((psPathInfo->asLout2[0].abSrcOnOff[MCDRV_SRC_LINE1_M_BLOCK] & (MCDRV_SRC1_LINE1_M_ON|MCDRV_SRC1_LINE1_M_OFF)) == MCDRV_SRC1_LINE1_M_ON)
+		|| ((sCurPathInfo.asLout2[0].abSrcOnOff[MCDRV_SRC_LINE1_M_BLOCK] & (MCDRV_SRC1_LINE1_M_ON|MCDRV_SRC1_LINE1_M_OFF)) == MCDRV_SRC1_LINE1_M_ON))
+		{
+			return MCDRV_ERROR_ARGUMENT;
+		}
+	}
+	if((psPathInfo->asLout2[0].abSrcOnOff[MCDRV_SRC_LINE1_M_BLOCK] & (MCDRV_SRC1_LINE1_M_ON|MCDRV_SRC1_LINE1_M_OFF)) == MCDRV_SRC1_LINE1_M_ON)
+	{
+		if((sCurPathInfo.asLout2[0].abSrcOnOff[MCDRV_SRC_LINE1_L_BLOCK] & (MCDRV_SRC1_LINE1_L_ON|MCDRV_SRC1_LINE1_L_OFF)) == MCDRV_SRC1_LINE1_L_ON)
+		{
+			return MCDRV_ERROR_ARGUMENT;
+		}
+	}
+	if((psPathInfo->asLout2[0].abSrcOnOff[MCDRV_SRC_DAC_L_BLOCK] & (MCDRV_SRC5_DAC_L_ON|MCDRV_SRC5_DAC_L_OFF)) == MCDRV_SRC5_DAC_L_ON)
+	{
+		if(((psPathInfo->asLout2[0].abSrcOnOff[MCDRV_SRC_DAC_M_BLOCK] & (MCDRV_SRC5_DAC_M_ON|MCDRV_SRC5_DAC_M_OFF)) == MCDRV_SRC5_DAC_M_ON)
+		|| ((sCurPathInfo.asLout2[0].abSrcOnOff[MCDRV_SRC_DAC_M_BLOCK] & (MCDRV_SRC5_DAC_M_ON|MCDRV_SRC5_DAC_M_OFF)) == MCDRV_SRC5_DAC_M_ON))
+		{
+			return MCDRV_ERROR_ARGUMENT;
+		}
+	}
+	if((psPathInfo->asLout2[0].abSrcOnOff[MCDRV_SRC_DAC_M_BLOCK] & (MCDRV_SRC5_DAC_M_ON|MCDRV_SRC5_DAC_M_OFF)) == MCDRV_SRC5_DAC_M_ON)
+	{
+		if((sCurPathInfo.asLout2[0].abSrcOnOff[MCDRV_SRC_DAC_L_BLOCK] & (MCDRV_SRC5_DAC_L_ON|MCDRV_SRC5_DAC_L_OFF)) == MCDRV_SRC5_DAC_L_ON)
+		{
+			return MCDRV_ERROR_ARGUMENT;
+		}
+	}
+
+	/*	PeakMeter	*/
+
+	/*	DIT0	*/
+	if((psPathInfo->asDit0[0].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK] & (MCDRV_SRC3_DIR0_ON|MCDRV_SRC3_DIR0_OFF)) == MCDRV_SRC3_DIR0_ON)
+	{
+		if((psPathInfo->asDit0[0].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK] & (MCDRV_SRC3_DIR1_ON|MCDRV_SRC3_DIR1_OFF)) == MCDRV_SRC3_DIR1_ON
+		|| (psPathInfo->asDit0[0].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK] & (MCDRV_SRC3_DIR2_ON|MCDRV_SRC3_DIR2_OFF)) == MCDRV_SRC3_DIR2_ON
+		|| (psPathInfo->asDit0[0].abSrcOnOff[MCDRV_SRC_PDM_BLOCK] & (MCDRV_SRC4_PDM_ON|MCDRV_SRC4_PDM_OFF)) == MCDRV_SRC4_PDM_ON
+		|| (psPathInfo->asDit0[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK] & (MCDRV_SRC4_ADC0_ON|MCDRV_SRC4_ADC0_OFF)) == MCDRV_SRC4_ADC0_ON
+		|| (psPathInfo->asDit0[0].abSrcOnOff[MCDRV_SRC_AE_BLOCK] & (MCDRV_SRC6_AE_ON|MCDRV_SRC6_AE_OFF)) == MCDRV_SRC6_AE_ON
+		|| (psPathInfo->asDit0[0].abSrcOnOff[MCDRV_SRC_MIX_BLOCK] & (MCDRV_SRC6_MIX_ON|MCDRV_SRC6_MIX_OFF)) == MCDRV_SRC6_MIX_ON
+		|| (sCurPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK] & (MCDRV_SRC3_DIR0_ON|MCDRV_SRC3_DIR0_OFF)) == MCDRV_SRC3_DIR0_ON)
+		{
+			return MCDRV_ERROR_ARGUMENT;
+		}
+	}
+	if((psPathInfo->asDit0[0].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK] & (MCDRV_SRC3_DIR1_ON|MCDRV_SRC3_DIR1_OFF)) == MCDRV_SRC3_DIR1_ON)
+	{
+		if((psPathInfo->asDit0[0].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK] & (MCDRV_SRC3_DIR2_ON|MCDRV_SRC3_DIR2_OFF)) == MCDRV_SRC3_DIR2_ON
+		|| (psPathInfo->asDit0[0].abSrcOnOff[MCDRV_SRC_PDM_BLOCK] & (MCDRV_SRC4_PDM_ON|MCDRV_SRC4_PDM_OFF)) == MCDRV_SRC4_PDM_ON
+		|| (psPathInfo->asDit0[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK] & (MCDRV_SRC4_ADC0_ON|MCDRV_SRC4_ADC0_OFF)) == MCDRV_SRC4_ADC0_ON
+		|| (psPathInfo->asDit0[0].abSrcOnOff[MCDRV_SRC_AE_BLOCK] & (MCDRV_SRC6_AE_ON|MCDRV_SRC6_AE_OFF)) == MCDRV_SRC6_AE_ON
+		|| (psPathInfo->asDit0[0].abSrcOnOff[MCDRV_SRC_MIX_BLOCK] & (MCDRV_SRC6_MIX_ON|MCDRV_SRC6_MIX_OFF)) == MCDRV_SRC6_MIX_ON
+		|| (sCurPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK] & (MCDRV_SRC3_DIR1_ON|MCDRV_SRC3_DIR1_OFF)) == MCDRV_SRC3_DIR1_ON)
+		{
+			return MCDRV_ERROR_ARGUMENT;
+		}
+	}
+	if((psPathInfo->asDit0[0].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK] & (MCDRV_SRC3_DIR2_ON|MCDRV_SRC3_DIR2_OFF)) == MCDRV_SRC3_DIR2_ON)
+	{
+		if((psPathInfo->asDit0[0].abSrcOnOff[MCDRV_SRC_PDM_BLOCK] & (MCDRV_SRC4_PDM_ON|MCDRV_SRC4_PDM_OFF)) == MCDRV_SRC4_PDM_ON
+		|| (psPathInfo->asDit0[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK] & (MCDRV_SRC4_ADC0_ON|MCDRV_SRC4_ADC0_OFF)) == MCDRV_SRC4_ADC0_ON
+		|| (psPathInfo->asDit0[0].abSrcOnOff[MCDRV_SRC_AE_BLOCK] & (MCDRV_SRC6_AE_ON|MCDRV_SRC6_AE_OFF)) == MCDRV_SRC6_AE_ON
+		|| (psPathInfo->asDit0[0].abSrcOnOff[MCDRV_SRC_MIX_BLOCK] & (MCDRV_SRC6_MIX_ON|MCDRV_SRC6_MIX_OFF)) == MCDRV_SRC6_MIX_ON
+		|| (sCurPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK] & (MCDRV_SRC3_DIR2_ON|MCDRV_SRC3_DIR2_OFF)) == MCDRV_SRC3_DIR2_ON)
+		{
+			return MCDRV_ERROR_ARGUMENT;
+		}
+	}
+	if((psPathInfo->asDit0[0].abSrcOnOff[MCDRV_SRC_PDM_BLOCK] & (MCDRV_SRC4_PDM_ON|MCDRV_SRC4_PDM_OFF)) == MCDRV_SRC4_PDM_ON)
+	{
+		if((psPathInfo->asDit0[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK] & (MCDRV_SRC4_ADC0_ON|MCDRV_SRC4_ADC0_OFF)) == MCDRV_SRC4_ADC0_ON
+		|| (psPathInfo->asDit0[0].abSrcOnOff[MCDRV_SRC_AE_BLOCK] & (MCDRV_SRC6_AE_ON|MCDRV_SRC6_AE_OFF)) == MCDRV_SRC6_AE_ON
+		|| (psPathInfo->asDit0[0].abSrcOnOff[MCDRV_SRC_MIX_BLOCK] & (MCDRV_SRC6_MIX_ON|MCDRV_SRC6_MIX_OFF)) == MCDRV_SRC6_MIX_ON
+		|| (sCurPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_PDM_BLOCK] & (MCDRV_SRC4_PDM_ON|MCDRV_SRC4_PDM_OFF)) == MCDRV_SRC4_PDM_ON)
+		{
+			return MCDRV_ERROR_ARGUMENT;
+		}
+	}
+	if((psPathInfo->asDit0[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK] & (MCDRV_SRC4_ADC0_ON|MCDRV_SRC4_ADC0_OFF)) == MCDRV_SRC4_ADC0_ON)
+	{
+		if((psPathInfo->asDit0[0].abSrcOnOff[MCDRV_SRC_AE_BLOCK] & (MCDRV_SRC6_AE_ON|MCDRV_SRC6_AE_OFF)) == MCDRV_SRC6_AE_ON
+		|| (psPathInfo->asDit0[0].abSrcOnOff[MCDRV_SRC_MIX_BLOCK] & (MCDRV_SRC6_MIX_ON|MCDRV_SRC6_MIX_OFF)) == MCDRV_SRC6_MIX_ON
+		|| (sCurPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK] & (MCDRV_SRC4_ADC0_ON|MCDRV_SRC4_ADC0_OFF)) == MCDRV_SRC4_ADC0_ON)
+		{
+			return MCDRV_ERROR_ARGUMENT;
+		}
+	}
+	if((psPathInfo->asDit0[0].abSrcOnOff[MCDRV_SRC_AE_BLOCK] & (MCDRV_SRC6_AE_ON|MCDRV_SRC6_AE_OFF)) == MCDRV_SRC6_AE_ON)
+	{
+		if((psPathInfo->asDit0[0].abSrcOnOff[MCDRV_SRC_MIX_BLOCK] & (MCDRV_SRC6_MIX_ON|MCDRV_SRC6_MIX_OFF)) == MCDRV_SRC6_MIX_ON)
+		{
+			return MCDRV_ERROR_ARGUMENT;
+		}
+	}
+	if((psPathInfo->asDit0[0].abSrcOnOff[MCDRV_SRC_MIX_BLOCK] & (MCDRV_SRC6_MIX_ON|MCDRV_SRC6_MIX_OFF)) == MCDRV_SRC6_MIX_ON)
+	{
+		if((sCurPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_MIX_BLOCK] & (MCDRV_SRC6_MIX_ON|MCDRV_SRC6_MIX_OFF)) == MCDRV_SRC6_MIX_ON)
+		{
+			return MCDRV_ERROR_ARGUMENT;
+		}
+	}
+
+	if((psPathInfo->asDit0[0].abSrcOnOff[MCDRV_SRC_PDM_BLOCK] & (MCDRV_SRC4_PDM_ON|MCDRV_SRC4_PDM_OFF)) == MCDRV_SRC4_PDM_ON)
+	{
+		if(bADC0IsSrc == 1)
+		{
+			return MCDRV_ERROR_ARGUMENT;
+		}
+		else
+		{
+			bPDMIsSrc	= 1;
+		}
+	}
+	if((psPathInfo->asDit0[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK] & (MCDRV_SRC4_ADC0_ON|MCDRV_SRC4_ADC0_OFF)) == MCDRV_SRC4_ADC0_ON)
+	{
+		if(bPDMIsSrc == 1)
+		{
+			return MCDRV_ERROR_ARGUMENT;
+		}
+		else
+		{
+			bADC0IsSrc	= 1;
+		}
+	}
+
+	/*	DIT1	*/
+	if((psPathInfo->asDit1[0].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK] & (MCDRV_SRC3_DIR0_ON|MCDRV_SRC3_DIR0_OFF)) == MCDRV_SRC3_DIR0_ON)
+	{
+		if((psPathInfo->asDit1[0].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK] & (MCDRV_SRC3_DIR1_ON|MCDRV_SRC3_DIR1_OFF)) == MCDRV_SRC3_DIR1_ON
+		|| (psPathInfo->asDit1[0].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK] & (MCDRV_SRC3_DIR2_ON|MCDRV_SRC3_DIR2_OFF)) == MCDRV_SRC3_DIR2_ON
+		|| (psPathInfo->asDit1[0].abSrcOnOff[MCDRV_SRC_PDM_BLOCK] & (MCDRV_SRC4_PDM_ON|MCDRV_SRC4_PDM_OFF)) == MCDRV_SRC4_PDM_ON
+		|| (psPathInfo->asDit1[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK] & (MCDRV_SRC4_ADC0_ON|MCDRV_SRC4_ADC0_OFF)) == MCDRV_SRC4_ADC0_ON
+		|| (psPathInfo->asDit1[0].abSrcOnOff[MCDRV_SRC_AE_BLOCK] & (MCDRV_SRC6_AE_ON|MCDRV_SRC6_AE_OFF)) == MCDRV_SRC6_AE_ON
+		|| (psPathInfo->asDit1[0].abSrcOnOff[MCDRV_SRC_MIX_BLOCK] & (MCDRV_SRC6_MIX_ON|MCDRV_SRC6_MIX_OFF)) == MCDRV_SRC6_MIX_ON
+		|| (sCurPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK] & (MCDRV_SRC3_DIR0_ON|MCDRV_SRC3_DIR0_OFF)) == MCDRV_SRC3_DIR0_ON)
+		{
+			return MCDRV_ERROR_ARGUMENT;
+		}
+	}
+	if((psPathInfo->asDit1[0].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK] & (MCDRV_SRC3_DIR1_ON|MCDRV_SRC3_DIR1_OFF)) == MCDRV_SRC3_DIR1_ON)
+	{
+		if((psPathInfo->asDit1[0].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK] & (MCDRV_SRC3_DIR2_ON|MCDRV_SRC3_DIR2_OFF)) == MCDRV_SRC3_DIR2_ON
+		|| (psPathInfo->asDit1[0].abSrcOnOff[MCDRV_SRC_PDM_BLOCK] & (MCDRV_SRC4_PDM_ON|MCDRV_SRC4_PDM_OFF)) == MCDRV_SRC4_PDM_ON
+		|| (psPathInfo->asDit1[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK] & (MCDRV_SRC4_ADC0_ON|MCDRV_SRC4_ADC0_OFF)) == MCDRV_SRC4_ADC0_ON
+		|| (psPathInfo->asDit1[0].abSrcOnOff[MCDRV_SRC_AE_BLOCK] & (MCDRV_SRC6_AE_ON|MCDRV_SRC6_AE_OFF)) == MCDRV_SRC6_AE_ON
+		|| (psPathInfo->asDit1[0].abSrcOnOff[MCDRV_SRC_MIX_BLOCK] & (MCDRV_SRC6_MIX_ON|MCDRV_SRC6_MIX_OFF)) == MCDRV_SRC6_MIX_ON
+		|| (sCurPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK] & (MCDRV_SRC3_DIR1_ON|MCDRV_SRC3_DIR1_OFF)) == MCDRV_SRC3_DIR1_ON)
+		{
+			return MCDRV_ERROR_ARGUMENT;
+		}
+	}
+	if((psPathInfo->asDit1[0].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK] & (MCDRV_SRC3_DIR2_ON|MCDRV_SRC3_DIR2_OFF)) == MCDRV_SRC3_DIR2_ON)
+	{
+		if((psPathInfo->asDit1[0].abSrcOnOff[MCDRV_SRC_PDM_BLOCK] & (MCDRV_SRC4_PDM_ON|MCDRV_SRC4_PDM_OFF)) == MCDRV_SRC4_PDM_ON
+		|| (psPathInfo->asDit1[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK] & (MCDRV_SRC4_ADC0_ON|MCDRV_SRC4_ADC0_OFF)) == MCDRV_SRC4_ADC0_ON
+		|| (psPathInfo->asDit1[0].abSrcOnOff[MCDRV_SRC_AE_BLOCK] & (MCDRV_SRC6_AE_ON|MCDRV_SRC6_AE_OFF)) == MCDRV_SRC6_AE_ON
+		|| (psPathInfo->asDit1[0].abSrcOnOff[MCDRV_SRC_MIX_BLOCK] & (MCDRV_SRC6_MIX_ON|MCDRV_SRC6_MIX_OFF)) == MCDRV_SRC6_MIX_ON
+		|| (sCurPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK] & (MCDRV_SRC3_DIR2_ON|MCDRV_SRC3_DIR2_OFF)) == MCDRV_SRC3_DIR2_ON)
+		{
+			return MCDRV_ERROR_ARGUMENT;
+		}
+	}
+	if((psPathInfo->asDit1[0].abSrcOnOff[MCDRV_SRC_PDM_BLOCK] & (MCDRV_SRC4_PDM_ON|MCDRV_SRC4_PDM_OFF)) == MCDRV_SRC4_PDM_ON)
+	{
+		if((psPathInfo->asDit1[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK] & (MCDRV_SRC4_ADC0_ON|MCDRV_SRC4_ADC0_OFF)) == MCDRV_SRC4_ADC0_ON
+		|| (psPathInfo->asDit1[0].abSrcOnOff[MCDRV_SRC_AE_BLOCK] & (MCDRV_SRC6_AE_ON|MCDRV_SRC6_AE_OFF)) == MCDRV_SRC6_AE_ON
+		|| (psPathInfo->asDit1[0].abSrcOnOff[MCDRV_SRC_MIX_BLOCK] & (MCDRV_SRC6_MIX_ON|MCDRV_SRC6_MIX_OFF)) == MCDRV_SRC6_MIX_ON
+		|| (sCurPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_PDM_BLOCK] & (MCDRV_SRC4_PDM_ON|MCDRV_SRC4_PDM_OFF)) == MCDRV_SRC4_PDM_ON)
+		{
+			return MCDRV_ERROR_ARGUMENT;
+		}
+	}
+	if((psPathInfo->asDit1[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK] & (MCDRV_SRC4_ADC0_ON|MCDRV_SRC4_ADC0_OFF)) == MCDRV_SRC4_ADC0_ON)
+	{
+		if((psPathInfo->asDit1[0].abSrcOnOff[MCDRV_SRC_AE_BLOCK] & (MCDRV_SRC6_AE_ON|MCDRV_SRC6_AE_OFF)) == MCDRV_SRC6_AE_ON
+		|| (psPathInfo->asDit1[0].abSrcOnOff[MCDRV_SRC_MIX_BLOCK] & (MCDRV_SRC6_MIX_ON|MCDRV_SRC6_MIX_OFF)) == MCDRV_SRC6_MIX_ON
+		|| (sCurPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK] & (MCDRV_SRC4_ADC0_ON|MCDRV_SRC4_ADC0_OFF)) == MCDRV_SRC4_ADC0_ON)
+		{
+			return MCDRV_ERROR_ARGUMENT;
+		}
+	}
+	if((psPathInfo->asDit1[0].abSrcOnOff[MCDRV_SRC_AE_BLOCK] & (MCDRV_SRC6_AE_ON|MCDRV_SRC6_AE_OFF)) == MCDRV_SRC6_AE_ON)
+	{
+		if((psPathInfo->asDit1[0].abSrcOnOff[MCDRV_SRC_MIX_BLOCK] & (MCDRV_SRC6_MIX_ON|MCDRV_SRC6_MIX_OFF)) == MCDRV_SRC6_MIX_ON)
+		{
+			return MCDRV_ERROR_ARGUMENT;
+		}
+	}
+	if((psPathInfo->asDit1[0].abSrcOnOff[MCDRV_SRC_MIX_BLOCK] & (MCDRV_SRC6_MIX_ON|MCDRV_SRC6_MIX_OFF)) == MCDRV_SRC6_MIX_ON)
+	{
+		if((sCurPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_MIX_BLOCK] & (MCDRV_SRC6_MIX_ON|MCDRV_SRC6_MIX_OFF)) == MCDRV_SRC6_MIX_ON)
+		{
+			return MCDRV_ERROR_ARGUMENT;
+		}
+	}
+
+	if((psPathInfo->asDit1[0].abSrcOnOff[MCDRV_SRC_PDM_BLOCK] & (MCDRV_SRC4_PDM_ON|MCDRV_SRC4_PDM_OFF)) == MCDRV_SRC4_PDM_ON)
+	{
+		if(bADC0IsSrc == 1)
+		{
+			return MCDRV_ERROR_ARGUMENT;
+		}
+		else
+		{
+			bPDMIsSrc	= 1;
+		}
+	}
+	if((psPathInfo->asDit1[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK] & (MCDRV_SRC4_ADC0_ON|MCDRV_SRC4_ADC0_OFF)) == MCDRV_SRC4_ADC0_ON)
+	{
+		if(bPDMIsSrc == 1)
+		{
+			return MCDRV_ERROR_ARGUMENT;
+		}
+		else
+		{
+			bADC0IsSrc	= 1;
+		}
+	}
+
+	/*	DIT2	*/
+	if((psPathInfo->asDit2[0].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK] & (MCDRV_SRC3_DIR0_ON|MCDRV_SRC3_DIR0_OFF)) == MCDRV_SRC3_DIR0_ON)
+	{
+		if((psPathInfo->asDit2[0].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK] & (MCDRV_SRC3_DIR1_ON|MCDRV_SRC3_DIR1_OFF)) == MCDRV_SRC3_DIR1_ON
+		|| (psPathInfo->asDit2[0].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK] & (MCDRV_SRC3_DIR2_ON|MCDRV_SRC3_DIR2_OFF)) == MCDRV_SRC3_DIR2_ON
+		|| (psPathInfo->asDit2[0].abSrcOnOff[MCDRV_SRC_PDM_BLOCK] & (MCDRV_SRC4_PDM_ON|MCDRV_SRC4_PDM_OFF)) == MCDRV_SRC4_PDM_ON
+		|| (psPathInfo->asDit2[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK] & (MCDRV_SRC4_ADC0_ON|MCDRV_SRC4_ADC0_OFF)) == MCDRV_SRC4_ADC0_ON
+		|| (psPathInfo->asDit2[0].abSrcOnOff[MCDRV_SRC_AE_BLOCK] & (MCDRV_SRC6_AE_ON|MCDRV_SRC6_AE_OFF)) == MCDRV_SRC6_AE_ON
+		|| (psPathInfo->asDit2[0].abSrcOnOff[MCDRV_SRC_MIX_BLOCK] & (MCDRV_SRC6_MIX_ON|MCDRV_SRC6_MIX_OFF)) == MCDRV_SRC6_MIX_ON
+		|| (sCurPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK] & (MCDRV_SRC3_DIR0_ON|MCDRV_SRC3_DIR0_OFF)) == MCDRV_SRC3_DIR0_ON)
+		{
+			return MCDRV_ERROR_ARGUMENT;
+		}
+	}
+	if((psPathInfo->asDit2[0].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK] & (MCDRV_SRC3_DIR1_ON|MCDRV_SRC3_DIR1_OFF)) == MCDRV_SRC3_DIR1_ON)
+	{
+		if((psPathInfo->asDit2[0].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK] & (MCDRV_SRC3_DIR2_ON|MCDRV_SRC3_DIR2_OFF)) == MCDRV_SRC3_DIR2_ON
+		|| (psPathInfo->asDit2[0].abSrcOnOff[MCDRV_SRC_PDM_BLOCK] & (MCDRV_SRC4_PDM_ON|MCDRV_SRC4_PDM_OFF)) == MCDRV_SRC4_PDM_ON
+		|| (psPathInfo->asDit2[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK] & (MCDRV_SRC4_ADC0_ON|MCDRV_SRC4_ADC0_OFF)) == MCDRV_SRC4_ADC0_ON
+		|| (psPathInfo->asDit2[0].abSrcOnOff[MCDRV_SRC_AE_BLOCK] & (MCDRV_SRC6_AE_ON|MCDRV_SRC6_AE_OFF)) == MCDRV_SRC6_AE_ON
+		|| (psPathInfo->asDit2[0].abSrcOnOff[MCDRV_SRC_MIX_BLOCK] & (MCDRV_SRC6_MIX_ON|MCDRV_SRC6_MIX_OFF)) == MCDRV_SRC6_MIX_ON
+		|| (sCurPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK] & (MCDRV_SRC3_DIR1_ON|MCDRV_SRC3_DIR1_OFF)) == MCDRV_SRC3_DIR1_ON)
+		{
+			return MCDRV_ERROR_ARGUMENT;
+		}
+	}
+	if((psPathInfo->asDit2[0].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK] & (MCDRV_SRC3_DIR2_ON|MCDRV_SRC3_DIR2_OFF)) == MCDRV_SRC3_DIR2_ON)
+	{
+		if((psPathInfo->asDit2[0].abSrcOnOff[MCDRV_SRC_PDM_BLOCK] & (MCDRV_SRC4_PDM_ON|MCDRV_SRC4_PDM_OFF)) == MCDRV_SRC4_PDM_ON
+		|| (psPathInfo->asDit2[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK] & (MCDRV_SRC4_ADC0_ON|MCDRV_SRC4_ADC0_OFF)) == MCDRV_SRC4_ADC0_ON
+		|| (psPathInfo->asDit2[0].abSrcOnOff[MCDRV_SRC_AE_BLOCK] & (MCDRV_SRC6_AE_ON|MCDRV_SRC6_AE_OFF)) == MCDRV_SRC6_AE_ON
+		|| (psPathInfo->asDit2[0].abSrcOnOff[MCDRV_SRC_MIX_BLOCK] & (MCDRV_SRC6_MIX_ON|MCDRV_SRC6_MIX_OFF)) == MCDRV_SRC6_MIX_ON
+		|| (sCurPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK] & (MCDRV_SRC3_DIR2_ON|MCDRV_SRC3_DIR2_OFF)) == MCDRV_SRC3_DIR2_ON)
+		{
+			return MCDRV_ERROR_ARGUMENT;
+		}
+	}
+	if((psPathInfo->asDit2[0].abSrcOnOff[MCDRV_SRC_PDM_BLOCK] & (MCDRV_SRC4_PDM_ON|MCDRV_SRC4_PDM_OFF)) == MCDRV_SRC4_PDM_ON)
+	{
+		if((psPathInfo->asDit2[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK] & (MCDRV_SRC4_ADC0_ON|MCDRV_SRC4_ADC0_OFF)) == MCDRV_SRC4_ADC0_ON
+		|| (psPathInfo->asDit2[0].abSrcOnOff[MCDRV_SRC_AE_BLOCK] & (MCDRV_SRC6_AE_ON|MCDRV_SRC6_AE_OFF)) == MCDRV_SRC6_AE_ON
+		|| (psPathInfo->asDit2[0].abSrcOnOff[MCDRV_SRC_MIX_BLOCK] & (MCDRV_SRC6_MIX_ON|MCDRV_SRC6_MIX_OFF)) == MCDRV_SRC6_MIX_ON
+		|| (sCurPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_PDM_BLOCK] & (MCDRV_SRC4_PDM_ON|MCDRV_SRC4_PDM_OFF)) == MCDRV_SRC4_PDM_ON)
+		{
+			return MCDRV_ERROR_ARGUMENT;
+		}
+	}
+	if((psPathInfo->asDit2[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK] & (MCDRV_SRC4_ADC0_ON|MCDRV_SRC4_ADC0_OFF)) == MCDRV_SRC4_ADC0_ON)
+	{
+		if((psPathInfo->asDit2[0].abSrcOnOff[MCDRV_SRC_AE_BLOCK] & (MCDRV_SRC6_AE_ON|MCDRV_SRC6_AE_OFF)) == MCDRV_SRC6_AE_ON
+		|| (psPathInfo->asDit2[0].abSrcOnOff[MCDRV_SRC_MIX_BLOCK] & (MCDRV_SRC6_MIX_ON|MCDRV_SRC6_MIX_OFF)) == MCDRV_SRC6_MIX_ON
+		|| (sCurPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK] & (MCDRV_SRC4_ADC0_ON|MCDRV_SRC4_ADC0_OFF)) == MCDRV_SRC4_ADC0_ON)
+		{
+			return MCDRV_ERROR_ARGUMENT;
+		}
+	}
+	if((psPathInfo->asDit2[0].abSrcOnOff[MCDRV_SRC_AE_BLOCK] & (MCDRV_SRC6_AE_ON|MCDRV_SRC6_AE_OFF)) == MCDRV_SRC6_AE_ON)
+	{
+		if((psPathInfo->asDit2[0].abSrcOnOff[MCDRV_SRC_MIX_BLOCK] & (MCDRV_SRC6_MIX_ON|MCDRV_SRC6_MIX_OFF)) == MCDRV_SRC6_MIX_ON)
+		{
+			return MCDRV_ERROR_ARGUMENT;
+		}
+	}
+	if((psPathInfo->asDit2[0].abSrcOnOff[MCDRV_SRC_MIX_BLOCK] & (MCDRV_SRC6_MIX_ON|MCDRV_SRC6_MIX_OFF)) == MCDRV_SRC6_MIX_ON)
+	{
+		if((sCurPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_MIX_BLOCK] & (MCDRV_SRC6_MIX_ON|MCDRV_SRC6_MIX_OFF)) == MCDRV_SRC6_MIX_ON)
+		{
+			return MCDRV_ERROR_ARGUMENT;
+		}
+	}
+
+	if((psPathInfo->asDit2[0].abSrcOnOff[MCDRV_SRC_PDM_BLOCK] & (MCDRV_SRC4_PDM_ON|MCDRV_SRC4_PDM_OFF)) == MCDRV_SRC4_PDM_ON)
+	{
+		if(bADC0IsSrc == 1)
+		{
+			return MCDRV_ERROR_ARGUMENT;
+		}
+		else
+		{
+			bPDMIsSrc	= 1;
+		}
+	}
+	if((psPathInfo->asDit2[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK] & (MCDRV_SRC4_ADC0_ON|MCDRV_SRC4_ADC0_OFF)) == MCDRV_SRC4_ADC0_ON)
+	{
+		if(bPDMIsSrc == 1)
+		{
+			return MCDRV_ERROR_ARGUMENT;
+		}
+		else
+		{
+			bADC0IsSrc	= 1;
+		}
+	}
+
+	/*	DAC	*/
+	for(bCh = 0; bCh < DAC_PATH_CHANNELS; bCh++)
+	{
+		if((psPathInfo->asDac[bCh].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK] & (MCDRV_SRC3_DIR0_ON|MCDRV_SRC3_DIR0_OFF)) == MCDRV_SRC3_DIR0_ON)
+		{
+			if((psPathInfo->asDac[bCh].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK] & (MCDRV_SRC3_DIR1_ON|MCDRV_SRC3_DIR1_OFF)) == MCDRV_SRC3_DIR1_ON
+			|| (psPathInfo->asDac[bCh].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK] & (MCDRV_SRC3_DIR2_ON|MCDRV_SRC3_DIR2_OFF)) == MCDRV_SRC3_DIR2_ON
+			|| (psPathInfo->asDac[bCh].abSrcOnOff[MCDRV_SRC_PDM_BLOCK] & (MCDRV_SRC4_PDM_ON|MCDRV_SRC4_PDM_OFF)) == MCDRV_SRC4_PDM_ON
+			|| (psPathInfo->asDac[bCh].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK] & (MCDRV_SRC4_ADC0_ON|MCDRV_SRC4_ADC0_OFF)) == MCDRV_SRC4_ADC0_ON
+			|| (psPathInfo->asDac[bCh].abSrcOnOff[MCDRV_SRC_AE_BLOCK] & (MCDRV_SRC6_AE_ON|MCDRV_SRC6_AE_OFF)) == MCDRV_SRC6_AE_ON
+			|| (psPathInfo->asDac[bCh].abSrcOnOff[MCDRV_SRC_MIX_BLOCK] & (MCDRV_SRC6_MIX_ON|MCDRV_SRC6_MIX_OFF)) == MCDRV_SRC6_MIX_ON
+			|| (sCurPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK] & (MCDRV_SRC3_DIR0_ON|MCDRV_SRC3_DIR0_OFF)) == MCDRV_SRC3_DIR0_ON)
+			{
+				return MCDRV_ERROR_ARGUMENT;
+			}
+		}
+		if((psPathInfo->asDac[bCh].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK] & (MCDRV_SRC3_DIR1_ON|MCDRV_SRC3_DIR1_OFF)) == MCDRV_SRC3_DIR1_ON)
+		{
+			if((psPathInfo->asDac[bCh].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK] & (MCDRV_SRC3_DIR2_ON|MCDRV_SRC3_DIR2_OFF)) == MCDRV_SRC3_DIR2_ON
+			|| (psPathInfo->asDac[bCh].abSrcOnOff[MCDRV_SRC_PDM_BLOCK] & (MCDRV_SRC4_PDM_ON|MCDRV_SRC4_PDM_OFF)) == MCDRV_SRC4_PDM_ON
+			|| (psPathInfo->asDac[bCh].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK] & (MCDRV_SRC4_ADC0_ON|MCDRV_SRC4_ADC0_OFF)) == MCDRV_SRC4_ADC0_ON
+			|| (psPathInfo->asDac[bCh].abSrcOnOff[MCDRV_SRC_AE_BLOCK] & (MCDRV_SRC6_AE_ON|MCDRV_SRC6_AE_OFF)) == MCDRV_SRC6_AE_ON
+			|| (psPathInfo->asDac[bCh].abSrcOnOff[MCDRV_SRC_MIX_BLOCK] & (MCDRV_SRC6_MIX_ON|MCDRV_SRC6_MIX_OFF)) == MCDRV_SRC6_MIX_ON
+			|| (sCurPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK] & (MCDRV_SRC3_DIR1_ON|MCDRV_SRC3_DIR1_OFF)) == MCDRV_SRC3_DIR1_ON)
+			{
+				return MCDRV_ERROR_ARGUMENT;
+			}
+		}
+		if((psPathInfo->asDac[bCh].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK] & (MCDRV_SRC3_DIR2_ON|MCDRV_SRC3_DIR2_OFF)) == MCDRV_SRC3_DIR2_ON)
+		{
+			if((psPathInfo->asDac[bCh].abSrcOnOff[MCDRV_SRC_PDM_BLOCK] & (MCDRV_SRC4_PDM_ON|MCDRV_SRC4_PDM_OFF)) == MCDRV_SRC4_PDM_ON
+			|| (psPathInfo->asDac[bCh].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK] & (MCDRV_SRC4_ADC0_ON|MCDRV_SRC4_ADC0_OFF)) == MCDRV_SRC4_ADC0_ON
+			|| (psPathInfo->asDac[bCh].abSrcOnOff[MCDRV_SRC_AE_BLOCK] & (MCDRV_SRC6_AE_ON|MCDRV_SRC6_AE_OFF)) == MCDRV_SRC6_AE_ON
+			|| (psPathInfo->asDac[bCh].abSrcOnOff[MCDRV_SRC_MIX_BLOCK] & (MCDRV_SRC6_MIX_ON|MCDRV_SRC6_MIX_OFF)) == MCDRV_SRC6_MIX_ON
+			|| (sCurPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK] & (MCDRV_SRC3_DIR2_ON|MCDRV_SRC3_DIR2_OFF)) == MCDRV_SRC3_DIR2_ON)
+			{
+				return MCDRV_ERROR_ARGUMENT;
+			}
+		}
+		if((psPathInfo->asDac[bCh].abSrcOnOff[MCDRV_SRC_PDM_BLOCK] & (MCDRV_SRC4_PDM_ON|MCDRV_SRC4_PDM_OFF)) == MCDRV_SRC4_PDM_ON)
+		{
+			if((psPathInfo->asDac[bCh].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK] & (MCDRV_SRC4_ADC0_ON|MCDRV_SRC4_ADC0_OFF)) == MCDRV_SRC4_ADC0_ON
+			|| (psPathInfo->asDac[bCh].abSrcOnOff[MCDRV_SRC_AE_BLOCK] & (MCDRV_SRC6_AE_ON|MCDRV_SRC6_AE_OFF)) == MCDRV_SRC6_AE_ON
+			|| (psPathInfo->asDac[bCh].abSrcOnOff[MCDRV_SRC_MIX_BLOCK] & (MCDRV_SRC6_MIX_ON|MCDRV_SRC6_MIX_OFF)) == MCDRV_SRC6_MIX_ON
+			|| (sCurPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_PDM_BLOCK] & (MCDRV_SRC4_PDM_ON|MCDRV_SRC4_PDM_OFF)) == MCDRV_SRC4_PDM_ON)
+			{
+				return MCDRV_ERROR_ARGUMENT;
+			}
+		}
+		if((psPathInfo->asDac[bCh].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK] & (MCDRV_SRC4_ADC0_ON|MCDRV_SRC4_ADC0_OFF)) == MCDRV_SRC4_ADC0_ON)
+		{
+			if((psPathInfo->asDac[bCh].abSrcOnOff[MCDRV_SRC_AE_BLOCK] & (MCDRV_SRC6_AE_ON|MCDRV_SRC6_AE_OFF)) == MCDRV_SRC6_AE_ON
+			|| (psPathInfo->asDac[bCh].abSrcOnOff[MCDRV_SRC_MIX_BLOCK] & (MCDRV_SRC6_MIX_ON|MCDRV_SRC6_MIX_OFF)) == MCDRV_SRC6_MIX_ON
+			|| (sCurPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK] & (MCDRV_SRC4_ADC0_ON|MCDRV_SRC4_ADC0_OFF)) == MCDRV_SRC4_ADC0_ON)
+			{
+				return MCDRV_ERROR_ARGUMENT;
+			}
+		}
+		if((psPathInfo->asDac[bCh].abSrcOnOff[MCDRV_SRC_AE_BLOCK] & (MCDRV_SRC6_AE_ON|MCDRV_SRC6_AE_OFF)) == MCDRV_SRC6_AE_ON)
+		{
+			if((psPathInfo->asDac[bCh].abSrcOnOff[MCDRV_SRC_MIX_BLOCK] & (MCDRV_SRC6_MIX_ON|MCDRV_SRC6_MIX_OFF)) == MCDRV_SRC6_MIX_ON)
+			{
+				return MCDRV_ERROR_ARGUMENT;
+			}
+		}
+		if((psPathInfo->asDac[bCh].abSrcOnOff[MCDRV_SRC_MIX_BLOCK] & (MCDRV_SRC6_MIX_ON|MCDRV_SRC6_MIX_OFF)) == MCDRV_SRC6_MIX_ON)
+		{
+			if((sCurPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_MIX_BLOCK] & (MCDRV_SRC6_MIX_ON|MCDRV_SRC6_MIX_OFF)) == MCDRV_SRC6_MIX_ON)
+			{
+				return MCDRV_ERROR_ARGUMENT;
+			}
+		}
+
+		if((psPathInfo->asDac[bCh].abSrcOnOff[MCDRV_SRC_PDM_BLOCK] & (MCDRV_SRC4_PDM_ON|MCDRV_SRC4_PDM_OFF)) == MCDRV_SRC4_PDM_ON)
+		{
+			if(bADC0IsSrc == 1)
+			{
+				return MCDRV_ERROR_ARGUMENT;
+			}
+			else
+			{
+				bPDMIsSrc	= 1;
+			}
+		}
+		if((psPathInfo->asDac[bCh].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK] & (MCDRV_SRC4_ADC0_ON|MCDRV_SRC4_ADC0_OFF)) == MCDRV_SRC4_ADC0_ON)
+		{
+			if(bPDMIsSrc == 1)
+			{
+				return MCDRV_ERROR_ARGUMENT;
+			}
+			else
+			{
+				bADC0IsSrc	= 1;
+			}
+		}
+	}
+
+	/*	AE	*/
+	if((psPathInfo->asAe[0].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK] & (MCDRV_SRC3_DIR0_ON|MCDRV_SRC3_DIR0_OFF)) == MCDRV_SRC3_DIR0_ON)
+	{
+		if((psPathInfo->asAe[0].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK] & (MCDRV_SRC3_DIR1_ON|MCDRV_SRC3_DIR1_OFF)) == MCDRV_SRC3_DIR1_ON
+		|| (psPathInfo->asAe[0].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK] & (MCDRV_SRC3_DIR2_ON|MCDRV_SRC3_DIR2_OFF)) == MCDRV_SRC3_DIR2_ON
+		|| (psPathInfo->asAe[0].abSrcOnOff[MCDRV_SRC_PDM_BLOCK] & (MCDRV_SRC4_PDM_ON|MCDRV_SRC4_PDM_OFF)) == MCDRV_SRC4_PDM_ON
+		|| (psPathInfo->asAe[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK] & (MCDRV_SRC4_ADC0_ON|MCDRV_SRC4_ADC0_OFF)) == MCDRV_SRC4_ADC0_ON
+		|| (psPathInfo->asAe[0].abSrcOnOff[MCDRV_SRC_MIX_BLOCK] & (MCDRV_SRC6_MIX_ON|MCDRV_SRC6_MIX_OFF)) == MCDRV_SRC6_MIX_ON)
+		{
+			return MCDRV_ERROR_ARGUMENT;
+		}
+	}
+	if((psPathInfo->asAe[0].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK] & (MCDRV_SRC3_DIR1_ON|MCDRV_SRC3_DIR1_OFF)) == MCDRV_SRC3_DIR1_ON)
+	{
+		if((psPathInfo->asAe[0].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK] & (MCDRV_SRC3_DIR2_ON|MCDRV_SRC3_DIR2_OFF)) == MCDRV_SRC3_DIR2_ON
+		|| (psPathInfo->asAe[0].abSrcOnOff[MCDRV_SRC_PDM_BLOCK] & (MCDRV_SRC4_PDM_ON|MCDRV_SRC4_PDM_OFF)) == MCDRV_SRC4_PDM_ON
+		|| (psPathInfo->asAe[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK] & (MCDRV_SRC4_ADC0_ON|MCDRV_SRC4_ADC0_OFF)) == MCDRV_SRC4_ADC0_ON
+		|| (psPathInfo->asAe[0].abSrcOnOff[MCDRV_SRC_MIX_BLOCK] & (MCDRV_SRC6_MIX_ON|MCDRV_SRC6_MIX_OFF)) == MCDRV_SRC6_MIX_ON)
+		{
+			return MCDRV_ERROR_ARGUMENT;
+		}
+	}
+	if((psPathInfo->asAe[0].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK] & (MCDRV_SRC3_DIR2_ON|MCDRV_SRC3_DIR2_OFF)) == MCDRV_SRC3_DIR2_ON)
+	{
+		if((psPathInfo->asAe[0].abSrcOnOff[MCDRV_SRC_PDM_BLOCK] & (MCDRV_SRC4_PDM_ON|MCDRV_SRC4_PDM_OFF)) == MCDRV_SRC4_PDM_ON
+		|| (psPathInfo->asAe[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK] & (MCDRV_SRC4_ADC0_ON|MCDRV_SRC4_ADC0_OFF)) == MCDRV_SRC4_ADC0_ON
+		|| (psPathInfo->asAe[0].abSrcOnOff[MCDRV_SRC_MIX_BLOCK] & (MCDRV_SRC6_MIX_ON|MCDRV_SRC6_MIX_OFF)) == MCDRV_SRC6_MIX_ON)
+		{
+			return MCDRV_ERROR_ARGUMENT;
+		}
+	}
+	if((psPathInfo->asAe[0].abSrcOnOff[MCDRV_SRC_PDM_BLOCK] & (MCDRV_SRC4_PDM_ON|MCDRV_SRC4_PDM_OFF)) == MCDRV_SRC4_PDM_ON)
+	{
+		if((psPathInfo->asAe[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK] & (MCDRV_SRC4_ADC0_ON|MCDRV_SRC4_ADC0_OFF)) == MCDRV_SRC4_ADC0_ON
+		|| (psPathInfo->asAe[0].abSrcOnOff[MCDRV_SRC_MIX_BLOCK] & (MCDRV_SRC6_MIX_ON|MCDRV_SRC6_MIX_OFF)) == MCDRV_SRC6_MIX_ON)
+		{
+			return MCDRV_ERROR_ARGUMENT;
+		}
+	}
+	if((psPathInfo->asAe[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK] & (MCDRV_SRC4_ADC0_ON|MCDRV_SRC4_ADC0_OFF)) == MCDRV_SRC4_ADC0_ON)
+	{
+		if((psPathInfo->asAe[0].abSrcOnOff[MCDRV_SRC_MIX_BLOCK] & (MCDRV_SRC6_MIX_ON|MCDRV_SRC6_MIX_OFF)) == MCDRV_SRC6_MIX_ON)
+		{
+			return MCDRV_ERROR_ARGUMENT;
+		}
+	}
+
+	if((psPathInfo->asAe[0].abSrcOnOff[MCDRV_SRC_PDM_BLOCK] & (MCDRV_SRC4_PDM_ON|MCDRV_SRC4_PDM_OFF)) == MCDRV_SRC4_PDM_ON)
+	{
+		if(bADC0IsSrc == 1)
+		{
+			return MCDRV_ERROR_ARGUMENT;
+		}
+		else
+		{
+			bPDMIsSrc	= 1;
+		}
+	}
+	if((psPathInfo->asAe[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK] & (MCDRV_SRC4_ADC0_ON|MCDRV_SRC4_ADC0_OFF)) == MCDRV_SRC4_ADC0_ON)
+	{
+		if(bPDMIsSrc == 1)
+		{
+			return MCDRV_ERROR_ARGUMENT;
+		}
+		else
+		{
+			bADC0IsSrc	= 1;
+		}
+	}
+	if((psPathInfo->asAe[0].abSrcOnOff[MCDRV_SRC_MIX_BLOCK] & (MCDRV_SRC6_MIX_ON|MCDRV_SRC6_MIX_OFF)) == MCDRV_SRC6_MIX_ON
+	&& ((psPathInfo->asMix[0].abSrcOnOff[MCDRV_SRC_AE_BLOCK] & (MCDRV_SRC6_AE_ON|MCDRV_SRC6_AE_OFF)) == MCDRV_SRC6_AE_ON
+		|| (sCurPathInfo.asMix[0].abSrcOnOff[MCDRV_SRC_AE_BLOCK] & MCDRV_SRC6_AE_ON) == MCDRV_SRC6_AE_ON))
+	{
+		return MCDRV_ERROR_ARGUMENT;
+	}
+
+	/*	CDSP	*/
+	for(bCh = 0; bCh < 4; bCh++)
+	{
+	}
+
+	/*	ADC0	*/
+	if((psPathInfo->asAdc0[0].abSrcOnOff[MCDRV_SRC_LINE1_L_BLOCK] & (MCDRV_SRC1_LINE1_L_ON|MCDRV_SRC1_LINE1_L_OFF)) == MCDRV_SRC1_LINE1_L_ON)
+	{
+		if(((psPathInfo->asAdc0[0].abSrcOnOff[MCDRV_SRC_LINE1_M_BLOCK] & (MCDRV_SRC1_LINE1_M_ON|MCDRV_SRC1_LINE1_M_OFF)) == MCDRV_SRC1_LINE1_M_ON)
+		|| ((sCurPathInfo.asAdc0[0].abSrcOnOff[MCDRV_SRC_LINE1_M_BLOCK] & (MCDRV_SRC1_LINE1_M_ON|MCDRV_SRC1_LINE1_M_OFF)) == MCDRV_SRC1_LINE1_M_ON))
+		{
+			return MCDRV_ERROR_ARGUMENT;
+		}
+	}
+	if((psPathInfo->asAdc0[0].abSrcOnOff[MCDRV_SRC_LINE1_M_BLOCK] & (MCDRV_SRC1_LINE1_M_ON|MCDRV_SRC1_LINE1_M_OFF)) == MCDRV_SRC1_LINE1_M_ON)
+	{
+		if((sCurPathInfo.asAdc0[0].abSrcOnOff[MCDRV_SRC_LINE1_L_BLOCK] & (MCDRV_SRC1_LINE1_L_ON|MCDRV_SRC1_LINE1_L_OFF)) == MCDRV_SRC1_LINE1_L_ON)
+		{
+			return MCDRV_ERROR_ARGUMENT;
+		}
+	}
+	if((psPathInfo->asAdc0[1].abSrcOnOff[MCDRV_SRC_LINE1_R_BLOCK] & (MCDRV_SRC1_LINE1_R_ON|MCDRV_SRC1_LINE1_R_OFF)) == MCDRV_SRC1_LINE1_R_ON)
+	{
+		if(((psPathInfo->asAdc0[1].abSrcOnOff[MCDRV_SRC_LINE1_M_BLOCK] & (MCDRV_SRC1_LINE1_M_ON|MCDRV_SRC1_LINE1_M_OFF)) == MCDRV_SRC1_LINE1_M_ON)
+		|| ((sCurPathInfo.asAdc0[1].abSrcOnOff[MCDRV_SRC_LINE1_M_BLOCK] & (MCDRV_SRC1_LINE1_M_ON|MCDRV_SRC1_LINE1_M_OFF)) == MCDRV_SRC1_LINE1_M_ON))
+		{
+			return MCDRV_ERROR_ARGUMENT;
+		}
+	}
+	if((psPathInfo->asAdc0[1].abSrcOnOff[MCDRV_SRC_LINE1_M_BLOCK] & (MCDRV_SRC1_LINE1_M_ON|MCDRV_SRC1_LINE1_M_OFF)) == MCDRV_SRC1_LINE1_M_ON)
+	{
+		if((sCurPathInfo.asAdc0[1].abSrcOnOff[MCDRV_SRC_LINE1_R_BLOCK] & (MCDRV_SRC1_LINE1_R_ON|MCDRV_SRC1_LINE1_R_OFF)) == MCDRV_SRC1_LINE1_R_ON)
+		{
+			return MCDRV_ERROR_ARGUMENT;
+		}
+	}
+
+	/*	ADC1	*/
+
+	/*	MIX	*/
+	if((psPathInfo->asMix[0].abSrcOnOff[MCDRV_SRC_PDM_BLOCK] & (MCDRV_SRC4_PDM_ON|MCDRV_SRC4_PDM_OFF)) == MCDRV_SRC4_PDM_ON)
+	{
+		if(bADC0IsSrc == 1)
+		{
+			return MCDRV_ERROR_ARGUMENT;
+		}
+		else
+		{
+			bPDMIsSrc	= 1;
+		}
+	}
+	if((psPathInfo->asMix[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK] & (MCDRV_SRC4_ADC0_ON|MCDRV_SRC4_ADC0_OFF)) == MCDRV_SRC4_ADC0_ON)
+	{
+		if(bPDMIsSrc == 1)
+		{
+			return MCDRV_ERROR_ARGUMENT;
+		}
+		else
+		{
+			bADC0IsSrc	= 1;
+		}
+	}
+	if((psPathInfo->asMix[0].abSrcOnOff[MCDRV_SRC_AE_BLOCK] & (MCDRV_SRC6_AE_ON|MCDRV_SRC6_AE_OFF)) == MCDRV_SRC6_AE_ON)
+	{
+		if((psPathInfo->asAe[0].abSrcOnOff[MCDRV_SRC_MIX_BLOCK] & (MCDRV_SRC6_MIX_ON|MCDRV_SRC6_MIX_OFF)) == MCDRV_SRC6_MIX_ON
+		|| (sCurPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_MIX_BLOCK] & MCDRV_SRC6_MIX_ON) == MCDRV_SRC6_MIX_ON)
+		{
+			return MCDRV_ERROR_ARGUMENT;
+		}
+	}
+	if(((psPathInfo->asMix[0].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK] & (MCDRV_SRC3_DIR0_ON|MCDRV_SRC3_DIR0_OFF)) == MCDRV_SRC3_DIR0_ON)
+	&& ((sCurPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK] & (MCDRV_SRC3_DIR0_ON|MCDRV_SRC3_DIR0_OFF)) == MCDRV_SRC3_DIR0_ON))
+	{
+		return MCDRV_ERROR_ARGUMENT;
+	}
+	if(((psPathInfo->asMix[0].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK] & (MCDRV_SRC3_DIR1_ON|MCDRV_SRC3_DIR1_OFF)) == MCDRV_SRC3_DIR1_ON)
+	&& ((sCurPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK] & (MCDRV_SRC3_DIR1_ON|MCDRV_SRC3_DIR1_OFF)) == MCDRV_SRC3_DIR1_ON))
+	{
+		return MCDRV_ERROR_ARGUMENT;
+	}
+	if(((psPathInfo->asMix[0].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK] & (MCDRV_SRC3_DIR2_ON|MCDRV_SRC3_DIR2_OFF)) == MCDRV_SRC3_DIR2_ON)
+	&& ((sCurPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK] & (MCDRV_SRC3_DIR2_ON|MCDRV_SRC3_DIR2_OFF)) == MCDRV_SRC3_DIR2_ON))
+	{
+		return MCDRV_ERROR_ARGUMENT;
+	}
+	if(((psPathInfo->asMix[0].abSrcOnOff[MCDRV_SRC_PDM_BLOCK] & (MCDRV_SRC4_PDM_ON|MCDRV_SRC4_PDM_OFF)) == MCDRV_SRC4_PDM_ON)
+	&& ((sCurPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_PDM_BLOCK] & (MCDRV_SRC4_PDM_ON|MCDRV_SRC4_PDM_OFF)) == MCDRV_SRC4_PDM_ON))
+	{
+		return MCDRV_ERROR_ARGUMENT;
+	}
+	if(((psPathInfo->asMix[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK] & (MCDRV_SRC4_ADC0_ON|MCDRV_SRC4_ADC0_OFF)) == MCDRV_SRC4_ADC0_ON)
+	&& ((sCurPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK] & (MCDRV_SRC4_ADC0_ON|MCDRV_SRC4_ADC0_OFF)) == MCDRV_SRC4_ADC0_ON))
+	{
+		return MCDRV_ERROR_ARGUMENT;
+	}
+
+	if((psPathInfo->asAe[0].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK] & (MCDRV_SRC3_DIR0_ON|MCDRV_SRC3_DIR0_OFF)) == MCDRV_SRC3_DIR0_ON
+	&& ((psPathInfo->asDit0[0].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK] & (MCDRV_SRC3_DIR0_ON|MCDRV_SRC3_DIR0_OFF)) == MCDRV_SRC3_DIR0_ON
+	 || (psPathInfo->asDit1[0].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK] & (MCDRV_SRC3_DIR0_ON|MCDRV_SRC3_DIR0_OFF)) == MCDRV_SRC3_DIR0_ON
+	 || (psPathInfo->asDit2[0].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK] & (MCDRV_SRC3_DIR0_ON|MCDRV_SRC3_DIR0_OFF)) == MCDRV_SRC3_DIR0_ON
+	 || (psPathInfo->asDac[0].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK] & (MCDRV_SRC3_DIR0_ON|MCDRV_SRC3_DIR0_OFF)) == MCDRV_SRC3_DIR0_ON
+	 || (psPathInfo->asDac[1].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK] & (MCDRV_SRC3_DIR0_ON|MCDRV_SRC3_DIR0_OFF)) == MCDRV_SRC3_DIR0_ON
+	 || (psPathInfo->asMix[0].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK] & (MCDRV_SRC3_DIR0_ON|MCDRV_SRC3_DIR0_OFF)) == MCDRV_SRC3_DIR0_ON
+	 || (sCurPathInfo.asDit0[0].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK] & (MCDRV_SRC3_DIR0_ON|MCDRV_SRC3_DIR0_OFF)) == MCDRV_SRC3_DIR0_ON
+	 || (sCurPathInfo.asDit1[0].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK] & (MCDRV_SRC3_DIR0_ON|MCDRV_SRC3_DIR0_OFF)) == MCDRV_SRC3_DIR0_ON
+	 || (sCurPathInfo.asDit2[0].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK] & (MCDRV_SRC3_DIR0_ON|MCDRV_SRC3_DIR0_OFF)) == MCDRV_SRC3_DIR0_ON
+	 || (sCurPathInfo.asDac[0].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK] & (MCDRV_SRC3_DIR0_ON|MCDRV_SRC3_DIR0_OFF)) == MCDRV_SRC3_DIR0_ON
+	 || (sCurPathInfo.asDac[1].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK] & (MCDRV_SRC3_DIR0_ON|MCDRV_SRC3_DIR0_OFF)) == MCDRV_SRC3_DIR0_ON
+	 || (sCurPathInfo.asMix[0].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK] & (MCDRV_SRC3_DIR0_ON|MCDRV_SRC3_DIR0_OFF)) == MCDRV_SRC3_DIR0_ON
+	 ))
+	{
+		return MCDRV_ERROR_ARGUMENT;
+	}
+	if((psPathInfo->asAe[0].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK] & (MCDRV_SRC3_DIR1_ON|MCDRV_SRC3_DIR1_OFF)) == MCDRV_SRC3_DIR1_ON
+	&& ((psPathInfo->asDit0[0].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK] & (MCDRV_SRC3_DIR1_ON|MCDRV_SRC3_DIR1_OFF)) == MCDRV_SRC3_DIR1_ON
+	 || (psPathInfo->asDit1[0].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK] & (MCDRV_SRC3_DIR1_ON|MCDRV_SRC3_DIR1_OFF)) == MCDRV_SRC3_DIR1_ON
+	 || (psPathInfo->asDit2[0].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK] & (MCDRV_SRC3_DIR1_ON|MCDRV_SRC3_DIR1_OFF)) == MCDRV_SRC3_DIR1_ON
+	 || (psPathInfo->asDac[0].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK] & (MCDRV_SRC3_DIR1_ON|MCDRV_SRC3_DIR1_OFF)) == MCDRV_SRC3_DIR1_ON
+	 || (psPathInfo->asDac[1].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK] & (MCDRV_SRC3_DIR1_ON|MCDRV_SRC3_DIR1_OFF)) == MCDRV_SRC3_DIR1_ON
+	 || (psPathInfo->asMix[0].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK] & (MCDRV_SRC3_DIR1_ON|MCDRV_SRC3_DIR1_OFF)) == MCDRV_SRC3_DIR1_ON
+	 || (sCurPathInfo.asDit0[0].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK] & (MCDRV_SRC3_DIR1_ON|MCDRV_SRC3_DIR1_OFF)) == MCDRV_SRC3_DIR1_ON
+	 || (sCurPathInfo.asDit1[0].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK] & (MCDRV_SRC3_DIR1_ON|MCDRV_SRC3_DIR1_OFF)) == MCDRV_SRC3_DIR1_ON
+	 || (sCurPathInfo.asDit2[0].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK] & (MCDRV_SRC3_DIR1_ON|MCDRV_SRC3_DIR1_OFF)) == MCDRV_SRC3_DIR1_ON
+	 || (sCurPathInfo.asDac[0].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK] & (MCDRV_SRC3_DIR1_ON|MCDRV_SRC3_DIR1_OFF)) == MCDRV_SRC3_DIR1_ON
+	 || (sCurPathInfo.asDac[1].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK] & (MCDRV_SRC3_DIR1_ON|MCDRV_SRC3_DIR1_OFF)) == MCDRV_SRC3_DIR1_ON
+	 || (sCurPathInfo.asMix[0].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK] & (MCDRV_SRC3_DIR1_ON|MCDRV_SRC3_DIR1_OFF)) == MCDRV_SRC3_DIR1_ON
+	 ))
+	{
+		return MCDRV_ERROR_ARGUMENT;
+	}
+	if((psPathInfo->asAe[0].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK] & (MCDRV_SRC3_DIR2_ON|MCDRV_SRC3_DIR2_OFF)) == MCDRV_SRC3_DIR2_ON
+	&& ((psPathInfo->asDit0[0].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK] & (MCDRV_SRC3_DIR2_ON|MCDRV_SRC3_DIR2_OFF)) == MCDRV_SRC3_DIR2_ON
+	 || (psPathInfo->asDit1[0].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK] & (MCDRV_SRC3_DIR2_ON|MCDRV_SRC3_DIR2_OFF)) == MCDRV_SRC3_DIR2_ON
+	 || (psPathInfo->asDit2[0].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK] & (MCDRV_SRC3_DIR2_ON|MCDRV_SRC3_DIR2_OFF)) == MCDRV_SRC3_DIR2_ON
+	 || (psPathInfo->asDac[0].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK] & (MCDRV_SRC3_DIR2_ON|MCDRV_SRC3_DIR2_OFF)) == MCDRV_SRC3_DIR2_ON
+	 || (psPathInfo->asDac[1].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK] & (MCDRV_SRC3_DIR2_ON|MCDRV_SRC3_DIR2_OFF)) == MCDRV_SRC3_DIR2_ON
+	 || (psPathInfo->asMix[0].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK] & (MCDRV_SRC3_DIR2_ON|MCDRV_SRC3_DIR2_OFF)) == MCDRV_SRC3_DIR2_ON
+	 || (sCurPathInfo.asDit0[0].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK] & (MCDRV_SRC3_DIR2_ON|MCDRV_SRC3_DIR2_OFF)) == MCDRV_SRC3_DIR2_ON
+	 || (sCurPathInfo.asDit1[0].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK] & (MCDRV_SRC3_DIR2_ON|MCDRV_SRC3_DIR2_OFF)) == MCDRV_SRC3_DIR2_ON
+	 || (sCurPathInfo.asDit2[0].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK] & (MCDRV_SRC3_DIR2_ON|MCDRV_SRC3_DIR2_OFF)) == MCDRV_SRC3_DIR2_ON
+	 || (sCurPathInfo.asDac[0].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK] & (MCDRV_SRC3_DIR2_ON|MCDRV_SRC3_DIR2_OFF)) == MCDRV_SRC3_DIR2_ON
+	 || (sCurPathInfo.asDac[1].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK] & (MCDRV_SRC3_DIR2_ON|MCDRV_SRC3_DIR2_OFF)) == MCDRV_SRC3_DIR2_ON
+	 || (sCurPathInfo.asMix[0].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK] & (MCDRV_SRC3_DIR2_ON|MCDRV_SRC3_DIR2_OFF)) == MCDRV_SRC3_DIR2_ON
+	 ))
+	{
+		return MCDRV_ERROR_ARGUMENT;
+	}
+	if((psPathInfo->asAe[0].abSrcOnOff[MCDRV_SRC_PDM_BLOCK] & (MCDRV_SRC4_PDM_ON|MCDRV_SRC4_PDM_OFF)) == MCDRV_SRC4_PDM_ON
+	&& ((psPathInfo->asDit0[0].abSrcOnOff[MCDRV_SRC_PDM_BLOCK] & (MCDRV_SRC4_PDM_ON|MCDRV_SRC4_PDM_OFF)) == MCDRV_SRC4_PDM_ON
+	 || (psPathInfo->asDit1[0].abSrcOnOff[MCDRV_SRC_PDM_BLOCK] & (MCDRV_SRC4_PDM_ON|MCDRV_SRC4_PDM_OFF)) == MCDRV_SRC4_PDM_ON
+	 || (psPathInfo->asDit2[0].abSrcOnOff[MCDRV_SRC_PDM_BLOCK] & (MCDRV_SRC4_PDM_ON|MCDRV_SRC4_PDM_OFF)) == MCDRV_SRC4_PDM_ON
+	 || (psPathInfo->asDac[0].abSrcOnOff[MCDRV_SRC_PDM_BLOCK] & (MCDRV_SRC4_PDM_ON|MCDRV_SRC4_PDM_OFF)) == MCDRV_SRC4_PDM_ON
+	 || (psPathInfo->asDac[1].abSrcOnOff[MCDRV_SRC_PDM_BLOCK] & (MCDRV_SRC4_PDM_ON|MCDRV_SRC4_PDM_OFF)) == MCDRV_SRC4_PDM_ON
+	 || (psPathInfo->asMix[0].abSrcOnOff[MCDRV_SRC_PDM_BLOCK] & (MCDRV_SRC4_PDM_ON|MCDRV_SRC4_PDM_OFF)) == MCDRV_SRC4_PDM_ON
+	 || (sCurPathInfo.asDit0[0].abSrcOnOff[MCDRV_SRC_PDM_BLOCK] & (MCDRV_SRC4_PDM_ON|MCDRV_SRC4_PDM_OFF)) == MCDRV_SRC4_PDM_ON
+	 || (sCurPathInfo.asDit1[0].abSrcOnOff[MCDRV_SRC_PDM_BLOCK] & (MCDRV_SRC4_PDM_ON|MCDRV_SRC4_PDM_OFF)) == MCDRV_SRC4_PDM_ON
+	 || (sCurPathInfo.asDit2[0].abSrcOnOff[MCDRV_SRC_PDM_BLOCK] & (MCDRV_SRC4_PDM_ON|MCDRV_SRC4_PDM_OFF)) == MCDRV_SRC4_PDM_ON
+	 || (sCurPathInfo.asDac[0].abSrcOnOff[MCDRV_SRC_PDM_BLOCK] & (MCDRV_SRC4_PDM_ON|MCDRV_SRC4_PDM_OFF)) == MCDRV_SRC4_PDM_ON
+	 || (sCurPathInfo.asDac[1].abSrcOnOff[MCDRV_SRC_PDM_BLOCK] & (MCDRV_SRC4_PDM_ON|MCDRV_SRC4_PDM_OFF)) == MCDRV_SRC4_PDM_ON
+	 || (sCurPathInfo.asMix[0].abSrcOnOff[MCDRV_SRC_PDM_BLOCK] & (MCDRV_SRC4_PDM_ON|MCDRV_SRC4_PDM_OFF)) == MCDRV_SRC4_PDM_ON))
+	{
+		return MCDRV_ERROR_ARGUMENT;
+	}
+	if((psPathInfo->asAe[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK] & (MCDRV_SRC4_ADC0_ON|MCDRV_SRC4_ADC0_OFF)) == MCDRV_SRC4_ADC0_ON
+	&& ((psPathInfo->asDit0[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK] & (MCDRV_SRC4_ADC0_ON|MCDRV_SRC4_ADC0_OFF)) == MCDRV_SRC4_ADC0_ON
+	 || (psPathInfo->asDit1[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK] & (MCDRV_SRC4_ADC0_ON|MCDRV_SRC4_ADC0_OFF)) == MCDRV_SRC4_ADC0_ON
+	 || (psPathInfo->asDit2[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK] & (MCDRV_SRC4_ADC0_ON|MCDRV_SRC4_ADC0_OFF)) == MCDRV_SRC4_ADC0_ON
+	 || (psPathInfo->asDac[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK] & (MCDRV_SRC4_ADC0_ON|MCDRV_SRC4_ADC0_OFF)) == MCDRV_SRC4_ADC0_ON
+	 || (psPathInfo->asDac[1].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK] & (MCDRV_SRC4_ADC0_ON|MCDRV_SRC4_ADC0_OFF)) == MCDRV_SRC4_ADC0_ON
+	 || (psPathInfo->asMix[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK] & (MCDRV_SRC4_ADC0_ON|MCDRV_SRC4_ADC0_OFF)) == MCDRV_SRC4_ADC0_ON
+	 || (sCurPathInfo.asDit0[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK] & (MCDRV_SRC4_ADC0_ON|MCDRV_SRC4_ADC0_OFF)) == MCDRV_SRC4_ADC0_ON
+	 || (sCurPathInfo.asDit1[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK] & (MCDRV_SRC4_ADC0_ON|MCDRV_SRC4_ADC0_OFF)) == MCDRV_SRC4_ADC0_ON
+	 || (sCurPathInfo.asDit2[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK] & (MCDRV_SRC4_ADC0_ON|MCDRV_SRC4_ADC0_OFF)) == MCDRV_SRC4_ADC0_ON
+	 || (sCurPathInfo.asDac[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK] & (MCDRV_SRC4_ADC0_ON|MCDRV_SRC4_ADC0_OFF)) == MCDRV_SRC4_ADC0_ON
+	 || (sCurPathInfo.asDac[1].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK] & (MCDRV_SRC4_ADC0_ON|MCDRV_SRC4_ADC0_OFF)) == MCDRV_SRC4_ADC0_ON
+	 || (sCurPathInfo.asMix[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK] & (MCDRV_SRC4_ADC0_ON|MCDRV_SRC4_ADC0_OFF)) == MCDRV_SRC4_ADC0_ON))
+	{
+		return MCDRV_ERROR_ARGUMENT;
+	}
+	if((psPathInfo->asAe[0].abSrcOnOff[MCDRV_SRC_MIX_BLOCK] & (MCDRV_SRC6_MIX_ON|MCDRV_SRC6_MIX_OFF)) == MCDRV_SRC6_MIX_ON
+	&& ((psPathInfo->asDit0[0].abSrcOnOff[MCDRV_SRC_MIX_BLOCK] & (MCDRV_SRC6_MIX_ON|MCDRV_SRC6_MIX_OFF)) == MCDRV_SRC6_MIX_ON
+	 || (psPathInfo->asDit1[0].abSrcOnOff[MCDRV_SRC_MIX_BLOCK] & (MCDRV_SRC6_MIX_ON|MCDRV_SRC6_MIX_OFF)) == MCDRV_SRC6_MIX_ON
+	 || (psPathInfo->asDit2[0].abSrcOnOff[MCDRV_SRC_MIX_BLOCK] & (MCDRV_SRC6_MIX_ON|MCDRV_SRC6_MIX_OFF)) == MCDRV_SRC6_MIX_ON
+	 || (psPathInfo->asDac[0].abSrcOnOff[MCDRV_SRC_MIX_BLOCK] & (MCDRV_SRC6_MIX_ON|MCDRV_SRC6_MIX_OFF)) == MCDRV_SRC6_MIX_ON
+	 || (psPathInfo->asDac[1].abSrcOnOff[MCDRV_SRC_MIX_BLOCK] & (MCDRV_SRC6_MIX_ON|MCDRV_SRC6_MIX_OFF)) == MCDRV_SRC6_MIX_ON
+	 || (sCurPathInfo.asDit0[0].abSrcOnOff[MCDRV_SRC_MIX_BLOCK] & (MCDRV_SRC6_MIX_ON|MCDRV_SRC6_MIX_OFF)) == MCDRV_SRC6_MIX_ON
+	 || (sCurPathInfo.asDit1[0].abSrcOnOff[MCDRV_SRC_MIX_BLOCK] & (MCDRV_SRC6_MIX_ON|MCDRV_SRC6_MIX_OFF)) == MCDRV_SRC6_MIX_ON
+	 || (sCurPathInfo.asDit2[0].abSrcOnOff[MCDRV_SRC_MIX_BLOCK] & (MCDRV_SRC6_MIX_ON|MCDRV_SRC6_MIX_OFF)) == MCDRV_SRC6_MIX_ON
+	 || (sCurPathInfo.asDac[0].abSrcOnOff[MCDRV_SRC_MIX_BLOCK] & (MCDRV_SRC6_MIX_ON|MCDRV_SRC6_MIX_OFF)) == MCDRV_SRC6_MIX_ON
+	 || (sCurPathInfo.asDac[1].abSrcOnOff[MCDRV_SRC_MIX_BLOCK] & (MCDRV_SRC6_MIX_ON|MCDRV_SRC6_MIX_OFF)) == MCDRV_SRC6_MIX_ON
+	 ))
+	{
+		return MCDRV_ERROR_ARGUMENT;
+	}
+
+	return MCDRV_SUCCESS;
+}
+
+/****************************************************************************
+ *	ValidateDioParam
+ *
+ *	Description:
+ *			validate digital IO parameters.
+ *	Arguments:
+ *			psDioInfo	digital IO information
+ *			dUpdateInfo	update information
+ *	Return:
+ *			MCDRV_SUCCESS
+ *			MCDRV_ERROR_ARGUMENT
+ *
+ ****************************************************************************/
+static SINT32	ValidateDioParam
+(
+	const MCDRV_DIO_INFO*	psDioInfo,
+	UINT32					dUpdateInfo
+)
+{
+	SINT32				sdRet	= MCDRV_SUCCESS;
+	UINT8				bPort;
+	MCDRV_SRC_TYPE_AA		aeDITSource[IOPORT_NUM];
+	MCDRV_SRC_TYPE_AA		eAESource	= McResCtrl_GetAESource_AA();
+	MCDRV_SRC_TYPE_AA		eDAC0Source	= McResCtrl_GetDACSource_AA(eMCDRV_DAC_MASTER_AA);
+	MCDRV_SRC_TYPE_AA		eDAC1Source	= McResCtrl_GetDACSource_AA(eMCDRV_DAC_VOICE_AA);
+	UINT8				bDIRUsed[IOPORT_NUM];
+	MCDRV_DIO_INFO		sDioInfo;
+	MCDRV_DIO_PORT_NO_AA	aePort[IOPORT_NUM]	= {eMCDRV_DIO_0_AA, eMCDRV_DIO_1_AA, eMCDRV_DIO_2_AA};
+
+
+	McResCtrl_GetDioInfo_AA(&sDioInfo);
+
+	for(bPort = 0; bPort < IOPORT_NUM; bPort++)
+	{
+		aeDITSource[bPort]	= McResCtrl_GetDITSource_AA(aePort[bPort]);
+		bDIRUsed[bPort]		= 0;
+	}
+
+	if(eAESource == eMCDRV_SRC_DIR0_AA || eDAC0Source == eMCDRV_SRC_DIR0_AA || eDAC1Source == eMCDRV_SRC_DIR0_AA
+	|| aeDITSource[0] == eMCDRV_SRC_DIR0_AA || aeDITSource[1] == eMCDRV_SRC_DIR0_AA || aeDITSource[2] == eMCDRV_SRC_DIR0_AA)
+	{
+		bDIRUsed[0]	= 1;
+	}
+	if(eAESource == eMCDRV_SRC_DIR1_AA || eDAC0Source == eMCDRV_SRC_DIR1_AA || eDAC1Source == eMCDRV_SRC_DIR1_AA
+	|| aeDITSource[0] == eMCDRV_SRC_DIR1_AA || aeDITSource[1] == eMCDRV_SRC_DIR1_AA || aeDITSource[2] == eMCDRV_SRC_DIR1_AA)
+	{
+		bDIRUsed[1]	= 1;
+	}
+	if(eAESource == eMCDRV_SRC_DIR2_AA || eDAC0Source == eMCDRV_SRC_DIR2_AA || eDAC1Source == eMCDRV_SRC_DIR2_AA
+	|| aeDITSource[0] == eMCDRV_SRC_DIR2_AA || aeDITSource[1] == eMCDRV_SRC_DIR2_AA || aeDITSource[2] == eMCDRV_SRC_DIR2_AA)
+	{
+		bDIRUsed[2]	= 1;
+	}
+
+	if((bDIRUsed[0] == 1 && ((dUpdateInfo & MCDRV_DIO0_COM_UPDATE_FLAG) != 0 || (dUpdateInfo & MCDRV_DIO0_DIR_UPDATE_FLAG) != 0))
+	|| (aeDITSource[0] != eMCDRV_SRC_NONE_AA && ((dUpdateInfo & MCDRV_DIO0_COM_UPDATE_FLAG) != 0 || (dUpdateInfo & MCDRV_DIO0_DIT_UPDATE_FLAG) != 0)))
+	{
+		return MCDRV_ERROR_ARGUMENT;
+	}
+	if((bDIRUsed[1] == 1 && ((dUpdateInfo & MCDRV_DIO1_COM_UPDATE_FLAG) != 0 || (dUpdateInfo & MCDRV_DIO1_DIR_UPDATE_FLAG) != 0))
+	|| (aeDITSource[1] != eMCDRV_SRC_NONE_AA && ((dUpdateInfo & MCDRV_DIO1_COM_UPDATE_FLAG) != 0 || (dUpdateInfo & MCDRV_DIO1_DIT_UPDATE_FLAG) != 0)))
+	{
+		return MCDRV_ERROR_ARGUMENT;
+	}
+	if((bDIRUsed[2] == 1 && ((dUpdateInfo & MCDRV_DIO2_COM_UPDATE_FLAG) != 0 || (dUpdateInfo & MCDRV_DIO2_DIR_UPDATE_FLAG) != 0))
+	|| (aeDITSource[2] != eMCDRV_SRC_NONE_AA && ((dUpdateInfo & MCDRV_DIO2_COM_UPDATE_FLAG) != 0 || (dUpdateInfo & MCDRV_DIO2_DIT_UPDATE_FLAG) != 0)))
+	{
+		return MCDRV_ERROR_ARGUMENT;
+	}
+
+	if((dUpdateInfo & MCDRV_DIO0_COM_UPDATE_FLAG) != 0)
+	{
+		sdRet	= CheckDIOCommon(psDioInfo, 0);
+		if(sdRet != MCDRV_SUCCESS)
+		{
+			return sdRet;
+		}
+		sDioInfo.asPortInfo[0].sDioCommon.bInterface	= psDioInfo->asPortInfo[0].sDioCommon.bInterface;
+	}
+	if((dUpdateInfo & MCDRV_DIO1_COM_UPDATE_FLAG) != 0)
+	{
+		sdRet	= CheckDIOCommon(psDioInfo, 1);
+		if(sdRet != MCDRV_SUCCESS)
+		{
+			return sdRet;
+		}
+		sDioInfo.asPortInfo[1].sDioCommon.bInterface	= psDioInfo->asPortInfo[1].sDioCommon.bInterface;
+	}
+	if((dUpdateInfo & MCDRV_DIO2_COM_UPDATE_FLAG) != 0)
+	{
+		sdRet	= CheckDIOCommon(psDioInfo, 2);
+		if(sdRet != MCDRV_SUCCESS)
+		{
+			return sdRet;
+		}
+		sDioInfo.asPortInfo[2].sDioCommon.bInterface	= psDioInfo->asPortInfo[2].sDioCommon.bInterface;
+	}
+
+	if((dUpdateInfo & MCDRV_DIO0_DIR_UPDATE_FLAG) != 0)
+	{
+		sdRet	= CheckDIODIR(psDioInfo, 0, sDioInfo.asPortInfo[0].sDioCommon.bInterface);
+		if(sdRet != MCDRV_SUCCESS)
+		{
+			return sdRet;
+		}
+	}
+	if((dUpdateInfo & MCDRV_DIO1_DIR_UPDATE_FLAG) != 0)
+	{
+		sdRet	= CheckDIODIR(psDioInfo, 1, sDioInfo.asPortInfo[1].sDioCommon.bInterface);
+		if(sdRet != MCDRV_SUCCESS)
+		{
+			return sdRet;
+		}
+	}
+	if((dUpdateInfo & MCDRV_DIO2_DIR_UPDATE_FLAG) != 0)
+	{
+		sdRet	= CheckDIODIR(psDioInfo, 2, sDioInfo.asPortInfo[2].sDioCommon.bInterface);
+		if(sdRet != MCDRV_SUCCESS)
+		{
+			return sdRet;
+		}
+	}
+
+	if((dUpdateInfo & MCDRV_DIO0_DIT_UPDATE_FLAG) != 0)
+	{
+		sdRet	= CheckDIODIT(psDioInfo, 0, sDioInfo.asPortInfo[0].sDioCommon.bInterface);
+		if(sdRet != MCDRV_SUCCESS)
+		{
+			return sdRet;
+		}
+	}
+	if((dUpdateInfo & MCDRV_DIO1_DIT_UPDATE_FLAG) != 0)
+	{
+		sdRet	= CheckDIODIT(psDioInfo, 1, sDioInfo.asPortInfo[1].sDioCommon.bInterface);
+		if(sdRet != MCDRV_SUCCESS)
+		{
+			return sdRet;
+		}
+	}
+	if((dUpdateInfo & MCDRV_DIO2_DIT_UPDATE_FLAG) != 0)
+	{
+		sdRet	= CheckDIODIT(psDioInfo, 2, sDioInfo.asPortInfo[2].sDioCommon.bInterface);
+		if(sdRet != MCDRV_SUCCESS)
+		{
+			return sdRet;
+		}
+	}
+
+	return sdRet;
+}
+
+
+/****************************************************************************
+ *	CheckDIOCommon
+ *
+ *	Description:
+ *			validate Digital IO Common parameters.
+ *	Arguments:
+ *			psDioInfo	digital IO information
+ *			bPort		port number
+ *	Return:
+ *			MCDRV_SUCCESS
+ *			MCDRV_ERROR_ARGUMENT
+ *
+ ****************************************************************************/
+static SINT32	CheckDIOCommon
+(
+	const MCDRV_DIO_INFO*	psDioInfo,
+	UINT8	bPort
+)
+{
+
+	if(psDioInfo->asPortInfo[bPort].sDioCommon.bInterface == MCDRV_DIO_PCM)
+	{
+		if(psDioInfo->asPortInfo[bPort].sDioCommon.bFs == MCDRV_FS_48000
+		|| psDioInfo->asPortInfo[bPort].sDioCommon.bFs == MCDRV_FS_44100
+		|| psDioInfo->asPortInfo[bPort].sDioCommon.bFs == MCDRV_FS_32000
+		|| psDioInfo->asPortInfo[bPort].sDioCommon.bFs == MCDRV_FS_24000
+		|| psDioInfo->asPortInfo[bPort].sDioCommon.bFs == MCDRV_FS_22050
+		|| psDioInfo->asPortInfo[bPort].sDioCommon.bFs == MCDRV_FS_12000
+		|| psDioInfo->asPortInfo[bPort].sDioCommon.bFs == MCDRV_FS_11025)
+		{
+			return MCDRV_ERROR_ARGUMENT;
+		}
+
+		if(psDioInfo->asPortInfo[bPort].sDioCommon.bMasterSlave == MCDRV_DIO_MASTER
+		&& psDioInfo->asPortInfo[bPort].sDioCommon.bFs == MCDRV_FS_16000)
+		{
+			if(psDioInfo->asPortInfo[bPort].sDioCommon.bBckFs == MCDRV_BCKFS_512)
+			{
+				return MCDRV_ERROR_ARGUMENT;
+			}
+		}
+	}
+	else
+	{
+		if(psDioInfo->asPortInfo[bPort].sDioCommon.bBckFs == MCDRV_BCKFS_512
+		|| psDioInfo->asPortInfo[bPort].sDioCommon.bBckFs == MCDRV_BCKFS_256
+		|| psDioInfo->asPortInfo[bPort].sDioCommon.bBckFs == MCDRV_BCKFS_128
+		|| psDioInfo->asPortInfo[bPort].sDioCommon.bBckFs == MCDRV_BCKFS_16)
+		{
+			return MCDRV_ERROR_ARGUMENT;
+		}
+	}
+	return MCDRV_SUCCESS;
+}
+
+/****************************************************************************
+ *	CheckDIODIR
+ *
+ *	Description:
+ *			validate Digital IO DIR parameters.
+ *	Arguments:
+ *			psDioInfo	digital IO information
+ *			bPort		port number
+ *			bInterface	Interface(DA/PCM)
+ *	Return:
+ *			MCDRV_SUCCESS
+ *			MCDRV_ERROR_ARGUMENT
+ *
+ ****************************************************************************/
+static SINT32	CheckDIODIR
+(
+	const MCDRV_DIO_INFO*	psDioInfo,
+	UINT8	bPort,
+	UINT8	bInterface
+)
+{
+
+	if(bInterface == MCDRV_DIO_PCM)
+	{
+		if(psDioInfo->asPortInfo[bPort].sDir.sPcmFormat.bLaw == MCDRV_PCM_ALAW
+		|| psDioInfo->asPortInfo[bPort].sDir.sPcmFormat.bLaw == MCDRV_PCM_MULAW)
+		{
+			if(psDioInfo->asPortInfo[bPort].sDir.sPcmFormat.bBitSel == MCDRV_PCM_BITSEL_13
+			|| psDioInfo->asPortInfo[bPort].sDir.sPcmFormat.bBitSel == MCDRV_PCM_BITSEL_14
+			|| psDioInfo->asPortInfo[bPort].sDir.sPcmFormat.bBitSel == MCDRV_PCM_BITSEL_16)
+			{
+				return MCDRV_ERROR_ARGUMENT;
+			}
+		}
+	}
+	return MCDRV_SUCCESS;
+}
+
+/****************************************************************************
+ *	CheckDIDIT
+ *
+ *	Description:
+ *			validate Digital IO DIT parameters.
+ *	Arguments:
+ *			psDioInfo	digital IO information
+ *			bPort		port number
+ *			bInterface	Interface(DA/PCM)
+ *	Return:
+ *			MCDRV_SUCCESS
+ *			MCDRV_ERROR_ARGUMENT
+ *
+ ****************************************************************************/
+static SINT32	CheckDIODIT
+(
+	const MCDRV_DIO_INFO*	psDioInfo,
+	UINT8	bPort,
+	UINT8	bInterface
+)
+{
+
+	if(bInterface == MCDRV_DIO_PCM)
+	{
+		if(psDioInfo->asPortInfo[bPort].sDit.sPcmFormat.bLaw == MCDRV_PCM_ALAW
+		|| psDioInfo->asPortInfo[bPort].sDit.sPcmFormat.bLaw == MCDRV_PCM_MULAW)
+		{
+			if(psDioInfo->asPortInfo[bPort].sDit.sPcmFormat.bBitSel == MCDRV_PCM_BITSEL_13
+			|| psDioInfo->asPortInfo[bPort].sDit.sPcmFormat.bBitSel == MCDRV_PCM_BITSEL_14
+			|| psDioInfo->asPortInfo[bPort].sDit.sPcmFormat.bBitSel == MCDRV_PCM_BITSEL_16)
+			{
+				return MCDRV_ERROR_ARGUMENT;
+			}
+		}
+	}
+	return MCDRV_SUCCESS;
+}
+
+/****************************************************************************
+ *	SetVol
+ *
+ *	Description:
+ *			set volume.
+ *	Arguments:
+ *			dUpdate		target volume items
+ *			eMode		update mode
+ *	Return:
+ *			MCDRV_SUCCESS
+ *			MCDRV_ERROR_RESOURCEOVER
+ *
+ ****************************************************************************/
+static SINT32	SetVol
+(
+	UINT32					dUpdate,
+	MCDRV_VOLUPDATE_MODE_AA	eMode
+)
+{
+	SINT32	sdRet	= McPacket_AddVol_AA(dUpdate, eMode);
+	if(sdRet != MCDRV_SUCCESS)
+	{
+		return sdRet;
+	}
+	return McDevIf_ExecutePacket_AA();
+}
+
+/****************************************************************************
+ *	PreUpdatePath
+ *
+ *	Description:
+ *			Preprocess update path.
+ *	Arguments:
+ *			none
+ *	Return:
+ *			MCDRV_SUCCESS
+ *			MCDRV_ERROR_RESOURCEOVER
+ *
+ ****************************************************************************/
+static	SINT32	PreUpdatePath
+(
+void
+)
+{
+	SINT32	sdRet	= MCDRV_SUCCESS;
+	UINT8	bReg	= 0;
+	UINT8	bReadReg= 0;
+	UINT16	wDACMuteParam	= 0;
+	UINT16	wDITMuteParam	= 0;
+	UINT8	bLAT	= 0;
+
+	switch(McResCtrl_GetDACSource_AA(eMCDRV_DAC_MASTER_AA))
+	{
+	case	eMCDRV_SRC_PDM_AA:
+		bReg	= MCB_AA_DAC_SOURCE_AD;
+		break;
+	case	eMCDRV_SRC_ADC0_AA:
+		bReg	= MCB_AA_DAC_SOURCE_AD;
+		break;
+	case	eMCDRV_SRC_DIR0_AA:
+		bReg	= MCB_AA_DAC_SOURCE_DIR0;
+		break;
+	case	eMCDRV_SRC_DIR1_AA:
+		bReg	= MCB_AA_DAC_SOURCE_DIR1;
+		break;
+	case	eMCDRV_SRC_DIR2_AA:
+		bReg	= MCB_AA_DAC_SOURCE_DIR2;
+		break;
+	case	eMCDRV_SRC_MIX_AA:
+		bReg	= MCB_AA_DAC_SOURCE_MIX;
+		break;
+	default:
+		bReg	= 0;
+	}
+	bReadReg	= McResCtrl_GetRegVal_AA(MCDRV_PACKET_REGTYPE_B_MIXER_AA, MCI_AA_SOURCE);
+	if((bReadReg & 0xF0) != 0 && bReg != (bReadReg & 0xF0))
+	{/*	DAC source changed	*/
+		if((McResCtrl_GetRegVal_AA(MCDRV_PACKET_REGTYPE_B_MIXER_AA, MCI_AA_MASTER_OUTL)&MCB_AA_MASTER_OUTL) != 0)
+		{
+			if(McResCtrl_GetRegVal_AA(MCDRV_PACKET_REGTYPE_B_MIXER_AA, MCI_AA_MASTER_OUTR) != 0)
+			{
+				bLAT	= MCB_AA_MASTER_OLAT;
+			}
+			else
+			{
+				bLAT	= 0;
+			}
+			McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_WRITE_AA | MCDRV_PACKET_REGTYPE_B_MIXER_AA | MCI_AA_MASTER_OUTL, bLAT);
+		}
+		McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_WRITE_AA | MCDRV_PACKET_REGTYPE_B_MIXER_AA | MCI_AA_MASTER_OUTR, 0);
+		wDACMuteParam	|= (UINT16)(MCB_AA_MASTER_OFLAGL<<8);
+		wDACMuteParam	|= MCB_AA_MASTER_OFLAGR;
+	}
+
+	switch(McResCtrl_GetDACSource_AA(eMCDRV_DAC_VOICE_AA))
+	{
+	case	eMCDRV_SRC_PDM_AA:
+		bReg	= MCB_AA_VOICE_SOURCE_AD;
+		break;
+	case	eMCDRV_SRC_ADC0_AA:
+		bReg	= MCB_AA_VOICE_SOURCE_AD;
+		break;
+	case	eMCDRV_SRC_DIR0_AA:
+		bReg	= MCB_AA_VOICE_SOURCE_DIR0;
+		break;
+	case	eMCDRV_SRC_DIR1_AA:
+		bReg	= MCB_AA_VOICE_SOURCE_DIR1;
+		break;
+	case	eMCDRV_SRC_DIR2_AA:
+		bReg	= MCB_AA_VOICE_SOURCE_DIR2;
+		break;
+	case	eMCDRV_SRC_MIX_AA:
+		bReg	= MCB_AA_VOICE_SOURCE_MIX;
+		break;
+	default:
+		bReg	= 0;
+	}
+	if((bReadReg & 0x0F) != 0 && bReg != (bReadReg & 0x0F))
+	{/*	VOICE source changed	*/
+		if((McResCtrl_GetRegVal_AA(MCDRV_PACKET_REGTYPE_B_MIXER_AA, MCI_AA_VOICE_ATTL)&MCB_AA_VOICE_ATTL) != 0)
+		{
+			if(McResCtrl_GetRegVal_AA(MCDRV_PACKET_REGTYPE_B_MIXER_AA, MCI_AA_VOICE_ATTR) != 0)
+			{
+				bLAT	= MCB_AA_VOICE_LAT;
+			}
+			else
+			{
+				bLAT	= 0;
+			}
+			McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_WRITE_AA | MCDRV_PACKET_REGTYPE_B_MIXER_AA | MCI_AA_VOICE_ATTL, bLAT);
+		}
+		McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_WRITE_AA | MCDRV_PACKET_REGTYPE_B_MIXER_AA | MCI_AA_VOICE_ATTR, 0);
+		wDACMuteParam	|= (UINT16)(MCB_AA_VOICE_FLAGL<<8);
+		wDACMuteParam	|= MCB_AA_VOICE_FLAGR;
+	}
+
+	switch(McResCtrl_GetDITSource_AA(eMCDRV_DIO_0_AA))
+	{
+	case	eMCDRV_SRC_PDM_AA:
+		bReg	= MCB_AA_DIT0_SOURCE_AD;
+		break;
+	case	eMCDRV_SRC_ADC0_AA:
+		bReg	= MCB_AA_DIT0_SOURCE_AD;
+		break;
+	case	eMCDRV_SRC_DIR0_AA:
+		bReg	= MCB_AA_DIT0_SOURCE_DIR0;
+		break;
+	case	eMCDRV_SRC_DIR1_AA:
+		bReg	= MCB_AA_DIT0_SOURCE_DIR1;
+		break;
+	case	eMCDRV_SRC_DIR2_AA:
+		bReg	= MCB_AA_DIT0_SOURCE_DIR2;
+		break;
+	case	eMCDRV_SRC_MIX_AA:
+		bReg	= MCB_AA_DIT0_SOURCE_MIX;
+		break;
+	default:
+		bReg	= 0;
+	}
+	bReadReg	= McResCtrl_GetRegVal_AA(MCDRV_PACKET_REGTYPE_B_MIXER_AA, MCI_AA_SRC_SOURCE);
+	if((bReadReg & 0xF0) != 0 && bReg != (bReadReg & 0xF0))
+	{/*	DIT source changed	*/
+		if((McResCtrl_GetRegVal_AA(MCDRV_PACKET_REGTYPE_B_MIXER_AA, MCI_AA_DIT0_INVOLL)&MCB_AA_DIT0_INVOLL) != 0)
+		{
+			if(McResCtrl_GetRegVal_AA(MCDRV_PACKET_REGTYPE_B_MIXER_AA, MCI_AA_DIT0_INVOLR) != 0)
+			{
+				bLAT	= MCB_AA_DIT0_INLAT;
+			}
+			else
+			{
+				bLAT	= 0;
+			}
+			McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_WRITE_AA | MCDRV_PACKET_REGTYPE_B_MIXER_AA | MCI_AA_DIT0_INVOLL, bLAT);
+		}
+		McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_WRITE_AA | MCDRV_PACKET_REGTYPE_B_MIXER_AA | MCI_AA_DIT0_INVOLR, 0);
+		wDITMuteParam	|= (UINT16)(MCB_AA_DIT0_INVFLAGL<<8);
+		wDITMuteParam	|= MCB_AA_DIT0_INVFLAGR;
+	}
+
+	switch(McResCtrl_GetDITSource_AA(eMCDRV_DIO_1_AA))
+	{
+	case	eMCDRV_SRC_PDM_AA:
+		bReg	= MCB_AA_DIT1_SOURCE_AD;
+		break;
+	case	eMCDRV_SRC_ADC0_AA:
+		bReg	= MCB_AA_DIT1_SOURCE_AD;
+		break;
+	case	eMCDRV_SRC_DIR0_AA:
+		bReg	= MCB_AA_DIT1_SOURCE_DIR0;
+		break;
+	case	eMCDRV_SRC_DIR1_AA:
+		bReg	= MCB_AA_DIT1_SOURCE_DIR1;
+		break;
+	case	eMCDRV_SRC_DIR2_AA:
+		bReg	= MCB_AA_DIT1_SOURCE_DIR2;
+		break;
+	case	eMCDRV_SRC_MIX_AA:
+		bReg	= MCB_AA_DIT1_SOURCE_MIX;
+		break;
+	default:
+		bReg	= 0;
+	}
+	if((bReadReg & 0x0F) != 0 && bReg != (bReadReg & 0x0F))
+	{/*	DIT source changed	*/
+		if((McResCtrl_GetRegVal_AA(MCDRV_PACKET_REGTYPE_B_MIXER_AA, MCI_AA_DIT1_INVOLL)&MCB_AA_DIT1_INVOLL) != 0)
+		{
+			if(McResCtrl_GetRegVal_AA(MCDRV_PACKET_REGTYPE_B_MIXER_AA, MCI_AA_DIT1_INVOLR) != 0)
+			{
+				bLAT	= MCB_AA_DIT1_INLAT;
+			}
+			else
+			{
+				bLAT	= 0;
+			}
+			McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_WRITE_AA | MCDRV_PACKET_REGTYPE_B_MIXER_AA | MCI_AA_DIT1_INVOLL, bLAT);
+		}
+		McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_WRITE_AA | MCDRV_PACKET_REGTYPE_B_MIXER_AA | MCI_AA_DIT1_INVOLR, 0);
+		wDITMuteParam	|= (UINT16)(MCB_AA_DIT1_INVFLAGL<<8);
+		wDITMuteParam	|= MCB_AA_DIT1_INVFLAGR;
+	}
+
+	switch(McResCtrl_GetDITSource_AA(eMCDRV_DIO_2_AA))
+	{
+	case	eMCDRV_SRC_PDM_AA:
+		bReg	= MCB_AA_DIT2_SOURCE_AD;
+		break;
+	case	eMCDRV_SRC_ADC0_AA:
+		bReg	= MCB_AA_DIT2_SOURCE_AD;
+		break;
+	case	eMCDRV_SRC_DIR0_AA:
+		bReg	= MCB_AA_DIT2_SOURCE_DIR0;
+		break;
+	case	eMCDRV_SRC_DIR1_AA:
+		bReg	= MCB_AA_DIT2_SOURCE_DIR1;
+		break;
+	case	eMCDRV_SRC_DIR2_AA:
+		bReg	= MCB_AA_DIT2_SOURCE_DIR2;
+		break;
+	case	eMCDRV_SRC_MIX_AA:
+		bReg	= MCB_AA_DIT2_SOURCE_MIX;
+		break;
+	default:
+		bReg	= 0;
+	}
+	bReadReg	= McResCtrl_GetRegVal_AA(MCDRV_PACKET_REGTYPE_B_MIXER_AA, MCI_AA_SRC_SOURCE_1);
+	if((bReadReg & 0x0F) != 0 && bReg != (bReadReg & 0x0F))
+	{/*	DIT source changed	*/
+		if((McResCtrl_GetRegVal_AA(MCDRV_PACKET_REGTYPE_B_MIXER_AA, MCI_AA_DIT2_INVOLL)&MCB_AA_DIT2_INVOLL) != 0)
+		{
+			if(McResCtrl_GetRegVal_AA(MCDRV_PACKET_REGTYPE_B_MIXER_AA, MCI_AA_DIT2_INVOLR) != 0)
+			{
+				bLAT	= MCB_AA_DIT2_INLAT;
+			}
+			else
+			{
+				bLAT	= 0;
+			}
+			McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_WRITE_AA | MCDRV_PACKET_REGTYPE_B_MIXER_AA | MCI_AA_DIT2_INVOLL, bLAT);
+		}
+		McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_WRITE_AA | MCDRV_PACKET_REGTYPE_B_MIXER_AA | MCI_AA_DIT2_INVOLR, 0);
+		wDITMuteParam	|= (UINT16)(MCB_AA_DIT2_INVFLAGL<<8);
+		wDITMuteParam	|= MCB_AA_DIT2_INVFLAGR;
+	}
+
+	sdRet	= McDevIf_ExecutePacket_AA();
+	if(sdRet != MCDRV_SUCCESS)
+	{
+		return sdRet;
+	}
+
+	if(wDACMuteParam != 0)
+	{
+		McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_EVTWAIT_AA | MCDRV_EVT_DACMUTE_AA | wDACMuteParam, 0);
+	}
+	if(wDITMuteParam != 0)
+	{
+		McDevIf_AddPacket_AA(MCDRV_PACKET_TYPE_EVTWAIT_AA | MCDRV_EVT_DITMUTE_AA | wDITMuteParam, 0);
+	}
+	/*	do not Execute & Clear	*/
+	return MCDRV_SUCCESS;
+}
+
+/****************************************************************************
+ *	McDrv_Ctrl
+ *
+ *	Description:
+ *			MC Driver I/F function.
+ *	Arguments:
+ *			dCmd		command #
+ *			pvPrm		parameter
+ *			dPrm		update info
+ *	Return:
+ *			MCDRV_SUCCESS
+ *			MCDRV_ERROR_ARGUMENT
+ *			MCDRV_ERROR_RESOURCEOVER
+ *			MCDRV_ERROR_STATE
+ *
+ ****************************************************************************/
+SINT32	McDrv_Ctrl_AA
+(
+	UINT32	dCmd,
+	void*	pvPrm,
+	UINT32	dPrm
+)
+{
+	SINT32	sdRet	= MCDRV_ERROR;
+
+	switch(dCmd)
+	{
+	case	MCDRV_INIT:	return init((MCDRV_INIT_INFO*)pvPrm);
+	case	MCDRV_TERM:	return term();
+	default:			break;
+	}
+
+	McSrv_Lock();
+
+	switch (dCmd)
+	{
+	case	MCDRV_UPDATE_CLOCK:
+		sdRet	= update_clock((MCDRV_CLOCK_INFO*)pvPrm);
+		break;
+	case	MCDRV_GET_PATH:
+		sdRet	= get_path((MCDRV_PATH_INFO*)pvPrm);
+		break;
+	case	MCDRV_SET_PATH:
+		sdRet	= set_path((MCDRV_PATH_INFO*)pvPrm);
+		break;
+	case	MCDRV_GET_VOLUME:
+		sdRet	= get_volume((MCDRV_VOL_INFO*)pvPrm);
+		break;
+	case	MCDRV_SET_VOLUME:
+		sdRet	= set_volume((MCDRV_VOL_INFO*)pvPrm);
+		break;
+	case	MCDRV_GET_DIGITALIO:
+		sdRet	= get_digitalio((MCDRV_DIO_INFO*)pvPrm);
+		break;
+	case	MCDRV_SET_DIGITALIO:
+		sdRet	= set_digitalio((MCDRV_DIO_INFO*)pvPrm, dPrm);
+		break;
+	case	MCDRV_GET_DAC:
+		sdRet	= get_dac((MCDRV_DAC_INFO*)pvPrm);
+		break;
+	case	MCDRV_SET_DAC:
+		sdRet	= set_dac((MCDRV_DAC_INFO*)pvPrm, dPrm);
+		break;
+	case	MCDRV_GET_ADC:
+		sdRet	= get_adc((MCDRV_ADC_INFO*)pvPrm);
+		break;
+	case	MCDRV_SET_ADC:
+		sdRet	= set_adc((MCDRV_ADC_INFO*)pvPrm, dPrm);
+		break;
+	case	MCDRV_GET_SP:
+		sdRet	= get_sp((MCDRV_SP_INFO*)pvPrm);
+		break;
+	case	MCDRV_SET_SP:
+		sdRet	= set_sp((MCDRV_SP_INFO*)pvPrm);
+		break;
+	case	MCDRV_GET_DNG:
+		sdRet	= get_dng((MCDRV_DNG_INFO*)pvPrm);
+		break;
+	case	MCDRV_SET_DNG:
+		sdRet	= set_dng((MCDRV_DNG_INFO*)pvPrm, dPrm);
+		break;
+	case	MCDRV_SET_AUDIOENGINE:
+		sdRet	= set_ae((MCDRV_AE_INFO*)pvPrm, dPrm);
+		break;
+	case	MCDRV_GET_PDM:
+		sdRet	= get_pdm((MCDRV_PDM_INFO*)pvPrm);
+		break;
+	case	MCDRV_SET_PDM:
+		sdRet	= set_pdm((MCDRV_PDM_INFO*)pvPrm, dPrm);
+		break;
+	case MCDRV_CONFIG_GP:
+		sdRet	= config_gp((MCDRV_GP_MODE*)pvPrm);
+		break;
+	case MCDRV_MASK_GP:
+		sdRet	= mask_gp((UINT8*)pvPrm, dPrm);
+		break;
+	case MCDRV_GETSET_GP:
+		sdRet	= getset_gp((UINT8*)pvPrm, dPrm);
+		break;
+	case MCDRV_READ_REG :
+		sdRet	= read_reg((MCDRV_REG_INFO*)pvPrm);
+		break;
+	case MCDRV_WRITE_REG :
+		sdRet	= write_reg((MCDRV_REG_INFO*)pvPrm);
+		break;
+	case MCDRV_GET_SYSEQ :
+	case MCDRV_SET_SYSEQ :
+		sdRet	= MCDRV_SUCCESS;
+		break;
+
+	case MCDRV_IRQ:
+		break;
+
+	default:
+		break;
+	}
+
+	McSrv_Unlock();
+
+	return sdRet;
+}
diff --git a/sound/soc/codecs/mc1n2/mcdriver_AA.h b/sound/soc/codecs/mc1n2/mcdriver_AA.h
new file mode 100644
index 0000000..f8531d8
--- /dev/null
+++ b/sound/soc/codecs/mc1n2/mcdriver_AA.h
@@ -0,0 +1,25 @@
+/****************************************************************************
+ *
+ *		Copyright(c) 2010 Yamaha Corporation. All rights reserved.
+ *
+ *		Module		: mcdriver_AA.h
+ *
+ *		Description	: MC Driver header
+ *
+ *		Version		: 1.0.0 	2010.09.01
+ *
+ ****************************************************************************/
+
+#ifndef _MCDRIVER_AA_H_
+#define _MCDRIVER_AA_H_
+
+#include "mctypedef.h"
+
+
+
+signed long	McDrv_Ctrl_AA( UINT32 dCmd, void* pvPrm, UINT32 dPrm );
+
+
+
+
+#endif /* _MCDRIVER_H_ */
diff --git a/sound/soc/codecs/mc1n2/mcmachdep.c b/sound/soc/codecs/mc1n2/mcmachdep.c
new file mode 100644
index 0000000..eaebc5b
--- /dev/null
+++ b/sound/soc/codecs/mc1n2/mcmachdep.c
@@ -0,0 +1,318 @@
+/****************************************************************************
+ *
+ *		Copyright(c) 2010 Yamaha Corporation. All rights reserved.
+ *
+ *		Module		: mcmachdep.c
+ *
+ *		Description	: machine dependent part for MC Driver
+ *
+ *		Version		: 1.0.0 	2010.09.10
+ *
+ ****************************************************************************/
+
+#include <linux/delay.h>
+#include <linux/i2c.h>
+#include <linux/mutex.h>
+#include "mcmachdep.h"
+#include "mc1n2_priv.h"
+#if (MCDRV_DEBUG_LEVEL>=4)
+#include "mcdebuglog.h"
+#endif
+
+static struct mutex McDrv_Mutex;
+static struct i2c_client *McDrv_I2C_Client;
+
+/****************************************************************************
+ *	machdep_SystemInit
+ *
+ *	Description:
+ *			Initialize the system.
+ *	Arguments:
+ *			none
+ *	Return:
+ *			none
+ *
+ ****************************************************************************/
+void	machdep_SystemInit
+(
+	void
+)
+{
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncIn("machdep_SystemInit");
+#endif
+
+	/* Please implement system initialization procedure if need */
+	mutex_init(&McDrv_Mutex);
+	McDrv_I2C_Client = mc1n2_get_i2c_client();
+
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncOut("machdep_SystemInit", 0);
+#endif
+}
+
+/****************************************************************************
+ *	machdep_SystemTerm
+ *
+ *	Description:
+ *			Terminate the system.
+ *	Arguments:
+ *			none
+ *	Return:
+ *			none
+ *
+ ****************************************************************************/
+void	machdep_SystemTerm
+(
+	void
+)
+{
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncIn("machdep_SystemTerm");
+#endif
+
+	/* Please implement system termination procedure if need */
+	mutex_destroy(&McDrv_Mutex);
+
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncOut("machdep_SystemTerm", 0);
+#endif
+}
+
+/****************************************************************************
+ *	machdep_ClockStart
+ *
+ *	Description:
+ *			Start clock.
+ *	Arguments:
+ *			none
+ *	Return:
+ *			none
+ *
+ ****************************************************************************/
+void	machdep_ClockStart
+(
+	void
+)
+{
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncIn("machdep_ClockStart");
+#endif
+
+	/* Please implement clock start procedure if need */
+
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncOut("machdep_ClockStart", 0);
+#endif
+}
+
+/****************************************************************************
+ *	machdep_ClockStop
+ *
+ *	Description:
+ *			Stop clock.
+ *	Arguments:
+ *			none
+ *	Return:
+ *			none
+ *
+ ****************************************************************************/
+void	machdep_ClockStop
+(
+	void
+)
+{
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncIn("machdep_ClockStop");
+#endif
+
+	/* Please implement clock stop procedure if need */
+
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncOut("machdep_ClockStop", 0);
+#endif
+}
+
+/***************************************************************************
+ *	machdep_WriteI2C
+ *
+ *	Function:
+ *			Write a byte data to the register.
+ *	Arguments:
+ *			bSlaveAdr	slave address
+ *			pbData		byte data for write
+ *			dSize		byte data length
+ *	Return:
+ *			None
+ *
+ ****************************************************************************/
+void	machdep_WriteI2C
+(
+	UINT8	bSlaveAdr,
+	const UINT8*	pbData,
+	UINT32	dSize
+)
+{
+	int count;
+
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncIn("machdep_WriteI2C");
+#endif
+
+	/* Please implement register write procedure */
+	count = i2c_master_send(McDrv_I2C_Client, pbData, dSize);
+	if (count != dSize) {
+		dev_err(&McDrv_I2C_Client->dev, "I2C write error\n");
+	}
+
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncOut("machdep_WriteI2C", 0);
+#endif
+}
+
+/***************************************************************************
+ *	machdep_ReadI2C
+ *
+ *	Function:
+ *			Read a byte data from the register.
+ *	Arguments:
+ *			bSlaveAdr	slave address
+ *			dAddress	address of register
+ *	Return:
+ *			read data
+ *
+ ****************************************************************************/
+UINT8	machdep_ReadI2C
+(
+	UINT8	bSlaveAdr,
+	UINT32	dAddress
+)
+{
+	UINT8	bData;
+
+#if (MCDRV_DEBUG_LEVEL>=4)
+	SINT32	sdRet;
+	McDebugLog_FuncIn("machdep_ReadI2C");
+#endif
+
+	/* Please implement register read procedure */
+ 	bData = mc1n2_i2c_read_byte(McDrv_I2C_Client, dAddress);
+
+#if (MCDRV_DEBUG_LEVEL>=4)
+	sdRet	= (SINT32)bData;
+	McDebugLog_FuncOut("machdep_ReadI2C", &sdRet);
+#endif
+
+	return bData;
+}
+
+/****************************************************************************
+ *	machdep_Sleep
+ *
+ *	Function:
+ *			Sleep for a specified interval.
+ *	Arguments:
+ *			dSleepTime	sleep time [us]
+ *	Return:
+ *			None
+ *
+ ****************************************************************************/
+void	machdep_Sleep
+(
+	UINT32	dSleepTime
+)
+{
+	unsigned long ms = dSleepTime / 1000;
+	unsigned long us = dSleepTime % 1000;
+
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncIn("machdep_Sleep");
+#endif
+
+	/* Please implement sleep procedure */
+	if (us)
+		udelay(us);
+	if (ms)
+		msleep(ms);
+
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncOut("machdep_Sleep", 0);
+#endif
+}
+
+/***************************************************************************
+ *	machdep_Lock
+ *
+ *	Function:
+ *			Lock a call of the driver.
+ *	Arguments:
+ *			none
+ *	Return:
+ *			none
+ *
+ ****************************************************************************/
+void	machdep_Lock
+(
+	void
+)
+{
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncIn("machdep_Lock");
+#endif
+
+	/* Please implement lock procedure */
+	mutex_lock(&McDrv_Mutex);
+
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncOut("machdep_Lock", 0);
+#endif
+}
+
+/***************************************************************************
+ *	machdep_Unlock
+ *
+ *	Function:
+ *			Unlock a call of the driver.
+ *	Arguments:
+ *			none
+ *	Return:
+ *			none
+ *
+ ****************************************************************************/
+void	machdep_Unlock
+(
+	void
+)
+{
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncIn("machdep_Unlock");
+#endif
+
+	/* Please implement unlock procedure */
+	mutex_unlock(&McDrv_Mutex);
+
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncOut("machdep_Unlock", 0);
+#endif
+}
+
+/***************************************************************************
+ *	machdep_DebugPrint
+ *
+ *	Function:
+ *			Output debug log.
+ *	Arguments:
+ *			pbLogString	log string buffer pointer
+ *	Return:
+ *			none
+ *
+ ****************************************************************************/
+void	machdep_DebugPrint
+(
+	UINT8*	pbLogString
+)
+{
+	/* Please implement debug output procedure */
+	pr_debug("MCDRV: %s\n", pbLogString);
+}
+
diff --git a/sound/soc/codecs/mc1n2/mcmachdep.h b/sound/soc/codecs/mc1n2/mcmachdep.h
new file mode 100644
index 0000000..ea62018
--- /dev/null
+++ b/sound/soc/codecs/mc1n2/mcmachdep.h
@@ -0,0 +1,34 @@
+/****************************************************************************
+ *
+ *		Copyright(c) 2010 Yamaha Corporation. All rights reserved.
+ *
+ *		Module		: mcmachdep.h
+ *
+ *		Description	: MC Driver machine dependent part header
+ *
+ *		Version		: 1.0.0 	2010.09.10
+ *
+ ****************************************************************************/
+
+#ifndef _MCMACHDEP_H_
+#define _MCMACHDEP_H_
+
+#include "mctypedef.h"
+
+
+#define	MCDRV_DEBUG_LEVEL	(0)
+
+
+void	machdep_SystemInit	( void );
+void	machdep_SystemTerm	( void );
+void	machdep_ClockStart	( void );
+void	machdep_ClockStop	( void );
+void	machdep_WriteI2C	( UINT8 bSlaveAdr, const UINT8 *pbData, UINT32 dSize );
+UINT8	machdep_ReadI2C		( UINT8 bSlaveAdr, UINT32 dAddress );
+void	machdep_Sleep		( UINT32 dSleepTime );
+void	machdep_Lock		( void );
+void	machdep_Unlock		( void );
+void	machdep_DebugPrint	( UINT8 *pbLogString );
+
+
+#endif /* _MCMACHDEP_H_ */
diff --git a/sound/soc/codecs/mc1n2/mcpacking.c b/sound/soc/codecs/mc1n2/mcpacking.c
new file mode 100644
index 0000000..89651c5
--- /dev/null
+++ b/sound/soc/codecs/mc1n2/mcpacking.c
@@ -0,0 +1,4710 @@
+/****************************************************************************
+ *
+ *		Copyright(c) 2010 Yamaha Corporation. All rights reserved.
+ *
+ *		Module		: mcpacking.c
+ *
+ *		Description	: MC Driver packet packing control
+ *
+ *		Version		: 1.0.0 	2010.09.10
+ *
+ ****************************************************************************/
+
+
+#include "mcpacking.h"
+#include "mcdevif.h"
+#include "mcresctrl.h"
+#include "mcdefs.h"
+#include "mcdevprof.h"
+#include "mcservice.h"
+#include "mcmachdep.h"
+#if MCDRV_DEBUG_LEVEL
+#include "mcdebuglog.h"
+#endif
+
+
+
+#define	MCDRV_TCXO_WAIT_TIME	((UINT32)2000)
+#define	MCDRV_PLRST_WAIT_TIME	((UINT32)2000)
+#define	MCDRV_LDOA_WAIT_TIME	((UINT32)1000)
+#define	MCDRV_SP_WAIT_TIME		((UINT32)150)
+#define	MCDRV_HP_WAIT_TIME		((UINT32)300)
+#define	MCDRV_RC_WAIT_TIME		((UINT32)150)
+
+/* SrcRate default */
+#define	MCDRV_DIR_SRCRATE_48000	(32768)
+#define	MCDRV_DIR_SRCRATE_44100	(30106)
+#define	MCDRV_DIR_SRCRATE_32000	(21845)
+#define	MCDRV_DIR_SRCRATE_24000	(16384)
+#define	MCDRV_DIR_SRCRATE_22050	(15053)
+#define	MCDRV_DIR_SRCRATE_16000	(10923)
+#define	MCDRV_DIR_SRCRATE_12000	(8192)
+#define	MCDRV_DIR_SRCRATE_11025	(7526)
+#define	MCDRV_DIR_SRCRATE_8000	(5461)
+
+#define	MCDRV_DIT_SRCRATE_48000	(4096)
+#define	MCDRV_DIT_SRCRATE_44100	(4458)
+#define	MCDRV_DIT_SRCRATE_32000	(6144)
+#define	MCDRV_DIT_SRCRATE_24000	(8192)
+#define	MCDRV_DIT_SRCRATE_22050	(8916)
+#define	MCDRV_DIT_SRCRATE_16000	(12288)
+#define	MCDRV_DIT_SRCRATE_12000	(16384)
+#define	MCDRV_DIT_SRCRATE_11025	(17833)
+#define	MCDRV_DIT_SRCRATE_8000	(24576)
+
+static SINT32	AddAnalogPowerUpAuto(const MCDRV_POWER_INFO* psPowerInfo, const MCDRV_POWER_UPDATE* psPowerUpdate);
+
+static void		AddDIPad(void);
+static void		AddPAD(void);
+static SINT32	AddSource(void);
+static void		AddDIStart(void);
+static UINT8	GetMicMixBit(const MCDRV_CHANNEL* psChannel);
+static void		AddDigVolPacket(UINT8 bVolL, UINT8 bVolR, UINT8 bVolLAddr, UINT8 bLAT, UINT8 bVolRAddr, MCDRV_VOLUPDATE_MODE eMode);
+static void		AddStopADC(void);
+static void		AddStopPDM(void);
+static UINT8	IsModifiedDIO(UINT32 dUpdateInfo);
+static UINT8	IsModifiedDIOCommon(MCDRV_DIO_PORT_NO ePort);
+static UINT8	IsModifiedDIODIR(MCDRV_DIO_PORT_NO ePort);
+static UINT8	IsModifiedDIODIT(MCDRV_DIO_PORT_NO ePort);
+static void		AddDIOCommon(MCDRV_DIO_PORT_NO ePort);
+static void		AddDIODIR(MCDRV_DIO_PORT_NO ePort);
+static void		AddDIODIT(MCDRV_DIO_PORT_NO ePort);
+
+#define	MCDRV_DPB_KEEP	0
+#define	MCDRV_DPB_UP	1
+static SINT32	PowerUpDig(UINT8 bDPBUp);
+
+static UINT32	GetMaxWait(UINT8 bRegChange);
+
+/****************************************************************************
+ *	McPacket_AddInit
+ *
+ *	Description:
+ *			Add initialize packet.
+ *	Arguments:
+ *			psInitInfo		information for initialization
+ *	Return:
+ *			MCDRV_SUCCESS
+ *			MCDRV_ERROR_RESOURCEOVER
+ *
+ ****************************************************************************/
+SINT32	McPacket_AddInit
+(
+	const MCDRV_INIT_INFO*	psInitInfo
+)
+{
+	SINT32	sdRet	= MCDRV_SUCCESS;
+	UINT8	bReg;
+	MCDRV_POWER_INFO	sPowerInfo;
+	MCDRV_POWER_UPDATE	sPowerUpdate;
+
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncIn("McPacket_AddInit");
+#endif
+
+
+	/*	RSTA	*/
+	McDevIf_AddPacket(MCDRV_PACKET_TYPE_FORCE_WRITE | MCDRV_PACKET_REGTYPE_A | (UINT32)MCI_RST, MCB_RST);
+	McDevIf_AddPacket(MCDRV_PACKET_TYPE_FORCE_WRITE | MCDRV_PACKET_REGTYPE_A | (UINT32)MCI_RST, 0);
+
+	/*	ANA_RST	*/
+	McDevIf_AddPacket(MCDRV_PACKET_TYPE_FORCE_WRITE | MCDRV_PACKET_REGTYPE_B_ANA | (UINT32)MCI_ANA_RST, MCI_ANA_RST_DEF);
+	McDevIf_AddPacket(MCDRV_PACKET_TYPE_FORCE_WRITE | MCDRV_PACKET_REGTYPE_B_ANA | (UINT32)MCI_ANA_RST, 0);
+
+	/*	SDIN_MSK*, SDO_DDR*	*/
+	bReg	= MCB_SDIN_MSK2;
+	if(psInitInfo->bDioSdo2Hiz == MCDRV_DAHIZ_LOW)
+	{
+		bReg |= MCB_SDO_DDR2;
+	}
+	bReg |= MCB_SDIN_MSK1;
+	if(psInitInfo->bDioSdo1Hiz == MCDRV_DAHIZ_LOW)
+	{
+		bReg |= MCB_SDO_DDR1;
+	}
+	McDevIf_AddPacket(MCDRV_PACKET_TYPE_WRITE | MCDRV_PACKET_REGTYPE_B_BASE | (UINT32)MCI_SD_MSK, bReg);
+
+	bReg	= MCB_SDIN_MSK0;
+	if(psInitInfo->bDioSdo0Hiz == MCDRV_DAHIZ_LOW)
+	{
+		bReg |= MCB_SDO_DDR0;
+	}
+	McDevIf_AddPacket(MCDRV_PACKET_TYPE_WRITE | MCDRV_PACKET_REGTYPE_B_BASE | (UINT32)MCI_SD_MSK_1, bReg);
+
+	/*	BCLK_MSK*, BCLD_DDR*, LRCK_MSK*, LRCK_DDR*, PCM_HIZ*	*/
+	bReg	= 0;
+	bReg |= MCB_BCLK_MSK2;
+	bReg |= MCB_LRCK_MSK2;
+	if(psInitInfo->bDioClk2Hiz == MCDRV_DAHIZ_LOW)
+	{
+		bReg |= MCB_BCLK_DDR2;
+		bReg |= MCB_LRCK_DDR2;
+	}
+	bReg |= MCB_BCLK_MSK1;
+	bReg |= MCB_LRCK_MSK1;
+	if(psInitInfo->bDioClk1Hiz == MCDRV_DAHIZ_LOW)
+	{
+		bReg |= MCB_BCLK_DDR1;
+		bReg |= MCB_LRCK_DDR1;
+	}
+	McDevIf_AddPacket(MCDRV_PACKET_TYPE_WRITE | MCDRV_PACKET_REGTYPE_B_BASE | (UINT32)MCI_BCLK_MSK, bReg);
+
+	bReg	= 0;
+	bReg |= MCB_BCLK_MSK0;
+	bReg |= MCB_LRCK_MSK0;
+	if(psInitInfo->bDioClk0Hiz == MCDRV_DAHIZ_LOW)
+	{
+		bReg |= MCB_BCLK_DDR0;
+		bReg |= MCB_LRCK_DDR0;
+	}
+	if(psInitInfo->bPcmHiz == MCDRV_PCMHIZ_HIZ)
+	{
+		bReg |= (MCB_PCMOUT_HIZ2 | MCB_PCMOUT_HIZ1 | MCB_PCMOUT_HIZ0);
+	}
+	McDevIf_AddPacket(MCDRV_PACKET_TYPE_WRITE | MCDRV_PACKET_REGTYPE_B_BASE | (UINT32)MCI_BCLK_MSK_1, bReg);
+
+	/*	DI*_BCKP	*/
+
+	/*	PA*_MSK, PA*_DDR	*/
+	bReg	= MCI_PA_MSK_DEF;
+	if(psInitInfo->bPad0Func == MCDRV_PAD_PDMCK)
+	{
+		bReg	|= MCB_PA0_DDR;
+	}
+	McDevIf_AddPacket(MCDRV_PACKET_TYPE_WRITE | MCDRV_PACKET_REGTYPE_B_BASE | (UINT32)MCI_PA_MSK, bReg);
+
+	/*	PA0_OUT	*/
+	if(psInitInfo->bPad0Func == MCDRV_PAD_PDMCK)
+	{
+		McDevIf_AddPacket(MCDRV_PACKET_TYPE_WRITE | MCDRV_PACKET_REGTYPE_B_BASE | (UINT32)MCI_PA_OUT, MCB_PA_OUT);
+	}
+
+	/*	SCU_PA*	*/
+
+	/*	CKSEL	*/
+	McDevIf_AddPacket(MCDRV_PACKET_TYPE_WRITE | MCDRV_PACKET_REGTYPE_B_CODEC | (UINT32)MCI_CKSEL, psInitInfo->bCkSel);
+
+	/*	DIVR0, DIVF0	*/
+	McDevIf_AddPacket(MCDRV_PACKET_TYPE_WRITE | MCDRV_PACKET_REGTYPE_B_CODEC | (UINT32)MCI_DIVR0, psInitInfo->bDivR0);
+	McDevIf_AddPacket(MCDRV_PACKET_TYPE_WRITE | MCDRV_PACKET_REGTYPE_B_CODEC | (UINT32)MCI_DIVF0, psInitInfo->bDivF0);
+	McDevIf_AddPacket(MCDRV_PACKET_TYPE_WRITE | MCDRV_PACKET_REGTYPE_B_CODEC | (UINT32)MCI_DIVR1, psInitInfo->bDivR1);
+	McDevIf_AddPacket(MCDRV_PACKET_TYPE_WRITE | MCDRV_PACKET_REGTYPE_B_CODEC | (UINT32)MCI_DIVF1, psInitInfo->bDivF1);
+
+	/*	Clock Start	*/
+	sdRet	= McDevIf_ExecutePacket();
+	if(sdRet == MCDRV_SUCCESS)
+	{
+		McSrv_ClockStart();
+
+		/*	DP0	*/
+		bReg	= MCI_DPADIF_DEF & (UINT8)~MCB_DP0_CLKI0;
+		McDevIf_AddPacket(MCDRV_PACKET_TYPE_WRITE | MCDRV_PACKET_REGTYPE_B_CODEC | (UINT32)MCI_DPADIF, bReg);
+		if(psInitInfo->bCkSel != MCDRV_CKSEL_CMOS)
+		{
+			/*	2ms wait	*/
+			McDevIf_AddPacket(MCDRV_PACKET_TYPE_TIMWAIT | MCDRV_TCXO_WAIT_TIME, 0);
+		}
+
+		/*	PLLRST0	*/
+		McDevIf_AddPacket(MCDRV_PACKET_TYPE_WRITE | MCDRV_PACKET_REGTYPE_B_CODEC | (UINT32)MCI_PLL_RST, 0);
+		/*	2ms wait	*/
+		McDevIf_AddPacket(MCDRV_PACKET_TYPE_TIMWAIT | MCDRV_PLRST_WAIT_TIME, 0);
+		/*	DP1/DP2 up	*/
+		McDevIf_AddPacket(MCDRV_PACKET_TYPE_WRITE | MCDRV_PACKET_REGTYPE_B_BASE | (UINT32)MCI_PWM_DIGITAL, 0);
+		/*	RSTB	*/
+		McDevIf_AddPacket(MCDRV_PACKET_TYPE_WRITE | MCDRV_PACKET_REGTYPE_B_BASE | (UINT32)MCI_RSTB, 0);
+		/*	DPB	*/
+		bReg	= MCB_PWM_DPPDM|MCB_PWM_DPDI2|MCB_PWM_DPDI1|MCB_PWM_DPDI0;
+		McDevIf_AddPacket(MCDRV_PACKET_TYPE_WRITE | MCDRV_PACKET_REGTYPE_B_BASE | (UINT32)MCI_PWM_DIGITAL_1, bReg);
+
+		/*	DCL_GAIN, DCL_LMT	*/
+		bReg	= (psInitInfo->bDclGain<<4) | psInitInfo->bDclLimit;
+		McDevIf_AddPacket(MCDRV_PACKET_TYPE_WRITE | MCDRV_PACKET_REGTYPE_B_CODEC | (UINT32)MCI_DCL, bReg);
+
+		/*	DIF_LI, DIF_LO*	*/
+		bReg	= (psInitInfo->bLineOut2Dif<<5) | (psInitInfo->bLineOut1Dif<<4) | psInitInfo->bLineIn1Dif;
+		McDevIf_AddPacket(MCDRV_PACKET_TYPE_WRITE | MCDRV_PACKET_REGTYPE_B_ANA | (UINT32)MCI_DIF_LINE, bReg);
+
+		/*	SP*_HIZ, SPMN	*/
+		bReg	= (psInitInfo->bSpmn << 1);
+		if(MCDRV_SPHIZ_HIZ == psInitInfo->bSpHiz)
+		{
+			bReg	|= (MCB_SPL_HIZ|MCB_SPR_HIZ);
+		}
+		McDevIf_AddPacket(MCDRV_PACKET_TYPE_WRITE | MCDRV_PACKET_REGTYPE_B_ANA | (UINT32)MCI_SP_MODE, bReg);
+
+		/*	MC*SNG	*/
+		bReg	= (psInitInfo->bMic2Sng<<6) | (psInitInfo->bMic1Sng<<2);
+		McDevIf_AddPacket(MCDRV_PACKET_TYPE_WRITE | MCDRV_PACKET_REGTYPE_B_ANA | (UINT32)MCI_MC_GAIN, bReg);
+		bReg	= (psInitInfo->bMic3Sng<<2);
+		McDevIf_AddPacket(MCDRV_PACKET_TYPE_WRITE | MCDRV_PACKET_REGTYPE_B_ANA | (UINT32)MCI_MC3_GAIN, bReg);
+
+		/*	CPMOD	*/
+		McDevIf_AddPacket(MCDRV_PACKET_TYPE_WRITE | MCDRV_PACKET_REGTYPE_B_ANA | (UINT32)MCI_CPMOD, psInitInfo->bCpMod);
+
+		/*	AVDDLEV, VREFLEV	*/
+		bReg	= 0x20 | psInitInfo->bAvddLev;
+		McDevIf_AddPacket(MCDRV_PACKET_TYPE_WRITE | MCDRV_PACKET_REGTYPE_B_ANA | (UINT32)MCI_LEV, bReg);
+
+		if(((psInitInfo->bPowerMode & MCDRV_POWMODE_VREFON) != 0) || (McResCtrl_GetAPMode() == eMCDRV_APM_OFF))
+		{
+			bReg	= MCI_PWM_ANALOG_0_DEF;
+			if(psInitInfo->bLdo == MCDRV_LDO_ON)
+			{
+				/*	AP_LDOA	*/
+				bReg	&= (UINT8)~MCB_PWM_LDOA;
+				McDevIf_AddPacket(MCDRV_PACKET_TYPE_WRITE | MCDRV_PACKET_REGTYPE_B_ANA | (UINT32)MCI_PWM_ANALOG_0, bReg);
+				McDevIf_AddPacket(MCDRV_PACKET_TYPE_TIMWAIT | MCDRV_LDOA_WAIT_TIME, 0);
+			}
+			else
+			{
+				bReg	&= (UINT8)~MCB_PWM_REFA;
+			}
+			/*	AP_VR up	*/
+			bReg	&= (UINT8)~MCB_PWM_VR;
+			McDevIf_AddPacket(MCDRV_PACKET_TYPE_WRITE | MCDRV_PACKET_REGTYPE_B_ANA | (UINT32)MCI_PWM_ANALOG_0, bReg);
+			sdRet	= McDevIf_ExecutePacket();
+			if(sdRet == MCDRV_SUCCESS)
+			{
+				McDevIf_AddPacket(MCDRV_PACKET_TYPE_TIMWAIT | psInitInfo->sWaitTime.dVrefRdy2, 0);
+			}
+		}
+	}
+
+	if(MCDRV_SUCCESS == sdRet)
+	{
+		if(McResCtrl_GetAPMode() == eMCDRV_APM_OFF)
+		{
+			bReg	= MCB_APMOFF_SP|MCB_APMOFF_HP|MCB_APMOFF_RC;
+			McDevIf_AddPacket(MCDRV_PACKET_TYPE_WRITE | MCDRV_PACKET_REGTYPE_B_ANA | (UINT32)MCI_APMOFF, bReg);
+		}
+		sdRet	= McDevIf_ExecutePacket();
+	}
+	if(MCDRV_SUCCESS == sdRet)
+	{
+		/*	unused path power down	*/
+		McResCtrl_GetPowerInfo(&sPowerInfo);
+		sPowerUpdate.dDigital		= MCDRV_POWUPDATE_DIGITAL_ALL;
+		sPowerUpdate.abAnalog[0]	= (UINT8)MCDRV_POWUPDATE_ANALOG0_ALL;
+		sPowerUpdate.abAnalog[1]	= (UINT8)MCDRV_POWUPDATE_ANALOG1_ALL;
+		sPowerUpdate.abAnalog[2]	= (UINT8)MCDRV_POWUPDATE_ANALOG2_ALL;
+		sPowerUpdate.abAnalog[3]	= (UINT8)MCDRV_POWUPDATE_ANALOG3_ALL;
+		sPowerUpdate.abAnalog[4]	= (UINT8)MCDRV_POWUPDATE_ANALOG4_ALL;
+		sdRet	= McPacket_AddPowerDown(&sPowerInfo, &sPowerUpdate);
+	}
+
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncOut("McPacket_AddInit", &sdRet);
+#endif
+
+	return sdRet;
+}
+
+/****************************************************************************
+ *	McPacket_AddPowerUp
+ *
+ *	Description:
+ *			Add powerup packet.
+ *	Arguments:
+ *			psPowerInfo		power information
+ *			psPowerUpdate	power update information
+ *	Return:
+ *			MCDRV_SUCCESS
+ *			MCDRV_ERROR_RESOURCEOVER
+ *			MCDRV_ERROR_TIMEOUT
+ *
+ ****************************************************************************/
+SINT32	McPacket_AddPowerUp
+(
+	const MCDRV_POWER_INFO*		psPowerInfo,
+	const MCDRV_POWER_UPDATE*	psPowerUpdate
+)
+{
+	SINT32	sdRet	= MCDRV_SUCCESS;
+	UINT8	bReg;
+	UINT8	bRegDPADIF;
+	UINT8	bRegCur;
+	UINT8	bRegAna1;
+	UINT8	bRegAna2;
+	UINT32	dUpdate;
+	UINT8	bRegChange;
+	UINT8	bSpHizReg;
+	UINT32	dWaitTime;
+	UINT32	dWaitTimeDone	= 0;
+	UINT8	bWaitVREFRDY	= 0;
+	UINT8	bWaitHPVolUp	= 0;
+	UINT8	bWaitSPVolUp	= 0;
+	MCDRV_INIT_INFO		sInitInfo;
+
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncIn("McPacket_AddPowerUp");
+#endif
+
+	bRegDPADIF	= McResCtrl_GetRegVal(MCDRV_PACKET_REGTYPE_B_CODEC, MCI_DPADIF);
+
+
+	McResCtrl_GetInitInfo(&sInitInfo);
+
+	/*	Digital Power	*/
+	dUpdate	= ~psPowerInfo->dDigital & psPowerUpdate->dDigital;
+	if((dUpdate & MCDRV_POWINFO_DIGITAL_DP0) != 0UL)
+	{
+		if((bRegDPADIF & (MCB_DP0_CLKI1|MCB_DP0_CLKI0)) == (MCB_DP0_CLKI1|MCB_DP0_CLKI0))
+		{/*	DP0 changed	*/
+			/*	CKSEL	*/
+			McDevIf_AddPacket(MCDRV_PACKET_TYPE_WRITE | MCDRV_PACKET_REGTYPE_B_CODEC | (UINT32)MCI_CKSEL, sInitInfo.bCkSel);
+			/*	DIVR0, DIVF0	*/
+			McDevIf_AddPacket(MCDRV_PACKET_TYPE_WRITE | MCDRV_PACKET_REGTYPE_B_CODEC | (UINT32)MCI_DIVR0, sInitInfo.bDivR0);
+			McDevIf_AddPacket(MCDRV_PACKET_TYPE_WRITE | MCDRV_PACKET_REGTYPE_B_CODEC | (UINT32)MCI_DIVF0, sInitInfo.bDivF0);
+			McDevIf_AddPacket(MCDRV_PACKET_TYPE_WRITE | MCDRV_PACKET_REGTYPE_B_CODEC | (UINT32)MCI_DIVR1, sInitInfo.bDivR1);
+			McDevIf_AddPacket(MCDRV_PACKET_TYPE_WRITE | MCDRV_PACKET_REGTYPE_B_CODEC | (UINT32)MCI_DIVF1, sInitInfo.bDivF1);
+			sdRet	= McDevIf_ExecutePacket();
+			if(sdRet == MCDRV_SUCCESS)
+			{
+				/*	Clock Start	*/
+				McSrv_ClockStart();
+				/*	DP0 up	*/
+				if((((bRegDPADIF & MCB_CLKSRC) == 0) && ((bRegDPADIF & MCB_CLKINPUT) == 0))
+				|| (((bRegDPADIF & MCB_CLKSRC) != 0) && ((bRegDPADIF & MCB_CLKINPUT) != 0)))
+				{
+					bRegDPADIF	&= (UINT8)~MCB_DP0_CLKI0;
+				}
+				else
+				{
+					bRegDPADIF	&= (UINT8)~MCB_DP0_CLKI1;
+				}
+				McDevIf_AddPacket(MCDRV_PACKET_TYPE_WRITE | MCDRV_PACKET_REGTYPE_B_CODEC | (UINT32)MCI_DPADIF, bRegDPADIF);
+				if(sInitInfo.bCkSel != MCDRV_CKSEL_CMOS)
+				{
+					McDevIf_AddPacket(MCDRV_PACKET_TYPE_TIMWAIT | MCDRV_TCXO_WAIT_TIME, 0);
+				}
+				/*	PLLRST0 up	*/
+				McDevIf_AddPacket(MCDRV_PACKET_TYPE_WRITE | MCDRV_PACKET_REGTYPE_B_CODEC | (UINT32)MCI_PLL_RST, 0);
+				/*	2ms wait	*/
+				McDevIf_AddPacket(MCDRV_PACKET_TYPE_TIMWAIT | MCDRV_PLRST_WAIT_TIME, 0);
+				sdRet	= McDevIf_ExecutePacket();
+				if(sdRet == MCDRV_SUCCESS)
+				{
+					/*	DP1/DP2 up	*/
+					McDevIf_AddPacket(MCDRV_PACKET_TYPE_WRITE | MCDRV_PACKET_REGTYPE_B_BASE | (UINT32)MCI_PWM_DIGITAL, 0);
+					/*	DPB/DPDI* up	*/
+					bReg	= McResCtrl_GetRegVal(MCDRV_PACKET_REGTYPE_B_BASE, MCI_PWM_DIGITAL_1);
+					if((dUpdate & MCDRV_POWINFO_DIGITAL_DPDI0) != 0UL)
+					{
+						bReg	&= (UINT8)~MCB_PWM_DPDI0;
+					}
+					if((dUpdate & MCDRV_POWINFO_DIGITAL_DPDI1) != 0UL)
+					{
+						bReg	&= (UINT8)~MCB_PWM_DPDI1;
+					}
+					if((dUpdate & MCDRV_POWINFO_DIGITAL_DPDI2) != 0UL)
+					{
+						bReg	&= (UINT8)~MCB_PWM_DPDI2;
+					}
+					if((dUpdate & MCDRV_POWINFO_DIGITAL_DPPDM) != 0UL)
+					{
+						bReg	&= (UINT8)~MCB_PWM_DPPDM;
+					}
+					if((dUpdate & MCDRV_POWINFO_DIGITAL_DPB) != 0UL)
+					{
+						bReg	&= (UINT8)~MCB_PWM_DPB;
+					}
+					McDevIf_AddPacket(MCDRV_PACKET_TYPE_WRITE | MCDRV_PACKET_REGTYPE_B_BASE | (UINT32)MCI_PWM_DIGITAL_1, bReg);
+				}
+			}
+		}
+		else if((dUpdate & MCDRV_POWINFO_DIGITAL_DP2) != 0UL)
+		{
+			/*	DP1/DP2 up	*/
+			McDevIf_AddPacket(MCDRV_PACKET_TYPE_WRITE | MCDRV_PACKET_REGTYPE_B_BASE | (UINT32)MCI_PWM_DIGITAL, 0);
+			/*	DPB/DPDI* up	*/
+			bReg	= McResCtrl_GetRegVal(MCDRV_PACKET_REGTYPE_B_BASE, MCI_PWM_DIGITAL_1);
+			if((dUpdate & MCDRV_POWINFO_DIGITAL_DPDI0) != 0UL)
+			{
+				bReg	&= (UINT8)~MCB_PWM_DPDI0;
+			}
+			if((dUpdate & MCDRV_POWINFO_DIGITAL_DPDI1) != 0UL)
+			{
+				bReg	&= (UINT8)~MCB_PWM_DPDI1;
+			}
+			if((dUpdate & MCDRV_POWINFO_DIGITAL_DPDI2) != 0UL)
+			{
+				bReg	&= (UINT8)~MCB_PWM_DPDI2;
+			}
+			if((dUpdate & MCDRV_POWINFO_DIGITAL_DPPDM) != 0UL)
+			{
+				bReg	&= (UINT8)~MCB_PWM_DPPDM;
+			}
+			if((dUpdate & MCDRV_POWINFO_DIGITAL_DPB) != 0UL)
+			{
+				bReg	&= (UINT8)~MCB_PWM_DPB;
+			}
+			McDevIf_AddPacket(MCDRV_PACKET_TYPE_WRITE | MCDRV_PACKET_REGTYPE_B_BASE | (UINT32)MCI_PWM_DIGITAL_1, bReg);
+		}
+		else
+		{
+		}
+
+		if(sdRet == MCDRV_SUCCESS)
+		{
+			/*	DPBDSP	*/
+			if((dUpdate & MCDRV_POWINFO_DIGITAL_DPBDSP) != 0UL)
+			{
+				McDevIf_AddPacket(MCDRV_PACKET_TYPE_WRITE | MCDRV_PACKET_REGTYPE_B_BASE | (UINT32)MCI_PWM_DIGITAL_BDSP, 0);
+			}
+			/*	DPADIF	*/
+			if((dUpdate & MCDRV_POWINFO_DIGITAL_DPADIF) != 0UL)
+			{
+				bRegDPADIF	= McResCtrl_GetRegVal(MCDRV_PACKET_REGTYPE_B_CODEC, MCI_DPADIF);
+				bRegDPADIF	&= (UINT8)~MCB_DPADIF;
+				McDevIf_AddPacket(MCDRV_PACKET_TYPE_WRITE | MCDRV_PACKET_REGTYPE_B_CODEC | (UINT32)MCI_DPADIF, bRegDPADIF);
+			}
+		}
+	}
+
+	if(sdRet == MCDRV_SUCCESS)
+	{
+		if(McResCtrl_GetAPMode() == eMCDRV_APM_ON)
+		{
+			sdRet	= AddAnalogPowerUpAuto(psPowerInfo, psPowerUpdate);
+		}
+		else
+		{
+			/*	Analog Power	*/
+			dUpdate	= (UINT32)~psPowerInfo->abAnalog[0] & (UINT32)psPowerUpdate->abAnalog[0];
+			if((dUpdate & (UINT32)MCB_PWM_VR) != 0UL)
+			{
+				if((McResCtrl_GetRegVal(MCDRV_PACKET_REGTYPE_B_ANA, MCI_PWM_ANALOG_0) & MCB_PWM_VR) != 0)
+				{/*	AP_VR changed	*/
+					bReg	= MCI_PWM_ANALOG_0_DEF;
+					if(sInitInfo.bLdo == MCDRV_LDO_ON)
+					{
+						/*	AP_LDOA	*/
+						bReg	&= (UINT8)~MCB_PWM_LDOA;
+						McDevIf_AddPacket(MCDRV_PACKET_TYPE_WRITE | MCDRV_PACKET_REGTYPE_B_ANA | (UINT32)MCI_PWM_ANALOG_0, bReg);
+						McDevIf_AddPacket(MCDRV_PACKET_TYPE_TIMWAIT | MCDRV_LDOA_WAIT_TIME, 0);
+					}
+					else
+					{
+						bReg	&= (UINT8)~MCB_PWM_REFA;
+					}
+					/*	AP_VR up	*/
+					bReg	&= (UINT8)~MCB_PWM_VR;
+					McDevIf_AddPacket(MCDRV_PACKET_TYPE_WRITE | MCDRV_PACKET_REGTYPE_B_ANA | (UINT32)MCI_PWM_ANALOG_0, bReg);
+					dWaitTimeDone	= sInitInfo.sWaitTime.dVrefRdy1;
+					McDevIf_AddPacket(MCDRV_PACKET_TYPE_TIMWAIT | dWaitTimeDone, 0);
+					bWaitVREFRDY	= 1;
+				}
+
+				bReg	= (UINT8)((UINT8)~((UINT8)~psPowerInfo->abAnalog[1] & psPowerUpdate->abAnalog[1]) & McResCtrl_GetRegVal(MCDRV_PACKET_REGTYPE_B_ANA, MCI_PWM_ANALOG_1));
+				/*	SP_HIZ control	*/
+				if(MCDRV_SPHIZ_HIZ == sInitInfo.bSpHiz)
+				{
+					bSpHizReg	= 0;
+					if((bReg & (MCB_PWM_SPL1 | MCB_PWM_SPL2)) != 0)
+					{
+						bSpHizReg |= MCB_SPL_HIZ;
+					}
+
+					if((bReg & (MCB_PWM_SPR1 | MCB_PWM_SPR2)) != 0)
+					{
+						bSpHizReg |= MCB_SPR_HIZ;
+					}
+
+					bSpHizReg |= (McResCtrl_GetRegVal(MCDRV_PACKET_REGTYPE_B_ANA, MCI_SP_MODE) & (MCB_SPMN | MCB_SP_SWAP));
+					McDevIf_AddPacket(MCDRV_PACKET_TYPE_WRITE | MCDRV_PACKET_REGTYPE_B_ANA | (UINT32)MCI_SP_MODE, bSpHizReg);
+				}
+
+				bRegCur	= McResCtrl_GetRegVal(MCDRV_PACKET_REGTYPE_B_ANA, MCI_PWM_ANALOG_3);
+				bReg	= (UINT8)((UINT8)~((UINT8)~psPowerInfo->abAnalog[3] & psPowerUpdate->abAnalog[3]) & bRegCur);
+				bRegChange	= bReg ^ bRegCur;
+				/*	set DACON and NSMUTE before setting 0 to AP_DA	*/
+				if(((bRegChange & (MCB_PWM_DAR|MCB_PWM_DAL)) != 0) && ((psPowerInfo->abAnalog[3] & psPowerUpdate->abAnalog[3] & (MCB_PWM_DAR|MCB_PWM_DAL)) != (MCB_PWM_DAR|MCB_PWM_DAL)))
+				{
+					if((McResCtrl_GetRegVal(MCDRV_PACKET_REGTYPE_B_CODEC, MCI_DAC_CONFIG) & MCB_DACON) == 0)
+					{
+						McDevIf_AddPacket(MCDRV_PACKET_TYPE_WRITE | MCDRV_PACKET_REGTYPE_B_CODEC | (UINT32)MCI_DAC_CONFIG, MCB_NSMUTE);
+						McDevIf_AddPacket(MCDRV_PACKET_TYPE_WRITE | MCDRV_PACKET_REGTYPE_B_CODEC | (UINT32)MCI_DAC_CONFIG, (MCB_DACON | MCB_NSMUTE));
+						McDevIf_AddPacket(MCDRV_PACKET_TYPE_WRITE | MCDRV_PACKET_REGTYPE_B_CODEC | (UINT32)MCI_DAC_CONFIG, MCB_DACON);
+					}
+				}
+				McDevIf_AddPacket(MCDRV_PACKET_TYPE_WRITE | MCDRV_PACKET_REGTYPE_B_ANA | (UINT32)MCI_PWM_ANALOG_3, bReg);
+				bRegChange	&= (MCB_PWM_MB1|MCB_PWM_MB2|MCB_PWM_MB3);
+
+				bRegCur	= McResCtrl_GetRegVal(MCDRV_PACKET_REGTYPE_B_ANA, MCI_PWM_ANALOG_4);
+				bReg	= (UINT8)((UINT8)~((UINT8)~psPowerInfo->abAnalog[4] & psPowerUpdate->abAnalog[4]) & bRegCur);
+				bRegChange	|= (bReg ^ bRegCur);
+				McDevIf_AddPacket(MCDRV_PACKET_TYPE_WRITE | MCDRV_PACKET_REGTYPE_B_ANA | (UINT32)MCI_PWM_ANALOG_4, bReg);
+
+				if(bWaitVREFRDY != 0)
+				{
+					/*	wait VREF_RDY	*/
+					dWaitTimeDone	= sInitInfo.sWaitTime.dVrefRdy2 - dWaitTimeDone;
+					McDevIf_AddPacket(MCDRV_PACKET_TYPE_TIMWAIT | dWaitTimeDone, 0);
+				}
+
+				sdRet	= McDevIf_ExecutePacket();
+				if(sdRet == MCDRV_SUCCESS)
+				{
+					bRegCur	= McResCtrl_GetRegVal(MCDRV_PACKET_REGTYPE_B_ANA, MCI_PWM_ANALOG_0);
+					bReg	= (UINT8)(~dUpdate & bRegCur);
+					McDevIf_AddPacket(MCDRV_PACKET_TYPE_WRITE | MCDRV_PACKET_REGTYPE_B_ANA | (UINT32)MCI_PWM_ANALOG_0, bReg);
+					if(((bRegCur & MCB_PWM_CP) != 0) && ((bReg & MCB_PWM_CP) == 0))
+					{/*	AP_CP up	*/
+						dWaitTime		= MCDRV_HP_WAIT_TIME;
+					}
+					else
+					{
+						dWaitTime	= 0;
+					}
+
+					bRegCur	= McResCtrl_GetRegVal(MCDRV_PACKET_REGTYPE_B_ANA, MCI_PWM_ANALOG_1);
+					bRegAna1	= (UINT8)((UINT8)~((UINT8)~psPowerInfo->abAnalog[1] & psPowerUpdate->abAnalog[1]) & bRegCur);
+					if((((bRegCur & MCB_PWM_SPL1) != 0) && ((bRegAna1 & MCB_PWM_SPL1) == 0))
+					|| (((bRegCur & MCB_PWM_SPR1) != 0) && ((bRegAna1 & MCB_PWM_SPR1) == 0)))
+					{/*	AP_SP* up	*/
+						bReg	= bRegAna1|(bRegCur&(UINT8)~(MCB_PWM_SPL1|MCB_PWM_SPR1));
+						McDevIf_AddPacket(MCDRV_PACKET_TYPE_WRITE | MCDRV_PACKET_REGTYPE_B_ANA | (UINT32)MCI_PWM_ANALOG_1, bReg);
+						if(dWaitTime == (UINT32)0)
+						{
+							dWaitTime		= MCDRV_SP_WAIT_TIME;
+							bWaitSPVolUp	= 1;
+						}
+					}
+					if((((bRegCur & MCB_PWM_HPL) != 0) && ((bRegAna1 & MCB_PWM_HPL) == 0))
+					|| (((bRegCur & MCB_PWM_HPR) != 0) && ((bRegAna1 & MCB_PWM_HPR) == 0)))
+					{
+						bWaitHPVolUp	= 1;
+					}
+
+					bRegCur	= McResCtrl_GetRegVal(MCDRV_PACKET_REGTYPE_B_ANA, MCI_PWM_ANALOG_2);
+					bRegAna2	= (UINT8)((UINT8)~((UINT8)~psPowerInfo->abAnalog[2] & psPowerUpdate->abAnalog[2]) & bRegCur);
+					if(((bRegCur & MCB_PWM_RC1) != 0) && ((bRegAna2 & MCB_PWM_RC1) == 0))
+					{/*	AP_RC up	*/
+						bReg	= bRegAna2|(bRegCur&(UINT8)~MCB_PWM_RC1);
+						McDevIf_AddPacket(MCDRV_PACKET_TYPE_WRITE | MCDRV_PACKET_REGTYPE_B_ANA | (UINT32)MCI_PWM_ANALOG_2, bReg);
+						if(dWaitTime == (UINT32)0)
+						{
+							dWaitTime	= MCDRV_RC_WAIT_TIME;
+						}
+					}
+					if(dWaitTime > (UINT32)0)
+					{
+						McDevIf_AddPacket(MCDRV_PACKET_TYPE_TIMWAIT | dWaitTime, 0);
+						dWaitTimeDone	+= dWaitTime;
+					}
+
+					McDevIf_AddPacket(MCDRV_PACKET_TYPE_WRITE | MCDRV_PACKET_REGTYPE_B_ANA | (UINT32)MCI_PWM_ANALOG_1, bRegAna1);
+					McDevIf_AddPacket(MCDRV_PACKET_TYPE_WRITE | MCDRV_PACKET_REGTYPE_B_ANA | (UINT32)MCI_PWM_ANALOG_2, bRegAna2);
+
+					/*	time wait	*/
+					dWaitTime	= GetMaxWait(bRegChange);
+					if(dWaitTime > dWaitTimeDone)
+					{
+						dWaitTime	= dWaitTime - dWaitTimeDone;
+						McDevIf_AddPacket(MCDRV_PACKET_TYPE_TIMWAIT | dWaitTime, 0);
+						dWaitTimeDone	+= dWaitTime;
+					}
+
+					if((bWaitSPVolUp != 0) && (sInitInfo.sWaitTime.dSpRdy > dWaitTimeDone))
+					{
+						dWaitTime	= sInitInfo.sWaitTime.dSpRdy - dWaitTimeDone;
+						McDevIf_AddPacket(MCDRV_PACKET_TYPE_TIMWAIT | dWaitTime, 0);
+						dWaitTimeDone	+= dWaitTime;
+					}
+					if((bWaitHPVolUp != 0) && (sInitInfo.sWaitTime.dHpRdy > dWaitTimeDone))
+					{
+						dWaitTime	= sInitInfo.sWaitTime.dHpRdy - dWaitTimeDone;
+						McDevIf_AddPacket(MCDRV_PACKET_TYPE_TIMWAIT | dWaitTime, 0);
+						dWaitTimeDone	+= dWaitTime;
+					}
+				}
+			}
+		}
+	}
+
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncOut("McPacket_AddPowerUp", &sdRet);
+#endif
+	return sdRet;
+}
+
+/****************************************************************************
+ *	AddAnalogPowerUpAuto
+ *
+ *	Description:
+ *			Add analog auto powerup packet.
+ *	Arguments:
+ *			psPowerInfo		power information
+ *			psPowerUpdate	power update information
+ *	Return:
+ *			MCDRV_SUCCESS
+ *			MCDRV_ERROR_RESOURCEOVER
+ *			MCDRV_ERROR_TIMEOUT
+ *
+ ****************************************************************************/
+static SINT32	AddAnalogPowerUpAuto
+(
+	const MCDRV_POWER_INFO*		psPowerInfo,
+	const MCDRV_POWER_UPDATE*	psPowerUpdate
+)
+{
+	SINT32	sdRet	= MCDRV_SUCCESS;
+	UINT8	bReg;
+	UINT8	bRegCur;
+	UINT32	dUpdate;
+	UINT8	bRegChange;
+	UINT8	bSpHizReg;
+	MCDRV_INIT_INFO	sInitInfo;
+	UINT32	dWaitTime	= 0;
+
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncIn("AddAnalogPowerUpAuto");
+#endif
+
+
+	McResCtrl_GetInitInfo(&sInitInfo);
+
+	/*	Analog Power	*/
+	dUpdate	= (UINT32)~psPowerInfo->abAnalog[0] & psPowerUpdate->abAnalog[0];
+	if((dUpdate & (UINT32)MCB_PWM_VR) != 0UL)
+	{
+		if((McResCtrl_GetRegVal(MCDRV_PACKET_REGTYPE_B_ANA, MCI_PWM_ANALOG_0) & MCB_PWM_VR) != 0)
+		{/*	AP_VR changed	*/
+			/*	AP_VR up	*/
+			bReg	= MCI_PWM_ANALOG_0_DEF;
+			if(sInitInfo.bLdo == MCDRV_LDO_ON)
+			{
+				/*	AP_LDOA	*/
+				bReg	&= (UINT8)~MCB_PWM_LDOA;
+				McDevIf_AddPacket(MCDRV_PACKET_TYPE_WRITE | MCDRV_PACKET_REGTYPE_B_ANA | (UINT32)MCI_PWM_ANALOG_0, bReg);
+				McDevIf_AddPacket(MCDRV_PACKET_TYPE_TIMWAIT | MCDRV_LDOA_WAIT_TIME, 0);
+			}
+			else
+			{
+				bReg	&= (UINT8)~MCB_PWM_REFA;
+			}
+			bReg	&= (UINT8)~MCB_PWM_VR;
+			McDevIf_AddPacket(MCDRV_PACKET_TYPE_WRITE | MCDRV_PACKET_REGTYPE_B_ANA | (UINT32)MCI_PWM_ANALOG_0, bReg);
+			McDevIf_AddPacket(MCDRV_PACKET_TYPE_TIMWAIT | sInitInfo.sWaitTime.dVrefRdy1, 0);
+			if(sInitInfo.sWaitTime.dVrefRdy2 > sInitInfo.sWaitTime.dVrefRdy1)
+			{
+				dWaitTime	= sInitInfo.sWaitTime.dVrefRdy2 - sInitInfo.sWaitTime.dVrefRdy1;
+			}
+		}
+
+		bReg	= (UINT8)((UINT8)~((UINT8)~psPowerInfo->abAnalog[1] & psPowerUpdate->abAnalog[1]) & McResCtrl_GetRegVal(MCDRV_PACKET_REGTYPE_B_ANA, MCI_PWM_ANALOG_1));
+		/*	SP_HIZ control	*/
+		if(MCDRV_SPHIZ_HIZ == sInitInfo.bSpHiz)
+		{
+			bSpHizReg	= 0;
+			if((bReg & (MCB_PWM_SPL1 | MCB_PWM_SPL2)) != 0)
+			{
+				bSpHizReg |= MCB_SPL_HIZ;
+			}
+
+			if((bReg & (MCB_PWM_SPR1 | MCB_PWM_SPR2)) != 0)
+			{
+				bSpHizReg |= MCB_SPR_HIZ;
+			}
+
+			bSpHizReg |= (McResCtrl_GetRegVal(MCDRV_PACKET_REGTYPE_B_ANA, MCI_SP_MODE) & (MCB_SPMN | MCB_SP_SWAP));
+			McDevIf_AddPacket(MCDRV_PACKET_TYPE_WRITE | MCDRV_PACKET_REGTYPE_B_ANA | (UINT32)MCI_SP_MODE, bSpHizReg);
+		}
+
+		bRegCur	= McResCtrl_GetRegVal(MCDRV_PACKET_REGTYPE_B_ANA, MCI_PWM_ANALOG_3);
+		bReg	= (UINT8)~((UINT8)~psPowerInfo->abAnalog[3] & psPowerUpdate->abAnalog[3]) & bRegCur;
+		bRegChange	= bReg ^ bRegCur;
+		/*	set DACON and NSMUTE before setting 0 to AP_DA	*/
+		if(((bRegChange & (MCB_PWM_DAR|MCB_PWM_DAL)) != 0) && ((psPowerInfo->abAnalog[3] & psPowerUpdate->abAnalog[3] & (MCB_PWM_DAR|MCB_PWM_DAL)) != (MCB_PWM_DAR|MCB_PWM_DAL)))
+		{
+			if((McResCtrl_GetRegVal(MCDRV_PACKET_REGTYPE_B_CODEC, MCI_DAC_CONFIG) & MCB_DACON) == 0)
+			{
+				McDevIf_AddPacket(MCDRV_PACKET_TYPE_WRITE | MCDRV_PACKET_REGTYPE_B_CODEC | (UINT32)MCI_DAC_CONFIG, MCB_NSMUTE);
+				McDevIf_AddPacket(MCDRV_PACKET_TYPE_WRITE | MCDRV_PACKET_REGTYPE_B_CODEC | (UINT32)MCI_DAC_CONFIG, (MCB_DACON | MCB_NSMUTE));
+				McDevIf_AddPacket(MCDRV_PACKET_TYPE_WRITE | MCDRV_PACKET_REGTYPE_B_CODEC | (UINT32)MCI_DAC_CONFIG, MCB_DACON);
+			}
+		}
+		McDevIf_AddPacket(MCDRV_PACKET_TYPE_WRITE | MCDRV_PACKET_REGTYPE_B_ANA | (UINT32)MCI_PWM_ANALOG_3, bReg);
+		bRegChange	&= (MCB_PWM_MB1|MCB_PWM_MB2|MCB_PWM_MB3);
+
+		bRegCur	= McResCtrl_GetRegVal(MCDRV_PACKET_REGTYPE_B_ANA, MCI_PWM_ANALOG_4);
+		bReg	= (UINT8)~((UINT8)~psPowerInfo->abAnalog[4] & psPowerUpdate->abAnalog[4]) & bRegCur;
+		bRegChange	|= (bReg ^ bRegCur);
+		McDevIf_AddPacket(MCDRV_PACKET_TYPE_WRITE | MCDRV_PACKET_REGTYPE_B_ANA | (UINT32)MCI_PWM_ANALOG_4, bReg);
+
+		if(dWaitTime > (UINT32)0)
+		{
+			McDevIf_AddPacket(MCDRV_PACKET_TYPE_TIMWAIT | dWaitTime, 0);
+		}
+
+		sdRet	= McDevIf_ExecutePacket();
+		if(sdRet == MCDRV_SUCCESS)
+		{
+			bRegCur	= McResCtrl_GetRegVal(MCDRV_PACKET_REGTYPE_B_ANA, MCI_PWM_ANALOG_0);
+			bReg	= (UINT8)~dUpdate & bRegCur;
+			McDevIf_AddPacket(MCDRV_PACKET_TYPE_WRITE | MCDRV_PACKET_REGTYPE_B_ANA | (UINT32)MCI_PWM_ANALOG_0, bReg);
+
+			bRegCur	= McResCtrl_GetRegVal(MCDRV_PACKET_REGTYPE_B_ANA, MCI_PWM_ANALOG_1);
+			bReg	= (UINT8)~((UINT8)~psPowerInfo->abAnalog[1] & psPowerUpdate->abAnalog[1]) & bRegCur;
+			if((bRegCur & (MCB_PWM_ADL|MCB_PWM_ADR)) != (bReg & (MCB_PWM_ADL|MCB_PWM_ADR)))
+			{
+				McDevIf_AddPacket(MCDRV_PACKET_TYPE_WRITE | MCDRV_PACKET_REGTYPE_B_ANA | (UINT32)MCI_PWM_ANALOG_1, bReg);
+			}
+			else
+			{
+				sdRet	= McDevIf_ExecutePacket();
+				if(sdRet == MCDRV_SUCCESS)
+				{
+					McResCtrl_SetRegVal(MCDRV_PACKET_REGTYPE_B_ANA, MCI_PWM_ANALOG_1, bReg);
+				}
+			}
+		}
+
+		if(sdRet == MCDRV_SUCCESS)
+		{
+			bRegCur	= McResCtrl_GetRegVal(MCDRV_PACKET_REGTYPE_B_ANA, MCI_PWM_ANALOG_2);
+			bReg	= (UINT8)~((UINT8)~psPowerInfo->abAnalog[2] & psPowerUpdate->abAnalog[2]) & bRegCur;
+			if((bRegCur & (MCB_PWM_LO1L|MCB_PWM_LO1R|MCB_PWM_LO2L|MCB_PWM_LO2R)) != (bReg & (MCB_PWM_LO1L|MCB_PWM_LO1R|MCB_PWM_LO2L|MCB_PWM_LO2R)))
+			{
+				bReg	= bReg|(bRegCur&(MCB_PWM_RC1|MCB_PWM_RC2));
+				McDevIf_AddPacket(MCDRV_PACKET_TYPE_WRITE | MCDRV_PACKET_REGTYPE_B_ANA | (UINT32)MCI_PWM_ANALOG_2, bReg);
+			}
+			else
+			{
+				sdRet	= McDevIf_ExecutePacket();
+				if(sdRet == MCDRV_SUCCESS)
+				{
+					McResCtrl_SetRegVal(MCDRV_PACKET_REGTYPE_B_ANA, MCI_PWM_ANALOG_2, bReg);
+				}
+			}
+		}
+
+		if(sdRet == MCDRV_SUCCESS)
+		{
+			/*	time wait	*/
+			if(dWaitTime < GetMaxWait(bRegChange))
+			{
+				dWaitTime	= GetMaxWait(bRegChange) - dWaitTime;
+				McDevIf_AddPacket(MCDRV_PACKET_TYPE_TIMWAIT | dWaitTime, 0);
+			}
+		}
+	}
+
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncOut("AddAnalogPowerUpAuto", &sdRet);
+#endif
+	return sdRet;
+}
+
+/****************************************************************************
+ *	McPacket_AddPowerDown
+ *
+ *	Description:
+ *			Add powerdown packet.
+ *	Arguments:
+ *			psPowerInfo		power information
+ *			psPowerUpdate	power update information
+ *	Return:
+ *			MCDRV_SUCCESS
+ *			MCDRV_ERROR_RESOURCEOVER
+ *			MCDRV_ERROR_TIMEOUT
+ *
+ ****************************************************************************/
+SINT32	McPacket_AddPowerDown
+(
+	const MCDRV_POWER_INFO*		psPowerInfo,
+	const MCDRV_POWER_UPDATE*	psPowerUpdate
+)
+{
+	SINT32	sdRet	= MCDRV_SUCCESS;
+	UINT8	bReg;
+	UINT8	bRegDPADIF;
+	UINT8	bRegCur;
+	UINT32	dUpdate	= psPowerInfo->dDigital & psPowerUpdate->dDigital;
+	UINT32	dAPMDoneParam;
+	UINT32	dAnaRdyParam;
+	UINT8	bSpHizReg;
+	MCDRV_INIT_INFO	sInitInfo;
+
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncIn("McPacket_AddPowerDown");
+#endif
+
+	bRegDPADIF	= McResCtrl_GetRegVal(MCDRV_PACKET_REGTYPE_B_CODEC, MCI_DPADIF);
+
+
+	McResCtrl_GetInitInfo(&sInitInfo);
+
+	if(McResCtrl_GetAPMode() == eMCDRV_APM_ON)
+	{
+		if((((psPowerInfo->abAnalog[0] & psPowerUpdate->abAnalog[0] & MCB_PWM_VR) != 0)
+			&& (McResCtrl_GetRegVal(MCDRV_PACKET_REGTYPE_B_ANA, MCI_PWM_ANALOG_0) & MCB_PWM_VR) == 0))
+		{
+			/*	wait AP_XX_A	*/
+			dAPMDoneParam	= ((MCB_AP_CP_A|MCB_AP_HPL_A|MCB_AP_HPR_A)<<8)
+							| (MCB_AP_RC1_A|MCB_AP_RC2_A|MCB_AP_SPL1_A|MCB_AP_SPR1_A|MCB_AP_SPL2_A|MCB_AP_SPR2_A);
+			McDevIf_AddPacket(MCDRV_PACKET_TYPE_EVTWAIT | MCDRV_EVT_APM_DONE | dAPMDoneParam, 0);
+		}
+	}
+
+	if(((dUpdate & MCDRV_POWINFO_DIGITAL_DP0) != 0UL)
+	&& ((bRegDPADIF & (MCB_DP0_CLKI1|MCB_DP0_CLKI0)) != (MCB_DP0_CLKI1|MCB_DP0_CLKI0)))
+	{
+		/*	wait mute complete	*/
+		sdRet	= McDevIf_ExecutePacket();
+		if(sdRet == MCDRV_SUCCESS)
+		{
+			McDevIf_AddPacket(MCDRV_PACKET_TYPE_EVTWAIT | MCDRV_EVT_ALLMUTE, 0);
+		}
+	}
+
+	if(sdRet == MCDRV_SUCCESS)
+	{
+		/*	Analog Power	*/
+		bRegCur	= McResCtrl_GetRegVal(MCDRV_PACKET_REGTYPE_B_ANA, MCI_PWM_ANALOG_1);
+		bReg	= (psPowerInfo->abAnalog[1] & psPowerUpdate->abAnalog[1]) | bRegCur;
+		if(((psPowerUpdate->abAnalog[1] & MCDRV_POWUPDATE_ANALOG1_OUT) != 0) && (MCDRV_SPHIZ_HIZ == sInitInfo.bSpHiz))
+		{
+			/*	SP_HIZ control	*/
+			bSpHizReg	= 0;
+			if((bReg & (MCB_PWM_SPL1 | MCB_PWM_SPL2)) != 0)
+			{
+				bSpHizReg |= MCB_SPL_HIZ;
+			}
+
+			if((bReg & (MCB_PWM_SPR1 | MCB_PWM_SPR2)) != 0)
+			{
+				bSpHizReg |= MCB_SPR_HIZ;
+			}
+
+			bSpHizReg |= (McResCtrl_GetRegVal(MCDRV_PACKET_REGTYPE_B_ANA, MCI_SP_MODE) & (MCB_SPMN | MCB_SP_SWAP));
+			McDevIf_AddPacket(MCDRV_PACKET_TYPE_WRITE | MCDRV_PACKET_REGTYPE_B_ANA | (UINT32)MCI_SP_MODE, bSpHizReg);
+		}
+
+		if(McResCtrl_GetAPMode() == eMCDRV_APM_ON)
+		{
+			if((bRegCur & (MCB_PWM_ADL|MCB_PWM_ADR)) != (bReg & (MCB_PWM_ADL|MCB_PWM_ADR)))
+			{
+				McDevIf_AddPacket(MCDRV_PACKET_TYPE_WRITE | MCDRV_PACKET_REGTYPE_B_ANA | (UINT32)MCI_PWM_ANALOG_1, bReg);
+			}
+			else
+			{
+				sdRet	= McDevIf_ExecutePacket();
+				if(sdRet == MCDRV_SUCCESS)
+				{
+					McResCtrl_SetRegVal(MCDRV_PACKET_REGTYPE_B_ANA, MCI_PWM_ANALOG_1, bReg);
+				}
+			}
+		}
+		else
+		{
+			McDevIf_AddPacket(MCDRV_PACKET_TYPE_WRITE | MCDRV_PACKET_REGTYPE_B_ANA | (UINT32)MCI_PWM_ANALOG_1, bReg);
+		}
+	}
+
+	if(sdRet == MCDRV_SUCCESS)
+	{
+		bRegCur	= McResCtrl_GetRegVal(MCDRV_PACKET_REGTYPE_B_ANA, MCI_PWM_ANALOG_2);
+		bReg	= (psPowerInfo->abAnalog[2] & psPowerUpdate->abAnalog[2]) | bRegCur;
+		if(McResCtrl_GetAPMode() == eMCDRV_APM_ON)
+		{
+			if((bRegCur & (MCB_PWM_LO1L|MCB_PWM_LO1R|MCB_PWM_LO2L|MCB_PWM_LO2R)) != (bReg & (MCB_PWM_LO1L|MCB_PWM_LO1R|MCB_PWM_LO2L|MCB_PWM_LO2R)))
+			{
+				McDevIf_AddPacket(MCDRV_PACKET_TYPE_WRITE | MCDRV_PACKET_REGTYPE_B_ANA | (UINT32)MCI_PWM_ANALOG_2, bReg);
+			}
+			else
+			{
+				sdRet	= McDevIf_ExecutePacket();
+				if(sdRet == MCDRV_SUCCESS)
+				{
+					McResCtrl_SetRegVal(MCDRV_PACKET_REGTYPE_B_ANA, MCI_PWM_ANALOG_2, bReg);
+				}
+			}
+		}
+		else
+		{
+			McDevIf_AddPacket(MCDRV_PACKET_TYPE_WRITE | MCDRV_PACKET_REGTYPE_B_ANA | (UINT32)MCI_PWM_ANALOG_2, bReg);
+		}
+	}
+
+	if(sdRet == MCDRV_SUCCESS)
+	{
+		bReg	= (UINT8)((psPowerInfo->abAnalog[3] & psPowerUpdate->abAnalog[3]) | McResCtrl_GetRegVal(MCDRV_PACKET_REGTYPE_B_ANA, MCI_PWM_ANALOG_3));
+		McDevIf_AddPacket(MCDRV_PACKET_TYPE_WRITE | MCDRV_PACKET_REGTYPE_B_ANA | (UINT32)MCI_PWM_ANALOG_3, bReg);
+		bReg	= (UINT8)((psPowerInfo->abAnalog[4] & psPowerUpdate->abAnalog[4]) | McResCtrl_GetRegVal(MCDRV_PACKET_REGTYPE_B_ANA, MCI_PWM_ANALOG_4));
+		McDevIf_AddPacket(MCDRV_PACKET_TYPE_WRITE | MCDRV_PACKET_REGTYPE_B_ANA | (UINT32)MCI_PWM_ANALOG_4, bReg);
+
+		/*	set DACON and NSMUTE after setting 1 to AP_DA	*/
+		if((psPowerInfo->abAnalog[3] & psPowerUpdate->abAnalog[3] & (MCB_PWM_DAR|MCB_PWM_DAL)) == (MCB_PWM_DAR|MCB_PWM_DAL))
+		{
+			if((McResCtrl_GetRegVal(MCDRV_PACKET_REGTYPE_B_CODEC, MCI_DAC_CONFIG) & MCB_DACON) == MCB_DACON)
+			{
+				McDevIf_AddPacket(MCDRV_PACKET_TYPE_EVTWAIT | MCDRV_EVT_DACMUTE | (UINT32)((MCB_DAC_FLAGL<<8)|MCB_DAC_FLAGR), 0);
+			}
+			McDevIf_AddPacket(MCDRV_PACKET_TYPE_WRITE | MCDRV_PACKET_REGTYPE_B_CODEC | (UINT32)MCI_DAC_CONFIG, MCB_NSMUTE);
+		}
+
+		bRegCur	= McResCtrl_GetRegVal(MCDRV_PACKET_REGTYPE_B_ANA, MCI_PWM_ANALOG_0);
+		bReg	= psPowerInfo->abAnalog[0] & psPowerUpdate->abAnalog[0];
+		if(McResCtrl_GetAPMode() == eMCDRV_APM_OFF)
+		{
+			/*	wait CPPDRDY	*/
+			dAnaRdyParam	= 0;
+			if(((bRegCur & MCB_PWM_CP) == 0) && ((bReg & MCB_PWM_CP) == MCB_PWM_CP))
+			{
+				dAnaRdyParam	= MCB_CPPDRDY;
+				McDevIf_AddPacket(MCDRV_PACKET_TYPE_EVTWAIT | MCDRV_EVT_ANA_RDY | dAnaRdyParam, 0);
+				McDevIf_AddPacket(MCDRV_PACKET_TYPE_WRITE | MCDRV_PACKET_REGTYPE_B_ANA | (UINT32)MCI_PWM_ANALOG_0, (bRegCur|MCB_PWM_CP));
+			}
+		}
+
+		if(((bReg & MCB_PWM_VR) != 0) && ((bRegCur & MCB_PWM_VR) == 0))
+		{/*	AP_VR changed	*/
+			/*	AP_xx down	*/
+			McDevIf_AddPacket(MCDRV_PACKET_TYPE_WRITE | MCDRV_PACKET_REGTYPE_B_ANA | (UINT32)MCI_PWM_ANALOG_0, MCI_PWM_ANALOG_0_DEF);
+		}
+		else
+		{
+			bReg	|= bRegCur;
+			McDevIf_AddPacket(MCDRV_PACKET_TYPE_WRITE | MCDRV_PACKET_REGTYPE_B_ANA | (UINT32)MCI_PWM_ANALOG_0, bReg);
+		}
+
+
+		/*	Digital Power	*/
+		if(((dUpdate & MCDRV_POWINFO_DIGITAL_DPADIF) != 0UL)
+		&& (bRegDPADIF != MCB_DPADIF))
+		{
+			/*	DPADIF	*/
+			bRegDPADIF	|= MCB_DPADIF;
+			McDevIf_AddPacket(MCDRV_PACKET_TYPE_WRITE | MCDRV_PACKET_REGTYPE_B_CODEC | (UINT32)MCI_DPADIF, bRegDPADIF);
+		}
+
+		if((dUpdate & MCDRV_POWINFO_DIGITAL_DPBDSP) != 0UL)
+		{
+			/*	DPBDSP	*/
+			McDevIf_AddPacket(MCDRV_PACKET_TYPE_WRITE | MCDRV_PACKET_REGTYPE_B_BASE | (UINT32)MCI_PWM_DIGITAL_BDSP, MCB_PWM_DPBDSP);
+		}
+
+		/*	DPDI*, DPPDM	*/
+		bReg	= McResCtrl_GetRegVal(MCDRV_PACKET_REGTYPE_B_BASE, MCI_PWM_DIGITAL_1);
+		if(((dUpdate & MCDRV_POWINFO_DIGITAL_DPDI0) != 0UL) || ((dUpdate & MCDRV_POWINFO_DIGITAL_DP2) != 0UL))
+		{
+			bReg |= MCB_PWM_DPDI0;
+		}
+		if(((dUpdate & MCDRV_POWINFO_DIGITAL_DPDI1) != 0UL) || ((dUpdate & MCDRV_POWINFO_DIGITAL_DP2) != 0UL))
+		{
+			bReg |= MCB_PWM_DPDI1;
+		}
+		if(((dUpdate & MCDRV_POWINFO_DIGITAL_DPDI2) != 0UL) || ((dUpdate & MCDRV_POWINFO_DIGITAL_DP2) != 0UL))
+		{
+			bReg |= MCB_PWM_DPDI2;
+		}
+		if((dUpdate & MCDRV_POWINFO_DIGITAL_DPPDM) != 0UL)
+		{
+			bReg |= MCB_PWM_DPPDM;
+		}
+		if(bReg != 0)
+		{
+			/*	cannot set DP* & DPB at the same time	*/
+			McDevIf_AddPacket(MCDRV_PACKET_TYPE_WRITE | MCDRV_PACKET_REGTYPE_B_BASE | (UINT32)MCI_PWM_DIGITAL_1, bReg);
+		}
+		/*	DPB	*/
+		if((dUpdate & MCDRV_POWINFO_DIGITAL_DPB) != 0UL)
+		{
+			bReg |= MCB_PWM_DPB;
+		}
+		if(bReg != 0)
+		{
+			McDevIf_AddPacket(MCDRV_PACKET_TYPE_WRITE | MCDRV_PACKET_REGTYPE_B_BASE | (UINT32)MCI_PWM_DIGITAL_1, bReg);
+		}
+
+		if(((dUpdate & MCDRV_POWINFO_DIGITAL_DP2) != 0UL)
+		&& ((McResCtrl_GetRegVal(MCDRV_PACKET_REGTYPE_B_BASE, MCI_PWM_DIGITAL) & MCB_PWM_DP2) == 0))
+		{
+			if((dUpdate & MCDRV_POWINFO_DIGITAL_DP0) != 0UL)
+			{
+				/*	DP2, DP1	*/
+				McDevIf_AddPacket(MCDRV_PACKET_TYPE_WRITE | MCDRV_PACKET_REGTYPE_B_BASE | (UINT32)MCI_PWM_DIGITAL, (MCB_PWM_DP2 | MCB_PWM_DP1));
+				if((dUpdate & MCDRV_POWINFO_DIGITAL_PLLRST0) != 0UL)
+				{
+					/*	PLLRST0	*/
+					McDevIf_AddPacket(MCDRV_PACKET_TYPE_WRITE | MCDRV_PACKET_REGTYPE_B_CODEC | (UINT32)MCI_PLL_RST, MCB_PLLRST0);
+				}
+				/*	DP0	*/
+				bRegDPADIF	|= (MCB_DP0_CLKI1 | MCB_DP0_CLKI0);
+				McDevIf_AddPacket(MCDRV_PACKET_TYPE_WRITE | MCDRV_PACKET_REGTYPE_B_CODEC | (UINT32)MCI_DPADIF, bRegDPADIF);
+				sdRet	= McDevIf_ExecutePacket();
+				if(sdRet == MCDRV_SUCCESS)
+				{
+					McSrv_ClockStop();
+				}
+			}
+			else
+			{
+				/*	DP2	*/
+				McDevIf_AddPacket(MCDRV_PACKET_TYPE_WRITE | MCDRV_PACKET_REGTYPE_B_BASE | (UINT32)MCI_PWM_DIGITAL, MCB_PWM_DP2);
+			}
+		}
+	}
+
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncOut("McPacket_AddPowerDown", &sdRet);
+#endif
+	return sdRet;
+}
+
+/****************************************************************************
+ *	McPacket_AddPathSet
+ *
+ *	Description:
+ *			Add path update packet.
+ *	Arguments:
+ *			none
+ *	Return:
+ *			MCDRV_SUCCESS
+ *			MCDRV_ERROR_RESOURCEOVER
+ *			MCDRV_ERROR_TIMEOUT
+ *
+ ****************************************************************************/
+SINT32	McPacket_AddPathSet
+(
+	void
+)
+{
+	SINT32	sdRet	= MCDRV_SUCCESS;
+
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncIn("McPacket_AddPathSet");
+#endif
+
+	/*	DI Pad	*/
+	AddDIPad();
+
+	/*	PAD(PDM)	*/
+	AddPAD();
+
+	/*	Digital Mixer Source	*/
+	sdRet	= AddSource();
+	if(sdRet == MCDRV_SUCCESS)
+	{
+		/*	DIR*_START, DIT*_START	*/
+		AddDIStart();
+	}
+
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncOut("McPacket_AddPathSet", &sdRet);
+#endif
+	return sdRet;
+}
+
+/****************************************************************************
+ *	AddDIPad
+ *
+ *	Description:
+ *			Add DI Pad setup packet.
+ *	Arguments:
+ *			none
+ *	Return:
+ *			none
+ *
+ ****************************************************************************/
+static void	AddDIPad
+(
+	void
+)
+{
+	UINT8	bReg;
+	UINT8	bIsUsedDIR[3];
+	MCDRV_INIT_INFO	sInitInfo;
+	MCDRV_PATH_INFO	sPathInfo;
+	MCDRV_DIO_INFO	sDioInfo;
+
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncIn("AddDIPad");
+#endif
+
+	McResCtrl_GetInitInfo(&sInitInfo);
+	McResCtrl_GetPathInfo(&sPathInfo);
+	McResCtrl_GetDioInfo(&sDioInfo);
+
+	/*	SDIN_MSK2/1	*/
+	bReg	= 0;
+	if(McResCtrl_IsSrcUsed(eMCDRV_SRC_DIR2) == 0)
+	{
+		bReg |= MCB_SDIN_MSK2;
+		bIsUsedDIR[2]	= 0;
+	}
+	else
+	{
+		bIsUsedDIR[2]	= 1;
+	}
+	if(McResCtrl_IsSrcUsed(eMCDRV_SRC_DIR1) == 0)
+	{
+		bReg |= MCB_SDIN_MSK1;
+		bIsUsedDIR[1]	= 0;
+	}
+	else
+	{
+		bIsUsedDIR[1]	= 1;
+	}
+	/*	SDO_DDR2/1	*/
+	if(McResCtrl_IsDstUsed(eMCDRV_DST_DIT2, eMCDRV_DST_CH0) == 0)
+	{
+		if(sInitInfo.bDioSdo2Hiz == MCDRV_DAHIZ_LOW)
+		{
+			bReg |= MCB_SDO_DDR2;
+		}
+	}
+	else
+	{
+		bReg |= MCB_SDO_DDR2;
+	}
+	if(McResCtrl_IsDstUsed(eMCDRV_DST_DIT1, eMCDRV_DST_CH0) == 0)
+	{
+		if(sInitInfo.bDioSdo1Hiz == MCDRV_DAHIZ_LOW)
+		{
+			bReg |= MCB_SDO_DDR1;
+		}
+	}
+	else
+	{
+		bReg |= MCB_SDO_DDR1;
+	}
+	McDevIf_AddPacket(MCDRV_PACKET_TYPE_WRITE | MCDRV_PACKET_REGTYPE_B_BASE | (UINT32)MCI_SD_MSK, bReg);
+
+	/*	SDIN_MSK0	*/
+	bReg	= 0;
+	if(McResCtrl_IsSrcUsed(eMCDRV_SRC_DIR0) == 0)
+	{
+		bReg |= MCB_SDIN_MSK0;
+		bIsUsedDIR[0]	= 0;
+	}
+	else
+	{
+		bIsUsedDIR[0]	= 1;
+	}
+	/*	SDO_DDR0	*/
+	if(McResCtrl_IsDstUsed(eMCDRV_DST_DIT0, eMCDRV_DST_CH0) == 0)
+	{
+		if(sInitInfo.bDioSdo0Hiz == MCDRV_DAHIZ_LOW)
+		{
+			bReg |= MCB_SDO_DDR0;
+		}
+	}
+	else
+	{
+		bReg |= MCB_SDO_DDR0;
+	}
+	McDevIf_AddPacket(MCDRV_PACKET_TYPE_WRITE | MCDRV_PACKET_REGTYPE_B_BASE | (UINT32)MCI_SD_MSK_1, bReg);
+
+	/*	BCLK_MSK*, BCLD_DDR*, LRCK_MSK*, LRCK_DDR*	*/
+	bReg	= 0;
+	if((bIsUsedDIR[2] == 0) && (McResCtrl_GetDITSource(eMCDRV_DIO_2) == eMCDRV_SRC_NONE))
+	{
+		bReg |= MCB_BCLK_MSK2;
+		bReg |= MCB_LRCK_MSK2;
+		if(sInitInfo.bDioClk2Hiz == MCDRV_DAHIZ_LOW)
+		{
+			bReg |= MCB_BCLK_DDR2;
+			bReg |= MCB_LRCK_DDR2;
+		}
+	}
+	else
+	{
+		if(sDioInfo.asPortInfo[2].sDioCommon.bMasterSlave == MCDRV_DIO_MASTER)
+		{
+			bReg |= MCB_BCLK_DDR2;
+			bReg |= MCB_LRCK_DDR2;
+		}
+	}
+	if((bIsUsedDIR[1] == 0) && (McResCtrl_GetDITSource(eMCDRV_DIO_1) == eMCDRV_SRC_NONE))
+	{
+		bReg |= MCB_BCLK_MSK1;
+		bReg |= MCB_LRCK_MSK1;
+		if(sInitInfo.bDioClk1Hiz == MCDRV_DAHIZ_LOW)
+		{
+			bReg |= MCB_BCLK_DDR1;
+			bReg |= MCB_LRCK_DDR1;
+		}
+	}
+	else
+	{
+		if(sDioInfo.asPortInfo[1].sDioCommon.bMasterSlave == MCDRV_DIO_MASTER)
+		{
+			bReg |= MCB_BCLK_DDR1;
+			bReg |= MCB_LRCK_DDR1;
+		}
+	}
+	McDevIf_AddPacket(MCDRV_PACKET_TYPE_WRITE | MCDRV_PACKET_REGTYPE_B_BASE | (UINT32)MCI_BCLK_MSK, bReg);
+
+	/*	BCLK_MSK*, BCLD_DDR*, LRCK_MSK*, LRCK_DDR*, PCM_HIZ*	*/
+	bReg	= 0;
+	if((bIsUsedDIR[0] == 0) && (McResCtrl_GetDITSource(eMCDRV_DIO_0) == eMCDRV_SRC_NONE))
+	{
+		bReg |= MCB_BCLK_MSK0;
+		bReg |= MCB_LRCK_MSK0;
+		if(sInitInfo.bDioClk0Hiz == MCDRV_DAHIZ_LOW)
+		{
+			bReg |= MCB_BCLK_DDR0;
+			bReg |= MCB_LRCK_DDR0;
+		}
+	}
+	else
+	{
+		if(sDioInfo.asPortInfo[0].sDioCommon.bMasterSlave == MCDRV_DIO_MASTER)
+		{
+			bReg |= MCB_BCLK_DDR0;
+			bReg |= MCB_LRCK_DDR0;
+		}
+	}
+	if(sInitInfo.bPcmHiz == MCDRV_PCMHIZ_HIZ)
+	{
+		bReg |= (MCB_PCMOUT_HIZ2 | MCB_PCMOUT_HIZ1 | MCB_PCMOUT_HIZ0);
+	}
+	McDevIf_AddPacket(MCDRV_PACKET_TYPE_WRITE | MCDRV_PACKET_REGTYPE_B_BASE | (UINT32)MCI_BCLK_MSK_1, bReg);
+
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncOut("AddDIPad", 0);
+#endif
+}
+
+/****************************************************************************
+ *	AddPAD
+ *
+ *	Description:
+ *			Add PAD setup packet.
+ *	Arguments:
+ *			none
+ *	Return:
+ *			none
+ *
+ ****************************************************************************/
+static void	AddPAD
+(
+	void
+)
+{
+	UINT8	bReg;
+	MCDRV_INIT_INFO	sInitInfo;
+
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncIn("AddPAD");
+#endif
+
+	McResCtrl_GetInitInfo(&sInitInfo);
+
+	/*	PA*_MSK	*/
+	bReg	= McResCtrl_GetRegVal(MCDRV_PACKET_REGTYPE_B_BASE, MCI_PA_MSK);
+	if(McResCtrl_IsSrcUsed(eMCDRV_SRC_PDM) == 0)
+	{
+		bReg	|= MCB_PA0_MSK;
+		if(sInitInfo.bPad1Func == MCDRV_PAD_PDMDI)
+		{
+			bReg	|= MCB_PA1_MSK;
+		}
+	}
+	else
+	{
+		bReg	&= (UINT8)~MCB_PA0_MSK;
+		if(sInitInfo.bPad1Func == MCDRV_PAD_PDMDI)
+		{
+			bReg	&= (UINT8)~MCB_PA1_MSK;
+		}
+	}
+	McDevIf_AddPacket(MCDRV_PACKET_TYPE_WRITE | MCDRV_PACKET_REGTYPE_B_BASE | (UINT32)MCI_PA_MSK, bReg);
+
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncOut("AddPAD", 0);
+#endif
+}
+
+/****************************************************************************
+ *	AddSource
+ *
+ *	Description:
+ *			Add source setup packet.
+ *	Arguments:
+ *			none
+ *	Return:
+ *			MCDRV_SUCCESS
+ *			MCDRV_ERROR_TIMEOUT
+ *
+ ****************************************************************************/
+static SINT32	AddSource
+(
+	void
+)
+{
+	SINT32	sdRet			= MCDRV_SUCCESS;
+	UINT8	bReg;
+	UINT8	bAEng6;
+	UINT8	bRegAESource	= 0;
+	UINT8	bAESourceChange	= 0;
+	UINT32	dXFadeParam		= 0;
+	MCDRV_SRC_TYPE	eAESource;
+	MCDRV_PATH_INFO	sPathInfo;
+	MCDRV_DAC_INFO	sDacInfo;
+	MCDRV_AE_INFO	sAeInfo;
+
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncIn("AddSource");
+#endif
+
+	bAEng6		= McResCtrl_GetRegVal(MCDRV_PACKET_REGTYPE_B_MIXER, MCI_AENG6_SOURCE);
+	eAESource	= McResCtrl_GetAESource();
+
+	McResCtrl_GetPathInfo(&sPathInfo);
+	McResCtrl_GetAeInfo(&sAeInfo);
+
+	switch(eAESource)
+	{
+	case	eMCDRV_SRC_PDM:		bRegAESource	= MCB_AE_SOURCE_AD;		bAEng6	= MCB_AENG6_PDM;	break;
+	case	eMCDRV_SRC_ADC0:	bRegAESource	= MCB_AE_SOURCE_AD;		bAEng6	= MCB_AENG6_ADC0;	break;
+	case	eMCDRV_SRC_DIR0:	bRegAESource	= MCB_AE_SOURCE_DIR0;	break;
+	case	eMCDRV_SRC_DIR1:	bRegAESource	= MCB_AE_SOURCE_DIR1;	break;
+	case	eMCDRV_SRC_DIR2:	bRegAESource	= MCB_AE_SOURCE_DIR2;	break;
+	case	eMCDRV_SRC_MIX:		bRegAESource	= MCB_AE_SOURCE_MIX;	break;
+	default:					bRegAESource	= 0;
+	}
+	if(bRegAESource != (McResCtrl_GetRegVal(MCDRV_PACKET_REGTYPE_B_MIXER, MCI_SRC_SOURCE_1)&0xF0))
+	{
+		/*	xxx_INS	*/
+		dXFadeParam	= McResCtrl_GetRegVal(MCDRV_PACKET_REGTYPE_B_MIXER, MCI_DAC_INS);
+		dXFadeParam <<= 8;
+		dXFadeParam	|= McResCtrl_GetRegVal(MCDRV_PACKET_REGTYPE_B_MIXER, MCI_INS);
+		McDevIf_AddPacket(MCDRV_PACKET_TYPE_WRITE | MCDRV_PACKET_REGTYPE_B_MIXER | (UINT32)MCI_DAC_INS, 0);
+		McDevIf_AddPacket(MCDRV_PACKET_TYPE_WRITE | MCDRV_PACKET_REGTYPE_B_MIXER | (UINT32)MCI_INS, 0);
+		bAESourceChange	= 1;
+		sdRet	= McDevIf_ExecutePacket();
+	}
+
+	if(sdRet == MCDRV_SUCCESS)
+	{
+		McResCtrl_GetDacInfo(&sDacInfo);
+
+		/*	DAC_SOURCE/VOICE_SOURCE	*/
+		bReg	= 0;
+		switch(McResCtrl_GetDACSource(eMCDRV_DAC_MASTER))
+		{
+		case	eMCDRV_SRC_PDM:
+			bReg |= MCB_DAC_SOURCE_AD;
+			bAEng6	= MCB_AENG6_PDM;
+			break;
+		case	eMCDRV_SRC_ADC0:
+			bReg |= MCB_DAC_SOURCE_AD;
+			bAEng6	= MCB_AENG6_ADC0;
+			break;
+		case	eMCDRV_SRC_DIR0:
+			bReg |= MCB_DAC_SOURCE_DIR0;
+			break;
+		case	eMCDRV_SRC_DIR1:
+			bReg |= MCB_DAC_SOURCE_DIR1;
+			break;
+		case	eMCDRV_SRC_DIR2:
+			bReg |= MCB_DAC_SOURCE_DIR2;
+			break;
+		case	eMCDRV_SRC_MIX:
+			bReg |= MCB_DAC_SOURCE_MIX;
+			break;
+		default:
+			break;
+		}
+		switch(McResCtrl_GetDACSource(eMCDRV_DAC_VOICE))
+		{
+		case	eMCDRV_SRC_PDM:
+			bReg |= MCB_VOICE_SOURCE_AD;
+			bAEng6	= MCB_AENG6_PDM;
+			break;
+		case	eMCDRV_SRC_ADC0:
+			bReg |= MCB_VOICE_SOURCE_AD;
+			bAEng6	= MCB_AENG6_ADC0;
+			break;
+		case	eMCDRV_SRC_DIR0:
+			bReg |= MCB_VOICE_SOURCE_DIR0;
+			break;
+		case	eMCDRV_SRC_DIR1:
+			bReg |= MCB_VOICE_SOURCE_DIR1;
+			break;
+		case	eMCDRV_SRC_DIR2:
+			bReg |= MCB_VOICE_SOURCE_DIR2;
+			break;
+		case	eMCDRV_SRC_MIX:
+			bReg |= MCB_VOICE_SOURCE_MIX;
+			break;
+		default:
+			break;
+		}
+		McDevIf_AddPacket(MCDRV_PACKET_TYPE_WRITE | MCDRV_PACKET_REGTYPE_B_MIXER | (UINT32)MCI_SOURCE, bReg);
+
+		/*	SWP/VOICE_SWP	*/
+		bReg	= (sDacInfo.bMasterSwap << 4) | sDacInfo.bVoiceSwap;
+		McDevIf_AddPacket(MCDRV_PACKET_TYPE_WRITE | MCDRV_PACKET_REGTYPE_B_MIXER | (UINT32)MCI_SWP, bReg);
+
+		/*	DIT0SRC_SOURCE/DIT1SRC_SOURCE	*/
+		bReg	= 0;
+		switch(McResCtrl_GetDITSource(eMCDRV_DIO_0))
+		{
+		case	eMCDRV_SRC_PDM:
+			bReg |= MCB_DIT0_SOURCE_AD;
+				bAEng6	= MCB_AENG6_PDM;
+			break;
+		case	eMCDRV_SRC_ADC0:
+			bReg |= MCB_DIT0_SOURCE_AD;
+				bAEng6	= MCB_AENG6_ADC0;
+			break;
+		case	eMCDRV_SRC_DIR0:
+			bReg |= MCB_DIT0_SOURCE_DIR0;
+			break;
+		case	eMCDRV_SRC_DIR1:
+			bReg |= MCB_DIT0_SOURCE_DIR1;
+			break;
+		case	eMCDRV_SRC_DIR2:
+			bReg |= MCB_DIT0_SOURCE_DIR2;
+			break;
+		case	eMCDRV_SRC_MIX:
+			bReg |= MCB_DIT0_SOURCE_MIX;
+			break;
+		default:
+			break;
+		}
+		switch(McResCtrl_GetDITSource(eMCDRV_DIO_1))
+		{
+		case	eMCDRV_SRC_PDM:
+			bReg |= MCB_DIT1_SOURCE_AD;
+				bAEng6	= MCB_AENG6_PDM;
+			break;
+		case	eMCDRV_SRC_ADC0:
+			bReg |= MCB_DIT1_SOURCE_AD;
+				bAEng6	= MCB_AENG6_ADC0;
+			break;
+		case	eMCDRV_SRC_DIR0:
+			bReg |= MCB_DIT1_SOURCE_DIR0;
+			break;
+		case	eMCDRV_SRC_DIR1:
+			bReg |= MCB_DIT1_SOURCE_DIR1;
+			break;
+		case	eMCDRV_SRC_DIR2:
+			bReg |= MCB_DIT1_SOURCE_DIR2;
+			break;
+		case	eMCDRV_SRC_MIX:
+			bReg |= MCB_DIT1_SOURCE_MIX;
+			break;
+		default:
+			break;
+		}
+		McDevIf_AddPacket(MCDRV_PACKET_TYPE_WRITE | MCDRV_PACKET_REGTYPE_B_MIXER | (UINT32)MCI_SRC_SOURCE, bReg);
+
+		/*	AE_SOURCE/DIT2SRC_SOURCE	*/
+		bReg	= bRegAESource;
+		switch(McResCtrl_GetDITSource(eMCDRV_DIO_2))
+		{
+		case	eMCDRV_SRC_PDM:
+			bReg |= MCB_DIT2_SOURCE_AD;
+				bAEng6	= MCB_AENG6_PDM;
+			break;
+		case	eMCDRV_SRC_ADC0:
+			bReg |= MCB_DIT2_SOURCE_AD;
+				bAEng6	= MCB_AENG6_ADC0;
+			break;
+		case	eMCDRV_SRC_DIR0:
+			bReg |= MCB_DIT2_SOURCE_DIR0;
+			break;
+		case	eMCDRV_SRC_DIR1:
+			bReg |= MCB_DIT2_SOURCE_DIR1;
+			break;
+		case	eMCDRV_SRC_DIR2:
+			bReg |= MCB_DIT2_SOURCE_DIR2;
+			break;
+		case	eMCDRV_SRC_MIX:
+			bReg |= MCB_DIT2_SOURCE_MIX;
+			break;
+		default:
+			break;
+		}
+		if(bAESourceChange != 0)
+		{
+			/*	wait xfade complete	*/
+			McDevIf_AddPacket(MCDRV_PACKET_TYPE_EVTWAIT | MCDRV_EVT_INSFLG | dXFadeParam, 0);
+		}
+		McDevIf_AddPacket(MCDRV_PACKET_TYPE_WRITE | MCDRV_PACKET_REGTYPE_B_MIXER | (UINT32)MCI_SRC_SOURCE_1, bReg);
+
+		/*	BDSP_ST	*/
+		if(McResCtrl_GetAESource() == eMCDRV_SRC_NONE)
+		{/*	AE is unused	*/
+			/*	BDSP stop & reset	*/
+			if((McResCtrl_GetRegVal(MCDRV_PACKET_REGTYPE_A, MCI_BDSP_ST)&MCB_BDSP_ST) != 0)
+			{
+				bReg	= 0;
+				if((sAeInfo.bOnOff & MCDRV_EQ5_ON) != 0)
+				{
+					bReg |= MCB_EQ5ON;
+				}
+				if((sAeInfo.bOnOff & MCDRV_DRC_ON) != 0)
+				{
+					bReg |= MCB_DRCON;
+				}
+				if((sAeInfo.bOnOff & MCDRV_EQ3_ON) != 0)
+				{
+					bReg |= MCB_EQ3ON;
+				}
+				if(McDevProf_IsValid(eMCDRV_FUNC_DBEX) == 1)
+				{
+					if((sAeInfo.bOnOff & MCDRV_BEXWIDE_ON) != 0)
+					{
+						bReg |= MCB_DBEXON;
+					}
+				}
+				McDevIf_AddPacket(MCDRV_PACKET_TYPE_WRITE | MCDRV_PACKET_REGTYPE_A | (UINT32)MCI_BDSP_ST, bReg);
+				McDevIf_AddPacket(MCDRV_PACKET_TYPE_WRITE | MCDRV_PACKET_REGTYPE_A | (UINT32)MCI_BDSP_RST, MCB_TRAM_RST);
+				McDevIf_AddPacket(MCDRV_PACKET_TYPE_WRITE | MCDRV_PACKET_REGTYPE_A | (UINT32)MCI_BDSP_RST, 0);
+			}
+		}
+		else
+		{/*	AE is used	*/
+			bReg	= 0;
+			if((sAeInfo.bOnOff & MCDRV_EQ5_ON) != 0)
+			{
+				bReg |= MCB_EQ5ON;
+			}
+			if((sAeInfo.bOnOff & MCDRV_DRC_ON) != 0)
+			{
+				bReg |= MCB_DRCON;
+				bReg |= MCB_BDSP_ST;
+			}
+			if((sAeInfo.bOnOff & MCDRV_EQ3_ON) != 0)
+			{
+				bReg |= MCB_EQ3ON;
+			}
+			if(McDevProf_IsValid(eMCDRV_FUNC_DBEX) == 1)
+			{
+				if((sAeInfo.bOnOff & MCDRV_BEXWIDE_ON) != 0)
+				{
+					bReg |= MCB_DBEXON;
+					bReg |= MCB_BDSP_ST;
+				}
+			}
+			McDevIf_AddPacket(MCDRV_PACKET_TYPE_WRITE | MCDRV_PACKET_REGTYPE_A | (UINT32)MCI_BDSP_ST, bReg);
+		}
+
+		/*	check MIX SOURCE for AENG6_SOURCE	*/
+		if(McResCtrl_IsSrcUsed(eMCDRV_SRC_PDM) != 0)
+		{
+			bAEng6	= MCB_AENG6_PDM;
+		}
+		else if(McResCtrl_IsSrcUsed(eMCDRV_SRC_ADC0) != 0)
+		{
+			bAEng6	= MCB_AENG6_ADC0;
+		}
+		else
+		{
+		}
+
+		/*	AENG6_SOURCE	*/
+		if(bAEng6 != McResCtrl_GetRegVal(MCDRV_PACKET_REGTYPE_B_MIXER, MCI_AENG6_SOURCE))
+		{
+			bReg	= McResCtrl_GetRegVal(MCDRV_PACKET_REGTYPE_B_CODEC, MCI_AD_START);
+			if((bReg & MCB_AD_START) != 0)
+			{
+				McDevIf_AddPacket(MCDRV_PACKET_TYPE_WRITE | MCDRV_PACKET_REGTYPE_B_CODEC | (UINT32)MCI_AD_START, bReg&(UINT8)~MCB_AD_START);
+			}
+			bReg	= McResCtrl_GetRegVal(MCDRV_PACKET_REGTYPE_B_MIXER, MCI_PDM_START);
+			if((bReg & MCB_PDM_START) != 0)
+			{
+				McDevIf_AddPacket(MCDRV_PACKET_TYPE_WRITE | MCDRV_PACKET_REGTYPE_B_MIXER | (UINT32)MCI_PDM_START, bReg&(UINT8)~MCB_PDM_START);
+			}
+		}
+		McDevIf_AddPacket(MCDRV_PACKET_TYPE_WRITE | MCDRV_PACKET_REGTYPE_B_MIXER | (UINT32)MCI_AENG6_SOURCE, bAEng6);
+
+		/*	xxx_INS	*/
+		if(McResCtrl_IsSrcUsed(eMCDRV_SRC_AE) != 0)
+		{
+			switch(eAESource)
+			{
+			case	eMCDRV_SRC_PDM:
+			case	eMCDRV_SRC_ADC0:
+				McDevIf_AddPacket(MCDRV_PACKET_TYPE_WRITE | MCDRV_PACKET_REGTYPE_B_MIXER | (UINT32)MCI_INS, MCB_ADC_INS);
+				break;
+			case	eMCDRV_SRC_DIR0:
+				McDevIf_AddPacket(MCDRV_PACKET_TYPE_WRITE | MCDRV_PACKET_REGTYPE_B_MIXER | (UINT32)MCI_INS, MCB_DIR0_INS);
+				break;
+			case	eMCDRV_SRC_DIR1:
+				McDevIf_AddPacket(MCDRV_PACKET_TYPE_WRITE | MCDRV_PACKET_REGTYPE_B_MIXER | (UINT32)MCI_INS, MCB_DIR1_INS);
+				break;
+			case	eMCDRV_SRC_DIR2:
+				McDevIf_AddPacket(MCDRV_PACKET_TYPE_WRITE | MCDRV_PACKET_REGTYPE_B_MIXER | (UINT32)MCI_INS, MCB_DIR2_INS);
+				break;
+			case	eMCDRV_SRC_MIX:
+				McDevIf_AddPacket(MCDRV_PACKET_TYPE_WRITE | MCDRV_PACKET_REGTYPE_B_MIXER | (UINT32)MCI_DAC_INS, MCB_DAC_INS);
+				break;
+			default:
+				break;
+			}
+		}
+	}
+
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncOut("AddSource", &sdRet);
+#endif
+
+	return sdRet;
+}
+
+/****************************************************************************
+ *	AddDIStart
+ *
+ *	Description:
+ *			Add DIStart setup packet.
+ *	Arguments:
+ *			none
+ *	Return:
+ *			none
+ *
+ ****************************************************************************/
+static void	AddDIStart
+(
+	void
+)
+{
+	UINT8	bReg;
+	MCDRV_PATH_INFO	sPathInfo;
+	MCDRV_DIO_INFO	sDioInfo;
+
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncIn("AddDIStart");
+#endif
+
+	McResCtrl_GetPathInfo(&sPathInfo);
+	McResCtrl_GetDioInfo(&sDioInfo);
+
+	/*	DIR*_START, DIT*_START	*/
+	bReg	= 0;
+	if(McResCtrl_GetDITSource(eMCDRV_DIO_0) != eMCDRV_SRC_NONE)
+	{
+		if(sDioInfo.asPortInfo[0].sDioCommon.bMasterSlave == MCDRV_DIO_MASTER)
+		{
+			bReg |= MCB_DITIM0_START;
+		}
+		bReg |= MCB_DIT0_SRC_START;
+		bReg |= MCB_DIT0_START;
+	}
+	if(McResCtrl_IsSrcUsed(eMCDRV_SRC_DIR0) != 0)
+	{
+		if(sDioInfo.asPortInfo[0].sDioCommon.bMasterSlave == MCDRV_DIO_MASTER)
+		{
+			bReg |= MCB_DITIM0_START;
+		}
+		bReg |= MCB_DIR0_SRC_START;
+		bReg |= MCB_DIR0_START;
+	}
+	McDevIf_AddPacket(MCDRV_PACKET_TYPE_WRITE | MCDRV_PACKET_REGTYPE_B_MIXER | (UINT32)MCI_DIX0_START, bReg);
+
+	bReg	= 0;
+	if(McResCtrl_GetDITSource(eMCDRV_DIO_1) != eMCDRV_SRC_NONE)
+	{
+		if(sDioInfo.asPortInfo[1].sDioCommon.bMasterSlave == MCDRV_DIO_MASTER)
+		{
+			bReg |= MCB_DITIM1_START;
+		}
+		bReg |= MCB_DIT1_SRC_START;
+		bReg |= MCB_DIT1_START;
+	}
+	if(McResCtrl_IsSrcUsed(eMCDRV_SRC_DIR1) != 0)
+	{
+		if(sDioInfo.asPortInfo[1].sDioCommon.bMasterSlave == MCDRV_DIO_MASTER)
+		{
+			bReg |= MCB_DITIM1_START;
+		}
+		bReg |= MCB_DIR1_SRC_START;
+		bReg |= MCB_DIR1_START;
+	}
+	McDevIf_AddPacket(MCDRV_PACKET_TYPE_WRITE | MCDRV_PACKET_REGTYPE_B_MIXER | (UINT32)MCI_DIX1_START, bReg);
+
+	bReg	= 0;
+	if(McResCtrl_GetDITSource(eMCDRV_DIO_2) != eMCDRV_SRC_NONE)
+	{
+		if(sDioInfo.asPortInfo[2].sDioCommon.bMasterSlave == MCDRV_DIO_MASTER)
+		{
+			bReg |= MCB_DITIM2_START;
+		}
+		bReg |= MCB_DIT2_SRC_START;
+		bReg |= MCB_DIT2_START;
+	}
+	if(McResCtrl_IsSrcUsed(eMCDRV_SRC_DIR2) != 0)
+	{
+		if(sDioInfo.asPortInfo[2].sDioCommon.bMasterSlave == MCDRV_DIO_MASTER)
+		{
+			bReg |= MCB_DITIM2_START;
+		}
+		bReg |= MCB_DIR2_SRC_START;
+		bReg |= MCB_DIR2_START;
+	}
+	McDevIf_AddPacket(MCDRV_PACKET_TYPE_WRITE | MCDRV_PACKET_REGTYPE_B_MIXER | (UINT32)MCI_DIX2_START, bReg);
+
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncOut("AddDIStart", 0);
+#endif
+}
+
+/****************************************************************************
+ *	McPacket_AddMixSet
+ *
+ *	Description:
+ *			Add analog mixer set packet.
+ *	Arguments:
+ *			none
+ *	Return:
+ *			MCDRV_SUCCESS
+ *
+ ****************************************************************************/
+SINT32	McPacket_AddMixSet
+(
+	void
+)
+{
+	SINT32	sdRet	= MCDRV_SUCCESS;
+	UINT8	bReg;
+	MCDRV_INIT_INFO	sInitInfo;
+	MCDRV_PATH_INFO	sPathInfo;
+
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncIn("McPacket_AddMixSet");
+#endif
+
+	McResCtrl_GetInitInfo(&sInitInfo);
+	McResCtrl_GetPathInfo(&sPathInfo);
+
+	/*	ADL_MIX	*/
+	bReg	= GetMicMixBit(&sPathInfo.asAdc0[0]);
+	if(((sPathInfo.asAdc0[0].abSrcOnOff[MCDRV_SRC_LINE1_L_BLOCK] & MCDRV_SRC1_LINE1_L_ON) == MCDRV_SRC1_LINE1_L_ON)
+	|| ((sPathInfo.asAdc0[0].abSrcOnOff[MCDRV_SRC_LINE1_M_BLOCK] & MCDRV_SRC1_LINE1_M_ON) == MCDRV_SRC1_LINE1_M_ON))
+	{
+		bReg |= MCB_LI1MIX;
+	}
+	McDevIf_AddPacket(MCDRV_PACKET_TYPE_WRITE | MCDRV_PACKET_REGTYPE_B_ANA | (UINT32)MCI_ADL_MIX, bReg);
+	/*	ADL_MONO	*/
+	bReg	= 0;
+	if((sPathInfo.asAdc0[0].abSrcOnOff[MCDRV_SRC_LINE1_M_BLOCK] & MCDRV_SRC1_LINE1_M_ON) == MCDRV_SRC1_LINE1_M_ON)
+	{
+		bReg |= MCB_MONO_LI1;
+	}
+	McDevIf_AddPacket(MCDRV_PACKET_TYPE_WRITE | MCDRV_PACKET_REGTYPE_B_ANA | (UINT32)MCI_ADL_MONO, bReg);
+
+	/*	ADR_MIX	*/
+	bReg	= GetMicMixBit(&sPathInfo.asAdc0[1]);
+	if(((sPathInfo.asAdc0[1].abSrcOnOff[MCDRV_SRC_LINE1_R_BLOCK] & MCDRV_SRC1_LINE1_R_ON) == MCDRV_SRC1_LINE1_R_ON)
+	|| ((sPathInfo.asAdc0[1].abSrcOnOff[MCDRV_SRC_LINE1_M_BLOCK] & MCDRV_SRC1_LINE1_M_ON) == MCDRV_SRC1_LINE1_M_ON))
+	{
+		bReg |= MCB_LI1MIX;
+	}
+	McDevIf_AddPacket(MCDRV_PACKET_TYPE_WRITE | MCDRV_PACKET_REGTYPE_B_ANA | (UINT32)MCI_ADR_MIX, bReg);
+	/*	ADR_MONO	*/
+	bReg	= 0;
+	if((sPathInfo.asAdc0[1].abSrcOnOff[MCDRV_SRC_LINE1_M_BLOCK] & MCDRV_SRC1_LINE1_M_ON) == MCDRV_SRC1_LINE1_M_ON)
+	{
+		bReg |= MCB_MONO_LI1;
+	}
+	McDevIf_AddPacket(MCDRV_PACKET_TYPE_WRITE | MCDRV_PACKET_REGTYPE_B_ANA | (UINT32)MCI_ADR_MONO, bReg);
+
+	/*	L1L_MIX	*/
+	bReg	= GetMicMixBit(&sPathInfo.asLout1[0]);
+	if(((sPathInfo.asLout1[0].abSrcOnOff[MCDRV_SRC_LINE1_L_BLOCK] & MCDRV_SRC1_LINE1_L_ON) == MCDRV_SRC1_LINE1_L_ON)
+	|| ((sPathInfo.asLout1[0].abSrcOnOff[MCDRV_SRC_LINE1_M_BLOCK] & MCDRV_SRC1_LINE1_M_ON) == MCDRV_SRC1_LINE1_M_ON))
+	{
+		bReg |= MCB_LI1MIX;
+	}
+	if(((sPathInfo.asLout1[0].abSrcOnOff[MCDRV_SRC_DAC_L_BLOCK] & MCDRV_SRC5_DAC_L_ON) == MCDRV_SRC5_DAC_L_ON)
+	|| ((sPathInfo.asLout1[0].abSrcOnOff[MCDRV_SRC_DAC_M_BLOCK] & MCDRV_SRC5_DAC_M_ON) == MCDRV_SRC5_DAC_M_ON))
+	{
+		bReg |= MCB_DAMIX;
+	}
+	McDevIf_AddPacket(MCDRV_PACKET_TYPE_WRITE | MCDRV_PACKET_REGTYPE_B_ANA | (UINT32)MCI_LO1L_MIX, bReg);
+	/*	L1L_MONO	*/
+	bReg	= 0;
+	if((sPathInfo.asLout1[0].abSrcOnOff[MCDRV_SRC_LINE1_M_BLOCK] & MCDRV_SRC1_LINE1_M_ON) == MCDRV_SRC1_LINE1_M_ON)
+	{
+		bReg |= MCB_MONO_LI1;
+	}
+	if((sPathInfo.asLout1[0].abSrcOnOff[MCDRV_SRC_DAC_M_BLOCK] & MCDRV_SRC5_DAC_M_ON) == MCDRV_SRC5_DAC_M_ON)
+	{
+		bReg |= MCB_MONO_DA;
+	}
+	McDevIf_AddPacket(MCDRV_PACKET_TYPE_WRITE | MCDRV_PACKET_REGTYPE_B_ANA | (UINT32)MCI_LO1L_MONO, bReg);
+
+	/*	L1R_MIX	*/
+	if(sInitInfo.bLineOut1Dif != MCDRV_LINE_DIF)
+	{
+		bReg	= GetMicMixBit(&sPathInfo.asLout1[1]);
+		if((sPathInfo.asLout1[1].abSrcOnOff[MCDRV_SRC_LINE1_R_BLOCK] & MCDRV_SRC1_LINE1_R_ON) == MCDRV_SRC1_LINE1_R_ON)
+		{
+			bReg |= MCB_LI1MIX;
+		}
+		if((sPathInfo.asLout1[1].abSrcOnOff[MCDRV_SRC_DAC_R_BLOCK] & MCDRV_SRC5_DAC_R_ON) == MCDRV_SRC5_DAC_R_ON)
+		{
+			bReg |= MCB_DAMIX;
+		}
+		McDevIf_AddPacket(MCDRV_PACKET_TYPE_WRITE | MCDRV_PACKET_REGTYPE_B_ANA | (UINT32)MCI_LO1R_MIX, bReg);
+	}
+
+	/*	L2L_MIX	*/
+	bReg	= GetMicMixBit(&sPathInfo.asLout2[0]);
+	if(((sPathInfo.asLout2[0].abSrcOnOff[MCDRV_SRC_LINE1_L_BLOCK] & MCDRV_SRC1_LINE1_L_ON) == MCDRV_SRC1_LINE1_L_ON)
+	|| ((sPathInfo.asLout2[0].abSrcOnOff[MCDRV_SRC_LINE1_M_BLOCK] & MCDRV_SRC1_LINE1_M_ON) == MCDRV_SRC1_LINE1_M_ON))
+	{
+		bReg |= MCB_LI1MIX;
+	}
+	if(((sPathInfo.asLout2[0].abSrcOnOff[MCDRV_SRC_DAC_L_BLOCK] & MCDRV_SRC5_DAC_L_ON) == MCDRV_SRC5_DAC_L_ON)
+	|| ((sPathInfo.asLout2[0].abSrcOnOff[MCDRV_SRC_DAC_M_BLOCK] & MCDRV_SRC5_DAC_M_ON) == MCDRV_SRC5_DAC_M_ON))
+	{
+		bReg |= MCB_DAMIX;
+	}
+	McDevIf_AddPacket(MCDRV_PACKET_TYPE_WRITE | MCDRV_PACKET_REGTYPE_B_ANA | (UINT32)MCI_LO2L_MIX, bReg);
+	/*	L2L_MONO	*/
+	bReg	= 0;
+	if((sPathInfo.asLout2[0].abSrcOnOff[MCDRV_SRC_LINE1_M_BLOCK] & MCDRV_SRC1_LINE1_M_ON) == MCDRV_SRC1_LINE1_M_ON)
+	{
+		bReg |= MCB_MONO_LI1;
+	}
+	if((sPathInfo.asLout2[0].abSrcOnOff[MCDRV_SRC_DAC_M_BLOCK] & MCDRV_SRC5_DAC_M_ON) == MCDRV_SRC5_DAC_M_ON)
+	{
+		bReg |= MCB_MONO_DA;
+	}
+	McDevIf_AddPacket(MCDRV_PACKET_TYPE_WRITE | MCDRV_PACKET_REGTYPE_B_ANA | (UINT32)MCI_LO2L_MONO, bReg);
+
+	/*	L2R_MIX	*/
+	if(sInitInfo.bLineOut2Dif != MCDRV_LINE_DIF)
+	{
+		bReg	= GetMicMixBit(&sPathInfo.asLout2[1]);
+		if((sPathInfo.asLout2[1].abSrcOnOff[MCDRV_SRC_LINE1_R_BLOCK] & MCDRV_SRC1_LINE1_R_ON) == MCDRV_SRC1_LINE1_R_ON)
+		{
+			bReg |= MCB_LI1MIX;
+		}
+		if((sPathInfo.asLout2[1].abSrcOnOff[MCDRV_SRC_DAC_R_BLOCK] & MCDRV_SRC5_DAC_R_ON) == MCDRV_SRC5_DAC_R_ON)
+		{
+			bReg |= MCB_DAMIX;
+		}
+		McDevIf_AddPacket(MCDRV_PACKET_TYPE_WRITE | MCDRV_PACKET_REGTYPE_B_ANA | (UINT32)MCI_LO2R_MIX, bReg);
+	}
+
+	/*	HPL_MIX	*/
+	bReg	= GetMicMixBit(&sPathInfo.asHpOut[0]);
+	if(((sPathInfo.asHpOut[0].abSrcOnOff[MCDRV_SRC_LINE1_L_BLOCK] & MCDRV_SRC1_LINE1_L_ON) == MCDRV_SRC1_LINE1_L_ON)
+	|| ((sPathInfo.asHpOut[0].abSrcOnOff[MCDRV_SRC_LINE1_M_BLOCK] & MCDRV_SRC1_LINE1_M_ON) == MCDRV_SRC1_LINE1_M_ON))
+	{
+		bReg |= MCB_LI1MIX;
+	}
+	if(((sPathInfo.asHpOut[0].abSrcOnOff[MCDRV_SRC_DAC_L_BLOCK] & MCDRV_SRC5_DAC_L_ON) == MCDRV_SRC5_DAC_L_ON)
+	|| ((sPathInfo.asHpOut[0].abSrcOnOff[MCDRV_SRC_DAC_M_BLOCK] & MCDRV_SRC5_DAC_M_ON) == MCDRV_SRC5_DAC_M_ON))
+	{
+		bReg |= MCB_DAMIX;
+	}
+	McDevIf_AddPacket(MCDRV_PACKET_TYPE_WRITE | MCDRV_PACKET_REGTYPE_B_ANA | (UINT32)MCI_HPL_MIX, bReg);
+	/*	HPL_MONO	*/
+	bReg	= 0;
+	if((sPathInfo.asHpOut[0].abSrcOnOff[MCDRV_SRC_LINE1_M_BLOCK] & MCDRV_SRC1_LINE1_M_ON) == MCDRV_SRC1_LINE1_M_ON)
+	{
+		bReg |= MCB_MONO_LI1;
+	}
+	if((sPathInfo.asHpOut[0].abSrcOnOff[MCDRV_SRC_DAC_M_BLOCK] & MCDRV_SRC5_DAC_M_ON) == MCDRV_SRC5_DAC_M_ON)
+	{
+		bReg |= MCB_MONO_DA;
+	}
+	McDevIf_AddPacket(MCDRV_PACKET_TYPE_WRITE | MCDRV_PACKET_REGTYPE_B_ANA | (UINT32)MCI_HPL_MONO, bReg);
+
+	/*	HPR_MIX	*/
+	bReg	= GetMicMixBit(&sPathInfo.asHpOut[1]);
+	if((sPathInfo.asHpOut[1].abSrcOnOff[MCDRV_SRC_LINE1_R_BLOCK] & MCDRV_SRC1_LINE1_R_ON) == MCDRV_SRC1_LINE1_R_ON)
+	{
+		bReg |= MCB_LI1MIX;
+	}
+	if((sPathInfo.asHpOut[1].abSrcOnOff[MCDRV_SRC_DAC_R_BLOCK] & MCDRV_SRC5_DAC_R_ON) == MCDRV_SRC5_DAC_R_ON)
+	{
+		bReg |= MCB_DAMIX;
+	}
+	McDevIf_AddPacket(MCDRV_PACKET_TYPE_WRITE | MCDRV_PACKET_REGTYPE_B_ANA | (UINT32)MCI_HPR_MIX, bReg);
+
+	/*	SPL_MIX	*/
+	bReg	= 0;
+	if(((sPathInfo.asSpOut[0].abSrcOnOff[MCDRV_SRC_LINE1_L_BLOCK] & MCDRV_SRC1_LINE1_L_ON) == MCDRV_SRC1_LINE1_L_ON)
+	|| ((sPathInfo.asSpOut[0].abSrcOnOff[MCDRV_SRC_LINE1_M_BLOCK] & MCDRV_SRC1_LINE1_M_ON) == MCDRV_SRC1_LINE1_M_ON))
+	{
+		bReg |= MCB_LI1MIX;
+	}
+	if(((sPathInfo.asSpOut[0].abSrcOnOff[MCDRV_SRC_DAC_L_BLOCK] & MCDRV_SRC5_DAC_L_ON) == MCDRV_SRC5_DAC_L_ON)
+	|| ((sPathInfo.asSpOut[0].abSrcOnOff[MCDRV_SRC_DAC_M_BLOCK] & MCDRV_SRC5_DAC_M_ON) == MCDRV_SRC5_DAC_M_ON))
+	{
+		bReg |= MCB_DAMIX;
+	}
+	McDevIf_AddPacket(MCDRV_PACKET_TYPE_WRITE | MCDRV_PACKET_REGTYPE_B_ANA | (UINT32)MCI_SPL_MIX, bReg);
+	/*	SPL_MONO	*/
+	bReg	= 0;
+	if((sPathInfo.asSpOut[0].abSrcOnOff[MCDRV_SRC_LINE1_M_BLOCK] & MCDRV_SRC1_LINE1_M_ON) == MCDRV_SRC1_LINE1_M_ON)
+	{
+		bReg |= MCB_MONO_LI1;
+	}
+	if((sPathInfo.asSpOut[0].abSrcOnOff[MCDRV_SRC_DAC_M_BLOCK] & MCDRV_SRC5_DAC_M_ON) == MCDRV_SRC5_DAC_M_ON)
+	{
+		bReg |= MCB_MONO_DA;
+	}
+	McDevIf_AddPacket(MCDRV_PACKET_TYPE_WRITE | MCDRV_PACKET_REGTYPE_B_ANA | (UINT32)MCI_SPL_MONO, bReg);
+
+	/*	SPR_MIX	*/
+	bReg	= 0;
+	if(((sPathInfo.asSpOut[1].abSrcOnOff[MCDRV_SRC_LINE1_R_BLOCK] & MCDRV_SRC1_LINE1_R_ON) == MCDRV_SRC1_LINE1_R_ON)
+	|| ((sPathInfo.asSpOut[1].abSrcOnOff[MCDRV_SRC_LINE1_M_BLOCK] & MCDRV_SRC1_LINE1_M_ON) == MCDRV_SRC1_LINE1_M_ON))
+	{
+		bReg |= MCB_LI1MIX;
+	}
+	if(((sPathInfo.asSpOut[1].abSrcOnOff[MCDRV_SRC_DAC_R_BLOCK] & MCDRV_SRC5_DAC_R_ON) == MCDRV_SRC5_DAC_R_ON)
+	|| ((sPathInfo.asSpOut[1].abSrcOnOff[MCDRV_SRC_DAC_M_BLOCK] & MCDRV_SRC5_DAC_M_ON) == MCDRV_SRC5_DAC_M_ON))
+	{
+		bReg |= MCB_DAMIX;
+	}
+	McDevIf_AddPacket(MCDRV_PACKET_TYPE_WRITE | MCDRV_PACKET_REGTYPE_B_ANA | (UINT32)MCI_SPR_MIX, bReg);
+	/*	SPR_MONO	*/
+	bReg	= 0;
+	if((sPathInfo.asSpOut[1].abSrcOnOff[MCDRV_SRC_LINE1_M_BLOCK] & MCDRV_SRC1_LINE1_M_ON) == MCDRV_SRC1_LINE1_M_ON)
+	{
+		bReg |= MCB_MONO_LI1;
+	}
+	if((sPathInfo.asSpOut[1].abSrcOnOff[MCDRV_SRC_DAC_M_BLOCK] & MCDRV_SRC5_DAC_M_ON) == MCDRV_SRC5_DAC_M_ON)
+	{
+		bReg |= MCB_MONO_DA;
+	}
+	McDevIf_AddPacket(MCDRV_PACKET_TYPE_WRITE | MCDRV_PACKET_REGTYPE_B_ANA | (UINT32)MCI_SPR_MONO, bReg);
+
+	/*	RCV_MIX	*/
+	bReg	= GetMicMixBit(&sPathInfo.asRcOut[0]);
+	if((sPathInfo.asRcOut[0].abSrcOnOff[MCDRV_SRC_LINE1_M_BLOCK] & MCDRV_SRC1_LINE1_M_ON) == MCDRV_SRC1_LINE1_M_ON)
+	{
+		bReg |= MCB_LI1MIX;
+	}
+	if((sPathInfo.asRcOut[0].abSrcOnOff[MCDRV_SRC_DAC_L_BLOCK] & MCDRV_SRC5_DAC_L_ON) == MCDRV_SRC5_DAC_L_ON)
+	{
+		bReg |= MCB_DALMIX;
+	}
+	if((sPathInfo.asRcOut[0].abSrcOnOff[MCDRV_SRC_DAC_R_BLOCK] & MCDRV_SRC5_DAC_R_ON) == MCDRV_SRC5_DAC_R_ON)
+	{
+		bReg |= MCB_DARMIX;
+	}
+	McDevIf_AddPacket(MCDRV_PACKET_TYPE_WRITE | MCDRV_PACKET_REGTYPE_B_ANA | (UINT32)MCI_RC_MIX, bReg);
+
+
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncOut("McPacket_AddMixSet", &sdRet);
+#endif
+	return sdRet;
+}
+
+/****************************************************************************
+ *	GetMicMixBit
+ *
+ *	Description:
+ *			Get mic mixer bit.
+ *	Arguments:
+ *			source info
+ *	Return:
+ *			mic mixer bit
+ *
+ ****************************************************************************/
+static UINT8	GetMicMixBit
+(
+	const MCDRV_CHANNEL* psChannel
+)
+{
+	UINT8	bMicMix	= 0;
+
+#if (MCDRV_DEBUG_LEVEL>=4)
+	SINT32	sdRet;
+	McDebugLog_FuncIn("GetMicMixBit");
+#endif
+
+	if((psChannel->abSrcOnOff[MCDRV_SRC_MIC1_BLOCK] & MCDRV_SRC0_MIC1_ON) == MCDRV_SRC0_MIC1_ON)
+	{
+		bMicMix |= MCB_M1MIX;
+	}
+	if((psChannel->abSrcOnOff[MCDRV_SRC_MIC2_BLOCK] & MCDRV_SRC0_MIC2_ON) == MCDRV_SRC0_MIC2_ON)
+	{
+		bMicMix |= MCB_M2MIX;
+	}
+	if((psChannel->abSrcOnOff[MCDRV_SRC_MIC3_BLOCK] & MCDRV_SRC0_MIC3_ON) == MCDRV_SRC0_MIC3_ON)
+	{
+		bMicMix |= MCB_M3MIX;
+	}
+
+#if (MCDRV_DEBUG_LEVEL>=4)
+	sdRet	= (SINT32)bMicMix;
+	McDebugLog_FuncOut("GetMicMixBit", &sdRet);
+#endif
+	return bMicMix;
+}
+
+/****************************************************************************
+ *	McPacket_AddStart
+ *
+ *	Description:
+ *			Add start packet.
+ *	Arguments:
+ *			none
+ *	Return:
+ *			MCDRV_SUCCESS
+ *			MCDRV_ERROR_RESOURCEOVER
+ *			MCDRV_ERROR_TIMEOUT
+ *
+ ****************************************************************************/
+SINT32	McPacket_AddStart
+(
+	void
+)
+{
+	SINT32	sdRet	= MCDRV_SUCCESS;
+	UINT8	bReg;
+	MCDRV_INIT_INFO	sInitInfo;
+	MCDRV_PATH_INFO	sPathInfo;
+	MCDRV_ADC_INFO	sAdcInfo;
+	MCDRV_PDM_INFO	sPdmInfo;
+
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncIn("McPacket_AddStart");
+#endif
+
+	McResCtrl_GetInitInfo(&sInitInfo);
+	McResCtrl_GetPathInfo(&sPathInfo);
+	McResCtrl_GetAdcInfo(&sAdcInfo);
+	McResCtrl_GetPdmInfo(&sPdmInfo);
+
+	if((McResCtrl_IsDstUsed(eMCDRV_DST_ADC0, eMCDRV_DST_CH0) == 1)
+	|| (McResCtrl_IsDstUsed(eMCDRV_DST_ADC0, eMCDRV_DST_CH1) == 1))
+	{/*	ADC0 source is used	*/
+		if((McResCtrl_GetRegVal(MCDRV_PACKET_REGTYPE_B_CODEC, MCI_AD_START) & MCB_AD_START) == 0)
+		{
+			bReg	= (sAdcInfo.bAgcOn << 2) | sAdcInfo.bAgcAdjust;
+			McDevIf_AddPacket(MCDRV_PACKET_TYPE_WRITE | MCDRV_PACKET_REGTYPE_B_CODEC | (UINT32)MCI_AD_AGC, bReg);
+			bReg	= (sAdcInfo.bMono << 1) | MCB_AD_START;
+			McDevIf_AddPacket(MCDRV_PACKET_TYPE_WRITE | MCDRV_PACKET_REGTYPE_B_CODEC | (UINT32)MCI_AD_START, bReg);
+		}
+	}
+	else if(McResCtrl_IsSrcUsed(eMCDRV_SRC_PDM) != 0)
+	{/*	PDM is used	*/
+		if((McResCtrl_GetRegVal(MCDRV_PACKET_REGTYPE_B_MIXER, MCI_PDM_START) & MCB_PDM_START) == 0)
+		{
+			bReg	= (sPdmInfo.bAgcOn << 2) | sPdmInfo.bAgcAdjust;
+			McDevIf_AddPacket(MCDRV_PACKET_TYPE_WRITE | MCDRV_PACKET_REGTYPE_B_MIXER | (UINT32)MCI_PDM_AGC, bReg);
+			bReg	= (sPdmInfo.bMono << 1) | MCB_PDM_START;
+			McDevIf_AddPacket(MCDRV_PACKET_TYPE_WRITE | MCDRV_PACKET_REGTYPE_B_MIXER | (UINT32)MCI_PDM_START, bReg);
+		}
+	}
+	else
+	{
+	}
+
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncOut("McPacket_AddStart", &sdRet);
+#endif
+
+	return sdRet;
+}
+
+/****************************************************************************
+ *	McPacket_AddStop
+ *
+ *	Description:
+ *			Add stop packet.
+ *	Arguments:
+ *			none
+ *	Return:
+ *			MCDRV_SUCCESS
+ *
+ ****************************************************************************/
+SINT32	McPacket_AddStop
+(
+	void
+)
+{
+	SINT32	sdRet	= MCDRV_SUCCESS;
+	UINT8	bReg;
+
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncIn("McPacket_AddStop");
+#endif
+
+	bReg	= McResCtrl_GetRegVal(MCDRV_PACKET_REGTYPE_B_MIXER, MCI_DIX0_START);
+	if(McResCtrl_GetDITSource(eMCDRV_DIO_0) == eMCDRV_SRC_NONE)
+	{/*	DIT is unused	*/
+		bReg &= (UINT8)~MCB_DIT0_SRC_START;
+		bReg &= (UINT8)~MCB_DIT0_START;
+	}
+	if(McResCtrl_IsSrcUsed(eMCDRV_SRC_DIR0) == 0)
+	{/*	DIR is unused	*/
+		bReg &= (UINT8)~MCB_DIR0_SRC_START;
+		bReg &= (UINT8)~MCB_DIR0_START;
+	}
+	if((bReg & 0x0F) == 0)
+	{
+		bReg &= (UINT8)~MCB_DITIM0_START;
+	}
+	McDevIf_AddPacket(MCDRV_PACKET_TYPE_WRITE | MCDRV_PACKET_REGTYPE_B_MIXER | (UINT32)MCI_DIX0_START, bReg);
+
+	bReg	= McResCtrl_GetRegVal(MCDRV_PACKET_REGTYPE_B_MIXER, MCI_DIX1_START);
+	if(McResCtrl_GetDITSource(eMCDRV_DIO_1) == eMCDRV_SRC_NONE)
+	{/*	DIT is unused	*/
+		bReg &= (UINT8)~MCB_DIT1_SRC_START;
+		bReg &= (UINT8)~MCB_DIT1_START;
+	}
+	if(McResCtrl_IsSrcUsed(eMCDRV_SRC_DIR1) == 0)
+	{/*	DIR is unused	*/
+		bReg &= (UINT8)~MCB_DIR1_SRC_START;
+		bReg &= (UINT8)~MCB_DIR1_START;
+	}
+	if((bReg & 0x0F) == 0)
+	{
+		bReg &= (UINT8)~MCB_DITIM1_START;
+	}
+	McDevIf_AddPacket(MCDRV_PACKET_TYPE_WRITE | MCDRV_PACKET_REGTYPE_B_MIXER | (UINT32)MCI_DIX1_START, bReg);
+
+	bReg	= McResCtrl_GetRegVal(MCDRV_PACKET_REGTYPE_B_MIXER, MCI_DIX2_START);
+	if(McResCtrl_GetDITSource(eMCDRV_DIO_2) == eMCDRV_SRC_NONE)
+	{/*	DIT is unused	*/
+		bReg &= (UINT8)~MCB_DIT2_SRC_START;
+		bReg &= (UINT8)~MCB_DIT2_START;
+	}
+	if(McResCtrl_IsSrcUsed(eMCDRV_SRC_DIR2) == 0)
+	{/*	DIR is unused	*/
+		bReg &= (UINT8)~MCB_DIR2_SRC_START;
+		bReg &= (UINT8)~MCB_DIR2_START;
+	}
+	if((bReg & 0x0F) == 0)
+	{
+		bReg &= (UINT8)~MCB_DITIM2_START;
+	}
+	McDevIf_AddPacket(MCDRV_PACKET_TYPE_WRITE | MCDRV_PACKET_REGTYPE_B_MIXER | (UINT32)MCI_DIX2_START, bReg);
+
+	if((McResCtrl_IsDstUsed(eMCDRV_DST_ADC0, eMCDRV_DST_CH0) == 0)
+	&& (McResCtrl_IsDstUsed(eMCDRV_DST_ADC0, eMCDRV_DST_CH1) == 0))
+	{/*	ADC0 source is unused	*/
+		AddStopADC();
+	}
+	if(McResCtrl_IsSrcUsed(eMCDRV_SRC_PDM) == 0)
+	{/*	PDM is unused	*/
+		AddStopPDM();
+	}
+
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncOut("McPacket_AddStop", &sdRet);
+#endif
+
+	return sdRet;
+}
+
+/****************************************************************************
+ *	McPacket_AddVol
+ *
+ *	Description:
+ *			Add volume mute packet.
+ *	Arguments:
+ *			dUpdate			target volume items
+ *			eMode			update mode
+ *			pdSVolDoneParam	wait soft volume complete flag
+ *	Return:
+ *			MCDRV_SUCCESS
+ *
+ ****************************************************************************/
+SINT32	McPacket_AddVol
+(
+	UINT32					dUpdate,
+	MCDRV_VOLUPDATE_MODE	eMode,
+	UINT32*					pdSVolDoneParam
+)
+{
+	SINT32			sdRet	= MCDRV_SUCCESS;
+	UINT8			bVolL;
+	UINT8			bVolR;
+	UINT8			bLAT;
+	UINT8			bReg;
+	MCDRV_INIT_INFO	sInitInfo;
+	MCDRV_VOL_INFO	sVolInfo;
+
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncIn("McPacket_AddVol");
+#endif
+
+	McResCtrl_GetInitInfo(&sInitInfo);
+	McResCtrl_GetVolReg(&sVolInfo);
+
+	if((dUpdate & MCDRV_VOLUPDATE_ANAOUT_ALL) != (UINT32)0)
+	{
+		*pdSVolDoneParam	= 0;
+
+		bVolL	= (UINT8)sVolInfo.aswA_Hp[0]&MCB_HPVOL_L;
+		bVolR	= (UINT8)sVolInfo.aswA_Hp[1]&MCB_HPVOL_R;
+		if(bVolL != (McResCtrl_GetRegVal(MCDRV_PACKET_REGTYPE_B_ANA, MCI_HPVOL_L) & MCB_HPVOL_L))
+		{
+			if((eMode != eMCDRV_VOLUPDATE_MUTE) || (bVolL == MCDRV_REG_MUTE))
+			{
+				if(((eMode != eMCDRV_VOLUPDATE_MUTE) || (bVolR == MCDRV_REG_MUTE))
+				&& (bVolR != McResCtrl_GetRegVal(MCDRV_PACKET_REGTYPE_B_ANA, MCI_HPVOL_R)))
+				{
+					bLAT	= MCB_ALAT_HP;
+				}
+				else
+				{
+					bLAT	= 0;
+				}
+				bReg	= bLAT|MCB_SVOL_HP|bVolL;
+				McDevIf_AddPacket(MCDRV_PACKET_TYPE_WRITE | MCDRV_PACKET_REGTYPE_B_ANA | (UINT32)MCI_HPVOL_L, bReg);
+				if(bVolL == MCDRV_REG_MUTE)
+				{
+					*pdSVolDoneParam	|= (MCB_HPL_BUSY<<8);
+				}
+			}
+		}
+		if((eMode != eMCDRV_VOLUPDATE_MUTE) || (bVolR == MCDRV_REG_MUTE))
+		{
+			if((bVolR == MCDRV_REG_MUTE) && (McResCtrl_GetRegVal(MCDRV_PACKET_REGTYPE_B_ANA, MCI_HPVOL_R) != 0))
+			{
+				*pdSVolDoneParam	|= (UINT8)MCB_HPR_BUSY;
+			}
+			McDevIf_AddPacket(MCDRV_PACKET_TYPE_WRITE | MCDRV_PACKET_REGTYPE_B_ANA | (UINT32)MCI_HPVOL_R, bVolR);
+		}
+
+		bVolL	= (UINT8)sVolInfo.aswA_Sp[0]&MCB_SPVOL_L;
+		bVolR	= (UINT8)sVolInfo.aswA_Sp[1]&MCB_SPVOL_R;
+		if(bVolL != (McResCtrl_GetRegVal(MCDRV_PACKET_REGTYPE_B_ANA, MCI_SPVOL_L) & MCB_SPVOL_L))
+		{
+			if((eMode != eMCDRV_VOLUPDATE_MUTE) || (bVolL == MCDRV_REG_MUTE))
+			{
+				if(((eMode != eMCDRV_VOLUPDATE_MUTE) || (bVolR == MCDRV_REG_MUTE))
+				&& (bVolR != McResCtrl_GetRegVal(MCDRV_PACKET_REGTYPE_B_ANA, MCI_SPVOL_R)))
+				{
+					bLAT	= MCB_ALAT_SP;
+				}
+				else
+				{
+					bLAT	= 0;
+				}
+				bReg	= bLAT|MCB_SVOL_SP|bVolL;
+				McDevIf_AddPacket(MCDRV_PACKET_TYPE_WRITE | MCDRV_PACKET_REGTYPE_B_ANA | (UINT32)MCI_SPVOL_L, bReg);
+				if(bVolL == MCDRV_REG_MUTE)
+				{
+					*pdSVolDoneParam	|= (MCB_SPL_BUSY<<8);
+				}
+			}
+		}
+		if((eMode != eMCDRV_VOLUPDATE_MUTE) || (bVolR == MCDRV_REG_MUTE))
+		{
+			if((bVolR == MCDRV_REG_MUTE) && (McResCtrl_GetRegVal(MCDRV_PACKET_REGTYPE_B_ANA, MCI_SPVOL_R) != 0))
+			{
+				*pdSVolDoneParam	|= (UINT8)MCB_SPR_BUSY;
+			}
+			McDevIf_AddPacket(MCDRV_PACKET_TYPE_WRITE | MCDRV_PACKET_REGTYPE_B_ANA | (UINT32)MCI_SPVOL_R, bVolR);
+		}
+
+		bVolL	= (UINT8)sVolInfo.aswA_Rc[0]&MCB_RCVOL;
+		if(bVolL != (McResCtrl_GetRegVal(MCDRV_PACKET_REGTYPE_B_ANA, MCI_RCVOL) & MCB_RCVOL))
+		{
+			if((eMode != eMCDRV_VOLUPDATE_MUTE) || (bVolL == MCDRV_REG_MUTE))
+			{
+				bReg	= MCB_SVOL_RC|bVolL;
+				McDevIf_AddPacket(MCDRV_PACKET_TYPE_WRITE | MCDRV_PACKET_REGTYPE_B_ANA | (UINT32)MCI_RCVOL, bReg);
+				if(bVolL == MCDRV_REG_MUTE)
+				{
+					*pdSVolDoneParam	|= (MCB_RC_BUSY<<8);
+				}
+			}
+		}
+
+		bVolL	= (UINT8)sVolInfo.aswA_Lout1[0]&MCB_LO1VOL_L;
+		bVolR	= (UINT8)sVolInfo.aswA_Lout1[1]&MCB_LO1VOL_R;
+		if(bVolL != (McResCtrl_GetRegVal(MCDRV_PACKET_REGTYPE_B_ANA, MCI_LO1VOL_L) & MCB_LO1VOL_L))
+		{
+			if((eMode != eMCDRV_VOLUPDATE_MUTE) || (bVolL == MCDRV_REG_MUTE))
+			{
+				if(((eMode != eMCDRV_VOLUPDATE_MUTE) || (bVolR == MCDRV_REG_MUTE))
+				&& (bVolR != McResCtrl_GetRegVal(MCDRV_PACKET_REGTYPE_B_ANA, MCI_LO1VOL_R)))
+				{
+					bLAT	= MCB_ALAT_LO1;
+				}
+				else
+				{
+					bLAT	= 0;
+				}
+				bReg	= bLAT|bVolL;
+				McDevIf_AddPacket(MCDRV_PACKET_TYPE_WRITE | MCDRV_PACKET_REGTYPE_B_ANA | (UINT32)MCI_LO1VOL_L, bReg);
+			}
+		}
+		if((eMode != eMCDRV_VOLUPDATE_MUTE) || (bVolR == MCDRV_REG_MUTE))
+		{
+			McDevIf_AddPacket(MCDRV_PACKET_TYPE_WRITE | MCDRV_PACKET_REGTYPE_B_ANA | (UINT32)MCI_LO1VOL_R, bVolR);
+		}
+
+		bVolL	= (UINT8)sVolInfo.aswA_Lout2[0]&MCB_LO2VOL_L;
+		bVolR	= (UINT8)sVolInfo.aswA_Lout2[1]&MCB_LO2VOL_R;
+		if(bVolL != (McResCtrl_GetRegVal(MCDRV_PACKET_REGTYPE_B_ANA, MCI_LO2VOL_L) & MCB_LO2VOL_L))
+		{
+			if((eMode != eMCDRV_VOLUPDATE_MUTE) || (bVolL == MCDRV_REG_MUTE))
+			{
+				if(((eMode != eMCDRV_VOLUPDATE_MUTE) || (bVolR == MCDRV_REG_MUTE))
+				&& (bVolR != McResCtrl_GetRegVal(MCDRV_PACKET_REGTYPE_B_ANA, MCI_LO2VOL_R)))
+				{
+					bLAT	= MCB_ALAT_LO2;
+				}
+				else
+				{
+					bLAT	= 0;
+				}
+				bReg	= bLAT|bVolL;
+				McDevIf_AddPacket(MCDRV_PACKET_TYPE_WRITE | MCDRV_PACKET_REGTYPE_B_ANA | (UINT32)MCI_LO2VOL_L, bReg);
+			}
+		}
+		if((eMode != eMCDRV_VOLUPDATE_MUTE) || (bVolR == MCDRV_REG_MUTE))
+		{
+			McDevIf_AddPacket(MCDRV_PACKET_TYPE_WRITE | MCDRV_PACKET_REGTYPE_B_ANA | (UINT32)MCI_LO2VOL_R, bVolR);
+		}
+
+		bVolL	= (UINT8)sVolInfo.aswA_HpGain[0];
+		if(bVolL != McResCtrl_GetRegVal(MCDRV_PACKET_REGTYPE_B_ANA, MCI_HP_GAIN))
+		{
+			if((eMode != eMCDRV_VOLUPDATE_MUTE) || (bVolL == MCDRV_REG_MUTE))
+			{
+				McDevIf_AddPacket(MCDRV_PACKET_TYPE_WRITE | MCDRV_PACKET_REGTYPE_B_ANA | (UINT32)MCI_HP_GAIN, bVolL);
+			}
+		}
+	}
+	if((dUpdate & ~MCDRV_VOLUPDATE_ANAOUT_ALL) != (UINT32)0)
+	{
+		bVolL	= (UINT8)sVolInfo.aswA_Lin1[0]&MCB_LI1VOL_L;
+		bVolR	= (UINT8)sVolInfo.aswA_Lin1[1]&MCB_LI1VOL_R;
+		if(bVolL != (McResCtrl_GetRegVal(MCDRV_PACKET_REGTYPE_B_ANA, MCI_LI1VOL_L) & MCB_LI1VOL_L))
+		{
+			if((eMode != eMCDRV_VOLUPDATE_MUTE) || (bVolL == MCDRV_REG_MUTE))
+			{
+				if(((eMode != eMCDRV_VOLUPDATE_MUTE) || (bVolR == MCDRV_REG_MUTE))
+				&& (bVolR != McResCtrl_GetRegVal(MCDRV_PACKET_REGTYPE_B_ANA, MCI_LI1VOL_R)))
+				{
+					bLAT	= MCB_ALAT_LI1;
+				}
+				else
+				{
+					bLAT	= 0;
+				}
+				bReg	= bLAT|bVolL;
+				McDevIf_AddPacket(MCDRV_PACKET_TYPE_WRITE | MCDRV_PACKET_REGTYPE_B_ANA | (UINT32)MCI_LI1VOL_L, bReg);
+			}
+		}
+		if((eMode != eMCDRV_VOLUPDATE_MUTE) || (bVolR == MCDRV_REG_MUTE))
+		{
+			McDevIf_AddPacket(MCDRV_PACKET_TYPE_WRITE | MCDRV_PACKET_REGTYPE_B_ANA | (UINT32)MCI_LI1VOL_R, bVolR);
+		}
+
+		if(McDevProf_IsValid(eMCDRV_FUNC_LI2) == 1)
+		{
+			bVolL	= (UINT8)sVolInfo.aswA_Lin2[0]&MCB_LI2VOL_L;
+			bVolR	= (UINT8)sVolInfo.aswA_Lin2[1]&MCB_LI2VOL_R;
+			if(bVolL != (McResCtrl_GetRegVal(MCDRV_PACKET_REGTYPE_B_ANA, MCI_LI2VOL_L) & MCB_LI2VOL_L))
+			{
+				if((eMode != eMCDRV_VOLUPDATE_MUTE) || (bVolL == MCDRV_REG_MUTE))
+				{
+					if(((eMode != eMCDRV_VOLUPDATE_MUTE) || (bVolR == MCDRV_REG_MUTE))
+					&& (bVolR != McResCtrl_GetRegVal(MCDRV_PACKET_REGTYPE_B_ANA, MCI_LI2VOL_R)))
+					{
+						bLAT	= MCB_ALAT_LI2;
+					}
+					else
+					{
+						bLAT	= 0;
+					}
+					bReg	= bLAT|bVolL;
+					McDevIf_AddPacket(MCDRV_PACKET_TYPE_WRITE | MCDRV_PACKET_REGTYPE_B_ANA | (UINT32)MCI_LI2VOL_L, bReg);
+				}
+			}
+			if((eMode != eMCDRV_VOLUPDATE_MUTE) || (bVolR == MCDRV_REG_MUTE))
+			{
+				McDevIf_AddPacket(MCDRV_PACKET_TYPE_WRITE | MCDRV_PACKET_REGTYPE_B_ANA | (UINT32)MCI_LI2VOL_R, bVolR);
+			}
+		}
+
+		bVolL	= (UINT8)sVolInfo.aswA_Mic1[0]&MCB_MC1VOL;
+		if((eMode != eMCDRV_VOLUPDATE_MUTE) || (bVolL == MCDRV_REG_MUTE))
+		{
+			McDevIf_AddPacket(MCDRV_PACKET_TYPE_WRITE | MCDRV_PACKET_REGTYPE_B_ANA | (UINT32)MCI_MC1VOL, bVolL);
+		}
+		bVolL	= (UINT8)sVolInfo.aswA_Mic2[0]&MCB_MC2VOL;
+		if((eMode != eMCDRV_VOLUPDATE_MUTE) || (bVolL == MCDRV_REG_MUTE))
+		{
+			McDevIf_AddPacket(MCDRV_PACKET_TYPE_WRITE | MCDRV_PACKET_REGTYPE_B_ANA | (UINT32)MCI_MC2VOL, bVolL);
+		}
+		bVolL	= (UINT8)sVolInfo.aswA_Mic3[0]&MCB_MC3VOL;
+		if((eMode != eMCDRV_VOLUPDATE_MUTE) || (bVolL == MCDRV_REG_MUTE))
+		{
+			McDevIf_AddPacket(MCDRV_PACKET_TYPE_WRITE | MCDRV_PACKET_REGTYPE_B_ANA | (UINT32)MCI_MC3VOL, bVolL);
+		}
+
+		bVolL	= (UINT8)sVolInfo.aswA_Ad0[0]&MCB_ADVOL_L;
+		bVolR	= (UINT8)sVolInfo.aswA_Ad0[1]&MCB_ADVOL_R;
+		if(bVolL != (McResCtrl_GetRegVal(MCDRV_PACKET_REGTYPE_B_ANA, MCI_ADVOL_L) & MCB_ADVOL_L))
+		{
+			if((eMode != eMCDRV_VOLUPDATE_MUTE) || (bVolL == MCDRV_REG_MUTE))
+			{
+				if(((eMode != eMCDRV_VOLUPDATE_MUTE) || (bVolR == MCDRV_REG_MUTE))
+				&& (bVolR != McResCtrl_GetRegVal(MCDRV_PACKET_REGTYPE_B_ANA, MCI_ADVOL_R)))
+				{
+					bLAT	= MCB_ALAT_AD;
+				}
+				else
+				{
+					bLAT	= 0;
+				}
+				bReg	= bLAT|bVolL;
+				McDevIf_AddPacket(MCDRV_PACKET_TYPE_WRITE | MCDRV_PACKET_REGTYPE_B_ANA | (UINT32)MCI_ADVOL_L, bReg);
+			}
+		}
+		if((eMode != eMCDRV_VOLUPDATE_MUTE) || (bVolR == MCDRV_REG_MUTE))
+		{
+			McDevIf_AddPacket(MCDRV_PACKET_TYPE_WRITE | MCDRV_PACKET_REGTYPE_B_ANA | (UINT32)MCI_ADVOL_R, bVolR);
+		}
+
+		bVolL	= (UINT8)sVolInfo.aswA_Mic2Gain[0]&0x03;
+		bVolL	= (UINT8)((bVolL << 4) & MCB_MC2GAIN) | ((UINT8)sVolInfo.aswA_Mic1Gain[0]&MCB_MC1GAIN);
+		bVolL |= ((sInitInfo.bMic2Sng << 6) & MCB_MC2SNG);
+		bVolL |= ((sInitInfo.bMic1Sng << 2) & MCB_MC1SNG);
+		if(eMode == eMCDRV_VOLUPDATE_MUTE)
+		{
+			bReg	= McResCtrl_GetRegVal(MCDRV_PACKET_REGTYPE_B_ANA, MCI_MC_GAIN);
+			if(((bReg & MCB_MC2GAIN) == 0) && ((bReg & MCB_MC1GAIN) == 0))
+			{
+				;
+			}
+			else
+			{
+				if((bReg & MCB_MC2GAIN) == 0)
+				{
+					bVolL &= (UINT8)~MCB_MC2GAIN;
+				}
+				else if((bReg & MCB_MC1GAIN) == 0)
+				{
+					bVolL &= (UINT8)~MCB_MC1GAIN;
+				}
+				else
+				{
+				}
+				McDevIf_AddPacket(MCDRV_PACKET_TYPE_WRITE | MCDRV_PACKET_REGTYPE_B_ANA | (UINT32)MCI_MC_GAIN, bVolL);
+			}
+		}
+		else
+		{
+			McDevIf_AddPacket(MCDRV_PACKET_TYPE_WRITE | MCDRV_PACKET_REGTYPE_B_ANA | (UINT32)MCI_MC_GAIN, bVolL);
+		}
+
+		bVolL	= ((UINT8)sVolInfo.aswA_Mic3Gain[0]&MCB_MC3GAIN) | ((sInitInfo.bMic3Sng << 2) & MCB_MC3SNG);
+		if(eMode == eMCDRV_VOLUPDATE_MUTE)
+		{
+			bReg	= McResCtrl_GetRegVal(MCDRV_PACKET_REGTYPE_B_ANA, MCI_MC3_GAIN);
+			if((bReg & MCB_MC3GAIN) == 0)
+			{
+				;
+			}
+			else
+			{
+				McDevIf_AddPacket(MCDRV_PACKET_TYPE_WRITE | MCDRV_PACKET_REGTYPE_B_ANA | (UINT32)MCI_MC3_GAIN, bVolL);
+			}
+		}
+		else
+		{
+			McDevIf_AddPacket(MCDRV_PACKET_TYPE_WRITE | MCDRV_PACKET_REGTYPE_B_ANA | (UINT32)MCI_MC3_GAIN, bVolL);
+		}
+
+		/*	DIT0_INVOL	*/
+		bVolL	= (UINT8)sVolInfo.aswD_Dit0[0]&MCB_DIT0_INVOLL;
+		bVolR	= (UINT8)sVolInfo.aswD_Dit0[1]&MCB_DIT0_INVOLR;
+		AddDigVolPacket(bVolL, bVolR, MCI_DIT0_INVOLL, MCB_DIT0_INLAT, MCI_DIT0_INVOLR, eMode);
+
+		/*	DIT1_INVOL	*/
+		bVolL	= (UINT8)sVolInfo.aswD_Dit1[0]&MCB_DIT1_INVOLL;
+		bVolR	= (UINT8)sVolInfo.aswD_Dit1[1]&MCB_DIT1_INVOLR;
+		AddDigVolPacket(bVolL, bVolR, MCI_DIT1_INVOLL, MCB_DIT1_INLAT, MCI_DIT1_INVOLR, eMode);
+
+		/*	DIT2_INVOL	*/
+		bVolL	= (UINT8)sVolInfo.aswD_Dit2[0]&MCB_DIT2_INVOLL;
+		bVolR	= (UINT8)sVolInfo.aswD_Dit2[1]&MCB_DIT2_INVOLR;
+		AddDigVolPacket(bVolL, bVolR, MCI_DIT2_INVOLL, MCB_DIT2_INLAT, MCI_DIT2_INVOLR, eMode);
+
+		/*	PDM0_VOL	*/
+		bVolL	= (UINT8)sVolInfo.aswD_Pdm[0]&MCB_PDM0_VOLL;
+		bVolR	= (UINT8)sVolInfo.aswD_Pdm[1]&MCB_PDM0_VOLR;
+		AddDigVolPacket(bVolL, bVolR, MCI_PDM0_VOLL, MCB_PDM0_LAT, MCI_PDM0_VOLR, eMode);
+
+		/*	DIR0_VOL	*/
+		bVolL	= (UINT8)sVolInfo.aswD_Dir0[0]&MCB_DIR0_VOLL;
+		bVolR	= (UINT8)sVolInfo.aswD_Dir0[1]&MCB_DIR0_VOLR;
+		AddDigVolPacket(bVolL, bVolR, MCI_DIR0_VOLL, MCB_DIR0_LAT, MCI_DIR0_VOLR, eMode);
+
+		/*	DIR1_VOL	*/
+		bVolL	= (UINT8)sVolInfo.aswD_Dir1[0]&MCB_DIR1_VOLL;
+		bVolR	= (UINT8)sVolInfo.aswD_Dir1[1]&MCB_DIR1_VOLR;
+		AddDigVolPacket(bVolL, bVolR, MCI_DIR1_VOLL, MCB_DIR1_LAT, MCI_DIR1_VOLR, eMode);
+
+		/*	DIR2_VOL	*/
+		bVolL	= (UINT8)sVolInfo.aswD_Dir2[0]&MCB_DIR2_VOLL;
+		bVolR	= (UINT8)sVolInfo.aswD_Dir2[1]&MCB_DIR2_VOLR;
+		AddDigVolPacket(bVolL, bVolR, MCI_DIR2_VOLL, MCB_DIR2_LAT, MCI_DIR2_VOLR, eMode);
+
+		/*	ADC_VOL	*/
+		bVolL	= (UINT8)sVolInfo.aswD_Ad0[0]&MCB_ADC_VOLL;
+		bVolR	= (UINT8)sVolInfo.aswD_Ad0[1]&MCB_ADC_VOLR;
+		AddDigVolPacket(bVolL, bVolR, MCI_ADC_VOLL, MCB_ADC_LAT, MCI_ADC_VOLR, eMode);
+
+		if(McDevProf_IsValid(eMCDRV_FUNC_ADC1) == 1)
+		{
+#if 0
+			bVolL	= (UINT8)sVolInfo.aswD_Ad1[0]&MCB_ADC1_VOLL;
+			bVolR	= (UINT8)sVolInfo.aswD_Ad1[1]&MCB_ADC1_VOLR;
+			AddDigVolPacket(bVolL, bVolR, MCI_ADC1_VOLL, MCB_ADC1_LAT, MCI_ADC1_VOLR, eMode);
+#endif
+		}
+
+		/*	AENG6_VOL	*/
+		bVolL	= (UINT8)sVolInfo.aswD_Aeng6[0]&MCB_AENG6_VOLL;
+		bVolR	= (UINT8)sVolInfo.aswD_Aeng6[1]&MCB_AENG6_VOLR;
+		AddDigVolPacket(bVolL, bVolR, MCI_AENG6_VOLL, MCB_AENG6_LAT, MCI_AENG6_VOLR, eMode);
+
+		/*	ADC_ATT	*/
+		bVolL	= (UINT8)sVolInfo.aswD_Ad0Att[0]&MCB_ADC_ATTL;
+		bVolR	= (UINT8)sVolInfo.aswD_Ad0Att[1]&MCB_ADC_ATTR;
+		AddDigVolPacket(bVolL, bVolR, MCI_ADC_ATTL, MCB_ADC_ALAT, MCI_ADC_ATTR, eMode);
+
+		/*	DIR0_ATT	*/
+		bVolL	= (UINT8)sVolInfo.aswD_Dir0Att[0]&MCB_DIR0_ATTL;
+		bVolR	= (UINT8)sVolInfo.aswD_Dir0Att[1]&MCB_DIR0_ATTR;
+		AddDigVolPacket(bVolL, bVolR, MCI_DIR0_ATTL, MCB_DIR0_ALAT, MCI_DIR0_ATTR, eMode);
+
+		/*	DIR1_ATT	*/
+		bVolL	= (UINT8)sVolInfo.aswD_Dir1Att[0]&MCB_DIR1_ATTL;
+		bVolR	= (UINT8)sVolInfo.aswD_Dir1Att[1]&MCB_DIR1_ATTR;
+		AddDigVolPacket(bVolL, bVolR, MCI_DIR1_ATTL, MCB_DIR1_ALAT, MCI_DIR1_ATTR, eMode);
+
+		/*	DIR2_ATT	*/
+		bVolL	= (UINT8)sVolInfo.aswD_Dir2Att[0]&MCB_DIR2_ATTL;
+		bVolR	= (UINT8)sVolInfo.aswD_Dir2Att[1]&MCB_DIR2_ATTR;
+		AddDigVolPacket(bVolL, bVolR, MCI_DIR2_ATTL, MCB_DIR2_ALAT, MCI_DIR2_ATTR, eMode);
+
+		/*	ST_VOL	*/
+		if(McResCtrl_GetRegVal(MCDRV_PACKET_REGTYPE_B_MIXER, MCI_AENG6_SOURCE) == MCB_AENG6_PDM)
+		{
+			bVolL	= (UINT8)sVolInfo.aswD_SideTone[0]&MCB_ST_VOLL;
+			bVolR	= (UINT8)sVolInfo.aswD_SideTone[1]&MCB_ST_VOLR;
+			AddDigVolPacket(bVolL, bVolR, MCI_ST_VOLL, MCB_ST_LAT, MCI_ST_VOLR, eMode);
+		}
+
+		/*	MASTER_OUT	*/
+		bVolL	= (UINT8)sVolInfo.aswD_DacMaster[0]&MCB_MASTER_OUTL;
+		bVolR	= (UINT8)sVolInfo.aswD_DacMaster[1]&MCB_MASTER_OUTR;
+		AddDigVolPacket(bVolL, bVolR, MCI_MASTER_OUTL, MCB_MASTER_OLAT, MCI_MASTER_OUTR, eMode);
+
+		/*	VOICE_ATT	*/
+		bVolL	= (UINT8)sVolInfo.aswD_DacVoice[0]&MCB_VOICE_ATTL;
+		bVolR	= (UINT8)sVolInfo.aswD_DacVoice[1]&MCB_VOICE_ATTR;
+		AddDigVolPacket(bVolL, bVolR, MCI_VOICE_ATTL, MCB_VOICE_LAT, MCI_VOICE_ATTR, eMode);
+
+		/*	DAC_ATT	*/
+		bVolL	= (UINT8)sVolInfo.aswD_DacAtt[0]&MCB_DAC_ATTL;
+		bVolR	= (UINT8)sVolInfo.aswD_DacAtt[1]&MCB_DAC_ATTR;
+		AddDigVolPacket(bVolL, bVolR, MCI_DAC_ATTL, MCB_DAC_LAT, MCI_DAC_ATTR, eMode);
+	}
+
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncOut("McPacket_AddVol", &sdRet);
+#endif
+
+	return sdRet;
+}
+
+/****************************************************************************
+ *	AddDigVolPacket
+ *
+ *	Description:
+ *			Add digital vol setup packet.
+ *	Arguments:
+ *				bVolL		Left volume
+ *				bVolR		Right volume
+ *				bVolLAddr	Left volume register address
+ *				bLAT		LAT
+ *				bVolRAddr	Right volume register address
+ *				eMode		update mode
+ *	Return:
+ *			none
+ *
+ ****************************************************************************/
+static void	AddDigVolPacket
+(
+	UINT8	bVolL,
+	UINT8	bVolR,
+	UINT8	bVolLAddr,
+	UINT8	bLAT,
+	UINT8	bVolRAddr,
+	MCDRV_VOLUPDATE_MODE	eMode
+)
+{
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncIn("AddDigVolPacket");
+#endif
+
+	if(bVolL != (McResCtrl_GetRegVal(MCDRV_PACKET_REGTYPE_B_MIXER, bVolLAddr) & (UINT8)~bLAT))
+	{
+		if((eMode != eMCDRV_VOLUPDATE_MUTE) || (bVolL == MCDRV_REG_MUTE))
+		{
+			if(((eMode != eMCDRV_VOLUPDATE_MUTE) || (bVolR == MCDRV_REG_MUTE))
+			&& (bVolR != McResCtrl_GetRegVal(MCDRV_PACKET_REGTYPE_B_MIXER, bVolRAddr)))
+			{
+			}
+			else
+			{
+				bLAT	= 0;
+			}
+			McDevIf_AddPacket(MCDRV_PACKET_TYPE_WRITE | MCDRV_PACKET_REGTYPE_B_MIXER | (UINT32)bVolLAddr, bLAT|bVolL);
+		}
+	}
+	if((eMode != eMCDRV_VOLUPDATE_MUTE) || (bVolR == MCDRV_REG_MUTE))
+	{
+		McDevIf_AddPacket(MCDRV_PACKET_TYPE_WRITE | MCDRV_PACKET_REGTYPE_B_MIXER | (UINT32)bVolRAddr, bVolR);
+	}
+
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncOut("AddDigVolPacket", 0);
+#endif
+}
+
+/****************************************************************************
+ *	AddStopADC
+ *
+ *	Description:
+ *			Add stop ADC packet.
+ *	Arguments:
+ *			none
+ *	Return:
+ *			none
+ *
+ ****************************************************************************/
+static void	AddStopADC
+(
+	void
+)
+{
+	UINT8	bReg;
+
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncIn("AddStopADC");
+#endif
+
+	bReg	= McResCtrl_GetRegVal(MCDRV_PACKET_REGTYPE_B_CODEC, MCI_AD_START);
+
+	if((bReg & MCB_AD_START) != 0)
+	{
+		McDevIf_AddPacket(MCDRV_PACKET_TYPE_WRITE | MCDRV_PACKET_REGTYPE_B_CODEC | (UINT32)MCI_AD_START, bReg&(UINT8)~MCB_AD_START);
+	}
+
+	McDevIf_AddPacket(MCDRV_PACKET_TYPE_EVTWAIT | MCDRV_EVT_ADCMUTE, 0);
+
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncOut("AddStopADC", 0);
+#endif
+}
+
+/****************************************************************************
+ *	AddStopPDM
+ *
+ *	Description:
+ *			Add stop PDM packet.
+ *	Arguments:
+ *			none
+ *	Return:
+ *			none
+ *
+ ****************************************************************************/
+static void	AddStopPDM
+(
+	void
+)
+{
+	UINT8	bReg;
+
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncIn("AddStopPDM");
+#endif
+
+	bReg	= McResCtrl_GetRegVal(MCDRV_PACKET_REGTYPE_B_MIXER, MCI_PDM_START);
+
+	if((bReg & MCB_PDM_START) != 0)
+	{
+		McDevIf_AddPacket(MCDRV_PACKET_TYPE_WRITE | MCDRV_PACKET_REGTYPE_B_MIXER | (UINT32)MCI_PDM_START, bReg&(UINT8)~MCB_PDM_START);
+	}
+
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncOut("AddStopPDM", 0);
+#endif
+}
+
+/****************************************************************************
+ *	McPacket_AddDigitalIO
+ *
+ *	Description:
+ *			Add DigitalI0 setup packet.
+ *	Arguments:
+ *			dUpdateInfo	update information
+ *	Return:
+ *			MCDRV_SUCCESS
+ *			MCDRV_ERROR_RESOURCEOVER
+ *			MCDRV_ERROR_TIMEOUT
+ *
+ ****************************************************************************/
+SINT32	McPacket_AddDigitalIO
+(
+	UINT32	dUpdateInfo
+)
+{
+	SINT32	sdRet	= MCDRV_SUCCESS;
+	UINT8	bReg;
+	MCDRV_POWER_INFO	sPowerInfo;
+	MCDRV_POWER_UPDATE	sPowerUpdate;
+	MCDRV_DIO_INFO		sDioInfo;
+
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncIn("McPacket_AddDigitalIO");
+#endif
+
+	if(IsModifiedDIO(dUpdateInfo) != 0)
+	{
+		McResCtrl_GetCurPowerInfo(&sPowerInfo);
+		sdRet	= PowerUpDig(MCDRV_DPB_UP);
+		if(sdRet == MCDRV_SUCCESS)
+		{
+			if((dUpdateInfo & MCDRV_DIO0_COM_UPDATE_FLAG) != (UINT32)0)
+			{
+				AddDIOCommon(eMCDRV_DIO_0);
+			}
+			if((dUpdateInfo & MCDRV_DIO1_COM_UPDATE_FLAG) != (UINT32)0)
+			{
+				AddDIOCommon(eMCDRV_DIO_1);
+			}
+			if((dUpdateInfo & MCDRV_DIO2_COM_UPDATE_FLAG) != (UINT32)0)
+			{
+				AddDIOCommon(eMCDRV_DIO_2);
+			}
+
+			/*	DI*_BCKP	*/
+			if(((dUpdateInfo & MCDRV_DIO0_COM_UPDATE_FLAG) != (UINT32)0)
+			|| ((dUpdateInfo & MCDRV_DIO1_COM_UPDATE_FLAG) != (UINT32)0)
+			|| ((dUpdateInfo & MCDRV_DIO2_COM_UPDATE_FLAG) != (UINT32)0))
+			{
+				McResCtrl_GetDioInfo(&sDioInfo);
+				bReg	= 0;
+				if(sDioInfo.asPortInfo[0].sDioCommon.bBckInvert == MCDRV_BCLK_INVERT)
+				{
+					bReg |= MCB_DI0_BCKP;
+				}
+				if(sDioInfo.asPortInfo[1].sDioCommon.bBckInvert == MCDRV_BCLK_INVERT)
+				{
+					bReg |= MCB_DI1_BCKP;
+				}
+				if(sDioInfo.asPortInfo[2].sDioCommon.bBckInvert == MCDRV_BCLK_INVERT)
+				{
+					bReg |= MCB_DI2_BCKP;
+				}
+				if(bReg != McResCtrl_GetRegVal(MCDRV_PACKET_REGTYPE_B_BASE, MCI_BCKP))
+				{
+					McDevIf_AddPacket(MCDRV_PACKET_TYPE_WRITE | MCDRV_PACKET_REGTYPE_B_BASE | (UINT32)MCI_BCKP, bReg);
+				}
+			}
+
+			if((dUpdateInfo & MCDRV_DIO0_DIR_UPDATE_FLAG) != (UINT32)0)
+			{
+				AddDIODIR(eMCDRV_DIO_0);
+			}
+			if((dUpdateInfo & MCDRV_DIO1_DIR_UPDATE_FLAG) != (UINT32)0)
+			{
+				AddDIODIR(eMCDRV_DIO_1);
+			}
+			if((dUpdateInfo & MCDRV_DIO2_DIR_UPDATE_FLAG) != (UINT32)0)
+			{
+				AddDIODIR(eMCDRV_DIO_2);
+			}
+
+			if((dUpdateInfo & MCDRV_DIO0_DIT_UPDATE_FLAG) != (UINT32)0)
+			{
+				AddDIODIT(eMCDRV_DIO_0);
+			}
+			if((dUpdateInfo & MCDRV_DIO1_DIT_UPDATE_FLAG) != (UINT32)0)
+			{
+				AddDIODIT(eMCDRV_DIO_1);
+			}
+			if((dUpdateInfo & MCDRV_DIO2_DIT_UPDATE_FLAG) != (UINT32)0)
+			{
+				AddDIODIT(eMCDRV_DIO_2);
+			}
+
+			/*	unused path power down	*/
+			sPowerUpdate.dDigital		= MCDRV_POWUPDATE_DIGITAL_ALL;
+			sPowerUpdate.abAnalog[0]	= 
+			sPowerUpdate.abAnalog[1]	= 
+			sPowerUpdate.abAnalog[2]	= 
+			sPowerUpdate.abAnalog[3]	= 
+			sPowerUpdate.abAnalog[4]	= 0;
+			sdRet	= McPacket_AddPowerDown(&sPowerInfo, &sPowerUpdate);
+		}
+	}
+
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncOut("McPacket_AddDigitalIO", &sdRet);
+#endif
+
+	return sdRet;
+}
+
+/****************************************************************************
+ *	IsModifiedDIO
+ *
+ *	Description:
+ *			Is modified DigitalIO.
+ *	Arguments:
+ *			dUpdateInfo	update information
+ *	Return:
+ *			0:not modified/1:modified
+ *
+ ****************************************************************************/
+static UINT8	IsModifiedDIO
+(
+	UINT32		dUpdateInfo
+)
+{
+	UINT8	bModified	= 0;
+
+#if (MCDRV_DEBUG_LEVEL>=4)
+	SINT32	sdRet;
+	McDebugLog_FuncIn("IsModifiedDIO");
+#endif
+
+	if((((dUpdateInfo & MCDRV_DIO0_COM_UPDATE_FLAG) != (UINT32)0) && (IsModifiedDIOCommon(eMCDRV_DIO_0) != 0))
+	|| (((dUpdateInfo & MCDRV_DIO1_COM_UPDATE_FLAG) != (UINT32)0) && (IsModifiedDIOCommon(eMCDRV_DIO_1) != 0))
+	|| (((dUpdateInfo & MCDRV_DIO2_COM_UPDATE_FLAG) != (UINT32)0) && (IsModifiedDIOCommon(eMCDRV_DIO_2) != 0)))
+	{
+		bModified	= 1;
+	}
+	else if((((dUpdateInfo & MCDRV_DIO0_DIR_UPDATE_FLAG) != (UINT32)0) && (IsModifiedDIODIR(eMCDRV_DIO_0) != 0))
+	|| (((dUpdateInfo & MCDRV_DIO1_DIR_UPDATE_FLAG) != (UINT32)0) && (IsModifiedDIODIR(eMCDRV_DIO_1) != 0))
+	|| (((dUpdateInfo & MCDRV_DIO2_DIR_UPDATE_FLAG) != (UINT32)0) && (IsModifiedDIODIR(eMCDRV_DIO_2) != 0)))
+	{
+		bModified	= 1;
+	}
+	else if((((dUpdateInfo & MCDRV_DIO0_DIT_UPDATE_FLAG) != (UINT32)0) && (IsModifiedDIODIT(eMCDRV_DIO_0) != 0))
+	|| (((dUpdateInfo & MCDRV_DIO1_DIT_UPDATE_FLAG) != (UINT32)0) && (IsModifiedDIODIT(eMCDRV_DIO_1) != 0))
+	|| (((dUpdateInfo & MCDRV_DIO2_DIT_UPDATE_FLAG) != (UINT32)0) && (IsModifiedDIODIT(eMCDRV_DIO_2) != 0)))
+	{
+		bModified	= 1;
+	}
+	else
+	{
+	}
+
+#if (MCDRV_DEBUG_LEVEL>=4)
+	sdRet	= (SINT32)bModified;
+	McDebugLog_FuncOut("IsModifiedDIO", &sdRet);
+#endif
+	return bModified;
+}
+
+/****************************************************************************
+ *	IsModifiedDIOCommon
+ *
+ *	Description:
+ *			Is modified DigitalIO Common.
+ *	Arguments:
+ *			ePort		port number
+ *	Return:
+ *			0:not modified/1:modified
+ *
+ ****************************************************************************/
+static UINT8	IsModifiedDIOCommon
+(
+	MCDRV_DIO_PORT_NO	ePort
+)
+{
+	UINT8	bReg;
+	UINT8	bRegOffset;
+	UINT8	bModified	= 0;
+	MCDRV_DIO_INFO	sDioInfo;
+
+#if (MCDRV_DEBUG_LEVEL>=4)
+	SINT32	sdRet;
+	McDebugLog_FuncIn("IsModifiedDIOCommon");
+#endif
+
+	if(ePort == eMCDRV_DIO_0)
+	{
+		bRegOffset	= 0;
+	}
+	else if(ePort == eMCDRV_DIO_1)
+	{
+		bRegOffset	= MCI_DIMODE1 - MCI_DIMODE0;
+	}
+	else if(ePort == eMCDRV_DIO_2)
+	{
+		bRegOffset	= MCI_DIMODE2 - MCI_DIMODE0;
+	}
+	else
+	{
+		#if (MCDRV_DEBUG_LEVEL>=4)
+			sdRet	= MCDRV_ERROR;
+			McDebugLog_FuncOut("IsModifiedDIOCommon", &sdRet);
+		#endif
+		return 0;
+	}
+
+	McResCtrl_GetDioInfo(&sDioInfo);
+
+	if(sDioInfo.asPortInfo[ePort].sDioCommon.bInterface != McResCtrl_GetRegVal(MCDRV_PACKET_REGTYPE_B_MIXER, MCI_DIMODE0+bRegOffset))
+	{
+		bModified	= 1;
+	}
+
+	bReg	= (sDioInfo.asPortInfo[ePort].sDioCommon.bAutoFs << 7)
+			| (sDioInfo.asPortInfo[ePort].sDioCommon.bBckFs << 4)
+			| sDioInfo.asPortInfo[ePort].sDioCommon.bFs;
+	if(bReg != McResCtrl_GetRegVal(MCDRV_PACKET_REGTYPE_B_MIXER, MCI_DI_FS0+bRegOffset))
+	{
+		bModified	= 1;
+	}
+
+	bReg	= McResCtrl_GetRegVal(MCDRV_PACKET_REGTYPE_B_MIXER, MCI_DI0_SRC+bRegOffset);
+	if((sDioInfo.asPortInfo[ePort].sDioCommon.bAutoFs == 0)
+	&& (sDioInfo.asPortInfo[ePort].sDioCommon.bMasterSlave == MCDRV_DIO_SLAVE))
+	{
+		bReg |= MCB_DICOMMON_SRC_RATE_SET;
+	}
+	if(bReg != McResCtrl_GetRegVal(MCDRV_PACKET_REGTYPE_B_MIXER, MCI_DI0_SRC+bRegOffset))
+	{
+		bModified	= 1;
+	}
+	if(sDioInfo.asPortInfo[ePort].sDioCommon.bInterface == MCDRV_DIO_PCM)
+	{
+		bReg	= (sDioInfo.asPortInfo[ePort].sDioCommon.bPcmHizTim << 7)
+				| (sDioInfo.asPortInfo[ePort].sDioCommon.bPcmClkDown << 6)
+				| (sDioInfo.asPortInfo[ePort].sDioCommon.bPcmFrame << 5)
+				| (sDioInfo.asPortInfo[ePort].sDioCommon.bPcmHighPeriod);
+		if(bReg != McResCtrl_GetRegVal(MCDRV_PACKET_REGTYPE_B_MIXER, MCI_HIZ_REDGE0+bRegOffset))
+		{
+			bModified	= 1;
+		}
+	}
+
+#if (MCDRV_DEBUG_LEVEL>=4)
+	sdRet	= (SINT32)bModified;
+	McDebugLog_FuncOut("IsModifiedDIOCommon", &sdRet);
+#endif
+	return bModified;
+}
+
+/****************************************************************************
+ *	IsModifiedDIODIR
+ *
+ *	Description:
+ *			Is modified DigitalIO DIR.
+ *	Arguments:
+ *			ePort		port number
+ *	Return:
+ *			0:not modified/1:modified
+ *
+ ****************************************************************************/
+static UINT8	IsModifiedDIODIR
+(
+	MCDRV_DIO_PORT_NO	ePort
+)
+{
+	UINT8	bReg;
+	UINT8	bRegOffset;
+	UINT8	bModified	= 0;
+	MCDRV_DIO_INFO	sDioInfo;
+
+#if (MCDRV_DEBUG_LEVEL>=4)
+	SINT32	sdRet;
+	McDebugLog_FuncIn("IsModifiedDIODIR");
+#endif
+
+	if(ePort == eMCDRV_DIO_0)
+	{
+		bRegOffset	= 0;
+	}
+	else if(ePort == eMCDRV_DIO_1)
+	{
+		bRegOffset	= MCI_DIMODE1 - MCI_DIMODE0;
+	}
+	else if(ePort == eMCDRV_DIO_2)
+	{
+		bRegOffset	= MCI_DIMODE2 - MCI_DIMODE0;
+	}
+	else
+	{
+		#if (MCDRV_DEBUG_LEVEL>=4)
+			sdRet	= MCDRV_ERROR;
+			McDebugLog_FuncOut("IsModifiedDIODIR", &sdRet);
+		#endif
+		return 0;
+	}
+
+	McResCtrl_GetDioInfo(&sDioInfo);
+
+	bReg	= (UINT8)(sDioInfo.asPortInfo[ePort].sDir.wSrcRate>>8);
+	if(bReg != McResCtrl_GetRegVal(MCDRV_PACKET_REGTYPE_B_MIXER, MCI_DIRSRC_RATE0_MSB+bRegOffset))
+	{
+		bModified	= 1;
+	}
+
+	bReg	= (UINT8)sDioInfo.asPortInfo[ePort].sDir.wSrcRate;
+	if(bReg != McResCtrl_GetRegVal(MCDRV_PACKET_REGTYPE_B_MIXER, MCI_DIRSRC_RATE0_LSB+bRegOffset))
+	{
+		bModified	= 1;
+	}
+
+	if(sDioInfo.asPortInfo[ePort].sDioCommon.bInterface == MCDRV_DIO_DA)
+	{
+		bReg	= (sDioInfo.asPortInfo[ePort].sDit.sDaFormat.bMode << 6)
+				| (sDioInfo.asPortInfo[ePort].sDit.sDaFormat.bBitSel << 4)
+				| (sDioInfo.asPortInfo[ePort].sDir.sDaFormat.bMode << 2)
+				| (sDioInfo.asPortInfo[ePort].sDir.sDaFormat.bBitSel);
+		if(bReg != McResCtrl_GetRegVal(MCDRV_PACKET_REGTYPE_B_MIXER, MCI_DIX0_FMT+bRegOffset))
+		{
+			bModified	= 1;
+		}
+		/*	DIR*_CH	*/
+		bReg	= (sDioInfo.asPortInfo[ePort].sDir.abSlot[1] << 4) | (sDioInfo.asPortInfo[ePort].sDir.abSlot[0]);
+		if(bReg != McResCtrl_GetRegVal(MCDRV_PACKET_REGTYPE_B_MIXER, MCI_DIR0_CH+bRegOffset))
+		{
+			bModified	= 1;
+		}
+	}
+	else
+	{
+		/*	PCM_MONO_RX*, PCM_EXTEND_RX*, PCM_LSBON_RX*, PCM_LAW_RX*, PCM_BIT_RX*	*/
+		bReg	= (sDioInfo.asPortInfo[ePort].sDir.sPcmFormat.bMono << 7)
+				| (sDioInfo.asPortInfo[ePort].sDir.sPcmFormat.bOrder << 4)
+				| (sDioInfo.asPortInfo[ePort].sDir.sPcmFormat.bLaw << 2)
+				| (sDioInfo.asPortInfo[ePort].sDir.sPcmFormat.bBitSel);
+		if(bReg != McResCtrl_GetRegVal(MCDRV_PACKET_REGTYPE_B_MIXER, MCI_PCM_RX0+bRegOffset))
+		{
+			bModified	= 1;
+		}
+		/*	PCM_CH1_RX*, PCM_CH0_RX*	*/
+		bReg	= (sDioInfo.asPortInfo[ePort].sDir.abSlot[1] << 4) | (sDioInfo.asPortInfo[ePort].sDir.abSlot[0]);
+		if(bReg != McResCtrl_GetRegVal(MCDRV_PACKET_REGTYPE_B_MIXER, MCI_PCM_SLOT_RX0+bRegOffset))
+		{
+			bModified	= 1;
+		}
+	}
+
+#if (MCDRV_DEBUG_LEVEL>=4)
+	sdRet	= (SINT32)bModified;
+	McDebugLog_FuncOut("IsModifiedDIODIR", &sdRet);
+#endif
+	return bModified;
+}
+
+/****************************************************************************
+ *	IsModifiedDIODIT
+ *
+ *	Description:
+ *			Is modified DigitalIO DIT.
+ *	Arguments:
+ *			ePort		port number
+ *	Return:
+ *			0:not modified/1:modified
+ *
+ ****************************************************************************/
+static UINT8	IsModifiedDIODIT
+(
+	MCDRV_DIO_PORT_NO	ePort
+)
+{
+	UINT8	bReg;
+	UINT8	bRegOffset;
+	UINT8	bModified	= 0;
+	MCDRV_DIO_INFO	sDioInfo;
+
+#if (MCDRV_DEBUG_LEVEL>=4)
+	SINT32	sdRet;
+	McDebugLog_FuncIn("IsModifiedDIODIT");
+#endif
+
+	if(ePort == eMCDRV_DIO_0)
+	{
+		bRegOffset	= 0;
+	}
+	else if(ePort == eMCDRV_DIO_1)
+	{
+		bRegOffset	= MCI_DIMODE1 - MCI_DIMODE0;
+	}
+	else if(ePort == eMCDRV_DIO_2)
+	{
+		bRegOffset	= MCI_DIMODE2 - MCI_DIMODE0;
+	}
+	else
+	{
+		#if (MCDRV_DEBUG_LEVEL>=4)
+			sdRet	= MCDRV_ERROR;
+			McDebugLog_FuncOut("IsModifiedDIODIT", &sdRet);
+		#endif
+		return 0;
+	}
+
+	McResCtrl_GetDioInfo(&sDioInfo);
+
+	bReg	= (UINT8)(sDioInfo.asPortInfo[ePort].sDit.wSrcRate>>8);
+	if(bReg != McResCtrl_GetRegVal(MCDRV_PACKET_REGTYPE_B_MIXER, MCI_DITSRC_RATE0_MSB+bRegOffset))
+	{
+		bModified	= 1;
+	}
+	bReg	= (UINT8)sDioInfo.asPortInfo[ePort].sDit.wSrcRate;
+	if(bReg != McResCtrl_GetRegVal(MCDRV_PACKET_REGTYPE_B_MIXER, MCI_DITSRC_RATE0_LSB+bRegOffset))
+	{
+		bModified	= 1;
+	}
+
+	if(sDioInfo.asPortInfo[ePort].sDioCommon.bInterface == MCDRV_DIO_DA)
+	{
+		/*	DIT*_FMT, DIT*_BIT, DIR*_FMT, DIR*_BIT	*/
+		bReg	= (sDioInfo.asPortInfo[ePort].sDit.sDaFormat.bMode << 6)
+				| (sDioInfo.asPortInfo[ePort].sDit.sDaFormat.bBitSel << 4)
+				| (sDioInfo.asPortInfo[ePort].sDir.sDaFormat.bMode << 2)
+				| (sDioInfo.asPortInfo[ePort].sDir.sDaFormat.bBitSel);
+		if(bReg != McResCtrl_GetRegVal(MCDRV_PACKET_REGTYPE_B_MIXER, MCI_DIX0_FMT+bRegOffset))
+		{
+			bModified	= 1;
+		}
+
+		/*	DIT*_SLOT	*/
+		bReg	= (sDioInfo.asPortInfo[ePort].sDit.abSlot[1] << 4) | (sDioInfo.asPortInfo[ePort].sDit.abSlot[0]);
+		if(bReg != McResCtrl_GetRegVal(MCDRV_PACKET_REGTYPE_B_MIXER, MCI_DIT0_SLOT+bRegOffset))
+		{
+			bModified	= 1;
+		}
+	}
+	else
+	{
+		/*	PCM_MONO_TX*, PCM_EXTEND_TX*, PCM_LSBON_TX*, PCM_LAW_TX*, PCM_BIT_TX*	*/
+		bReg	= (sDioInfo.asPortInfo[ePort].sDit.sPcmFormat.bMono << 7)
+				| (sDioInfo.asPortInfo[ePort].sDit.sPcmFormat.bOrder << 4)
+				| (sDioInfo.asPortInfo[ePort].sDit.sPcmFormat.bLaw << 2)
+				| (sDioInfo.asPortInfo[ePort].sDit.sPcmFormat.bBitSel);
+		if(bReg != McResCtrl_GetRegVal(MCDRV_PACKET_REGTYPE_B_MIXER, MCI_PCM_TX0+bRegOffset))
+		{
+			bModified	= 1;
+		}
+
+		/*	PCM_CH1_TX*, PCM_CH0_TX*	*/
+		bReg	= (sDioInfo.asPortInfo[ePort].sDit.abSlot[1] << 4) | (sDioInfo.asPortInfo[ePort].sDit.abSlot[0]);
+		if(bReg != McResCtrl_GetRegVal(MCDRV_PACKET_REGTYPE_B_MIXER, MCI_PCM_SLOT_TX0+bRegOffset))
+		{
+			bModified	= 1;
+		}
+	}
+
+#if (MCDRV_DEBUG_LEVEL>=4)
+	sdRet	= (SINT32)bModified;
+	McDebugLog_FuncOut("IsModifiedDIODIT", &sdRet);
+#endif
+	return bModified;
+}
+
+/****************************************************************************
+ *	AddDIOCommon
+ *
+ *	Description:
+ *			Add DigitalI0 Common setup packet.
+ *	Arguments:
+ *			ePort		port number
+ *	Return:
+ *			none
+ *
+ ****************************************************************************/
+static void	AddDIOCommon
+(
+	MCDRV_DIO_PORT_NO	ePort
+)
+{
+	UINT8	bReg;
+	UINT8	bRegOffset;
+	MCDRV_DIO_INFO	sDioInfo;
+
+#if (MCDRV_DEBUG_LEVEL>=4)
+	SINT32	sdRet;
+	McDebugLog_FuncIn("AddDIOCommon");
+#endif
+
+	if(ePort == eMCDRV_DIO_0)
+	{
+		bRegOffset	= 0;
+	}
+	else if(ePort == eMCDRV_DIO_1)
+	{
+		bRegOffset	= MCI_DIMODE1 - MCI_DIMODE0;
+	}
+	else if(ePort == eMCDRV_DIO_2)
+	{
+		bRegOffset	= MCI_DIMODE2 - MCI_DIMODE0;
+	}
+	else
+	{
+
+		#if (MCDRV_DEBUG_LEVEL>=4)
+			sdRet	= MCDRV_ERROR;
+			McDebugLog_FuncOut("AddDIOCommon", &sdRet);
+		#endif
+		return;
+	}
+
+	McResCtrl_GetDioInfo(&sDioInfo);
+
+	/*	DIMODE*	*/
+	if(sDioInfo.asPortInfo[ePort].sDioCommon.bInterface != McResCtrl_GetRegVal(MCDRV_PACKET_REGTYPE_B_MIXER, MCI_DIMODE0+bRegOffset))
+	{
+		McDevIf_AddPacket(MCDRV_PACKET_TYPE_WRITE | MCDRV_PACKET_REGTYPE_B_MIXER | (UINT32)(MCI_DIMODE0+bRegOffset),
+							sDioInfo.asPortInfo[ePort].sDioCommon.bInterface);
+	}
+
+	/*	DIAUTO_FS*, DIBCK*, DIFS*	*/
+	bReg	= (sDioInfo.asPortInfo[ePort].sDioCommon.bAutoFs << 7)
+			| (sDioInfo.asPortInfo[ePort].sDioCommon.bBckFs << 4)
+			| sDioInfo.asPortInfo[ePort].sDioCommon.bFs;
+	if(bReg != McResCtrl_GetRegVal(MCDRV_PACKET_REGTYPE_B_MIXER, MCI_DI_FS0+bRegOffset))
+	{
+		McDevIf_AddPacket(MCDRV_PACKET_TYPE_WRITE | MCDRV_PACKET_REGTYPE_B_MIXER | (UINT32)(MCI_DI_FS0+bRegOffset), bReg);
+	}
+
+	/*	DI*_SRCRATE_SET	*/
+	bReg	= McResCtrl_GetRegVal(MCDRV_PACKET_REGTYPE_B_MIXER, MCI_DI0_SRC+bRegOffset);
+	if((sDioInfo.asPortInfo[ePort].sDioCommon.bAutoFs == 0)
+	&& (sDioInfo.asPortInfo[ePort].sDioCommon.bMasterSlave == MCDRV_DIO_SLAVE))
+	{
+		bReg |= MCB_DICOMMON_SRC_RATE_SET;
+	}
+	else
+	{
+		bReg &= (UINT8)~MCB_DICOMMON_SRC_RATE_SET;
+	}
+	if(bReg != McResCtrl_GetRegVal(MCDRV_PACKET_REGTYPE_B_MIXER, MCI_DI0_SRC+bRegOffset))
+	{
+		McDevIf_AddPacket(MCDRV_PACKET_TYPE_WRITE | MCDRV_PACKET_REGTYPE_B_MIXER | (UINT32)(MCI_DI0_SRC+bRegOffset), bReg);
+	}
+
+	/*	HIZ_REDGE*, PCM_CLKDOWN*, PCM_FRAME*, PCM_HPERIOD*	*/
+	if(sDioInfo.asPortInfo[ePort].sDioCommon.bInterface == MCDRV_DIO_PCM)
+	{
+		bReg	= (sDioInfo.asPortInfo[ePort].sDioCommon.bPcmHizTim << 7)
+				| (sDioInfo.asPortInfo[ePort].sDioCommon.bPcmClkDown << 6)
+				| (sDioInfo.asPortInfo[ePort].sDioCommon.bPcmFrame << 5)
+				| (sDioInfo.asPortInfo[ePort].sDioCommon.bPcmHighPeriod);
+		if(bReg != McResCtrl_GetRegVal(MCDRV_PACKET_REGTYPE_B_MIXER, MCI_HIZ_REDGE0+bRegOffset))
+		{
+			McDevIf_AddPacket(MCDRV_PACKET_TYPE_WRITE | MCDRV_PACKET_REGTYPE_B_MIXER | (UINT32)(MCI_HIZ_REDGE0+bRegOffset), bReg);
+		}
+	}
+
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncOut("AddDIOCommon", 0);
+#endif
+}
+
+/****************************************************************************
+ *	AddDIODIR
+ *
+ *	Description:
+ *			Add DigitalI0 DIR setup packet.
+ *	Arguments:
+ *			ePort		port number
+ *	Return:
+ *			none
+ *
+ ****************************************************************************/
+static void	AddDIODIR
+(
+	MCDRV_DIO_PORT_NO	ePort
+)
+{
+	UINT8	bReg;
+	UINT8	bRegOffset;
+	UINT16	wSrcRate;
+	MCDRV_DIO_INFO	sDioInfo;
+
+#if (MCDRV_DEBUG_LEVEL>=4)
+	SINT32	sdRet;
+	McDebugLog_FuncIn("AddDIODIR");
+#endif
+
+	if(ePort == eMCDRV_DIO_0)
+	{
+		bRegOffset	= 0;
+	}
+	else if(ePort == eMCDRV_DIO_1)
+	{
+		bRegOffset	= MCI_DIMODE1 - MCI_DIMODE0;
+	}
+	else if(ePort == eMCDRV_DIO_2)
+	{
+		bRegOffset	= MCI_DIMODE2 - MCI_DIMODE0;
+	}
+	else
+	{
+		#if (MCDRV_DEBUG_LEVEL>=4)
+			sdRet	= MCDRV_ERROR;
+			McDebugLog_FuncOut("AddDIODIR", &sdRet);
+		#endif
+		return;
+	}
+
+	McResCtrl_GetDioInfo(&sDioInfo);
+
+	/*	DIRSRC_RATE*	*/
+	wSrcRate	= sDioInfo.asPortInfo[ePort].sDir.wSrcRate;
+	if(wSrcRate == 0)
+	{
+		switch(sDioInfo.asPortInfo[ePort].sDioCommon.bFs)
+		{
+		case MCDRV_FS_48000:
+			wSrcRate	= MCDRV_DIR_SRCRATE_48000;
+			break;
+		case MCDRV_FS_44100:
+			wSrcRate	= MCDRV_DIR_SRCRATE_44100;
+			break;
+		case MCDRV_FS_32000:
+			wSrcRate	= MCDRV_DIR_SRCRATE_32000;
+			break;
+		case MCDRV_FS_24000:
+			wSrcRate	= MCDRV_DIR_SRCRATE_24000;
+			break;
+		case MCDRV_FS_22050:
+			wSrcRate	= MCDRV_DIR_SRCRATE_22050;
+			break;
+		case MCDRV_FS_16000:
+			wSrcRate	= MCDRV_DIR_SRCRATE_16000;
+			break;
+		case MCDRV_FS_12000:
+			wSrcRate	= MCDRV_DIR_SRCRATE_12000;
+			break;
+		case MCDRV_FS_11025:
+			wSrcRate	= MCDRV_DIR_SRCRATE_11025;
+			break;
+		case MCDRV_FS_8000:
+			wSrcRate	= MCDRV_DIR_SRCRATE_8000;
+			break;
+		default:
+			/* unreachable */
+			wSrcRate = 0;
+			break;
+		}
+	}
+	bReg	= (UINT8)(wSrcRate>>8);
+	if(bReg != McResCtrl_GetRegVal(MCDRV_PACKET_REGTYPE_B_MIXER, MCI_DIRSRC_RATE0_MSB+bRegOffset))
+	{
+		McDevIf_AddPacket(MCDRV_PACKET_TYPE_WRITE | MCDRV_PACKET_REGTYPE_B_MIXER | (UINT32)(MCI_DIRSRC_RATE0_MSB+bRegOffset), bReg);
+	}
+	bReg	= (UINT8)wSrcRate;
+	if(bReg != McResCtrl_GetRegVal(MCDRV_PACKET_REGTYPE_B_MIXER, MCI_DIRSRC_RATE0_LSB+bRegOffset))
+	{
+		McDevIf_AddPacket(MCDRV_PACKET_TYPE_WRITE | MCDRV_PACKET_REGTYPE_B_MIXER | (UINT32)(MCI_DIRSRC_RATE0_LSB+bRegOffset), bReg);
+	}
+
+	/*	DIT*_FMT, DIT*_BIT, DIR*_FMT, DIR*_BIT	*/
+	if(sDioInfo.asPortInfo[ePort].sDioCommon.bInterface == MCDRV_DIO_DA)
+	{
+		bReg	= (sDioInfo.asPortInfo[ePort].sDit.sDaFormat.bMode << 6)
+				| (sDioInfo.asPortInfo[ePort].sDit.sDaFormat.bBitSel << 4)
+				| (sDioInfo.asPortInfo[ePort].sDir.sDaFormat.bMode << 2)
+				| (sDioInfo.asPortInfo[ePort].sDir.sDaFormat.bBitSel);
+		if(bReg != McResCtrl_GetRegVal(MCDRV_PACKET_REGTYPE_B_MIXER, MCI_DIX0_FMT+bRegOffset))
+		{
+			McDevIf_AddPacket(MCDRV_PACKET_TYPE_WRITE | MCDRV_PACKET_REGTYPE_B_MIXER | (UINT32)(MCI_DIX0_FMT+bRegOffset), bReg);
+		}
+		/*	DIR*_CH	*/
+		bReg	= (sDioInfo.asPortInfo[ePort].sDir.abSlot[1] << 4) | (sDioInfo.asPortInfo[ePort].sDir.abSlot[0]);
+		if(bReg != McResCtrl_GetRegVal(MCDRV_PACKET_REGTYPE_B_MIXER, MCI_DIR0_CH+bRegOffset))
+		{
+			McDevIf_AddPacket(MCDRV_PACKET_TYPE_WRITE | MCDRV_PACKET_REGTYPE_B_MIXER | (UINT32)(MCI_DIR0_CH+bRegOffset), bReg);
+		}
+	}
+	else
+	{
+		/*	PCM_MONO_RX*, PCM_EXTEND_RX*, PCM_LSBON_RX*, PCM_LAW_RX*, PCM_BIT_RX*	*/
+		bReg	= (sDioInfo.asPortInfo[ePort].sDir.sPcmFormat.bMono << 7)
+				| (sDioInfo.asPortInfo[ePort].sDir.sPcmFormat.bOrder << 4)
+				| (sDioInfo.asPortInfo[ePort].sDir.sPcmFormat.bLaw << 2)
+				| (sDioInfo.asPortInfo[ePort].sDir.sPcmFormat.bBitSel);
+		if(bReg != McResCtrl_GetRegVal(MCDRV_PACKET_REGTYPE_B_MIXER, MCI_PCM_RX0+bRegOffset))
+		{
+			McDevIf_AddPacket(MCDRV_PACKET_TYPE_WRITE | MCDRV_PACKET_REGTYPE_B_MIXER | (UINT32)(MCI_PCM_RX0+bRegOffset), bReg);
+		}
+		/*	PCM_CH1_RX*, PCM_CH0_RX*	*/
+		bReg	= (sDioInfo.asPortInfo[ePort].sDir.abSlot[1] << 4) | (sDioInfo.asPortInfo[ePort].sDir.abSlot[0]);
+		if(bReg != McResCtrl_GetRegVal(MCDRV_PACKET_REGTYPE_B_MIXER, MCI_PCM_SLOT_RX0+bRegOffset))
+		{
+			McDevIf_AddPacket(MCDRV_PACKET_TYPE_WRITE | MCDRV_PACKET_REGTYPE_B_MIXER | (UINT32)(MCI_PCM_SLOT_RX0+bRegOffset), bReg);
+		}
+	}
+
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncOut("AddDIODIR", 0);
+#endif
+}
+
+/****************************************************************************
+ *	AddDIODIT
+ *
+ *	Description:
+ *			Add DigitalI0 DIT setup packet.
+ *	Arguments:
+ *			ePort		port number
+ *	Return:
+ *			none
+ *
+ ****************************************************************************/
+static void	AddDIODIT
+(
+	MCDRV_DIO_PORT_NO	ePort
+)
+{
+	UINT8	bReg;
+	UINT8	bRegOffset;
+	UINT16	wSrcRate;
+	MCDRV_DIO_INFO	sDioInfo;
+
+#if (MCDRV_DEBUG_LEVEL>=4)
+	SINT32	sdRet;
+	McDebugLog_FuncIn("AddDIODIT");
+#endif
+
+	if(ePort == eMCDRV_DIO_0)
+	{
+		bRegOffset	= 0;
+	}
+	else if(ePort == eMCDRV_DIO_1)
+	{
+		bRegOffset	= MCI_DIMODE1 - MCI_DIMODE0;
+	}
+	else if(ePort == eMCDRV_DIO_2)
+	{
+		bRegOffset	= MCI_DIMODE2 - MCI_DIMODE0;
+	}
+	else
+	{
+		#if (MCDRV_DEBUG_LEVEL>=4)
+			sdRet	= MCDRV_ERROR;
+			McDebugLog_FuncOut("AddDIODIT", &sdRet);
+		#endif
+		return;
+	}
+
+	McResCtrl_GetDioInfo(&sDioInfo);
+
+	wSrcRate	= sDioInfo.asPortInfo[ePort].sDit.wSrcRate;
+	if(wSrcRate == 0)
+	{
+		switch(sDioInfo.asPortInfo[ePort].sDioCommon.bFs)
+		{
+		case MCDRV_FS_48000:
+			wSrcRate	= MCDRV_DIT_SRCRATE_48000;
+			break;
+		case MCDRV_FS_44100:
+			wSrcRate	= MCDRV_DIT_SRCRATE_44100;
+			break;
+		case MCDRV_FS_32000:
+			wSrcRate	= MCDRV_DIT_SRCRATE_32000;
+			break;
+		case MCDRV_FS_24000:
+			wSrcRate	= MCDRV_DIT_SRCRATE_24000;
+			break;
+		case MCDRV_FS_22050:
+			wSrcRate	= MCDRV_DIT_SRCRATE_22050;
+			break;
+		case MCDRV_FS_16000:
+			wSrcRate	= MCDRV_DIT_SRCRATE_16000;
+			break;
+		case MCDRV_FS_12000:
+			wSrcRate	= MCDRV_DIT_SRCRATE_12000;
+			break;
+		case MCDRV_FS_11025:
+			wSrcRate	= MCDRV_DIT_SRCRATE_11025;
+			break;
+		case MCDRV_FS_8000:
+			wSrcRate	= MCDRV_DIT_SRCRATE_8000;
+			break;
+		default:
+			/* unreachable */
+			wSrcRate = 0;
+			break;
+		}
+	}
+	/*	DITSRC_RATE*	*/
+	bReg	= (UINT8)(wSrcRate>>8);
+	if(bReg != McResCtrl_GetRegVal(MCDRV_PACKET_REGTYPE_B_MIXER, MCI_DITSRC_RATE0_MSB+bRegOffset))
+	{
+		McDevIf_AddPacket(MCDRV_PACKET_TYPE_WRITE | MCDRV_PACKET_REGTYPE_B_MIXER | (UINT32)(MCI_DITSRC_RATE0_MSB+bRegOffset), bReg);
+	}
+	bReg	= (UINT8)wSrcRate;
+	if(bReg != McResCtrl_GetRegVal(MCDRV_PACKET_REGTYPE_B_MIXER, MCI_DITSRC_RATE0_LSB+bRegOffset))
+	{
+		McDevIf_AddPacket(MCDRV_PACKET_TYPE_WRITE | MCDRV_PACKET_REGTYPE_B_MIXER | (UINT32)(MCI_DITSRC_RATE0_LSB+bRegOffset), bReg);
+	}
+
+	if(sDioInfo.asPortInfo[ePort].sDioCommon.bInterface == MCDRV_DIO_DA)
+	{
+		/*	DIT*_FMT, DIT*_BIT, DIR*_FMT, DIR*_BIT	*/
+		bReg	= (sDioInfo.asPortInfo[ePort].sDit.sDaFormat.bMode << 6)
+				| (sDioInfo.asPortInfo[ePort].sDit.sDaFormat.bBitSel << 4)
+				| (sDioInfo.asPortInfo[ePort].sDir.sDaFormat.bMode << 2)
+				| (sDioInfo.asPortInfo[ePort].sDir.sDaFormat.bBitSel);
+		if(bReg != McResCtrl_GetRegVal(MCDRV_PACKET_REGTYPE_B_MIXER, MCI_DIX0_FMT+bRegOffset))
+		{
+			McDevIf_AddPacket(MCDRV_PACKET_TYPE_WRITE | MCDRV_PACKET_REGTYPE_B_MIXER | (UINT32)(MCI_DIX0_FMT+bRegOffset), bReg);
+		}
+
+		/*	DIT*_SLOT	*/
+		bReg	= (sDioInfo.asPortInfo[ePort].sDit.abSlot[1] << 4) | (sDioInfo.asPortInfo[ePort].sDit.abSlot[0]);
+		if(bReg != McResCtrl_GetRegVal(MCDRV_PACKET_REGTYPE_B_MIXER, MCI_DIT0_SLOT+bRegOffset))
+		{
+			McDevIf_AddPacket(MCDRV_PACKET_TYPE_WRITE | MCDRV_PACKET_REGTYPE_B_MIXER | (UINT32)(MCI_DIT0_SLOT+bRegOffset), bReg);
+		}
+	}
+	else
+	{
+		/*	PCM_MONO_TX*, PCM_EXTEND_TX*, PCM_LSBON_TX*, PCM_LAW_TX*, PCM_BIT_TX*	*/
+		bReg	= (sDioInfo.asPortInfo[ePort].sDit.sPcmFormat.bMono << 7)
+				| (sDioInfo.asPortInfo[ePort].sDit.sPcmFormat.bOrder << 4)
+				| (sDioInfo.asPortInfo[ePort].sDit.sPcmFormat.bLaw << 2)
+				| (sDioInfo.asPortInfo[ePort].sDit.sPcmFormat.bBitSel);
+		if(bReg != McResCtrl_GetRegVal(MCDRV_PACKET_REGTYPE_B_MIXER, MCI_PCM_TX0+bRegOffset))
+		{
+			McDevIf_AddPacket(MCDRV_PACKET_TYPE_WRITE | MCDRV_PACKET_REGTYPE_B_MIXER | (UINT32)(MCI_PCM_TX0+bRegOffset), bReg);
+		}
+
+		/*	PCM_CH1_TX*, PCM_CH0_TX*	*/
+		bReg	= (sDioInfo.asPortInfo[ePort].sDit.abSlot[1] << 4) | (sDioInfo.asPortInfo[ePort].sDit.abSlot[0]);
+		if(bReg != McResCtrl_GetRegVal(MCDRV_PACKET_REGTYPE_B_MIXER, MCI_PCM_SLOT_TX0+bRegOffset))
+		{
+			McDevIf_AddPacket(MCDRV_PACKET_TYPE_WRITE | MCDRV_PACKET_REGTYPE_B_MIXER | (UINT32)(MCI_PCM_SLOT_TX0+bRegOffset), bReg);
+		}
+	}
+
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncOut("AddDIODIT", 0);
+#endif
+}
+
+/****************************************************************************
+ *	McPacket_AddDAC
+ *
+ *	Description:
+ *			Add DAC setup packet.
+ *	Arguments:
+ *			dUpdateInfo	update information
+ *	Return:
+ *			MCDRV_SUCCESS
+ *			MCDRV_ERROR_RESOURCEOVER
+ *			MCDRV_ERROR_TIMEOUT
+ *
+ ****************************************************************************/
+SINT32	McPacket_AddDAC
+(
+	UINT32			dUpdateInfo
+)
+{
+	SINT32	sdRet	= MCDRV_SUCCESS;
+	MCDRV_POWER_INFO	sPowerInfo;
+	MCDRV_POWER_UPDATE	sPowerUpdate;
+	MCDRV_DAC_INFO		sDacInfo;
+	UINT8	bReg;
+
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncIn("McPacket_AddDAC");
+#endif
+
+	McResCtrl_GetDacInfo(&sDacInfo);
+
+	if(((dUpdateInfo & MCDRV_DAC_MSWP_UPDATE_FLAG) != (UINT32)0) || ((dUpdateInfo & MCDRV_DAC_VSWP_UPDATE_FLAG) != (UINT32)0))
+	{
+		bReg	= (sDacInfo.bMasterSwap<<4)|sDacInfo.bVoiceSwap;
+		if(bReg == McResCtrl_GetRegVal(MCDRV_PACKET_REGTYPE_B_MIXER, MCI_SWP))
+		{
+			dUpdateInfo	&= ~(MCDRV_DAC_MSWP_UPDATE_FLAG|MCDRV_DAC_VSWP_UPDATE_FLAG);
+		}
+	}
+	if((dUpdateInfo & MCDRV_DAC_HPF_UPDATE_FLAG) != (UINT32)0)
+	{
+		if(sDacInfo.bDcCut == McResCtrl_GetRegVal(MCDRV_PACKET_REGTYPE_B_CODEC, MCI_DCCUTOFF))
+		{
+			dUpdateInfo	&= ~(MCDRV_DAC_HPF_UPDATE_FLAG);
+		}
+	}
+
+	if(dUpdateInfo != (UINT32)0)
+	{
+		McResCtrl_GetCurPowerInfo(&sPowerInfo);
+		sdRet	= PowerUpDig(MCDRV_DPB_UP);
+		if(sdRet == MCDRV_SUCCESS)
+		{
+			if(((dUpdateInfo & MCDRV_DAC_MSWP_UPDATE_FLAG) != (UINT32)0) || ((dUpdateInfo & MCDRV_DAC_VSWP_UPDATE_FLAG) != (UINT32)0))
+			{
+				bReg	= (sDacInfo.bMasterSwap<<4)|sDacInfo.bVoiceSwap;
+				McDevIf_AddPacket(MCDRV_PACKET_TYPE_WRITE | MCDRV_PACKET_REGTYPE_B_MIXER | (UINT32)MCI_SWP, bReg);
+			}
+			if((dUpdateInfo & MCDRV_DAC_HPF_UPDATE_FLAG) != (UINT32)0)
+			{
+				McDevIf_AddPacket(MCDRV_PACKET_TYPE_WRITE | MCDRV_PACKET_REGTYPE_B_CODEC | (UINT32)MCI_DCCUTOFF, sDacInfo.bDcCut);
+			}
+
+			/*	unused path power down	*/
+			sPowerUpdate.dDigital		= MCDRV_POWUPDATE_DIGITAL_ALL;
+			sPowerUpdate.abAnalog[0]	= 
+			sPowerUpdate.abAnalog[1]	= 
+			sPowerUpdate.abAnalog[2]	= 
+			sPowerUpdate.abAnalog[3]	= 
+			sPowerUpdate.abAnalog[4]	= 0;
+			sdRet	= McPacket_AddPowerDown(&sPowerInfo, &sPowerUpdate);
+		}
+	}
+
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncOut("McPacket_AddDAC", &sdRet);
+#endif
+	return sdRet;
+}
+
+/****************************************************************************
+ *	McPacket_AddADC
+ *
+ *	Description:
+ *			Add ADC setup packet.
+ *	Arguments:
+ *			dUpdateInfo	update information
+ *	Return:
+ *			MCDRV_SUCCESS
+ *			MCDRV_ERROR_RESOURCEOVER
+ *			MCDRV_ERROR_TIMEOUT
+ *
+ ****************************************************************************/
+SINT32	McPacket_AddADC
+(
+	UINT32			dUpdateInfo
+)
+{
+	SINT32	sdRet	= MCDRV_SUCCESS;
+	UINT8	bReg;
+	MCDRV_POWER_INFO	sPowerInfo;
+	MCDRV_POWER_UPDATE	sPowerUpdate;
+	MCDRV_ADC_INFO		sAdcInfo;
+
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncIn("McPacket_AddADC");
+#endif
+
+	McResCtrl_GetAdcInfo(&sAdcInfo);
+
+	if(((dUpdateInfo & MCDRV_ADCADJ_UPDATE_FLAG) != (UINT32)0) || ((dUpdateInfo & MCDRV_ADCAGC_UPDATE_FLAG) != (UINT32)0))
+	{
+		bReg	= (sAdcInfo.bAgcOn<<2)|sAdcInfo.bAgcAdjust;
+		if(bReg == McResCtrl_GetRegVal(MCDRV_PACKET_REGTYPE_B_CODEC, MCI_AD_AGC))
+		{
+			dUpdateInfo	&= ~(MCDRV_ADCADJ_UPDATE_FLAG|MCDRV_ADCAGC_UPDATE_FLAG);
+		}
+	}
+	if((dUpdateInfo & MCDRV_ADCMONO_UPDATE_FLAG) != (UINT32)0)
+	{
+		bReg	= (UINT8)((McResCtrl_GetRegVal(MCDRV_PACKET_REGTYPE_B_CODEC, MCI_AD_START) & MCB_AD_START) | (sAdcInfo.bMono << 1));
+		if(bReg == McResCtrl_GetRegVal(MCDRV_PACKET_REGTYPE_B_CODEC, MCI_AD_START))
+		{
+			dUpdateInfo	&= ~(MCDRV_ADCMONO_UPDATE_FLAG);
+		}
+	}
+
+	if(dUpdateInfo != (UINT32)0)
+	{
+		McResCtrl_GetCurPowerInfo(&sPowerInfo);
+		sdRet	= PowerUpDig(MCDRV_DPB_UP);
+		if(sdRet == MCDRV_SUCCESS)
+		{
+			if(((dUpdateInfo & MCDRV_ADCADJ_UPDATE_FLAG) != (UINT32)0) || ((dUpdateInfo & MCDRV_ADCAGC_UPDATE_FLAG) != (UINT32)0))
+			{
+				bReg	= (sAdcInfo.bAgcOn<<2)|sAdcInfo.bAgcAdjust;
+				if(bReg != McResCtrl_GetRegVal(MCDRV_PACKET_REGTYPE_B_CODEC, MCI_AD_AGC))
+				{
+					AddStopADC();
+					sdRet	= McDevIf_ExecutePacket();
+				}
+				if(MCDRV_SUCCESS == sdRet)
+				{
+					McDevIf_AddPacket(MCDRV_PACKET_TYPE_WRITE | MCDRV_PACKET_REGTYPE_B_CODEC | (UINT32)MCI_AD_AGC, bReg);
+				}
+			}
+			if(sdRet == MCDRV_SUCCESS)
+			{
+				if((dUpdateInfo & MCDRV_ADCMONO_UPDATE_FLAG) != (UINT32)0)
+				{
+					bReg	= (UINT8)((McResCtrl_GetRegVal(MCDRV_PACKET_REGTYPE_B_CODEC, MCI_AD_START) & MCB_AD_START) | (sAdcInfo.bMono << 1));
+					if(bReg != McResCtrl_GetRegVal(MCDRV_PACKET_REGTYPE_B_CODEC, MCI_AD_START))
+					{
+						AddStopADC();
+						sdRet	= McDevIf_ExecutePacket();
+					}
+					if(sdRet == MCDRV_SUCCESS)
+					{
+						McDevIf_AddPacket(MCDRV_PACKET_TYPE_WRITE | MCDRV_PACKET_REGTYPE_B_CODEC | (UINT32)MCI_AD_START, (sAdcInfo.bMono << 1));
+					}
+				}
+				if(sdRet == MCDRV_SUCCESS)
+				{
+					/*	unused path power down	*/
+					sPowerUpdate.dDigital		= MCDRV_POWUPDATE_DIGITAL_ALL;
+					sPowerUpdate.abAnalog[0]	= 
+					sPowerUpdate.abAnalog[1]	= 
+					sPowerUpdate.abAnalog[2]	= 
+					sPowerUpdate.abAnalog[3]	= 
+					sPowerUpdate.abAnalog[4]	= 0;
+					sdRet	= McPacket_AddPowerDown(&sPowerInfo, &sPowerUpdate);
+					if(sdRet == MCDRV_SUCCESS)
+					{
+						sdRet	= McPacket_AddStart();
+					}
+				}
+			}
+		}
+	}
+
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncOut("McPacket_AddADC", &sdRet);
+#endif
+
+	return sdRet;
+}
+
+/****************************************************************************
+ *	McPacket_AddSP
+ *
+ *	Description:
+ *			Add SP setup packet.
+ *	Arguments:
+ *			none
+ *	Return:
+ *			MCDRV_SUCCESS
+ *
+ ****************************************************************************/
+SINT32	McPacket_AddSP
+(
+	void
+)
+{
+	SINT32	sdRet	= MCDRV_SUCCESS;
+	MCDRV_SP_INFO	sSpInfo;
+	UINT8	bReg;
+
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncIn("McPacket_AddSP");
+#endif
+
+	bReg	= (UINT8)(McResCtrl_GetRegVal(MCDRV_PACKET_REGTYPE_B_ANA, MCI_SP_MODE) & (UINT8)~MCB_SP_SWAP);
+
+	McResCtrl_GetSpInfo(&sSpInfo);
+
+	McDevIf_AddPacket(MCDRV_PACKET_TYPE_WRITE | MCDRV_PACKET_REGTYPE_B_ANA | (UINT32)MCI_SP_MODE, bReg|sSpInfo.bSwap);
+
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncOut("McPacket_AddSP", &sdRet);
+#endif
+	return sdRet;
+}
+
+/****************************************************************************
+ *	McPacket_AddDNG
+ *
+ *	Description:
+ *			Add Digital Noise Gate setup packet.
+ *	Arguments:
+ *			dUpdateInfo	update information
+ *	Return:
+ *			MCDRV_SUCCESS
+ *
+ ****************************************************************************/
+SINT32	McPacket_AddDNG
+(
+	UINT32	dUpdateInfo
+)
+{
+	SINT32	sdRet	= MCDRV_SUCCESS;
+	MCDRV_DNG_INFO	sDngInfo;
+	UINT8	bReg;
+	UINT8	bRegDNGON;
+	UINT8	bItem;
+
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncIn("McPacket_AddDNG");
+#endif
+
+	McResCtrl_GetDngInfo(&sDngInfo);
+
+	for(bItem = MCDRV_DNG_ITEM_HP; bItem <= MCDRV_DNG_ITEM_RC; bItem++)
+	{
+		bRegDNGON	= McResCtrl_GetRegVal(MCDRV_PACKET_REGTYPE_B_ANA, MCI_DNGON_HP+(bItem*3));
+
+		/*	ReleseTime, Attack Time	*/
+		if(((dUpdateInfo & (MCDRV_DNGREL_HP_UPDATE_FLAG<<(8*bItem))) != 0UL) || ((dUpdateInfo & (MCDRV_DNGATK_HP_UPDATE_FLAG<<(8*bItem))) != 0UL))
+		{
+			bReg	= (sDngInfo.abRelease[bItem]<<4)|sDngInfo.abAttack[bItem];
+			if(bReg != McResCtrl_GetRegVal(MCDRV_PACKET_REGTYPE_B_ANA, MCI_DNGATRT_HP+(bItem*3)))
+			{
+				if((bRegDNGON&0x01) != 0)
+				{/*	DNG on	*/
+					/*	DNG off	*/
+					McDevIf_AddPacket(MCDRV_PACKET_TYPE_WRITE | MCDRV_PACKET_REGTYPE_B_ANA | (UINT32)(MCI_DNGON_HP+(bItem*3)), bRegDNGON&0xFE);
+				}
+				McDevIf_AddPacket(MCDRV_PACKET_TYPE_WRITE | MCDRV_PACKET_REGTYPE_B_ANA | (UINT32)(MCI_DNGATRT_HP+(bItem*3)), bReg);
+			}
+		}
+
+		/*	Target	*/
+		if((dUpdateInfo & (MCDRV_DNGTARGET_HP_UPDATE_FLAG<<(8*bItem))) != 0UL)
+		{
+			bReg	= sDngInfo.abTarget[bItem]<<4;
+			if(bReg != McResCtrl_GetRegVal(MCDRV_PACKET_REGTYPE_B_ANA, MCI_DNGTARGET_HP+(bItem*3)))
+			{
+				if((bRegDNGON&0x01) != 0)
+				{/*	DNG on	*/
+					/*	DNG off	*/
+					McDevIf_AddPacket(MCDRV_PACKET_TYPE_WRITE | MCDRV_PACKET_REGTYPE_B_ANA | (UINT32)(MCI_DNGON_HP+(bItem*3)), bRegDNGON&0xFE);
+				}
+				McDevIf_AddPacket(MCDRV_PACKET_TYPE_WRITE | MCDRV_PACKET_REGTYPE_B_ANA | (UINT32)(MCI_DNGTARGET_HP+(bItem*3)), bReg);
+			}
+		}
+
+		/*	Threshold, HoldTime	*/
+		if(((dUpdateInfo & (MCDRV_DNGTHRES_HP_UPDATE_FLAG<<(8*bItem))) != 0UL)
+		|| ((dUpdateInfo & (MCDRV_DNGHOLD_HP_UPDATE_FLAG<<(8*bItem))) != 0UL))
+		{
+			bReg	= (sDngInfo.abThreshold[bItem]<<4)|(sDngInfo.abHold[bItem]<<1);
+			if(bReg != McResCtrl_GetRegVal(MCDRV_PACKET_REGTYPE_B_ANA, MCI_DNGON_HP+(bItem*3)))
+			{
+				if((bRegDNGON&0x01) != 0)
+				{/*	DNG on	*/
+					/*	DNG off	*/
+					McDevIf_AddPacket(MCDRV_PACKET_TYPE_WRITE | MCDRV_PACKET_REGTYPE_B_ANA | (UINT32)(MCI_DNGON_HP+(bItem*3)), bRegDNGON&0xFE);
+				}
+				McDevIf_AddPacket(MCDRV_PACKET_TYPE_WRITE | MCDRV_PACKET_REGTYPE_B_ANA | (UINT32)(MCI_DNGON_HP+(bItem*3)), bReg);
+			}
+			bRegDNGON	= bReg | (bRegDNGON&0x01);
+		}
+
+		/*	DNGON	*/
+		if((dUpdateInfo & (MCDRV_DNGSW_HP_UPDATE_FLAG<<(8*bItem))) != 0UL)
+		{
+			bRegDNGON	= (bRegDNGON&0xFE) | sDngInfo.abOnOff[bItem];
+		}
+		McDevIf_AddPacket(MCDRV_PACKET_TYPE_WRITE | MCDRV_PACKET_REGTYPE_B_ANA | (UINT32)(MCI_DNGON_HP+(bItem*3)), bRegDNGON);
+	}
+
+
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncOut("McPacket_AddDNG", &sdRet);
+#endif
+	return sdRet;
+}
+
+/****************************************************************************
+ *	McPacket_AddAE
+ *
+ *	Description:
+ *			Add Audio Engine setup packet.
+ *	Arguments:
+ *			dUpdateInfo	update information
+ *	Return:
+ *			MCDRV_SUCCESS
+ *			MCDRV_ERROR_RESOURCEOVER
+ *			MCDRV_ERROR_TIMEOUT
+ *
+ ****************************************************************************/
+SINT32	McPacket_AddAE
+(
+	UINT32	dUpdateInfo
+)
+{
+	SINT32	sdRet	= MCDRV_SUCCESS;
+	UINT8	bReg;
+	UINT8	i;
+	UINT32	dXFadeParam	= 0;
+	MCDRV_AE_INFO	sAeInfo;
+	MCDRV_PATH_INFO	sPathInfo;
+	MCDRV_POWER_INFO	sPowerInfo;
+	MCDRV_POWER_UPDATE	sPowerUpdate;
+
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncIn("McPacket_AddAE");
+#endif
+
+	McResCtrl_GetPathInfo(&sPathInfo);
+	McResCtrl_GetAeInfo(&sAeInfo);
+
+	if(McResCtrl_IsDstUsed(eMCDRV_DST_AE, eMCDRV_DST_CH0) == 1)
+	{/*	AE is used	*/
+		bReg	= McResCtrl_GetRegVal(MCDRV_PACKET_REGTYPE_A, MCI_BDSP_ST);
+		if(McDevProf_IsValid(eMCDRV_FUNC_DBEX) == 1)
+		{
+			if((dUpdateInfo & MCDRV_AEUPDATE_FLAG_BEXWIDE_ONOFF) != (UINT32)0)
+			{
+				if((((sAeInfo.bOnOff & MCDRV_BEXWIDE_ON) != 0) && ((bReg & MCB_DBEXON) != 0))
+				|| (((sAeInfo.bOnOff & MCDRV_BEXWIDE_ON) == 0) && ((bReg & MCB_DBEXON) == 0)))
+				{
+					dUpdateInfo	&= ~MCDRV_AEUPDATE_FLAG_BEXWIDE_ONOFF;
+				}
+			}
+		}
+		if((dUpdateInfo & MCDRV_AEUPDATE_FLAG_DRC_ONOFF) != (UINT32)0)
+		{
+			if((((sAeInfo.bOnOff & MCDRV_DRC_ON) != 0) && ((bReg & MCB_DRCON) != 0))
+			|| (((sAeInfo.bOnOff & MCDRV_DRC_ON) == 0) && ((bReg & MCB_DRCON) == 0)))
+			{
+				dUpdateInfo	&= ~MCDRV_AEUPDATE_FLAG_DRC_ONOFF;
+			}
+		}
+		if((dUpdateInfo & MCDRV_AEUPDATE_FLAG_EQ5_ONOFF) != (UINT32)0)
+		{
+			if((((sAeInfo.bOnOff & MCDRV_EQ5_ON) != 0) && ((bReg & MCB_EQ5ON) != 0))
+			|| (((sAeInfo.bOnOff & MCDRV_EQ5_ON) == 0) && ((bReg & MCB_EQ5ON) == 0)))
+			{
+				dUpdateInfo	&= ~MCDRV_AEUPDATE_FLAG_EQ5_ONOFF;
+			}
+		}
+		if((dUpdateInfo & MCDRV_AEUPDATE_FLAG_EQ3_ONOFF) != (UINT32)0)
+		{
+			if((((sAeInfo.bOnOff & MCDRV_EQ3_ON) != 0) && ((bReg & MCB_EQ3ON) != 0))
+			|| (((sAeInfo.bOnOff & MCDRV_EQ3_ON) == 0) && ((bReg & MCB_EQ3ON) == 0)))
+			{
+				dUpdateInfo	&= ~MCDRV_AEUPDATE_FLAG_EQ3_ONOFF;
+			}
+		}
+		if(dUpdateInfo != (UINT32)0)
+		{
+			/*	on/off setting or param changed	*/
+			if(((dUpdateInfo & MCDRV_AEUPDATE_FLAG_EQ5) != (UINT32)0)
+			|| ((dUpdateInfo & MCDRV_AEUPDATE_FLAG_EQ3) != (UINT32)0)
+			|| ((dUpdateInfo & MCDRV_AEUPDATE_FLAG_BEX) != (UINT32)0)
+			|| ((dUpdateInfo & MCDRV_AEUPDATE_FLAG_WIDE) != (UINT32)0)
+			|| ((dUpdateInfo & MCDRV_AEUPDATE_FLAG_DRC) != (UINT32)0)
+			|| ((dUpdateInfo & MCDRV_AEUPDATE_FLAG_BEXWIDE_ONOFF) != (UINT32)0)
+			|| ((dUpdateInfo & MCDRV_AEUPDATE_FLAG_DRC_ONOFF) != (UINT32)0)
+			|| ((dUpdateInfo & MCDRV_AEUPDATE_FLAG_EQ5_ONOFF) != (UINT32)0)
+			|| ((dUpdateInfo & MCDRV_AEUPDATE_FLAG_EQ3_ONOFF) != (UINT32)0))
+			{
+				dXFadeParam	= McResCtrl_GetRegVal(MCDRV_PACKET_REGTYPE_B_MIXER, MCI_DAC_INS);
+				dXFadeParam	<<= 8;
+				dXFadeParam	|= McResCtrl_GetRegVal(MCDRV_PACKET_REGTYPE_B_MIXER, MCI_INS);
+				McDevIf_AddPacket(MCDRV_PACKET_TYPE_WRITE | MCDRV_PACKET_REGTYPE_B_MIXER | (UINT32)MCI_DAC_INS, 0);
+				McDevIf_AddPacket(MCDRV_PACKET_TYPE_WRITE | MCDRV_PACKET_REGTYPE_B_MIXER | (UINT32)MCI_INS, 0);
+			}
+			sdRet	= McDevIf_ExecutePacket();
+			if(sdRet == MCDRV_SUCCESS)
+			{
+				/*	wait xfade complete	*/
+				if(dXFadeParam != (UINT32)0)
+				{
+					McDevIf_AddPacket(MCDRV_PACKET_TYPE_EVTWAIT | MCDRV_EVT_INSFLG | dXFadeParam, 0);
+					bReg	= McResCtrl_GetRegVal(MCDRV_PACKET_REGTYPE_A, MCI_BDSP_ST);
+					if((dUpdateInfo & MCDRV_AEUPDATE_FLAG_EQ5) != (UINT32)0)
+					{
+						bReg	&= (UINT8)~MCB_EQ5ON;
+					}
+					if((dUpdateInfo & MCDRV_AEUPDATE_FLAG_EQ3) != (UINT32)0)
+					{
+						bReg	&= (UINT8)~MCB_EQ3ON;
+					}
+					McDevIf_AddPacket(MCDRV_PACKET_TYPE_WRITE | MCDRV_PACKET_REGTYPE_A | (UINT32)MCI_BDSP_ST, bReg);
+				}
+
+				bReg	= McResCtrl_GetRegVal(MCDRV_PACKET_REGTYPE_A, MCI_BDSP_ST);
+				if((bReg & MCB_BDSP_ST) == MCB_BDSP_ST)
+				{
+					/*	Stop BDSP	*/
+					McDevIf_AddPacket(MCDRV_PACKET_TYPE_WRITE | MCDRV_PACKET_REGTYPE_A | (UINT32)MCI_BDSP_ST, 0);
+					/*	Reset TRAM	*/
+					McDevIf_AddPacket(MCDRV_PACKET_TYPE_WRITE | MCDRV_PACKET_REGTYPE_A | (UINT32)MCI_BDSP_RST, MCB_TRAM_RST);
+					McDevIf_AddPacket(MCDRV_PACKET_TYPE_WRITE | MCDRV_PACKET_REGTYPE_A | (UINT32)MCI_BDSP_RST, 0);
+				}
+			}
+		}
+	}
+
+	if((dUpdateInfo != (UINT32)0) && (sdRet == MCDRV_SUCCESS))
+	{
+		if((dUpdateInfo & MCDRV_AEUPDATE_FLAG_DRC) != (UINT32)0)
+		{
+			McResCtrl_GetPowerInfo(&sPowerInfo);
+			sPowerInfo.dDigital	&= ~MCDRV_POWINFO_DIGITAL_DP0;
+			sPowerInfo.dDigital	&= ~MCDRV_POWINFO_DIGITAL_DP1;
+			sPowerInfo.dDigital	&= ~MCDRV_POWINFO_DIGITAL_DP2;
+			sPowerInfo.dDigital	&= ~MCDRV_POWINFO_DIGITAL_DPBDSP;
+			sPowerInfo.dDigital	&= ~MCDRV_POWINFO_DIGITAL_PLLRST0;
+			sPowerUpdate.dDigital	= MCDRV_POWUPDATE_DIGITAL_ALL;
+			sPowerUpdate.abAnalog[0]	= 
+			sPowerUpdate.abAnalog[1]	= 
+			sPowerUpdate.abAnalog[2]	= 
+			sPowerUpdate.abAnalog[3]	= 
+			sPowerUpdate.abAnalog[4]	= 0;
+			sdRet	= McPacket_AddPowerUp(&sPowerInfo, &sPowerUpdate);
+			if(MCDRV_SUCCESS == sdRet)
+			{
+				sdRet	= McDevIf_ExecutePacket();
+			}
+			if(MCDRV_SUCCESS == sdRet)
+			{
+				McDevIf_AddPacket(MCDRV_PACKET_TYPE_FORCE_WRITE | MCDRV_PACKET_REGTYPE_A | (UINT32)MCI_BDSP_ADR, 0);
+				sdRet	= McDevIf_ExecutePacket();
+				if(MCDRV_SUCCESS == sdRet)
+				{
+					McDevIf_AddPacketRepeat(MCDRV_PACKET_TYPE_FORCE_WRITE | MCDRV_PACKET_REGTYPE_A | (UINT32)MCI_BDSP_WINDOW, sAeInfo.abDrc, DRC_PARAM_SIZE);
+				}
+			}
+		}
+
+		if(MCDRV_SUCCESS == sdRet)
+		{
+			if((dUpdateInfo & MCDRV_AEUPDATE_FLAG_EQ5) != (UINT32)0)
+			{
+				for(i = 0; i < EQ5_PARAM_SIZE; i++)
+				{
+					McDevIf_AddPacket(MCDRV_PACKET_TYPE_FORCE_WRITE | MCDRV_PACKET_REGTYPE_B_AE | (UINT32)(MCI_BAND0_CEQ0+i), sAeInfo.abEq5[i]);
+				}
+			}
+			if((dUpdateInfo & MCDRV_AEUPDATE_FLAG_EQ3) != (UINT32)0)
+			{
+				for(i = 0; i < EQ3_PARAM_SIZE; i++)
+				{
+					McDevIf_AddPacket(MCDRV_PACKET_TYPE_FORCE_WRITE | MCDRV_PACKET_REGTYPE_B_AE | (UINT32)(MCI_BAND5_CEQ0+i), sAeInfo.abEq3[i]);
+				}
+			}
+		}
+	}
+
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncOut("McPacket_AddAE", &sdRet);
+#endif
+
+	return sdRet;
+}
+
+/****************************************************************************
+ *	McPacket_AddPDM
+ *
+ *	Description:
+ *			Add PDM setup packet.
+ *	Arguments:
+ *			dUpdateInfo	update information
+ *	Return:
+ *			MCDRV_SUCCESS
+ *			MCDRV_ERROR_RESOURCEOVER
+ *			MCDRV_ERROR_TIMEOUT
+ *
+ ****************************************************************************/
+SINT32	McPacket_AddPDM
+(
+	UINT32			dUpdateInfo
+)
+{
+	SINT32				sdRet		= MCDRV_SUCCESS;
+	UINT8				bReg;
+	MCDRV_POWER_INFO	sPowerInfo;
+	MCDRV_POWER_UPDATE	sPowerUpdate;
+	MCDRV_PDM_INFO		sPdmInfo;
+
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncIn("McPacket_AddPDM");
+#endif
+
+	McResCtrl_GetPdmInfo(&sPdmInfo);
+	if(((dUpdateInfo & MCDRV_PDMADJ_UPDATE_FLAG) != (UINT32)0) || ((dUpdateInfo & MCDRV_PDMAGC_UPDATE_FLAG) != (UINT32)0))
+	{
+		bReg	= (sPdmInfo.bAgcOn<<2)|sPdmInfo.bAgcAdjust;
+		if(bReg == McResCtrl_GetRegVal(MCDRV_PACKET_REGTYPE_B_MIXER, MCI_PDM_AGC))
+		{
+			dUpdateInfo &= ~(MCDRV_PDMADJ_UPDATE_FLAG|MCDRV_PDMAGC_UPDATE_FLAG);
+		}
+	}
+	if((dUpdateInfo & MCDRV_PDMMONO_UPDATE_FLAG) != (UINT32)0)
+	{
+		bReg	= (UINT8)(McResCtrl_GetRegVal(MCDRV_PACKET_REGTYPE_B_MIXER, MCI_PDM_START) & (UINT8)MCB_PDM_MN);
+		if((sPdmInfo.bMono<<1) == bReg)
+		{
+			dUpdateInfo &= ~(MCDRV_PDMMONO_UPDATE_FLAG);
+		}
+	}
+	if(((dUpdateInfo & MCDRV_PDMCLK_UPDATE_FLAG) != (UINT32)0)
+	|| ((dUpdateInfo & MCDRV_PDMEDGE_UPDATE_FLAG) != (UINT32)0)
+	|| ((dUpdateInfo & MCDRV_PDMWAIT_UPDATE_FLAG) != (UINT32)0)
+	|| ((dUpdateInfo & MCDRV_PDMSEL_UPDATE_FLAG) != (UINT32)0))
+	{
+		bReg	= (sPdmInfo.bPdmWait<<5) | (sPdmInfo.bPdmEdge<<4) | (sPdmInfo.bPdmSel<<2) | sPdmInfo.bClk;
+		if(bReg == McResCtrl_GetRegVal(MCDRV_PACKET_REGTYPE_B_MIXER, MCI_PDM_STWAIT))
+		{
+			dUpdateInfo &= ~(MCDRV_PDMCLK_UPDATE_FLAG|MCDRV_PDMEDGE_UPDATE_FLAG|MCDRV_PDMWAIT_UPDATE_FLAG|MCDRV_PDMSEL_UPDATE_FLAG);
+		}
+	}
+	if(dUpdateInfo != (UINT32)0)
+	{
+		McResCtrl_GetCurPowerInfo(&sPowerInfo);
+		sdRet	= PowerUpDig(MCDRV_DPB_UP);
+		if(sdRet == MCDRV_SUCCESS)
+		{
+			if(((dUpdateInfo & MCDRV_PDMADJ_UPDATE_FLAG) != (UINT32)0) || ((dUpdateInfo & MCDRV_PDMAGC_UPDATE_FLAG) != (UINT32)0))
+			{
+				bReg	= (sPdmInfo.bAgcOn<<2)|sPdmInfo.bAgcAdjust;
+				if(bReg != McResCtrl_GetRegVal(MCDRV_PACKET_REGTYPE_B_MIXER, MCI_PDM_AGC))
+				{
+					AddStopPDM();
+					sdRet	= McDevIf_ExecutePacket();
+				}
+				if(sdRet == MCDRV_SUCCESS)
+				{
+					McDevIf_AddPacket(MCDRV_PACKET_TYPE_WRITE | MCDRV_PACKET_REGTYPE_B_MIXER | (UINT32)MCI_PDM_AGC, bReg);
+				}
+			}
+		}
+		if(sdRet == MCDRV_SUCCESS)
+		{
+			if((dUpdateInfo & MCDRV_PDMMONO_UPDATE_FLAG) != (UINT32)0)
+			{
+				bReg	= (UINT8)((McResCtrl_GetRegVal(MCDRV_PACKET_REGTYPE_B_MIXER, MCI_PDM_START) & (UINT8)~MCB_PDM_MN) | (sPdmInfo.bMono<<1));
+				if(bReg != McResCtrl_GetRegVal(MCDRV_PACKET_REGTYPE_B_MIXER, MCI_PDM_START))
+				{
+					AddStopPDM();
+					sdRet	= McDevIf_ExecutePacket();
+					if(MCDRV_SUCCESS == sdRet)
+					{
+						McDevIf_AddPacket(MCDRV_PACKET_TYPE_WRITE | MCDRV_PACKET_REGTYPE_B_MIXER | (UINT32)MCI_PDM_START, (sPdmInfo.bMono<<1));
+					}
+				}
+			}
+		}
+		if(sdRet == MCDRV_SUCCESS)
+		{
+			if(((dUpdateInfo & MCDRV_PDMCLK_UPDATE_FLAG) != (UINT32)0)
+			|| ((dUpdateInfo & MCDRV_PDMEDGE_UPDATE_FLAG) != (UINT32)0)
+			|| ((dUpdateInfo & MCDRV_PDMWAIT_UPDATE_FLAG) != (UINT32)0)
+			|| ((dUpdateInfo & MCDRV_PDMSEL_UPDATE_FLAG) != (UINT32)0))
+			{
+				bReg	= (sPdmInfo.bPdmWait<<5) | (sPdmInfo.bPdmEdge<<4) | (sPdmInfo.bPdmSel<<2) | sPdmInfo.bClk;
+				McDevIf_AddPacket(MCDRV_PACKET_TYPE_WRITE | MCDRV_PACKET_REGTYPE_B_MIXER | (UINT32)MCI_PDM_STWAIT, bReg);
+			}
+
+			/*	unused path power down	*/
+			sPowerUpdate.dDigital		= MCDRV_POWUPDATE_DIGITAL_ALL;
+			sPowerUpdate.abAnalog[0]	= 
+			sPowerUpdate.abAnalog[1]	= 
+			sPowerUpdate.abAnalog[2]	= 
+			sPowerUpdate.abAnalog[3]	= 
+			sPowerUpdate.abAnalog[4]	= 0;
+			sdRet	= McPacket_AddPowerDown(&sPowerInfo, &sPowerUpdate);
+			if(sdRet == MCDRV_SUCCESS)
+			{
+				sdRet	= McPacket_AddStart();
+			}
+		}
+	}
+
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncOut("McPacket_AddPDM", &sdRet);
+#endif
+
+	return sdRet;
+}
+
+/****************************************************************************
+ *	McPacket_AddGPMode
+ *
+ *	Description:
+ *			Add GP mode setup packet.
+ *	Arguments:
+ *			none
+ *	Return:
+ *			MCDRV_SUCCESS
+ *
+ ****************************************************************************/
+SINT32	McPacket_AddGPMode
+(
+	void
+)
+{
+	SINT32	sdRet	= MCDRV_SUCCESS;
+	UINT8	bReg;
+	MCDRV_INIT_INFO	sInitInfo;
+	MCDRV_GP_MODE	sGPMode;
+
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncIn("McPacket_AddGPMode");
+#endif
+
+	McResCtrl_GetInitInfo(&sInitInfo);
+	McResCtrl_GetGPMode(&sGPMode);
+
+	bReg	= McResCtrl_GetRegVal(MCDRV_PACKET_REGTYPE_B_BASE, MCI_PA_MSK);
+
+	if(sInitInfo.bPad0Func == MCDRV_PAD_GPIO)
+	{
+		if(sGPMode.abGpDdr[0] == MCDRV_GPDDR_IN)
+		{
+			bReg	&= (UINT8)~MCB_PA0_DDR;
+		}
+		else
+		{
+			bReg	|= MCB_PA0_DDR;
+		}
+	}
+	if(sInitInfo.bPad1Func == MCDRV_PAD_GPIO)
+	{
+		if(sGPMode.abGpDdr[1] == MCDRV_GPDDR_IN)
+		{
+			bReg	&= (UINT8)~MCB_PA1_DDR;
+		}
+		else
+		{
+			bReg	|= MCB_PA1_DDR;
+		}
+	}
+	McDevIf_AddPacket(MCDRV_PACKET_TYPE_WRITE | MCDRV_PACKET_REGTYPE_B_BASE | (UINT32)MCI_PA_MSK, bReg);
+
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncOut("McPacket_AddGPMode", &sdRet);
+#endif
+
+	return sdRet;
+}
+
+/****************************************************************************
+ *	McPacket_AddGPMask
+ *
+ *	Description:
+ *			Add GP mask setup packet.
+ *	Arguments:
+ *			dPadNo		PAD number
+ *	Return:
+ *			MCDRV_SUCCESS
+ *			MCDRV_ERROR
+ *
+ ****************************************************************************/
+SINT32	McPacket_AddGPMask
+(
+	UINT32	dPadNo
+)
+{
+	SINT32	sdRet	= MCDRV_SUCCESS;
+	UINT8	bReg;
+	MCDRV_INIT_INFO	sInitInfo;
+	MCDRV_GP_MODE	sGPMode;
+	UINT8	abMask[GPIO_PAD_NUM];
+
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncIn("McPacket_AddGPMask");
+#endif
+
+	McResCtrl_GetInitInfo(&sInitInfo);
+	McResCtrl_GetGPMode(&sGPMode);
+	McResCtrl_GetGPMask(abMask);
+
+	if(dPadNo == MCDRV_GP_PAD0)
+	{
+		if((sInitInfo.bPad0Func == MCDRV_PAD_GPIO) && (sGPMode.abGpDdr[0] == MCDRV_GPDDR_IN))
+		{
+			bReg	= McResCtrl_GetRegVal(MCDRV_PACKET_REGTYPE_B_BASE, MCI_PA_MSK);
+			if(abMask[0] == MCDRV_GPMASK_OFF)
+			{
+				bReg	&= (UINT8)~MCB_PA0_MSK;
+			}
+			else
+			{
+				bReg	|= MCB_PA0_MSK;
+			}
+			McDevIf_AddPacket(MCDRV_PACKET_TYPE_WRITE | MCDRV_PACKET_REGTYPE_B_BASE | (UINT32)MCI_PA_MSK, bReg);
+		}
+	}
+	else if(dPadNo == MCDRV_GP_PAD1)
+	{
+		if((sInitInfo.bPad1Func == MCDRV_PAD_GPIO) && (sGPMode.abGpDdr[1] == MCDRV_GPDDR_IN))
+		{
+			bReg	= McResCtrl_GetRegVal(MCDRV_PACKET_REGTYPE_B_BASE, MCI_PA_MSK);
+			if(abMask[1] == MCDRV_GPMASK_OFF)
+			{
+				bReg	&= (UINT8)~MCB_PA1_MSK;
+			}
+			else
+			{
+				bReg	|= MCB_PA1_MSK;
+			}
+			McDevIf_AddPacket(MCDRV_PACKET_TYPE_WRITE | MCDRV_PACKET_REGTYPE_B_BASE | (UINT32)MCI_PA_MSK, bReg);
+		}
+	}
+	else
+	{
+		sdRet	= MCDRV_ERROR;
+	}
+
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncOut("McPacket_AddGPMask", &sdRet);
+#endif
+
+	return sdRet;
+}
+
+/****************************************************************************
+ *	McPacket_AddGPSet
+ *
+ *	Description:
+ *			Add GPIO output packet.
+ *	Arguments:
+ *			bGpio		pin state setting
+ *			dPadNo		PAD number
+ *	Return:
+ *			MCDRV_SUCCESS
+ *			MCDRV_ERROR
+ *
+ ****************************************************************************/
+SINT32	McPacket_AddGPSet
+(
+	UINT8	bGpio,
+	UINT32	dPadNo
+)
+{
+	SINT32	sdRet	= MCDRV_SUCCESS;
+	UINT8	bReg;
+
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncIn("McPacket_AddGPSet");
+#endif
+
+	bReg	= McResCtrl_GetRegVal(MCDRV_PACKET_REGTYPE_B_BASE, MCI_PA_SCU_PA);
+
+	if(dPadNo == MCDRV_GP_PAD0)
+	{
+		if(bGpio == MCDRV_GP_LOW)
+		{
+			bReg	&= (UINT8)~MCB_PA_SCU_PA0;
+		}
+		else if(bGpio == MCDRV_GP_HIGH)
+		{
+			bReg	|= MCB_PA_SCU_PA0;
+		}
+		else
+		{
+		}
+	}
+	else if(dPadNo == MCDRV_GP_PAD1)
+	{
+		if(bGpio == MCDRV_GP_LOW)
+		{
+			bReg	&= (UINT8)~MCB_PA_SCU_PA1;
+		}
+		else if(bGpio == MCDRV_GP_HIGH)
+		{
+			bReg	|= MCB_PA_SCU_PA1;
+		}
+		else
+		{
+		}
+	}
+	else
+	{
+		sdRet	= MCDRV_ERROR;
+	}
+
+	if(sdRet == MCDRV_SUCCESS)
+	{
+		McDevIf_AddPacket(MCDRV_PACKET_TYPE_WRITE | MCDRV_PACKET_REGTYPE_B_BASE | (UINT32)MCI_PA_SCU_PA, bReg);
+	}
+
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncOut("McPacket_AddGPSet", &sdRet);
+#endif
+
+	return sdRet;
+}
+
+/****************************************************************************
+ *	McPacket_AddSysEq
+ *
+ *	Description:
+ *			Add GPIO output packet.
+ *	Arguments:
+ *			dUpdateInfo	update information
+ *	Return:
+ *			MCDRV_SUCCESS
+ *
+ ****************************************************************************/
+SINT32	McPacket_AddSysEq
+(
+	UINT32	dUpdateInfo
+)
+{
+	SINT32	sdRet	= MCDRV_SUCCESS;
+	UINT8	bRegEQOn;
+	UINT8	bReg;
+	MCDRV_SYSEQ_INFO	sSysEq;
+	UINT8	i;
+
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncIn("McPacket_AddSysEq");
+#endif
+
+	bRegEQOn	= McResCtrl_GetRegVal(MCDRV_PACKET_REGTYPE_B_CODEC, MCI_SYSTEM_EQON);
+
+	McResCtrl_GetSysEq(&sSysEq);
+
+	if((dUpdateInfo & MCDRV_SYSEQ_PARAM_UPDATE_FLAG) != 0UL)
+	{
+		if((bRegEQOn & MCB_SYSTEM_EQON) != 0)
+		{/*	EQ on	*/
+			/*	EQ off	*/
+			bReg	= bRegEQOn;
+			bReg	&= (UINT8)~MCB_SYSTEM_EQON;
+			McDevIf_AddPacket(MCDRV_PACKET_TYPE_WRITE | MCDRV_PACKET_REGTYPE_B_CODEC | (UINT32)MCI_SYSTEM_EQON, bReg);
+			McDevIf_AddPacket(MCDRV_PACKET_TYPE_EVTWAIT | MCDRV_EVT_SYSEQ_FLAG_RESET, 0);
+		}
+		/*	EQ coef	*/
+		for(i = 0; i < sizeof(sSysEq.abParam); i++)
+		{
+			McDevIf_AddPacket(MCDRV_PACKET_TYPE_FORCE_WRITE | MCDRV_PACKET_REGTYPE_B_CODEC | (UINT32)(MCI_SYS_CEQ0_19_12+i), sSysEq.abParam[i]);
+		}
+	}
+
+	if((dUpdateInfo & MCDRV_SYSEQ_ONOFF_UPDATE_FLAG) != 0UL)
+	{
+		bRegEQOn	&= (UINT8)~MCB_SYSTEM_EQON;
+		bRegEQOn	|= sSysEq.bOnOff;
+	}
+
+	McDevIf_AddPacket(MCDRV_PACKET_TYPE_WRITE | MCDRV_PACKET_REGTYPE_B_CODEC | (UINT32)MCI_SYSTEM_EQON, bRegEQOn);
+
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncOut("McPacket_AddSysEq", &sdRet);
+#endif
+	return sdRet;
+}
+
+/****************************************************************************
+ *	McPacket_AddClockSwitch
+ *
+ *	Description:
+ *			Add switch clock packet.
+ *	Arguments:
+ *			none
+ *	Return:
+ *			MCDRV_SUCCESS
+ *
+ ****************************************************************************/
+SINT32	McPacket_AddClockSwitch
+(
+	void
+)
+{
+	SINT32	sdRet	= MCDRV_SUCCESS;
+	UINT8	bReg;
+	MCDRV_CLKSW_INFO	sClockInfo;
+
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncIn("McPacket_AddClockSwitch");
+#endif
+
+	bReg	= McResCtrl_GetRegVal(MCDRV_PACKET_REGTYPE_B_CODEC, MCI_DPADIF);
+
+	McResCtrl_GetClockSwitch(&sClockInfo);
+
+	if((bReg & (MCB_DP0_CLKI1 | MCB_DP0_CLKI0)) != (MCB_DP0_CLKI1 | MCB_DP0_CLKI0))
+	{
+		if(sClockInfo.bClkSrc == MCDRV_CLKSW_CLKI0)
+		{
+			if((bReg & MCB_DP0_CLKI1) == 0)
+			{/*	CLKI1->CLKI0	*/
+				bReg	&= (UINT8)~MCB_DP0_CLKI0;
+				McDevIf_AddPacket(MCDRV_PACKET_TYPE_WRITE | MCDRV_PACKET_REGTYPE_B_CODEC | (UINT32)MCI_DPADIF, bReg);
+				if((bReg & MCB_CLKINPUT) != 0)
+				{
+					bReg	|= MCB_CLKSRC;
+				}
+				else
+				{
+					bReg	&= (UINT8)~MCB_CLKSRC;
+				}
+				McDevIf_AddPacket(MCDRV_PACKET_TYPE_WRITE | MCDRV_PACKET_REGTYPE_B_CODEC | (UINT32)MCI_DPADIF, bReg);
+				McDevIf_AddPacket(MCDRV_PACKET_TYPE_EVTWAIT | MCDRV_EVT_CLKBUSY_RESET, 0);
+				McDevIf_AddPacket(MCDRV_PACKET_TYPE_EVTWAIT | MCDRV_EVT_CLKSRC_RESET, 0);
+				bReg	|= MCB_DP0_CLKI1;
+				McDevIf_AddPacket(MCDRV_PACKET_TYPE_WRITE | MCDRV_PACKET_REGTYPE_B_CODEC | (UINT32)MCI_DPADIF, bReg);
+			}
+		}
+		else
+		{
+			if((bReg & MCB_DP0_CLKI0) == 0)
+			{/*	CLKI0->CLKI1	*/
+				bReg	&= (UINT8)~MCB_DP0_CLKI1;
+				McDevIf_AddPacket(MCDRV_PACKET_TYPE_WRITE | MCDRV_PACKET_REGTYPE_B_CODEC | (UINT32)MCI_DPADIF, bReg);
+				if((bReg & MCB_CLKINPUT) == 0)
+				{
+					bReg	|= MCB_CLKSRC;
+				}
+				else
+				{
+					bReg	&= (UINT8)~MCB_CLKSRC;
+				}
+				McDevIf_AddPacket(MCDRV_PACKET_TYPE_WRITE | MCDRV_PACKET_REGTYPE_B_CODEC | (UINT32)MCI_DPADIF, bReg);
+				McDevIf_AddPacket(MCDRV_PACKET_TYPE_EVTWAIT | MCDRV_EVT_CLKBUSY_RESET, 0);
+				McDevIf_AddPacket(MCDRV_PACKET_TYPE_EVTWAIT | MCDRV_EVT_CLKSRC_SET, 0);
+				bReg	|= MCB_DP0_CLKI0;
+				McDevIf_AddPacket(MCDRV_PACKET_TYPE_WRITE | MCDRV_PACKET_REGTYPE_B_CODEC | (UINT32)MCI_DPADIF, bReg);
+			}
+		}
+	}
+	else
+	{
+		if(sClockInfo.bClkSrc == MCDRV_CLKSW_CLKI0)
+		{
+			if((bReg & MCB_CLKSRC) != 0)
+			{
+				bReg	|= MCB_CLKINPUT;
+			}
+			else
+			{
+				bReg	&= (UINT8)~MCB_CLKINPUT;
+			}
+		}
+		else
+		{
+			if((bReg & MCB_CLKSRC) == 0)
+			{
+				bReg	|= MCB_CLKINPUT;
+			}
+			else
+			{
+				bReg	&= (UINT8)~MCB_CLKINPUT;
+			}
+		}
+		McDevIf_AddPacket(MCDRV_PACKET_TYPE_WRITE | MCDRV_PACKET_REGTYPE_B_CODEC | (UINT32)MCI_DPADIF, bReg);
+		sdRet	= McDevIf_ExecutePacket();
+	}
+
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncOut("McPacket_AddClockSwitch", &sdRet);
+#endif
+
+	return sdRet;
+}
+
+
+/****************************************************************************
+ *	PowerUpDig
+ *
+ *	Description:
+ *			Digital power up.
+ *	Arguments:
+ *			bDPBUp		1:DPB power up
+ *	Return:
+ *			MCDRV_SUCCESS
+ *			MCDRV_ERROR_RESOURCEOVER
+ *			MCDRV_ERROR_TIMEOUT
+ *
+ ****************************************************************************/
+static SINT32	PowerUpDig
+(
+	UINT8	bDPBUp
+)
+{
+	SINT32	sdRet	= MCDRV_SUCCESS;
+	MCDRV_POWER_INFO	sPowerInfo;
+	MCDRV_POWER_UPDATE	sPowerUpdate;
+
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncIn("PowerUpDig");
+#endif
+
+	McResCtrl_GetCurPowerInfo(&sPowerInfo);
+	sPowerInfo.dDigital	&= ~MCDRV_POWINFO_DIGITAL_DP0;
+	sPowerInfo.dDigital	&= ~MCDRV_POWINFO_DIGITAL_DP1;
+	sPowerInfo.dDigital	&= ~MCDRV_POWINFO_DIGITAL_DP2;
+	sPowerInfo.dDigital	&= ~MCDRV_POWINFO_DIGITAL_PLLRST0;
+	if(bDPBUp == MCDRV_DPB_UP)
+	{
+		sPowerInfo.dDigital	&= ~MCDRV_POWINFO_DIGITAL_DPB;
+	}
+	sPowerUpdate.dDigital	= MCDRV_POWUPDATE_DIGITAL_ALL;
+	sdRet	= McPacket_AddPowerUp(&sPowerInfo, &sPowerUpdate);
+	if(MCDRV_SUCCESS == sdRet)
+	{
+		sdRet	= McDevIf_ExecutePacket();
+	}
+
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncOut("PowerUpDig", &sdRet);
+#endif
+
+	return sdRet;
+}
+
+/****************************************************************************
+ *	GetMaxWait
+ *
+ *	Description:
+ *			Get maximum wait time.
+ *	Arguments:
+ *			bRegChange	analog power management register update information
+ *	Return:
+ *			wait time
+ *
+ ****************************************************************************/
+static UINT32	GetMaxWait
+(
+	UINT8	bRegChange
+)
+{
+	UINT32	dWaitTimeMax	= 0;
+	MCDRV_INIT_INFO	sInitInfo;
+
+#if (MCDRV_DEBUG_LEVEL>=4)
+	SINT32	sdRet;
+	McDebugLog_FuncIn("GetMaxWait");
+#endif
+
+	McResCtrl_GetInitInfo(&sInitInfo);
+
+	if((bRegChange & MCB_PWM_LI) != 0)
+	{
+		if(sInitInfo.sWaitTime.dLine1Cin > dWaitTimeMax)
+		{
+			dWaitTimeMax	= sInitInfo.sWaitTime.dLine1Cin;
+		}
+	}
+	if(((bRegChange & MCB_PWM_MB1) != 0) || ((bRegChange & MCB_PWM_MC1) != 0))
+	{
+		if(sInitInfo.sWaitTime.dMic1Cin > dWaitTimeMax)
+		{
+			dWaitTimeMax	= sInitInfo.sWaitTime.dMic1Cin;
+		}
+	}
+	if(((bRegChange & MCB_PWM_MB2) != 0) || ((bRegChange & MCB_PWM_MC2) != 0))
+	{
+		if(sInitInfo.sWaitTime.dMic2Cin > dWaitTimeMax)
+		{
+			dWaitTimeMax	= sInitInfo.sWaitTime.dMic2Cin;
+		}
+	}
+	if(((bRegChange & MCB_PWM_MB3) != 0) || ((bRegChange & MCB_PWM_MC3) != 0))
+	{
+		if(sInitInfo.sWaitTime.dMic3Cin > dWaitTimeMax)
+		{
+			dWaitTimeMax	= sInitInfo.sWaitTime.dMic3Cin;
+		}
+	}
+
+#if (MCDRV_DEBUG_LEVEL>=4)
+	sdRet	= (SINT32)dWaitTimeMax;
+	McDebugLog_FuncOut("GetMaxWait", &sdRet);
+#endif
+
+	return dWaitTimeMax;
+}
+
diff --git a/sound/soc/codecs/mc1n2/mcpacking.h b/sound/soc/codecs/mc1n2/mcpacking.h
new file mode 100644
index 0000000..04202fc
--- /dev/null
+++ b/sound/soc/codecs/mc1n2/mcpacking.h
@@ -0,0 +1,91 @@
+/****************************************************************************
+ *
+ *		Copyright(c) 2010 Yamaha Corporation. All rights reserved.
+ *
+ *		Module		: mcpacking.h
+ *
+ *		Description	: MC Driver Packet packing header
+ *
+ *		Version		: 1.0.0 	2010.08.24
+ *
+ ****************************************************************************/
+
+#ifndef _MCPACKING_H_
+#define _MCPACKING_H_
+
+#include "mctypedef.h"
+#include "mcdriver.h"
+
+/* volume update */
+typedef enum
+{
+	eMCDRV_VOLUPDATE_MUTE,
+	eMCDRV_VOLUPDATE_ALL
+} MCDRV_VOLUPDATE_MODE;
+
+/*	power setting	*/
+#define	MCDRV_POWINFO_DIGITAL_DP0			((UINT32)0x0001)
+#define	MCDRV_POWINFO_DIGITAL_DP1			((UINT32)0x0002)
+#define	MCDRV_POWINFO_DIGITAL_DP2			((UINT32)0x0004)
+#define	MCDRV_POWINFO_DIGITAL_DPB			((UINT32)0x0008)
+#define	MCDRV_POWINFO_DIGITAL_DPDI0			((UINT32)0x0010)
+#define	MCDRV_POWINFO_DIGITAL_DPDI1			((UINT32)0x0020)
+#define	MCDRV_POWINFO_DIGITAL_DPDI2			((UINT32)0x0040)
+#define	MCDRV_POWINFO_DIGITAL_DPPDM			((UINT32)0x0080)
+#define	MCDRV_POWINFO_DIGITAL_DPBDSP		((UINT32)0x0100)
+#define	MCDRV_POWINFO_DIGITAL_DPADIF		((UINT32)0x0200)
+#define	MCDRV_POWINFO_DIGITAL_PLLRST0		((UINT32)0x0400)
+typedef struct
+{
+	UINT32	dDigital;
+	UINT8	abAnalog[5];
+} MCDRV_POWER_INFO;
+
+/* power update */
+typedef struct
+{
+	UINT32	dDigital;
+	UINT8	abAnalog[5];
+} MCDRV_POWER_UPDATE;
+
+#define	MCDRV_POWUPDATE_DIGITAL_ALL			(0xFFFFFFFFUL)
+#define	MCDRV_POWUPDATE_ANALOG0_ALL			(0x0F)
+#define	MCDRV_POWUPDATE_ANALOG1_ALL			(0xFF)
+#define	MCDRV_POWUPDATE_ANALOG2_ALL			(0x3F)
+#define	MCDRV_POWUPDATE_ANALOG3_ALL			(0x1F)
+#define	MCDRV_POWUPDATE_ANALOG4_ALL			(0xF0)
+#define	MCDRV_POWUPDATE_ANALOG0_IN			(0x0D)
+#define	MCDRV_POWUPDATE_ANALOG1_IN			(0xC0)
+#define	MCDRV_POWUPDATE_ANALOG2_IN			(0x00)
+#define	MCDRV_POWUPDATE_ANALOG3_IN			(0x1F)
+#define	MCDRV_POWUPDATE_ANALOG4_IN			(0xF0)
+#define	MCDRV_POWUPDATE_ANALOG0_OUT			(0x02)
+#define	MCDRV_POWUPDATE_ANALOG1_OUT			(0x3F)
+#define	MCDRV_POWUPDATE_ANALOG2_OUT			(0x3F)
+#define	MCDRV_POWUPDATE_ANALOG3_OUT			(0x00)
+#define	MCDRV_POWUPDATE_ANALOG4_OUT			(0x00)
+
+
+SINT32		McPacket_AddInit			(const MCDRV_INIT_INFO* psInitInfo);
+SINT32		McPacket_AddVol				(UINT32 dUpdate, MCDRV_VOLUPDATE_MODE eMode, UINT32* pdSVolDoneParam);
+SINT32		McPacket_AddPowerUp			(const MCDRV_POWER_INFO* psPowerInfo, const MCDRV_POWER_UPDATE* psPowerUpdate);
+SINT32		McPacket_AddPowerDown		(const MCDRV_POWER_INFO* psPowerInfo, const MCDRV_POWER_UPDATE* psPowerUpdate);
+SINT32		McPacket_AddPathSet			(void);
+SINT32		McPacket_AddMixSet			(void);
+SINT32		McPacket_AddStart			(void);
+SINT32		McPacket_AddStop			(void);
+SINT32		McPacket_AddDigitalIO		(UINT32 dUpdateInfo);
+SINT32		McPacket_AddDAC				(UINT32 dUpdateInfo);
+SINT32		McPacket_AddADC				(UINT32 dUpdateInfo);
+SINT32		McPacket_AddSP				(void);
+SINT32		McPacket_AddDNG				(UINT32 dUpdateInfo);
+SINT32		McPacket_AddAE				(UINT32 dUpdateInfo);
+SINT32		McPacket_AddPDM				(UINT32 dUpdateInfo);
+SINT32		McPacket_AddGPMode			(void);
+SINT32		McPacket_AddGPMask			(UINT32 dPadNo);
+SINT32		McPacket_AddGPSet			(UINT8 bGpio, UINT32 dPadNo);
+SINT32		McPacket_AddSysEq			(UINT32 dUpdateInfo);
+SINT32		McPacket_AddClockSwitch		(void);
+
+
+#endif /* _MCPACKING_H_ */
diff --git a/sound/soc/codecs/mc1n2/mcresctrl.c b/sound/soc/codecs/mc1n2/mcresctrl.c
new file mode 100644
index 0000000..bb30235
--- /dev/null
+++ b/sound/soc/codecs/mc1n2/mcresctrl.c
@@ -0,0 +1,9419 @@
+/****************************************************************************
+ *
+ *		Copyright(c) 2010 Yamaha Corporation. All rights reserved.
+ *
+ *		Module		: mcresctrl.c
+ *
+ *		Description	: MC Driver resource control
+ *
+ *		Version		: 1.0.0 	2010.09.10
+ *
+ ****************************************************************************/
+
+
+#include "mcresctrl.h"
+#include "mcdevif.h"
+#include "mcservice.h"
+#include "mcdriver.h"
+#include "mcdefs.h"
+#include "mcdevprof.h"
+#include "mcmachdep.h"
+#if MCDRV_DEBUG_LEVEL
+#include "mcdebuglog.h"
+#endif
+
+
+
+/* wait time */
+#define	MCDRV_INTERVAL_MUTE	(1000)
+#define	MCDRV_TIME_OUT_MUTE	(1000)
+
+
+static MCDRV_STATE	geState	= eMCDRV_STATE_NOTINIT;
+
+static MCDRV_GLOBAL_INFO	gsGlobalInfo;
+static MCDRV_PACKET			gasPacket[MCDRV_MAX_PACKETS+1];
+
+/* register next address */
+static const UINT16	gawNextAddressA[MCDRV_A_REG_NUM] =
+{
+	0,		1,		2,		0xFFFF,	0xFFFF,	0xFFFF,	0xFFFF,	0xFFFF,	8,		0xFFFF,	0xFFFF,	0xFFFF,	12,		13,		14,		15,
+	16,		17,		18,		19,		20,		21,		22,		23,		0xFFFF,	0xFFFF,	0xFFFF,	0xFFFF,	0xFFFF,	0xFFFF,	0xFFFF,	0xFFFF,
+	0xFFFF,	0xFFFF,	0xFFFF,	0xFFFF,	0xFFFF,	0xFFFF,	0xFFFF,	0xFFFF,	0xFFFF,	0xFFFF,	0xFFFF,	0xFFFF,	0xFFFF,	0xFFFF,	0xFFFF,	0xFFFF,
+	0xFFFF,	0xFFFF,	0xFFFF,	0xFFFF,	0xFFFF,	0xFFFF,	0xFFFF,	0xFFFF,	0xFFFF,	0xFFFF,	0xFFFF,	0xFFFF,	0xFFFF,	0xFFFF,	0xFFFF,	0xFFFF
+};
+
+static const UINT16	gawNextAddressB_BASE[MCDRV_B_BASE_REG_NUM] =
+{
+	1,		2,		3,		4,		5,		6,		7,		0xFFFF,	9,		10,		11,		12,		13,		0xFFFF,	0xFFFF,	0xFFFF,
+	0xFFFF,	0xFFFF,	0xFFFF,	0xFFFF,	0xFFFF,	0xFFFF,	0xFFFF,	0xFFFF,	0xFFFF,	26,		0xFFFF,	0xFFFF,	0xFFFF,	0xFFFF,	31,		0xFFFF
+};
+
+static const UINT16	gawNextAddressB_MIXER[MCDRV_B_MIXER_REG_NUM] =
+{
+	1,		2,		3,		4,		5,		6,		7,		8,		9,		10,		11,		12,		13,		14,		15,		16,
+	17,		18,		19,		20,		21,		22,		23,		24,		25,		26,		27,		28,		29,		30,		31,		32,
+	33,		34,		35,		36,		37,		38,		39,		40,		41,		42,		43,		44,		45,		46,		47,		48,
+	49,		50,		51,		52,		53,		54,		55,		56,		57,		58,		59,		60,		61,		62,		63,		64,
+	65,		66,		67,		68,		69,		70,		71,		72,		73,		74,		75,		76,		77,		78,		79,		80,
+	81,		82,		83,		84,		85,		86,		87,		88,		89,		90,		91,		92,		93,		94,		95,		96,
+	97,		98,		99,		100,	101,	102,	103,	104,	105,	106,	107,	108,	109,	110,	111,	112,
+	113,	114,	115,	116,	117,	118,	119,	120,	121,	122,	123,	124,	125,	126,	127,	128,
+	129,	130,	131,	132,	133,	134,	135,	136,	137,	138,	139,	140,	141,	142,	143,	144,
+	145,	146,	147,	148,	149,	150,	151,	152,	153,	154,	155,	156,	157,	158,	159,	160,
+	161,	162,	163,	164,	165,	166,	167,	168,	169,	170,	171,	172,	173,	174,	175,	176,
+	177,	178,	179,	180,	181,	182,	183,	184,	185,	186,	187,	188,	189,	190,	191,	192,
+	193,	194,	195,	196,	197,	198,	199,	200,	201,	202,	0xFFFF,	0xFFFF,	0xFFFF,	0xFFFF,	0xFFFF,	0xFFFF,
+	0xFFFF,	0xFFFF,	0xFFFF,	0xFFFF,	0xFFFF,	0xFFFF,	0xFFFF,	0xFFFF,	0xFFFF,	0xFFFF
+};
+
+static const UINT16	gawNextAddressB_AE[MCDRV_B_AE_REG_NUM] =
+{
+	1,		2,		3,		4,		5,		6,		7,		8,		9,		10,		11,		12,		13,		14,		15,		16,
+	17,		18,		19,		20,		21,		22,		23,		24,		25,		26,		27,		28,		29,		30,		31,		32,
+	33,		34,		35,		36,		37,		38,		39,		40,		41,		42,		43,		44,		45,		46,		47,		48,
+	49,		50,		51,		52,		53,		54,		55,		56,		57,		58,		59,		60,		61,		62,		63,		64,
+	65,		66,		67,		68,		69,		70,		71,		72,		73,		74,		75,		76,		77,		78,		79,		80,
+	81,		82,		83,		84,		85,		86,		87,		88,		89,		90,		91,		92,		93,		94,		95,		96,
+	97,		98,		99,		100,	101,	102,	103,	104,	105,	106,	107,	108,	109,	110,	111,	112,
+	113,	114,	115,	116,	117,	118,	119,	120,	121,	122,	123,	124,	125,	126,	127,	128,
+	129,	130,	131,	132,	133,	134,	135,	136,	137,	138,	139,	140,	141,	142,	143,	144,
+	145,	146,	147,	148,	149,	150,	151,	152,	153,	154,	155,	156,	157,	158,	159,	160,
+	161,	162,	163,	164,	165,	166,	167,	168,	169,	170,	171,	172,	173,	174,	175,	176,
+	177,	178,	179,	180,	181,	182,	183,	184,	185,	186,	187,	188,	189,	190,	191,	192,
+	193,	194,	195,	196,	197,	198,	199,	200,	201,	202,	203,	204,	205,	206,	207,	208,
+	209,	210,	211,	212,	213,	214,	215,	216,	217,	218,	219,	220,	221,	222,	223,	224,
+	225,	226,	227,	228,	229,	230,	231,	232,	233,	234,	235,	236,	237,	238,	239,	240,
+	241,	242,	243,	244,	245,	246,	247,	248,	249,	250,	251,	252,	253,	254,	0xFFFF
+};
+
+static const UINT16	gawNextAddressB_CDSP[MCDRV_B_CDSP_REG_NUM] =
+{
+	1,		2,		3,		4,		5,		6,		7,		8,		9,		10,		11,		12,		13,		14,		15,		16,
+	17,		18,		19,		20,		21,		22,		23,		24,		25,		26,		27,		28,		29,		30,		31,		32,
+	33,		34,		35,		36,		37,		38,		39,		40,		41,		42,		43,		44,		45,		46,		47,		48,
+	49,		50,		51,		52,		53,		54,		55,		56,		57,		58,		59,		60,		61,		62,		63,		64,
+	65,		66,		67,		68,		69,		70,		71,		72,		73,		74,		75,		76,		77,		78,		79,		80,
+	81,		82,		83,		84,		85,		86,		87,		88,		89,		90,		91,		92,		93,		94,		95,		96,
+	97,		98,		99,		100,	101,	102,	103,	104,	105,	106,	107,	108,	109,	110,	111,	112,
+	113,	114,	115,	116,	117,	118,	119,	120,	121,	122,	123,	124,	125,	126,	127,	128,
+	129,	0xFFFF
+};
+
+static const UINT16	gawNextAddressB_CODEC[MCDRV_B_CODEC_REG_NUM] =
+{
+	1,		2,		3,		4,		5,		6,		7,		8,		9,		10,		11,		12,		13,		14,		15,		16,
+	17,		18,		19,		20,		21,		22,		23,		24,		25,		26,		27,		28,		29,		30,		31,		32,
+	33,		34,		35,		36,		37,		38,		39,		40,		41,		42,		43,		44,		45,		46,		47,		48,
+	49,		50,		51,		52,		53,		54,		55,		56,		57,		58,		59,		60,		61,		62,		63,		64,
+	65,		66,		67,		68,		69,		70,		71,		72,		73,		74,		75,		76,		77,		78,		79,		80,
+	81,		82,		83,		84,		85,		86,		87,		88,		89,		90,		91,		92,		93,		94,		95,		96,
+	97,		98,		99,		100,	101,	102,	103,	104,	105,	106,	107,	108,	109,	110,	111,	112,
+	113,	114,	115,	116,	117,	118,	119,	120,	121,	122,	123,	124,	125,	126,	127,	0xFFFF
+};
+
+static const UINT16	gawNextAddressB_Ana[MCDRV_B_ANA_REG_NUM] =
+{
+	1,		2,		3,		4,		5,		6,		7,		8,		9,		10,		11,		12,		13,		14,		15,		16,
+	17,		18,		19,		20,		21,		22,		23,		24,		25,		26,		27,		28,		29,		30,		31,		32,
+	33,		34,		35,		36,		37,		38,		39,		40,		41,		42,		43,		44,		45,		46,		47,		48,
+	49,		50,		51,		52,		53,		54,		55,		56,		57,		58,		59,		60,		61,		62,		63,		64,
+	65,		66,		67,		68,		69,		70,		71,		72,		73,		74,		75,		76,		77,		0xFFFF,	79,		80,
+	81,		82,		83,		84,		85,		86,		87,		88,		89,		90,		91,		92,		93,		94,		95,		96,
+	97,		98,		99,		100,	101,	102,	103,	104,	105,	106,	107,	108,	109,	110,	111,	112,
+	113,	114,	115,	116,	117,	118,	119,	120,	121,	122,	123,	124,	125,	126,	127,	0xFFFF
+};
+
+/*	register access available	*/
+static const MCDRV_REG_ACCSESS	gawRegAccessAvailableA[256] =
+{
+	eMCDRV_READ_WRITE,	eMCDRV_READ_WRITE,	eMCDRV_READ_WRITE,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,
+	eMCDRV_READ_ONLY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_READ_WRITE,	eMCDRV_READ_WRITE,	eMCDRV_READ_WRITE,	eMCDRV_READ_WRITE,
+	eMCDRV_READ_WRITE,	eMCDRV_READ_WRITE,	eMCDRV_READ_WRITE,	eMCDRV_WRITE_ONLY,	eMCDRV_READ_WRITE,	eMCDRV_READ_WRITE,	eMCDRV_WRITE_ONLY,	eMCDRV_WRITE_ONLY,
+	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,
+	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,
+	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,
+	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,
+	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,
+	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,
+	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,
+	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,
+	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,
+	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,
+	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,
+	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,
+	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,
+	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,
+	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,
+	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,
+	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,
+	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,
+	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,
+	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,
+	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,
+	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,
+	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,
+	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,
+	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,
+	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,
+	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,
+	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,
+	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,
+};
+static const MCDRV_REG_ACCSESS	gawRegAccessAvailableB_BASE[256] =
+{
+	eMCDRV_READ_WRITE,	eMCDRV_READ_WRITE,	eMCDRV_ACCESS_DENY,	eMCDRV_READ_WRITE,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_READ_WRITE,	eMCDRV_ACCESS_DENY,
+	eMCDRV_ACCESS_DENY,	eMCDRV_READ_WRITE,	eMCDRV_READ_WRITE,	eMCDRV_READ_WRITE,	eMCDRV_READ_WRITE,	eMCDRV_READ_WRITE,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,
+	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,
+	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_READ_WRITE,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_READ_WRITE,	eMCDRV_READ_WRITE,
+	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,
+	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,
+	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,
+	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,
+	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,
+	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,
+	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,
+	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,
+	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,
+	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,
+	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,
+	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,
+	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,
+	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,
+	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,
+	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,
+	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,
+	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,
+	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,
+	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,
+	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,
+	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,
+	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,
+	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,
+	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,
+	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,
+	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,
+	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,
+};
+static const MCDRV_REG_ACCSESS	gawRegAccessAvailableB_ANA[256] =
+{
+	eMCDRV_READ_WRITE,	eMCDRV_ACCESS_DENY,	eMCDRV_READ_WRITE,	eMCDRV_READ_WRITE,	eMCDRV_READ_WRITE,	eMCDRV_READ_WRITE,	eMCDRV_READ_WRITE,	eMCDRV_ACCESS_DENY,
+	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_READ_ONLY,	eMCDRV_READ_ONLY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,
+	eMCDRV_READ_WRITE,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,
+	eMCDRV_READ_WRITE,	eMCDRV_READ_WRITE,	eMCDRV_READ_WRITE,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_READ_WRITE,	eMCDRV_READ_WRITE,	eMCDRV_READ_WRITE,
+	eMCDRV_READ_WRITE,	eMCDRV_READ_WRITE,	eMCDRV_ACCESS_DENY,	eMCDRV_READ_WRITE,	eMCDRV_READ_WRITE,	eMCDRV_READ_WRITE,	eMCDRV_READ_WRITE,	eMCDRV_READ_WRITE,
+	eMCDRV_READ_WRITE,	eMCDRV_READ_WRITE,	eMCDRV_READ_WRITE,	eMCDRV_READ_WRITE,	eMCDRV_READ_WRITE,	eMCDRV_READ_WRITE,	eMCDRV_READ_WRITE,	eMCDRV_READ_ONLY,
+	eMCDRV_READ_WRITE,	eMCDRV_ACCESS_DENY,	eMCDRV_READ_WRITE,	eMCDRV_READ_WRITE,	eMCDRV_READ_WRITE,	eMCDRV_READ_WRITE,	eMCDRV_ACCESS_DENY,	eMCDRV_READ_WRITE,
+	eMCDRV_READ_WRITE,	eMCDRV_READ_WRITE,	eMCDRV_READ_WRITE,	eMCDRV_READ_WRITE,	eMCDRV_READ_WRITE,	eMCDRV_READ_WRITE,	eMCDRV_READ_WRITE,	eMCDRV_READ_WRITE,
+	eMCDRV_READ_WRITE,	eMCDRV_READ_WRITE,	eMCDRV_READ_WRITE,	eMCDRV_READ_WRITE,	eMCDRV_READ_WRITE,	eMCDRV_READ_WRITE,	eMCDRV_READ_ONLY,	eMCDRV_ACCESS_DENY,
+	eMCDRV_READ_WRITE,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_READ_WRITE,	eMCDRV_READ_WRITE,	eMCDRV_READ_WRITE,	eMCDRV_ACCESS_DENY,	eMCDRV_READ_WRITE,
+	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_READ_WRITE,	eMCDRV_READ_WRITE,	eMCDRV_READ_WRITE,	eMCDRV_READ_WRITE,	eMCDRV_READ_WRITE,	eMCDRV_READ_WRITE,
+	eMCDRV_READ_WRITE,	eMCDRV_READ_WRITE,	eMCDRV_READ_WRITE,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,
+	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_READ_ONLY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,
+	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,
+	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,
+	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,
+	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,
+	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,
+	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,
+	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,
+	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,
+	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,
+	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,
+	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,
+	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,
+	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,
+	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,
+	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,
+	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,
+	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,
+	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,
+	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,
+};
+static const MCDRV_REG_ACCSESS	gawRegAccessAvailableB_CODEC[256] =
+{
+	eMCDRV_ACCESS_DENY,	eMCDRV_READ_WRITE,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_READ_WRITE,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,
+	eMCDRV_READ_ONLY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_READ_WRITE,
+	eMCDRV_READ_WRITE,	eMCDRV_READ_WRITE,	eMCDRV_READ_WRITE,	eMCDRV_READ_WRITE,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,
+	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,
+	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,
+	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,
+	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,
+	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,
+	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_READ_WRITE,	eMCDRV_ACCESS_DENY,
+	eMCDRV_READ_WRITE,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_READ_WRITE,	eMCDRV_READ_WRITE,	eMCDRV_READ_WRITE,
+	eMCDRV_WRITE_ONLY,	eMCDRV_WRITE_ONLY,	eMCDRV_WRITE_ONLY,	eMCDRV_WRITE_ONLY,	eMCDRV_WRITE_ONLY,	eMCDRV_WRITE_ONLY,	eMCDRV_WRITE_ONLY,	eMCDRV_WRITE_ONLY,
+	eMCDRV_WRITE_ONLY,	eMCDRV_WRITE_ONLY,	eMCDRV_WRITE_ONLY,	eMCDRV_WRITE_ONLY,	eMCDRV_WRITE_ONLY,	eMCDRV_WRITE_ONLY,	eMCDRV_WRITE_ONLY,	eMCDRV_READ_WRITE,
+	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,
+	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,
+	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,
+	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,
+	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,
+	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,
+	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,
+	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,
+	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,
+	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,
+	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,
+	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,
+	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,
+	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,
+	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,
+	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,
+	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,
+	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,
+	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,
+	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,
+};
+static const MCDRV_REG_ACCSESS	gawRegAccessAvailableB_MIX[256] =
+{
+	eMCDRV_READ_ONLY,	eMCDRV_READ_ONLY,	eMCDRV_READ_ONLY,	eMCDRV_READ_ONLY,	eMCDRV_READ_ONLY,	eMCDRV_READ_ONLY,	eMCDRV_READ_ONLY,	eMCDRV_READ_ONLY,
+	eMCDRV_READ_ONLY,	eMCDRV_READ_ONLY,	eMCDRV_READ_ONLY,	eMCDRV_READ_ONLY,	eMCDRV_READ_WRITE,	eMCDRV_READ_WRITE,	eMCDRV_READ_WRITE,	eMCDRV_READ_WRITE,
+	eMCDRV_READ_WRITE,	eMCDRV_READ_WRITE,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,
+	eMCDRV_READ_WRITE,	eMCDRV_READ_WRITE,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_READ_WRITE,	eMCDRV_READ_WRITE,	eMCDRV_READ_WRITE,	eMCDRV_READ_WRITE,
+	eMCDRV_READ_WRITE,	eMCDRV_READ_WRITE,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,
+	eMCDRV_READ_WRITE,	eMCDRV_READ_WRITE,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_READ_WRITE,	eMCDRV_READ_WRITE,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,
+	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_READ_WRITE,	eMCDRV_READ_WRITE,	eMCDRV_READ_WRITE,	eMCDRV_ACCESS_DENY,	eMCDRV_READ_WRITE,	eMCDRV_READ_WRITE,
+	eMCDRV_READ_WRITE,	eMCDRV_READ_WRITE,	eMCDRV_READ_WRITE,	eMCDRV_READ_WRITE,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_READ_WRITE,	eMCDRV_READ_WRITE,
+	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,
+	eMCDRV_READ_WRITE,	eMCDRV_ACCESS_DENY,	eMCDRV_READ_WRITE,	eMCDRV_READ_WRITE,	eMCDRV_READ_WRITE,	eMCDRV_READ_WRITE,	eMCDRV_READ_WRITE,	eMCDRV_READ_WRITE,
+	eMCDRV_READ_WRITE,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_READ_WRITE,	eMCDRV_READ_WRITE,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,
+	eMCDRV_ACCESS_DENY,	eMCDRV_READ_WRITE,	eMCDRV_READ_WRITE,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_READ_WRITE,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,
+	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,
+	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_READ_WRITE,	eMCDRV_READ_WRITE,
+	eMCDRV_READ_WRITE,	eMCDRV_READ_WRITE,	eMCDRV_ACCESS_DENY,	eMCDRV_READ_WRITE,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,
+	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,
+	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_READ_WRITE,	eMCDRV_READ_WRITE,	eMCDRV_READ_WRITE,	eMCDRV_READ_WRITE,	eMCDRV_READ_WRITE,	eMCDRV_READ_WRITE,
+	eMCDRV_READ_WRITE,	eMCDRV_READ_WRITE,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_READ_WRITE,	eMCDRV_READ_WRITE,
+	eMCDRV_READ_WRITE,	eMCDRV_READ_WRITE,	eMCDRV_READ_WRITE,	eMCDRV_READ_WRITE,	eMCDRV_READ_WRITE,	eMCDRV_READ_WRITE,	eMCDRV_READ_WRITE,	eMCDRV_READ_WRITE,
+	eMCDRV_READ_WRITE,	eMCDRV_READ_WRITE,	eMCDRV_READ_WRITE,	eMCDRV_READ_WRITE,	eMCDRV_READ_WRITE,	eMCDRV_READ_WRITE,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,
+	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_READ_WRITE,	eMCDRV_READ_WRITE,	eMCDRV_READ_WRITE,	eMCDRV_READ_WRITE,	eMCDRV_READ_WRITE,	eMCDRV_READ_WRITE,
+	eMCDRV_READ_WRITE,	eMCDRV_READ_WRITE,	eMCDRV_READ_WRITE,	eMCDRV_READ_WRITE,	eMCDRV_READ_WRITE,	eMCDRV_READ_WRITE,	eMCDRV_READ_WRITE,	eMCDRV_READ_WRITE,
+	eMCDRV_READ_WRITE,	eMCDRV_READ_WRITE,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_READ_WRITE,	eMCDRV_READ_WRITE,
+	eMCDRV_READ_WRITE,	eMCDRV_READ_WRITE,	eMCDRV_READ_WRITE,	eMCDRV_READ_WRITE,	eMCDRV_READ_WRITE,	eMCDRV_READ_WRITE,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,
+	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,
+	eMCDRV_READ_WRITE,	eMCDRV_ACCESS_DENY,	eMCDRV_READ_WRITE,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_READ_WRITE,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,
+	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,
+	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,
+	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,
+	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,
+	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,
+	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,
+};
+static const MCDRV_REG_ACCSESS	gawRegAccessAvailableB_AE[256] =
+{
+	eMCDRV_WRITE_ONLY,	eMCDRV_WRITE_ONLY,	eMCDRV_WRITE_ONLY,	eMCDRV_WRITE_ONLY,	eMCDRV_WRITE_ONLY,	eMCDRV_WRITE_ONLY,	eMCDRV_WRITE_ONLY,	eMCDRV_WRITE_ONLY,
+	eMCDRV_WRITE_ONLY,	eMCDRV_WRITE_ONLY,	eMCDRV_WRITE_ONLY,	eMCDRV_WRITE_ONLY,	eMCDRV_WRITE_ONLY,	eMCDRV_WRITE_ONLY,	eMCDRV_WRITE_ONLY,	eMCDRV_WRITE_ONLY,
+	eMCDRV_WRITE_ONLY,	eMCDRV_WRITE_ONLY,	eMCDRV_WRITE_ONLY,	eMCDRV_WRITE_ONLY,	eMCDRV_WRITE_ONLY,	eMCDRV_WRITE_ONLY,	eMCDRV_WRITE_ONLY,	eMCDRV_WRITE_ONLY,
+	eMCDRV_WRITE_ONLY,	eMCDRV_WRITE_ONLY,	eMCDRV_WRITE_ONLY,	eMCDRV_WRITE_ONLY,	eMCDRV_WRITE_ONLY,	eMCDRV_WRITE_ONLY,	eMCDRV_WRITE_ONLY,	eMCDRV_WRITE_ONLY,
+	eMCDRV_WRITE_ONLY,	eMCDRV_WRITE_ONLY,	eMCDRV_WRITE_ONLY,	eMCDRV_WRITE_ONLY,	eMCDRV_WRITE_ONLY,	eMCDRV_WRITE_ONLY,	eMCDRV_WRITE_ONLY,	eMCDRV_WRITE_ONLY,
+	eMCDRV_WRITE_ONLY,	eMCDRV_WRITE_ONLY,	eMCDRV_WRITE_ONLY,	eMCDRV_WRITE_ONLY,	eMCDRV_WRITE_ONLY,	eMCDRV_WRITE_ONLY,	eMCDRV_WRITE_ONLY,	eMCDRV_WRITE_ONLY,
+	eMCDRV_WRITE_ONLY,	eMCDRV_WRITE_ONLY,	eMCDRV_WRITE_ONLY,	eMCDRV_WRITE_ONLY,	eMCDRV_WRITE_ONLY,	eMCDRV_WRITE_ONLY,	eMCDRV_WRITE_ONLY,	eMCDRV_WRITE_ONLY,
+	eMCDRV_WRITE_ONLY,	eMCDRV_WRITE_ONLY,	eMCDRV_WRITE_ONLY,	eMCDRV_WRITE_ONLY,	eMCDRV_WRITE_ONLY,	eMCDRV_WRITE_ONLY,	eMCDRV_WRITE_ONLY,	eMCDRV_WRITE_ONLY,
+	eMCDRV_WRITE_ONLY,	eMCDRV_WRITE_ONLY,	eMCDRV_WRITE_ONLY,	eMCDRV_WRITE_ONLY,	eMCDRV_WRITE_ONLY,	eMCDRV_WRITE_ONLY,	eMCDRV_WRITE_ONLY,	eMCDRV_WRITE_ONLY,
+	eMCDRV_WRITE_ONLY,	eMCDRV_WRITE_ONLY,	eMCDRV_WRITE_ONLY,	eMCDRV_WRITE_ONLY,	eMCDRV_WRITE_ONLY,	eMCDRV_WRITE_ONLY,	eMCDRV_WRITE_ONLY,	eMCDRV_WRITE_ONLY,
+	eMCDRV_WRITE_ONLY,	eMCDRV_WRITE_ONLY,	eMCDRV_WRITE_ONLY,	eMCDRV_WRITE_ONLY,	eMCDRV_WRITE_ONLY,	eMCDRV_WRITE_ONLY,	eMCDRV_WRITE_ONLY,	eMCDRV_WRITE_ONLY,
+	eMCDRV_WRITE_ONLY,	eMCDRV_WRITE_ONLY,	eMCDRV_WRITE_ONLY,	eMCDRV_WRITE_ONLY,	eMCDRV_WRITE_ONLY,	eMCDRV_WRITE_ONLY,	eMCDRV_WRITE_ONLY,	eMCDRV_WRITE_ONLY,
+	eMCDRV_WRITE_ONLY,	eMCDRV_WRITE_ONLY,	eMCDRV_WRITE_ONLY,	eMCDRV_WRITE_ONLY,	eMCDRV_WRITE_ONLY,	eMCDRV_WRITE_ONLY,	eMCDRV_WRITE_ONLY,	eMCDRV_WRITE_ONLY,
+	eMCDRV_WRITE_ONLY,	eMCDRV_WRITE_ONLY,	eMCDRV_WRITE_ONLY,	eMCDRV_WRITE_ONLY,	eMCDRV_WRITE_ONLY,	eMCDRV_WRITE_ONLY,	eMCDRV_WRITE_ONLY,	eMCDRV_WRITE_ONLY,
+	eMCDRV_WRITE_ONLY,	eMCDRV_WRITE_ONLY,	eMCDRV_WRITE_ONLY,	eMCDRV_WRITE_ONLY,	eMCDRV_WRITE_ONLY,	eMCDRV_WRITE_ONLY,	eMCDRV_WRITE_ONLY,	eMCDRV_WRITE_ONLY,
+	eMCDRV_WRITE_ONLY,	eMCDRV_WRITE_ONLY,	eMCDRV_WRITE_ONLY,	eMCDRV_WRITE_ONLY,	eMCDRV_WRITE_ONLY,	eMCDRV_WRITE_ONLY,	eMCDRV_WRITE_ONLY,	eMCDRV_WRITE_ONLY,
+	eMCDRV_WRITE_ONLY,	eMCDRV_WRITE_ONLY,	eMCDRV_WRITE_ONLY,	eMCDRV_WRITE_ONLY,	eMCDRV_WRITE_ONLY,	eMCDRV_WRITE_ONLY,	eMCDRV_WRITE_ONLY,	eMCDRV_WRITE_ONLY,
+	eMCDRV_WRITE_ONLY,	eMCDRV_WRITE_ONLY,	eMCDRV_WRITE_ONLY,	eMCDRV_WRITE_ONLY,	eMCDRV_WRITE_ONLY,	eMCDRV_WRITE_ONLY,	eMCDRV_WRITE_ONLY,	eMCDRV_WRITE_ONLY,
+	eMCDRV_WRITE_ONLY,	eMCDRV_WRITE_ONLY,	eMCDRV_WRITE_ONLY,	eMCDRV_WRITE_ONLY,	eMCDRV_WRITE_ONLY,	eMCDRV_WRITE_ONLY,	eMCDRV_WRITE_ONLY,	eMCDRV_WRITE_ONLY,
+	eMCDRV_WRITE_ONLY,	eMCDRV_WRITE_ONLY,	eMCDRV_WRITE_ONLY,	eMCDRV_WRITE_ONLY,	eMCDRV_WRITE_ONLY,	eMCDRV_WRITE_ONLY,	eMCDRV_WRITE_ONLY,	eMCDRV_WRITE_ONLY,
+	eMCDRV_WRITE_ONLY,	eMCDRV_WRITE_ONLY,	eMCDRV_WRITE_ONLY,	eMCDRV_WRITE_ONLY,	eMCDRV_WRITE_ONLY,	eMCDRV_WRITE_ONLY,	eMCDRV_WRITE_ONLY,	eMCDRV_WRITE_ONLY,
+	eMCDRV_WRITE_ONLY,	eMCDRV_WRITE_ONLY,	eMCDRV_WRITE_ONLY,	eMCDRV_WRITE_ONLY,	eMCDRV_WRITE_ONLY,	eMCDRV_WRITE_ONLY,	eMCDRV_WRITE_ONLY,	eMCDRV_WRITE_ONLY,
+	eMCDRV_WRITE_ONLY,	eMCDRV_WRITE_ONLY,	eMCDRV_WRITE_ONLY,	eMCDRV_WRITE_ONLY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,
+	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,
+	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,
+	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,
+	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,
+	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,
+	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,
+	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,
+	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,
+	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,	eMCDRV_ACCESS_DENY,
+};
+
+
+static void		SetRegDefault(void);
+static void		InitPathInfo(void);
+static void		InitVolInfo(void);
+static void		InitDioInfo(void);
+static void		InitDacInfo(void);
+static void		InitAdcInfo(void);
+static void		InitSpInfo(void);
+static void		InitDngInfo(void);
+static void		InitAeInfo(void);
+static void		InitPdmInfo(void);
+static void		InitGpMode(void);
+static void		InitGpMask(void);
+static void		InitSysEq(void);
+static void		InitClockSwitch(void);
+
+static void		ValidateADC(void);
+static void		ValidateDAC(void);
+static void		ValidateAE(void);
+static void		ValidateMix(void);
+
+static void		SetHPSourceOnOff(const MCDRV_PATH_INFO* psPathInfo);
+static void		SetSPSourceOnOff(const MCDRV_PATH_INFO* psPathInfo);
+static void		SetRCVSourceOnOff(const MCDRV_PATH_INFO* psPathInfo);
+static void		SetLO1SourceOnOff(const MCDRV_PATH_INFO* psPathInfo);
+static void		SetLO2SourceOnOff(const MCDRV_PATH_INFO* psPathInfo);
+static void		SetPMSourceOnOff(const MCDRV_PATH_INFO* psPathInfo);
+static void		SetDIT0SourceOnOff(const MCDRV_PATH_INFO* psPathInfo);
+static void		SetDIT1SourceOnOff(const MCDRV_PATH_INFO* psPathInfo);
+static void		SetDIT2SourceOnOff(const MCDRV_PATH_INFO* psPathInfo);
+static void		SetDACSourceOnOff(const MCDRV_PATH_INFO* psPathInfo);
+static void		SetAESourceOnOff(const MCDRV_PATH_INFO* psPathInfo);
+static void		SetCDSPSourceOnOff(const MCDRV_PATH_INFO* psPathInfo);
+static void		SetADC0SourceOnOff(const MCDRV_PATH_INFO* psPathInfo);
+static void		SetADC1SourceOnOff(const MCDRV_PATH_INFO* psPathInfo);
+static void		SetMixSourceOnOff(const MCDRV_PATH_INFO* psPathInfo);
+static void		SetBiasSourceOnOff(const MCDRV_PATH_INFO* psPathInfo);
+
+static void		SetDIOCommon(const MCDRV_DIO_INFO* psDioInfo, UINT8 bPort);
+static void		SetDIODIR(const MCDRV_DIO_INFO* psDioInfo, UINT8 bPort);
+static void		SetDIODIT(const MCDRV_DIO_INFO* psDioInfo, UINT8 bPort);
+
+static SINT16	GetDigitalVolReg(SINT16 swVol);
+static SINT16	GetADVolReg(SINT16 swVol);
+static SINT16	GetLIVolReg(SINT16 swVol);
+static SINT16	GetMcVolReg(SINT16 swVol);
+static SINT16	GetMcGainReg(SINT16 swVol);
+static SINT16	GetHpVolReg(SINT16 swVol);
+static SINT16	GetHpGainReg(SINT16 swVol);
+static SINT16	GetSpVolReg(SINT16 swVol);
+static SINT16	GetRcVolReg(SINT16 swVol);
+static SINT16	GetLoVolReg(SINT16 swVol);
+
+static SINT32	WaitBitSet(UINT8 bSlaveAddr, UINT16 wRegAddr, UINT8 bBit, UINT32 dCycleTime, UINT32 dTimeOut);
+static SINT32	WaitBitRelease(UINT8 bSlaveAddr, UINT16 wRegAddr, UINT8 bBit, UINT32 dCycleTime, UINT32 dTimeOut);
+
+/****************************************************************************
+ *	McResCtrl_SetHwId
+ *
+ *	Description:
+ *			Set hardware ID.
+ *	Arguments:
+ *			bHwId	hardware ID
+ *	Return:
+ *			MCDRV_SUCCESS
+ *			MCDRV_ERROR_INIT
+ *
+ ****************************************************************************/
+SINT32	McResCtrl_SetHwId
+(
+	UINT8	bHwId
+)
+{
+	SINT32	sdRet	= MCDRV_SUCCESS;
+
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncIn("McResCtrl_SetHwId");
+#endif
+
+	gsGlobalInfo.bHwId	= bHwId;
+
+	switch (bHwId)
+	{
+	case MCDRV_HWID_AA:
+		McDevProf_SetDevId(eMCDRV_DEV_ID_1N2);
+		break;
+	case MCDRV_HWID_AB:
+		McDevProf_SetDevId(eMCDRV_DEV_ID_1N2);
+		break;
+	default:
+		sdRet	= MCDRV_ERROR_INIT;
+	}
+
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncOut("McResCtrl_SetHwId", &sdRet);
+#endif
+
+	return sdRet;
+}
+
+/****************************************************************************
+ *	McResCtrl_GetHwId
+ *
+ *	Description:
+ *			Get hardware ID.
+ *	Arguments:
+ *			none
+ *	Return:
+ *			hardware ID
+ *
+ ****************************************************************************/
+UINT8	McResCtrl_GetHwId
+(
+	void
+)
+{
+	SINT32	sdRet	= gsGlobalInfo.bHwId;
+
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncIn("McResCtrl_GetHwId");
+#endif
+
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncOut("McResCtrl_GetHwId", &sdRet);
+#endif
+
+	return (UINT8)sdRet;
+}
+
+/****************************************************************************
+ *	McResCtrl_Init
+ *
+ *	Description:
+ *			initialize the resource controller.
+ *	Arguments:
+ *			psInitInfo	pointer to the initialize information struct
+ *	Return:
+ *			none
+ *
+ ****************************************************************************/
+void	McResCtrl_Init
+(
+	const MCDRV_INIT_INFO*	psInitInfo
+)
+{
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncIn("McResCtrl_Init");
+#endif
+
+	gsGlobalInfo.ePacketBufAlloc	= eMCDRV_PACKETBUF_FREE;
+	SetRegDefault();
+
+	gsGlobalInfo.sInitInfo.bCkSel	= psInitInfo->bCkSel;
+	gsGlobalInfo.sInitInfo.bDivR0	= psInitInfo->bDivR0;
+	gsGlobalInfo.sInitInfo.bDivF0	= psInitInfo->bDivF0;
+	gsGlobalInfo.sInitInfo.bDivR1	= psInitInfo->bDivR1;
+	gsGlobalInfo.sInitInfo.bDivF1	= psInitInfo->bDivF1;
+	if(McDevProf_IsValid(eMCDRV_FUNC_RANGE) == 1)
+	{
+		gsGlobalInfo.sInitInfo.bRange0	= psInitInfo->bRange0;
+		gsGlobalInfo.sInitInfo.bRange1	= psInitInfo->bRange1;
+	}
+	else
+	{
+		gsGlobalInfo.sInitInfo.bRange0	= 0;
+		gsGlobalInfo.sInitInfo.bRange1	= 0;
+	}
+	if(McDevProf_IsValid(eMCDRV_FUNC_BYPASS) == 1)
+	{
+		gsGlobalInfo.sInitInfo.bBypass	= psInitInfo->bBypass;
+	}
+	else
+	{
+		gsGlobalInfo.sInitInfo.bBypass	= 0;
+	}
+	gsGlobalInfo.sInitInfo.bDioSdo0Hiz	= psInitInfo->bDioSdo0Hiz;
+	gsGlobalInfo.sInitInfo.bDioSdo1Hiz	= psInitInfo->bDioSdo1Hiz;
+	gsGlobalInfo.sInitInfo.bDioSdo2Hiz	= psInitInfo->bDioSdo2Hiz;
+	gsGlobalInfo.sInitInfo.bDioClk0Hiz	= psInitInfo->bDioClk0Hiz;
+	gsGlobalInfo.sInitInfo.bDioClk1Hiz	= psInitInfo->bDioClk1Hiz;
+	gsGlobalInfo.sInitInfo.bDioClk2Hiz	= psInitInfo->bDioClk2Hiz;
+	gsGlobalInfo.sInitInfo.bPcmHiz		= psInitInfo->bPcmHiz;
+	gsGlobalInfo.sInitInfo.bLineIn1Dif	= psInitInfo->bLineIn1Dif;
+	if(McDevProf_IsValid(eMCDRV_FUNC_LI2) == 1)
+	{
+		gsGlobalInfo.sInitInfo.bLineIn2Dif	= psInitInfo->bLineIn2Dif;
+	}
+	else
+	{
+		gsGlobalInfo.sInitInfo.bLineIn2Dif	= MCDRV_LINE_STEREO;
+	}
+	gsGlobalInfo.sInitInfo.bLineOut1Dif	= psInitInfo->bLineOut1Dif;
+	gsGlobalInfo.sInitInfo.bLineOut2Dif	= psInitInfo->bLineOut2Dif;
+	gsGlobalInfo.sInitInfo.bSpmn		= psInitInfo->bSpmn;
+	gsGlobalInfo.sInitInfo.bMic1Sng		= psInitInfo->bMic1Sng;
+	gsGlobalInfo.sInitInfo.bMic2Sng		= psInitInfo->bMic2Sng;
+	gsGlobalInfo.sInitInfo.bMic3Sng		= psInitInfo->bMic3Sng;
+	gsGlobalInfo.sInitInfo.bPowerMode	= psInitInfo->bPowerMode;
+	gsGlobalInfo.sInitInfo.bSpHiz		= psInitInfo->bSpHiz;
+	gsGlobalInfo.sInitInfo.bLdo			= psInitInfo->bLdo;
+	gsGlobalInfo.sInitInfo.bPad0Func	= psInitInfo->bPad0Func;
+	gsGlobalInfo.sInitInfo.bPad1Func	= psInitInfo->bPad1Func;
+	if(McDevProf_IsValid(eMCDRV_FUNC_PAD2) == 1)
+	{
+		gsGlobalInfo.sInitInfo.bPad2Func	= psInitInfo->bPad2Func;
+	}
+	else
+	{
+		gsGlobalInfo.sInitInfo.bPad2Func	= MCDRV_PAD_GPIO;
+	}
+	gsGlobalInfo.sInitInfo.bAvddLev		= psInitInfo->bAvddLev;
+	gsGlobalInfo.sInitInfo.bVrefLev		= psInitInfo->bVrefLev;
+	gsGlobalInfo.sInitInfo.bDclGain		= psInitInfo->bDclGain;
+	gsGlobalInfo.sInitInfo.bDclLimit	= psInitInfo->bDclLimit;
+	gsGlobalInfo.sInitInfo.bCpMod		= psInitInfo->bCpMod;
+	gsGlobalInfo.sInitInfo.bReserved1	= psInitInfo->bReserved1;
+	gsGlobalInfo.sInitInfo.bReserved2	= psInitInfo->bReserved2;
+	gsGlobalInfo.sInitInfo.bReserved3	= psInitInfo->bReserved3;
+	gsGlobalInfo.sInitInfo.bReserved4	= psInitInfo->bReserved4;
+	gsGlobalInfo.sInitInfo.bReserved5	= psInitInfo->bReserved5;
+	gsGlobalInfo.sInitInfo.sWaitTime	= psInitInfo->sWaitTime;
+
+	InitPathInfo();
+	InitVolInfo();
+	InitDioInfo();
+	InitDacInfo();
+	InitAdcInfo();
+	InitSpInfo();
+	InitDngInfo();
+	InitAeInfo();
+	InitPdmInfo();
+	InitGpMode();
+	InitGpMask();
+	InitSysEq();
+	InitClockSwitch();
+
+	McResCtrl_InitRegUpdate();
+
+	gsGlobalInfo.eAPMode = eMCDRV_APM_OFF;
+
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncOut("McResCtrl_Init", 0);
+#endif
+}
+
+/****************************************************************************
+ *	SetRegDefault
+ *
+ *	Description:
+ *			Initialize the virtual registers.
+ *	Arguments:
+ *			none
+ *	Return:
+ *			none
+ *
+ ****************************************************************************/
+static void	SetRegDefault
+(
+	void
+)
+{
+	UINT16	i;
+
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncIn("SetRegDefault");
+#endif
+
+	for(i = 0; i < MCDRV_A_REG_NUM; i++)
+	{
+		gsGlobalInfo.abRegValA[i]	= 0;
+	}
+	gsGlobalInfo.abRegValA[MCI_RST]		= MCI_RST_DEF;
+	gsGlobalInfo.abRegValA[MCI_HW_ID]	= MCI_HW_ID_DEF;
+
+	for(i = 0; i < MCDRV_B_BASE_REG_NUM; i++)
+	{
+		gsGlobalInfo.abRegValB_BASE[i]	= 0;
+	}
+	gsGlobalInfo.abRegValB_BASE[MCI_RSTB]				= MCI_RSTB_DEF;
+	gsGlobalInfo.abRegValB_BASE[MCI_PWM_DIGITAL]		= MCI_PWM_DIGITAL_DEF;
+	gsGlobalInfo.abRegValB_BASE[MCI_PWM_DIGITAL_1]		= MCI_PWM_DIGITAL_1_DEF;
+	gsGlobalInfo.abRegValB_BASE[MCI_PWM_DIGITAL_CDSP]	= MCI_PWM_DIGITAL_CDSP_DEF;
+	gsGlobalInfo.abRegValB_BASE[MCI_PWM_DIGITAL_BDSP]	= MCI_PWM_DIGITAL_BDSP_DEF;
+	gsGlobalInfo.abRegValB_BASE[MCI_SD_MSK]				= MCI_SD_MSK_DEF;
+	gsGlobalInfo.abRegValB_BASE[MCI_SD_MSK_1]			= MCI_SD_MSK_1_DEF;
+	gsGlobalInfo.abRegValB_BASE[MCI_BCLK_MSK]			= MCI_BCLK_MSK_DEF;
+	gsGlobalInfo.abRegValB_BASE[MCI_BCLK_MSK_1]			= MCI_BCLK_MSK_1_DEF;
+	gsGlobalInfo.abRegValB_BASE[MCI_BCKP]				= MCI_BCKP_DEF;
+	gsGlobalInfo.abRegValB_BASE[MCI_PA_MSK]				= MCI_PA_MSK_DEF;
+
+	for(i = 0; i < MCDRV_B_MIXER_REG_NUM; i++)
+	{
+		gsGlobalInfo.abRegValB_MIXER[i]	= 0;
+	}
+	gsGlobalInfo.abRegValB_MIXER[MCI_DIT_ININTP]	= MCI_DIT_ININTP_DEF;
+	gsGlobalInfo.abRegValB_MIXER[MCI_DIR_INTP]		= MCI_DIR_INTP_DEF;
+	gsGlobalInfo.abRegValB_MIXER[MCI_ADC_INTP]		= MCI_ADC_INTP_DEF;
+	gsGlobalInfo.abRegValB_MIXER[MCI_AINTP]			= MCI_AINTP_DEF;
+	gsGlobalInfo.abRegValB_MIXER[MCI_IINTP]			= MCI_IINTP_DEF;
+	gsGlobalInfo.abRegValB_MIXER[MCI_DAC_INTP]		= MCI_DAC_INTP_DEF;
+	gsGlobalInfo.abRegValB_MIXER[MCI_DIR0_CH]		= MCI_DIR0_CH_DEF;
+	gsGlobalInfo.abRegValB_MIXER[MCI_DIT0_SLOT]		= MCI_DIT0_SLOT_DEF;
+	gsGlobalInfo.abRegValB_MIXER[MCI_PCM_RX0]		= MCI_PCM_RX0_DEF;
+	gsGlobalInfo.abRegValB_MIXER[MCI_PCM_TX0]		= MCI_PCM_TX0_DEF;
+	gsGlobalInfo.abRegValB_MIXER[MCI_PCM_SLOT_TX0]	= MCI_PCM_SLOT_TX0_DEF;
+	gsGlobalInfo.abRegValB_MIXER[MCI_DIR1_CH]		= MCI_DIR1_CH_DEF;
+	gsGlobalInfo.abRegValB_MIXER[MCI_DIT1_SLOT]		= MCI_DIT1_SLOT_DEF;
+	gsGlobalInfo.abRegValB_MIXER[MCI_PCM_RX1]		= MCI_PCM_RX1_DEF;
+	gsGlobalInfo.abRegValB_MIXER[MCI_PCM_TX1]		= MCI_PCM_TX1_DEF;
+	gsGlobalInfo.abRegValB_MIXER[MCI_PCM_SLOT_TX1]	= MCI_PCM_SLOT_TX1_DEF;
+	gsGlobalInfo.abRegValB_MIXER[MCI_DIR2_CH]		= MCI_DIR2_CH_DEF;
+	gsGlobalInfo.abRegValB_MIXER[MCI_DIT2_SLOT]		= MCI_DIT2_SLOT_DEF;
+	gsGlobalInfo.abRegValB_MIXER[MCI_PCM_RX2]		= MCI_PCM_RX2_DEF;
+	gsGlobalInfo.abRegValB_MIXER[MCI_PCM_TX2]		= MCI_PCM_TX2_DEF;
+	gsGlobalInfo.abRegValB_MIXER[MCI_PCM_SLOT_TX2]	= MCI_PCM_SLOT_TX2_DEF;
+	gsGlobalInfo.abRegValB_MIXER[MCI_CDI_CH]		= MCI_CDI_CH_DEF;
+	gsGlobalInfo.abRegValB_MIXER[MCI_CDO_SLOT]		= MCI_CDO_SLOT_DEF;
+	gsGlobalInfo.abRegValB_MIXER[MCI_PDM_AGC]		= MCI_PDM_AGC_DEF;
+	gsGlobalInfo.abRegValB_MIXER[MCI_PDM_STWAIT]	= MCI_PDM_STWAIT_DEF;
+	gsGlobalInfo.abRegValB_MIXER[MCI_CHP_H]			= MCI_CHP_H_DEF;
+	gsGlobalInfo.abRegValB_MIXER[MCI_CHP_M]			= MCI_CHP_M_DEF;
+	gsGlobalInfo.abRegValB_MIXER[MCI_CHP_L]			= MCI_CHP_L_DEF;
+
+	for(i = 0; i < MCDRV_B_AE_REG_NUM; i++)
+	{
+		gsGlobalInfo.abRegValB_AE[i]	= 0;
+	}
+	gsGlobalInfo.abRegValB_AE[MCI_BAND0_CEQ0]	= MCI_BAND0_CEQ0_H_DEF;
+	gsGlobalInfo.abRegValB_AE[MCI_BAND1_CEQ0]	= MCI_BAND1_CEQ0_H_DEF;
+	gsGlobalInfo.abRegValB_AE[MCI_BAND2_CEQ0]	= MCI_BAND2_CEQ0_H_DEF;
+	gsGlobalInfo.abRegValB_AE[MCI_BAND3H_CEQ0]	= MCI_BAND3H_CEQ0_H_DEF;
+	gsGlobalInfo.abRegValB_AE[MCI_BAND4H_CEQ0]	= MCI_BAND4H_CEQ0_H_DEF;
+	gsGlobalInfo.abRegValB_AE[MCI_BAND5_CEQ0]	= MCI_BAND5_CEQ0_H_DEF;
+	gsGlobalInfo.abRegValB_AE[MCI_BAND6H_CEQ0]	= MCI_BAND6H_CEQ0_H_DEF;
+	gsGlobalInfo.abRegValB_AE[MCI_BAND7H_CEQ0]	= MCI_BAND7H_CEQ0_H_DEF;
+	gsGlobalInfo.abRegValB_AE[MCI_PDM_CHP0_H]	= MCI_PDM_CHP0_H_DEF;
+	gsGlobalInfo.abRegValB_AE[MCI_PDM_CHP0_M]	= MCI_PDM_CHP0_M_DEF;
+	gsGlobalInfo.abRegValB_AE[MCI_PDM_CHP0_L]	= MCI_PDM_CHP0_L_DEF;
+	gsGlobalInfo.abRegValB_AE[MCI_PDM_CHP1_H]	= MCI_PDM_CHP1_H_DEF;
+	gsGlobalInfo.abRegValB_AE[MCI_PDM_CHP1_M]	= MCI_PDM_CHP1_M_DEF;
+	gsGlobalInfo.abRegValB_AE[MCI_PDM_CHP1_L]	= MCI_PDM_CHP1_L_DEF;
+	gsGlobalInfo.abRegValB_AE[MCI_PDM_CHP3_H]	= MCI_PDM_CHP3_H_DEF;
+	gsGlobalInfo.abRegValB_AE[MCI_PDM_CHP3_M]	= MCI_PDM_CHP3_M_DEF;
+	gsGlobalInfo.abRegValB_AE[MCI_PDM_CHP3_L]	= MCI_PDM_CHP3_L_DEF;
+
+	for(i = 0; i < MCDRV_B_CDSP_REG_NUM; i++)
+	{
+		gsGlobalInfo.abRegValB_CDSP[i]	= 0;
+	}
+	gsGlobalInfo.abRegValB_CDSP[MCI_JOEMP]		= MCI_JOEMP_DEF;
+	gsGlobalInfo.abRegValB_CDSP[MCI_JEEMP]		= MCI_JEEMP_DEF;
+	gsGlobalInfo.abRegValB_CDSP[MCI_CDSP_SRST]	= MCI_CDSP_SRST_DEF;
+
+	for(i = 0; i < MCDRV_B_ANA_REG_NUM; i++)
+	{
+		gsGlobalInfo.abRegValB_ANA[i]	= 0;
+	}
+	gsGlobalInfo.abRegValB_ANA[MCI_ANA_RST]			= MCI_ANA_RST_DEF;
+	gsGlobalInfo.abRegValB_ANA[MCI_PWM_ANALOG_0]	= MCI_PWM_ANALOG_0_DEF;
+	gsGlobalInfo.abRegValB_ANA[MCI_PWM_ANALOG_1]	= MCI_PWM_ANALOG_1_DEF;
+	gsGlobalInfo.abRegValB_ANA[MCI_PWM_ANALOG_2]	= MCI_PWM_ANALOG_2_DEF;
+	gsGlobalInfo.abRegValB_ANA[MCI_PWM_ANALOG_3]	= MCI_PWM_ANALOG_3_DEF;
+	gsGlobalInfo.abRegValB_ANA[MCI_PWM_ANALOG_4]	= MCI_PWM_ANALOG_4_DEF;
+	gsGlobalInfo.abRegValB_ANA[MCI_HPVOL_L]			= MCI_HPVOL_L_DEF;
+	gsGlobalInfo.abRegValB_ANA[MCI_SPVOL_L]			= MCI_SPVOL_L_DEF;
+	gsGlobalInfo.abRegValB_ANA[MCI_RCVOL]			= MCI_RCVOL_DEF;
+	gsGlobalInfo.abRegValB_ANA[MCI_LEV]				= MCI_LEV_DEF;
+	gsGlobalInfo.abRegValB_ANA[MCI_DNGATRT_HP]		= MCI_DNGATRT_HP_DEF;
+	gsGlobalInfo.abRegValB_ANA[MCI_DNGTARGET_HP]	= MCI_DNGTARGET_HP_DEF;
+	gsGlobalInfo.abRegValB_ANA[MCI_DNGON_HP]		= MCI_DNGON_HP_DEF;
+	gsGlobalInfo.abRegValB_ANA[MCI_DNGATRT_SP]		= MCI_DNGATRT_SP_DEF;
+	gsGlobalInfo.abRegValB_ANA[MCI_DNGTARGET_SP]	= MCI_DNGTARGET_SP_DEF;
+	gsGlobalInfo.abRegValB_ANA[MCI_DNGON_SP]		= MCI_DNGON_SP_DEF;
+	gsGlobalInfo.abRegValB_ANA[MCI_DNGATRT_RC]		= MCI_DNGATRT_RC_DEF;
+	gsGlobalInfo.abRegValB_ANA[MCI_DNGTARGET_RC]	= MCI_DNGTARGET_RC_DEF;
+	gsGlobalInfo.abRegValB_ANA[MCI_DNGON_RC]		= MCI_DNGON_RC_DEF;
+
+	for(i = 0; i < MCDRV_B_CODEC_REG_NUM; i++)
+	{
+		gsGlobalInfo.abRegValB_CODEC[i]	= 0;
+	}
+	gsGlobalInfo.abRegValB_CODEC[MCI_DPADIF]		= MCI_DPADIF_DEF;
+	gsGlobalInfo.abRegValB_CODEC[MCI_PLL_RST]		= MCI_PLL_RST_DEF;
+	gsGlobalInfo.abRegValB_CODEC[MCI_DIVR0]			= MCI_DIVR0_DEF;
+	gsGlobalInfo.abRegValB_CODEC[MCI_DIVF0]			= MCI_DIVF0_DEF;
+	gsGlobalInfo.abRegValB_CODEC[MCI_DIVR1]			= MCI_DIVR1_DEF;
+	gsGlobalInfo.abRegValB_CODEC[MCI_DIVF1]			= MCI_DIVF1_DEF;
+	gsGlobalInfo.abRegValB_CODEC[MCI_AD_AGC]		= MCI_AD_AGC_DEF;
+	gsGlobalInfo.abRegValB_CODEC[MCI_DAC_CONFIG]	= MCI_DAC_CONFIG_DEF;
+	gsGlobalInfo.abRegValB_CODEC[MCI_SYS_CEQ0_19_12]= MCI_SYS_CEQ0_19_12_DEF;
+	gsGlobalInfo.abRegValB_CODEC[MCI_SYS_CEQ0_11_4]	= MCI_SYS_CEQ0_11_4_DEF;
+	gsGlobalInfo.abRegValB_CODEC[MCI_SYS_CEQ0_3_0]	= MCI_SYS_CEQ0_3_0_DEF;
+	gsGlobalInfo.abRegValB_CODEC[MCI_SYS_CEQ1_19_12]= MCI_SYS_CEQ1_19_12_DEF;
+	gsGlobalInfo.abRegValB_CODEC[MCI_SYS_CEQ1_11_4]	= MCI_SYS_CEQ1_11_4_DEF;
+	gsGlobalInfo.abRegValB_CODEC[MCI_SYS_CEQ1_3_0]	= MCI_SYS_CEQ1_3_0_DEF;
+	gsGlobalInfo.abRegValB_CODEC[MCI_SYS_CEQ2_19_12]= MCI_SYS_CEQ2_19_12_DEF;
+	gsGlobalInfo.abRegValB_CODEC[MCI_SYS_CEQ2_11_4]	= MCI_SYS_CEQ2_11_4_DEF;
+	gsGlobalInfo.abRegValB_CODEC[MCI_SYS_CEQ2_3_0]	= MCI_SYS_CEQ2_3_0_DEF;
+	gsGlobalInfo.abRegValB_CODEC[MCI_SYS_CEQ3_19_12]= MCI_SYS_CEQ3_19_12_DEF;
+	gsGlobalInfo.abRegValB_CODEC[MCI_SYS_CEQ3_11_4]	= MCI_SYS_CEQ3_11_4_DEF;
+	gsGlobalInfo.abRegValB_CODEC[MCI_SYS_CEQ3_3_0]	= MCI_SYS_CEQ3_3_0_DEF;
+	gsGlobalInfo.abRegValB_CODEC[MCI_SYS_CEQ4_19_12]= MCI_SYS_CEQ4_19_12_DEF;
+	gsGlobalInfo.abRegValB_CODEC[MCI_SYS_CEQ4_11_4]	= MCI_SYS_CEQ4_11_4_DEF;
+	gsGlobalInfo.abRegValB_CODEC[MCI_SYS_CEQ4_3_0]	= MCI_SYS_CEQ4_3_0_DEF;
+	gsGlobalInfo.abRegValB_CODEC[MCI_SYSTEM_EQON]	= MCI_SYSTEM_EQON_DEF;
+
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncOut("SetRegDefault", 0);
+#endif
+}
+
+/****************************************************************************
+ *	InitPathInfo
+ *
+ *	Description:
+ *			Initialize path info.
+ *	Arguments:
+ *			none
+ *	Return:
+ *			none
+ *
+ ****************************************************************************/
+static void	InitPathInfo
+(
+	void
+)
+{
+	UINT8	bCh, bBlockIdx;
+	UINT8	abOnOff[SOURCE_BLOCK_NUM];
+
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncIn("InitPathInfo");
+#endif
+
+	abOnOff[0]	= (MCDRV_SRC0_MIC1_OFF|MCDRV_SRC0_MIC2_OFF|MCDRV_SRC0_MIC3_OFF);
+	abOnOff[1]	= (MCDRV_SRC1_LINE1_L_OFF|MCDRV_SRC1_LINE1_R_OFF|MCDRV_SRC1_LINE1_M_OFF);
+	abOnOff[2]	= (MCDRV_SRC2_LINE2_L_OFF|MCDRV_SRC2_LINE2_R_OFF|MCDRV_SRC2_LINE2_M_OFF);
+	abOnOff[3]	= (MCDRV_SRC3_DIR0_OFF|MCDRV_SRC3_DIR1_OFF|MCDRV_SRC3_DIR2_OFF|MCDRV_SRC3_DIR2_DIRECT_OFF);
+	abOnOff[4]	= (MCDRV_SRC4_DTMF_OFF|MCDRV_SRC4_PDM_OFF|MCDRV_SRC4_ADC0_OFF|MCDRV_SRC4_ADC1_OFF);
+	abOnOff[5]	= (MCDRV_SRC5_DAC_L_OFF|MCDRV_SRC5_DAC_R_OFF|MCDRV_SRC5_DAC_M_OFF);
+	abOnOff[6]	= (MCDRV_SRC6_MIX_OFF|MCDRV_SRC6_AE_OFF|MCDRV_SRC6_CDSP_OFF|MCDRV_SRC6_CDSP_DIRECT_OFF);
+
+	for(bCh = 0; bCh < HP_PATH_CHANNELS; bCh++)
+	{
+		for(bBlockIdx = 0; bBlockIdx < SOURCE_BLOCK_NUM; bBlockIdx++)
+		{
+			gsGlobalInfo.sPathInfo.asHpOut[bCh].abSrcOnOff[bBlockIdx]	= abOnOff[bBlockIdx];
+		}
+	}
+	for(bCh = 0; bCh < SP_PATH_CHANNELS; bCh++)
+	{
+		for(bBlockIdx = 0; bBlockIdx < SOURCE_BLOCK_NUM; bBlockIdx++)
+		{
+			gsGlobalInfo.sPathInfo.asSpOut[bCh].abSrcOnOff[bBlockIdx]	= abOnOff[bBlockIdx];
+		}
+	}
+	for(bCh = 0; bCh < RC_PATH_CHANNELS; bCh++)
+	{
+		for(bBlockIdx = 0; bBlockIdx < SOURCE_BLOCK_NUM; bBlockIdx++)
+		{
+			gsGlobalInfo.sPathInfo.asRcOut[bCh].abSrcOnOff[bBlockIdx]	= abOnOff[bBlockIdx];
+		}
+	}
+	for(bCh = 0; bCh < LOUT1_PATH_CHANNELS; bCh++)
+	{
+		for(bBlockIdx = 0; bBlockIdx < SOURCE_BLOCK_NUM; bBlockIdx++)
+		{
+			gsGlobalInfo.sPathInfo.asLout1[bCh].abSrcOnOff[bBlockIdx]	= abOnOff[bBlockIdx];
+		}
+	}
+	for(bCh = 0; bCh < LOUT2_PATH_CHANNELS; bCh++)
+	{
+		for(bBlockIdx = 0; bBlockIdx < SOURCE_BLOCK_NUM; bBlockIdx++)
+		{
+			gsGlobalInfo.sPathInfo.asLout2[bCh].abSrcOnOff[bBlockIdx]	= abOnOff[bBlockIdx];
+		}
+	}
+	for(bCh = 0; bCh < PEAK_PATH_CHANNELS; bCh++)
+	{
+		for(bBlockIdx = 0; bBlockIdx < SOURCE_BLOCK_NUM; bBlockIdx++)
+		{
+			gsGlobalInfo.sPathInfo.asPeak[bCh].abSrcOnOff[bBlockIdx]	= abOnOff[bBlockIdx];
+		}
+	}
+	for(bCh = 0; bCh < DIT0_PATH_CHANNELS; bCh++)
+	{
+		for(bBlockIdx = 0; bBlockIdx < SOURCE_BLOCK_NUM; bBlockIdx++)
+		{
+			gsGlobalInfo.sPathInfo.asDit0[bCh].abSrcOnOff[bBlockIdx]	= abOnOff[bBlockIdx];
+		}
+	}
+	for(bCh = 0; bCh < DIT1_PATH_CHANNELS; bCh++)
+	{
+		for(bBlockIdx = 0; bBlockIdx < SOURCE_BLOCK_NUM; bBlockIdx++)
+		{
+			gsGlobalInfo.sPathInfo.asDit1[bCh].abSrcOnOff[bBlockIdx]	= abOnOff[bBlockIdx];
+		}
+	}
+	for(bCh = 0; bCh < DIT2_PATH_CHANNELS; bCh++)
+	{
+		for(bBlockIdx = 0; bBlockIdx < SOURCE_BLOCK_NUM; bBlockIdx++)
+		{
+			gsGlobalInfo.sPathInfo.asDit2[bCh].abSrcOnOff[bBlockIdx]	= abOnOff[bBlockIdx];
+		}
+	}
+	for(bCh = 0; bCh < DAC_PATH_CHANNELS; bCh++)
+	{
+		for(bBlockIdx = 0; bBlockIdx < SOURCE_BLOCK_NUM; bBlockIdx++)
+		{
+			gsGlobalInfo.sPathInfo.asDac[bCh].abSrcOnOff[bBlockIdx]	= abOnOff[bBlockIdx];
+		}
+	}
+	for(bCh = 0; bCh < AE_PATH_CHANNELS; bCh++)
+	{
+		for(bBlockIdx = 0; bBlockIdx < SOURCE_BLOCK_NUM; bBlockIdx++)
+		{
+			gsGlobalInfo.sPathInfo.asAe[bCh].abSrcOnOff[bBlockIdx]	= abOnOff[bBlockIdx];
+		}
+	}
+	for(bCh = 0; bCh < CDSP_PATH_CHANNELS; bCh++)
+	{
+		for(bBlockIdx = 0; bBlockIdx < SOURCE_BLOCK_NUM; bBlockIdx++)
+		{
+			gsGlobalInfo.sPathInfo.asCdsp[bCh].abSrcOnOff[bBlockIdx]	= abOnOff[bBlockIdx];
+		}
+	}
+	for(bCh = 0; bCh < ADC0_PATH_CHANNELS; bCh++)
+	{
+		for(bBlockIdx = 0; bBlockIdx < SOURCE_BLOCK_NUM; bBlockIdx++)
+		{
+			gsGlobalInfo.sPathInfo.asAdc0[bCh].abSrcOnOff[bBlockIdx]	= abOnOff[bBlockIdx];
+		}
+	}
+	for(bCh = 0; bCh < ADC1_PATH_CHANNELS; bCh++)
+	{
+		for(bBlockIdx = 0; bBlockIdx < SOURCE_BLOCK_NUM; bBlockIdx++)
+		{
+			gsGlobalInfo.sPathInfo.asAdc1[bCh].abSrcOnOff[bBlockIdx]	= abOnOff[bBlockIdx];
+		}
+	}
+	for(bCh = 0; bCh < MIX_PATH_CHANNELS; bCh++)
+	{
+		for(bBlockIdx = 0; bBlockIdx < SOURCE_BLOCK_NUM; bBlockIdx++)
+		{
+			gsGlobalInfo.sPathInfo.asMix[bCh].abSrcOnOff[bBlockIdx]	= abOnOff[bBlockIdx];
+		}
+	}
+	for(bCh = 0; bCh < BIAS_PATH_CHANNELS; bCh++)
+	{
+		for(bBlockIdx = 0; bBlockIdx < SOURCE_BLOCK_NUM; bBlockIdx++)
+		{
+			gsGlobalInfo.sPathInfo.asBias[bCh].abSrcOnOff[bBlockIdx]	= abOnOff[bBlockIdx];
+		}
+	}
+	gsGlobalInfo.sPathInfoVirtual	= gsGlobalInfo.sPathInfo;
+
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncOut("InitPathInfo", 0);
+#endif
+}
+
+/****************************************************************************
+ *	InitVolInfo
+ *
+ *	Description:
+ *			Initialize volume info.
+ *	Arguments:
+ *			none
+ *	Return:
+ *			none
+ *
+ ****************************************************************************/
+static void	InitVolInfo
+(
+	void
+)
+{
+	UINT8	bCh;
+
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncIn("InitVolInfo");
+#endif
+
+	for(bCh = 0; bCh < AD0_VOL_CHANNELS; bCh++)
+	{
+		gsGlobalInfo.sVolInfo.aswD_Ad0[bCh]			= MCDRV_LOGICAL_VOL_MUTE;
+	}
+	for(bCh = 0; bCh < AD1_VOL_CHANNELS; bCh++)
+	{
+		gsGlobalInfo.sVolInfo.aswD_Ad1[bCh]			= MCDRV_LOGICAL_VOL_MUTE;
+	}
+	for(bCh = 0; bCh < AENG6_VOL_CHANNELS; bCh++)
+	{
+		gsGlobalInfo.sVolInfo.aswD_Aeng6[bCh]		= MCDRV_LOGICAL_VOL_MUTE;
+	}
+	for(bCh = 0; bCh < PDM_VOL_CHANNELS; bCh++)
+	{
+		gsGlobalInfo.sVolInfo.aswD_Pdm[bCh]			= MCDRV_LOGICAL_VOL_MUTE;
+	}
+	for(bCh = 0; bCh < DTMF_VOL_CHANNELS; bCh++)
+	{
+		gsGlobalInfo.sVolInfo.aswD_Dtmfb[bCh]		= MCDRV_LOGICAL_VOL_MUTE;
+	}
+	for(bCh = 0; bCh < DIO0_VOL_CHANNELS; bCh++)
+	{
+		gsGlobalInfo.sVolInfo.aswD_Dir0[bCh]		= MCDRV_LOGICAL_VOL_MUTE;
+	}
+	for(bCh = 0; bCh < DIO1_VOL_CHANNELS; bCh++)
+	{
+		gsGlobalInfo.sVolInfo.aswD_Dir1[bCh]		= MCDRV_LOGICAL_VOL_MUTE;
+	}
+	for(bCh = 0; bCh < DIO2_VOL_CHANNELS; bCh++)
+	{
+		gsGlobalInfo.sVolInfo.aswD_Dir2[bCh]		= MCDRV_LOGICAL_VOL_MUTE;
+	}
+	for(bCh = 0; bCh < AD0_VOL_CHANNELS; bCh++)
+	{
+		gsGlobalInfo.sVolInfo.aswD_Ad0Att[bCh]		= MCDRV_LOGICAL_VOL_MUTE;
+	}
+	for(bCh = 0; bCh < AD1_VOL_CHANNELS; bCh++)
+	{
+		gsGlobalInfo.sVolInfo.aswD_Ad1Att[bCh]		= MCDRV_LOGICAL_VOL_MUTE;
+	}
+	for(bCh = 0; bCh < DIO0_VOL_CHANNELS; bCh++)
+	{
+		gsGlobalInfo.sVolInfo.aswD_Dir0Att[bCh]		= MCDRV_LOGICAL_VOL_MUTE;
+	}
+	for(bCh = 0; bCh < DIO1_VOL_CHANNELS; bCh++)
+	{
+		gsGlobalInfo.sVolInfo.aswD_Dir1Att[bCh]		= MCDRV_LOGICAL_VOL_MUTE;
+	}
+	for(bCh = 0; bCh < DIO2_VOL_CHANNELS; bCh++)
+	{
+		gsGlobalInfo.sVolInfo.aswD_Dir2Att[bCh]		= MCDRV_LOGICAL_VOL_MUTE;
+	}
+	for(bCh = 0; bCh < PDM_VOL_CHANNELS; bCh++)
+	{
+		gsGlobalInfo.sVolInfo.aswD_SideTone[bCh]	= MCDRV_LOGICAL_VOL_MUTE;
+	}
+	for(bCh = 0; bCh < DTFM_VOL_CHANNELS; bCh++)
+	{
+		gsGlobalInfo.sVolInfo.aswD_DtmfAtt[bCh]		= MCDRV_LOGICAL_VOL_MUTE;
+	}
+	for(bCh = 0; bCh < DAC_VOL_CHANNELS; bCh++)
+	{
+		gsGlobalInfo.sVolInfo.aswD_DacMaster[bCh]	= MCDRV_LOGICAL_VOL_MUTE;
+	}
+	for(bCh = 0; bCh < DAC_VOL_CHANNELS; bCh++)
+	{
+		gsGlobalInfo.sVolInfo.aswD_DacVoice[bCh]	= MCDRV_LOGICAL_VOL_MUTE;
+	}
+	for(bCh = 0; bCh < DAC_VOL_CHANNELS; bCh++)
+	{
+		gsGlobalInfo.sVolInfo.aswD_DacAtt[bCh]		= MCDRV_LOGICAL_VOL_MUTE;
+	}
+	for(bCh = 0; bCh < DIO0_VOL_CHANNELS; bCh++)
+	{
+		gsGlobalInfo.sVolInfo.aswD_Dit0[bCh]		= MCDRV_LOGICAL_VOL_MUTE;
+	}
+	for(bCh = 0; bCh < DIO1_VOL_CHANNELS; bCh++)
+	{
+		gsGlobalInfo.sVolInfo.aswD_Dit1[bCh]		= MCDRV_LOGICAL_VOL_MUTE;
+	}
+	for(bCh = 0; bCh < DIO2_VOL_CHANNELS; bCh++)
+	{
+		gsGlobalInfo.sVolInfo.aswD_Dit2[bCh]		= MCDRV_LOGICAL_VOL_MUTE;
+	}
+	for(bCh = 0; bCh < AD0_VOL_CHANNELS; bCh++)
+	{
+		gsGlobalInfo.sVolInfo.aswA_Ad0[bCh]			= MCDRV_LOGICAL_VOL_MUTE;
+	}
+	for(bCh = 0; bCh < AD1_VOL_CHANNELS; bCh++)
+	{
+		gsGlobalInfo.sVolInfo.aswA_Ad1[bCh]			= MCDRV_LOGICAL_VOL_MUTE;
+	}
+	for(bCh = 0; bCh < LIN1_VOL_CHANNELS; bCh++)
+	{
+		gsGlobalInfo.sVolInfo.aswA_Lin1[bCh]		= MCDRV_LOGICAL_VOL_MUTE;
+	}
+	for(bCh = 0; bCh < LIN2_VOL_CHANNELS; bCh++)	
+	{
+		gsGlobalInfo.sVolInfo.aswA_Lin2[bCh]		= MCDRV_LOGICAL_VOL_MUTE;
+	}
+	for(bCh = 0; bCh < MIC1_VOL_CHANNELS; bCh++)	
+	{
+		gsGlobalInfo.sVolInfo.aswA_Mic1[bCh]		= MCDRV_LOGICAL_VOL_MUTE;
+	}
+	for(bCh = 0; bCh < MIC2_VOL_CHANNELS; bCh++)	
+	{
+		gsGlobalInfo.sVolInfo.aswA_Mic2[bCh]		= MCDRV_LOGICAL_VOL_MUTE;
+	}
+	for(bCh = 0; bCh < MIC3_VOL_CHANNELS; bCh++)	
+	{
+		gsGlobalInfo.sVolInfo.aswA_Mic3[bCh]		= MCDRV_LOGICAL_VOL_MUTE;
+	}
+	for(bCh = 0; bCh < HP_VOL_CHANNELS; bCh++)
+	{
+		gsGlobalInfo.sVolInfo.aswA_Hp[bCh]			= MCDRV_LOGICAL_VOL_MUTE;
+	}
+	for(bCh = 0; bCh < SP_VOL_CHANNELS; bCh++)
+	{
+		gsGlobalInfo.sVolInfo.aswA_Sp[bCh]			= MCDRV_LOGICAL_VOL_MUTE;
+	}
+	for(bCh = 0; bCh < RC_VOL_CHANNELS; bCh++)
+	{
+		gsGlobalInfo.sVolInfo.aswA_Rc[bCh]			= MCDRV_LOGICAL_VOL_MUTE;
+	}
+	for(bCh = 0; bCh < LOUT1_VOL_CHANNELS; bCh++)
+	{
+		gsGlobalInfo.sVolInfo.aswA_Lout1[bCh]		= MCDRV_LOGICAL_VOL_MUTE;
+	}
+	for(bCh = 0; bCh < LOUT2_VOL_CHANNELS; bCh++)
+	{
+		gsGlobalInfo.sVolInfo.aswA_Lout2[bCh]		= MCDRV_LOGICAL_VOL_MUTE;
+	}
+	for(bCh = 0; bCh < MIC1_VOL_CHANNELS; bCh++)
+	{
+		gsGlobalInfo.sVolInfo.aswA_Mic1Gain[bCh]	= MCDRV_LOGICAL_MICGAIN_DEF;
+	}
+	for(bCh = 0; bCh < MIC2_VOL_CHANNELS; bCh++)
+	{
+		gsGlobalInfo.sVolInfo.aswA_Mic2Gain[bCh]	= MCDRV_LOGICAL_MICGAIN_DEF;
+	}
+	for(bCh = 0; bCh < MIC3_VOL_CHANNELS; bCh++)
+	{
+		gsGlobalInfo.sVolInfo.aswA_Mic3Gain[bCh]	= MCDRV_LOGICAL_MICGAIN_DEF;
+	}
+	for(bCh = 0; bCh < HPGAIN_VOL_CHANNELS; bCh++)
+	{
+		gsGlobalInfo.sVolInfo.aswA_HpGain[bCh]		= MCDRV_LOGICAL_HPGAIN_DEF;
+	}
+
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncOut("InitVolInfo", 0);
+#endif
+}
+
+/****************************************************************************
+ *	InitDioInfo
+ *
+ *	Description:
+ *			Initialize Digital I/O info.
+ *	Arguments:
+ *			none
+ *	Return:
+ *			none
+ *
+ ****************************************************************************/
+static void	InitDioInfo
+(
+	void
+)
+{
+	UINT8	bDioIdx, bDioCh;
+
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncIn("InitDioInfo");
+#endif
+
+	for(bDioIdx = 0; bDioIdx < 3; bDioIdx++)
+	{
+		gsGlobalInfo.sDioInfo.asPortInfo[bDioIdx].sDioCommon.bMasterSlave	= MCDRV_DIO_SLAVE;
+		gsGlobalInfo.sDioInfo.asPortInfo[bDioIdx].sDioCommon.bAutoFs		= MCDRV_AUTOFS_ON;
+		gsGlobalInfo.sDioInfo.asPortInfo[bDioIdx].sDioCommon.bFs			= MCDRV_FS_48000;
+		gsGlobalInfo.sDioInfo.asPortInfo[bDioIdx].sDioCommon.bBckFs			= MCDRV_BCKFS_64;
+		gsGlobalInfo.sDioInfo.asPortInfo[bDioIdx].sDioCommon.bInterface		= MCDRV_DIO_DA;
+		gsGlobalInfo.sDioInfo.asPortInfo[bDioIdx].sDioCommon.bBckInvert		= MCDRV_BCLK_NORMAL;
+		gsGlobalInfo.sDioInfo.asPortInfo[bDioIdx].sDioCommon.bPcmHizTim		= MCDRV_PCMHIZTIM_FALLING;
+		gsGlobalInfo.sDioInfo.asPortInfo[bDioIdx].sDioCommon.bPcmClkDown	= MCDRV_PCM_CLKDOWN_OFF;
+		gsGlobalInfo.sDioInfo.asPortInfo[bDioIdx].sDioCommon.bPcmFrame		= MCDRV_PCM_SHORTFRAME;
+		gsGlobalInfo.sDioInfo.asPortInfo[bDioIdx].sDioCommon.bPcmHighPeriod	= 0;
+
+		gsGlobalInfo.sDioInfo.asPortInfo[bDioIdx].sDir.wSrcRate				= 0x0000;
+		gsGlobalInfo.sDioInfo.asPortInfo[bDioIdx].sDir.sDaFormat.bBitSel	= MCDRV_BITSEL_16;
+		gsGlobalInfo.sDioInfo.asPortInfo[bDioIdx].sDir.sDaFormat.bMode		= MCDRV_DAMODE_HEADALIGN;
+		gsGlobalInfo.sDioInfo.asPortInfo[bDioIdx].sDir.sPcmFormat.bMono		= MCDRV_PCM_MONO;
+		gsGlobalInfo.sDioInfo.asPortInfo[bDioIdx].sDir.sPcmFormat.bOrder	= MCDRV_PCM_MSB_FIRST;
+		gsGlobalInfo.sDioInfo.asPortInfo[bDioIdx].sDir.sPcmFormat.bLaw		= MCDRV_PCM_LINEAR;
+		gsGlobalInfo.sDioInfo.asPortInfo[bDioIdx].sDir.sPcmFormat.bBitSel	= MCDRV_PCM_BITSEL_8;
+		for(bDioCh = 0; bDioCh < DIO_CHANNELS; bDioCh++)
+		{
+			gsGlobalInfo.sDioInfo.asPortInfo[bDioIdx].sDir.abSlot[bDioCh]	= bDioCh;
+		}
+
+		gsGlobalInfo.sDioInfo.asPortInfo[bDioIdx].sDit.wSrcRate				= 0x0000;
+		gsGlobalInfo.sDioInfo.asPortInfo[bDioIdx].sDit.sDaFormat.bBitSel	= MCDRV_BITSEL_16;
+		gsGlobalInfo.sDioInfo.asPortInfo[bDioIdx].sDit.sDaFormat.bMode		= MCDRV_DAMODE_HEADALIGN;
+		gsGlobalInfo.sDioInfo.asPortInfo[bDioIdx].sDit.sPcmFormat.bMono		= MCDRV_PCM_MONO;
+		gsGlobalInfo.sDioInfo.asPortInfo[bDioIdx].sDit.sPcmFormat.bOrder	= MCDRV_PCM_MSB_FIRST;
+		gsGlobalInfo.sDioInfo.asPortInfo[bDioIdx].sDit.sPcmFormat.bLaw		= MCDRV_PCM_LINEAR;
+		gsGlobalInfo.sDioInfo.asPortInfo[bDioIdx].sDit.sPcmFormat.bBitSel	= MCDRV_PCM_BITSEL_8;
+		for(bDioCh = 0; bDioCh < DIO_CHANNELS; bDioCh++)
+		{
+			gsGlobalInfo.sDioInfo.asPortInfo[bDioIdx].sDit.abSlot[bDioCh]	= bDioCh;
+		}
+	}
+
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncOut("InitDioInfo", 0);
+#endif
+}
+
+/****************************************************************************
+ *	InitDacInfo
+ *
+ *	Description:
+ *			Initialize Dac info.
+ *	Arguments:
+ *			none
+ *	Return:
+ *			none
+ *
+ ****************************************************************************/
+static void	InitDacInfo
+(
+	void
+)
+{
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncIn("InitDacInfo");
+#endif
+
+	gsGlobalInfo.sDacInfo.bMasterSwap	= MCDRV_DSWAP_OFF;
+	gsGlobalInfo.sDacInfo.bVoiceSwap	= MCDRV_DSWAP_OFF;
+	gsGlobalInfo.sDacInfo.bDcCut		= MCDRV_DCCUT_ON;
+
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncOut("InitDacInfo", 0);
+#endif
+}
+
+/****************************************************************************
+ *	InitAdcInfo
+ *
+ *	Description:
+ *			Initialize Adc info.
+ *	Arguments:
+ *			none
+ *	Return:
+ *			none
+ *
+ ****************************************************************************/
+static void	InitAdcInfo
+(
+	void
+)
+{
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncIn("InitAdcInfo");
+#endif
+
+	gsGlobalInfo.sAdcInfo.bAgcAdjust	= MCDRV_AGCADJ_0;
+	gsGlobalInfo.sAdcInfo.bAgcOn		= MCDRV_AGC_OFF;
+	gsGlobalInfo.sAdcInfo.bMono			= MCDRV_ADC_STEREO;
+
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncOut("InitAdcInfo", 0);
+#endif
+}
+
+/****************************************************************************
+ *	InitSpInfo
+ *
+ *	Description:
+ *			Initialize SP info.
+ *	Arguments:
+ *			none
+ *	Return:
+ *			none
+ *
+ ****************************************************************************/
+static void	InitSpInfo
+(
+	void
+)
+{
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncIn("InitSpInfo");
+#endif
+
+	gsGlobalInfo.sSpInfo.bSwap	= MCDRV_SPSWAP_OFF;
+
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncOut("InitSpInfo", 0);
+#endif
+}
+
+/****************************************************************************
+ *	InitDngInfo
+ *
+ *	Description:
+ *			Initialize DNG info.
+ *	Arguments:
+ *			none
+ *	Return:
+ *			none
+ *
+ ****************************************************************************/
+static void	InitDngInfo
+(
+	void
+)
+{
+	UINT8	bItem;
+
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncIn("InitDngInfo");
+#endif
+
+	for(bItem = MCDRV_DNG_ITEM_HP; bItem <= MCDRV_DNG_ITEM_RC; bItem++)
+	{
+		gsGlobalInfo.sDngInfo.abOnOff[bItem]		= MCDRV_DNG_OFF;
+		gsGlobalInfo.sDngInfo.abThreshold[bItem]	= MCDRV_DNG_THRES_60;
+		gsGlobalInfo.sDngInfo.abHold[bItem]		= MCDRV_DNG_HOLD_500;
+		gsGlobalInfo.sDngInfo.abAttack[bItem]	= MCDRV_DNG_ATTACK_800;
+		gsGlobalInfo.sDngInfo.abRelease[bItem]	= MCDRV_DNG_RELEASE_940;
+		gsGlobalInfo.sDngInfo.abTarget[bItem]	= MCDRV_DNG_TARGET_MUTE;
+	}
+
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncOut("InitDngInfo", 0);
+#endif
+}
+
+/****************************************************************************
+ *	InitAeInfo
+ *
+ *	Description:
+ *			Initialize Audio Engine info.
+ *	Arguments:
+ *			none
+ *	Return:
+ *			none
+ *
+ ****************************************************************************/
+static void	InitAeInfo
+(
+	void
+)
+{
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncIn("InitAeInfo");
+#endif
+
+	gsGlobalInfo.sAeInfo.bOnOff		= 0;
+
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncOut("InitAeInfo", 0);
+#endif
+}
+
+/****************************************************************************
+ *	InitPdmInfo
+ *
+ *	Description:
+ *			Initialize Pdm info.
+ *	Arguments:
+ *			none
+ *	Return:
+ *			none
+ *
+ ****************************************************************************/
+static void	InitPdmInfo
+(
+	void
+)
+{
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncIn("InitPdmInfo");
+#endif
+
+	gsGlobalInfo.sPdmInfo.bClk			= MCDRV_PDM_CLK_64;
+	gsGlobalInfo.sPdmInfo.bAgcAdjust	= MCDRV_AGCADJ_0;
+	gsGlobalInfo.sPdmInfo.bAgcOn		= MCDRV_AGC_OFF;
+	gsGlobalInfo.sPdmInfo.bPdmEdge		= MCDRV_PDMEDGE_LH;
+	gsGlobalInfo.sPdmInfo.bPdmWait		= MCDRV_PDMWAIT_10;
+	gsGlobalInfo.sPdmInfo.bPdmSel		= MCDRV_PDMSEL_L1R2;
+	gsGlobalInfo.sPdmInfo.bMono			= MCDRV_PDM_STEREO;
+
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncOut("InitPdmInfo", 0);
+#endif
+}
+
+/****************************************************************************
+ *	InitGpMode
+ *
+ *	Description:
+ *			Initialize Gp mode.
+ *	Arguments:
+ *			none
+ *	Return:
+ *			none
+ *
+ ****************************************************************************/
+static void	InitGpMode
+(
+	void
+)
+{
+	UINT8	bGpioIdx;
+
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncIn("InitGpMode");
+#endif
+
+	for(bGpioIdx = 0; bGpioIdx < GPIO_PAD_NUM; bGpioIdx++)
+	{
+		gsGlobalInfo.sGpMode.abGpDdr[bGpioIdx]		= MCDRV_GPDDR_IN;
+		gsGlobalInfo.sGpMode.abGpMode[bGpioIdx]		= MCDRV_GPMODE_RISING;
+		gsGlobalInfo.sGpMode.abGpHost[bGpioIdx]		= MCDRV_GPHOST_SCU;
+		gsGlobalInfo.sGpMode.abGpInvert[bGpioIdx]	= MCDRV_GPINV_NORMAL;
+	}
+
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncOut("InitGpMode", 0);
+#endif
+}
+
+/****************************************************************************
+ *	InitGpMask
+ *
+ *	Description:
+ *			Initialize Gp mask.
+ *	Arguments:
+ *			none
+ *	Return:
+ *			none
+ *
+ ****************************************************************************/
+static void	InitGpMask
+(
+	void
+)
+{
+	UINT8	bGpioIdx;
+
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncIn("InitGpMask");
+#endif
+
+	for(bGpioIdx = 0; bGpioIdx < GPIO_PAD_NUM; bGpioIdx++)
+	{
+		gsGlobalInfo.abGpMask[bGpioIdx]		= MCDRV_GPMASK_ON;
+	}
+
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncOut("InitGpMask", 0);
+#endif
+}
+
+/****************************************************************************
+ *	InitSysEq
+ *
+ *	Description:
+ *			Initialize System EQ.
+ *	Arguments:
+ *			none
+ *	Return:
+ *			none
+ *
+ ****************************************************************************/
+static void	InitSysEq
+(
+	void
+)
+{
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncIn("InitSysEq");
+#endif
+
+	gsGlobalInfo.sSysEq.bOnOff		= MCDRV_SYSEQ_ON;
+	gsGlobalInfo.sSysEq.abParam[0]	= 0x10;
+	gsGlobalInfo.sSysEq.abParam[1]	= 0xC4;
+	gsGlobalInfo.sSysEq.abParam[2]	= 0x50;
+	gsGlobalInfo.sSysEq.abParam[3]	= 0x12;
+	gsGlobalInfo.sSysEq.abParam[4]	= 0xC4;
+	gsGlobalInfo.sSysEq.abParam[5]	= 0x40;
+	gsGlobalInfo.sSysEq.abParam[6]	= 0x02;
+	gsGlobalInfo.sSysEq.abParam[7]	= 0xA9;
+	gsGlobalInfo.sSysEq.abParam[8]	= 0x60;
+	gsGlobalInfo.sSysEq.abParam[9]	= 0xED;
+	gsGlobalInfo.sSysEq.abParam[10]	= 0x3B;
+	gsGlobalInfo.sSysEq.abParam[11]	= 0xC0;
+	gsGlobalInfo.sSysEq.abParam[12]	= 0xFC;
+	gsGlobalInfo.sSysEq.abParam[13]	= 0x92;
+	gsGlobalInfo.sSysEq.abParam[14]	= 0x40;
+
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncOut("InitSysEq", 0);
+#endif
+}
+
+/****************************************************************************
+ *	InitClockSwitch
+ *
+ *	Description:
+ *			Initialize switch clock info.
+ *	Arguments:
+ *			none
+ *	Return:
+ *			none
+ *
+ ****************************************************************************/
+static void	InitClockSwitch
+(
+	void
+)
+{
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncIn("InitClockSwitch");
+#endif
+
+	gsGlobalInfo.sClockSwitch.bClkSrc	= MCDRV_CLKSW_CLKI0;
+
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncOut("InitClockSwitch", 0);
+#endif
+}
+
+/****************************************************************************
+ *	McResCtrl_UpdateState
+ *
+ *	Description:
+ *			update state.
+ *	Arguments:
+ *			eState	state
+ *	Return:
+ *			none
+ *
+ ****************************************************************************/
+void	McResCtrl_UpdateState
+(
+	MCDRV_STATE	eState
+)
+{
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncIn("McResCtrl_UpdateState");
+#endif
+
+	geState = eState;
+
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncOut("McResCtrl_UpdateState", 0);
+#endif
+}
+
+/****************************************************************************
+ *	McResCtrl_GetState
+ *
+ *	Description:
+ *			Get state.
+ *	Arguments:
+ *			none
+ *	Return:
+ *			current state
+ *
+ ****************************************************************************/
+MCDRV_STATE	McResCtrl_GetState
+(
+	void
+)
+{
+#if (MCDRV_DEBUG_LEVEL>=4)
+	SINT32	sdRet	= geState;
+	McDebugLog_FuncIn("McResCtrl_GetState");
+#endif
+
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncOut("McResCtrl_GetState", &sdRet);
+#endif
+
+	return geState;
+}
+
+/****************************************************************************
+ *	McResCtrl_GetRegVal
+ *
+ *	Description:
+ *			Get register value.
+ *	Arguments:
+ *			wRegType	register type
+ *			wRegAddr	address
+ *	Return:
+ *			register value
+ *
+ ****************************************************************************/
+UINT8	McResCtrl_GetRegVal
+(
+	UINT16	wRegType,
+	UINT16	wRegAddr
+)
+{
+	UINT8	bVal	= 0;
+
+#if (MCDRV_DEBUG_LEVEL>=4)
+	SINT32	sdRet;
+	McDebugLog_FuncIn("McResCtrl_GetRegVal");
+#endif
+
+	switch(wRegType)
+	{
+	case	MCDRV_PACKET_REGTYPE_A:
+		bVal	= gsGlobalInfo.abRegValA[wRegAddr];
+		break;
+	case	MCDRV_PACKET_REGTYPE_B_BASE:
+		bVal	= gsGlobalInfo.abRegValB_BASE[wRegAddr];
+		break;
+	case	MCDRV_PACKET_REGTYPE_B_MIXER:
+		bVal	= gsGlobalInfo.abRegValB_MIXER[wRegAddr];
+		break;
+	case	MCDRV_PACKET_REGTYPE_B_AE:
+		bVal	= gsGlobalInfo.abRegValB_AE[wRegAddr];
+		break;
+	case	MCDRV_PACKET_REGTYPE_B_CDSP:
+		bVal	= gsGlobalInfo.abRegValB_CDSP[wRegAddr];
+		break;
+	case	MCDRV_PACKET_REGTYPE_B_CODEC:
+		bVal	= gsGlobalInfo.abRegValB_CODEC[wRegAddr];
+		break;
+	case	MCDRV_PACKET_REGTYPE_B_ANA:
+		bVal	= gsGlobalInfo.abRegValB_ANA[wRegAddr];
+		break;
+	default:
+		break;
+	}
+
+#if (MCDRV_DEBUG_LEVEL>=4)
+	sdRet	= (SINT32)bVal;
+	McDebugLog_FuncOut("McResCtrl_GetRegVal", &sdRet);
+#endif
+
+	return bVal;
+}
+
+/****************************************************************************
+ *	McResCtrl_SetRegVal
+ *
+ *	Description:
+ *			Set register value.
+ *	Arguments:
+ *			wRegType	register type
+ *			wRegAddr	address
+ *			bRegVal		register value
+ *	Return:
+ *			none
+ *
+ ****************************************************************************/
+void	McResCtrl_SetRegVal
+(
+	UINT16	wRegType,
+	UINT16	wRegAddr,
+	UINT8	bRegVal
+)
+{
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncIn("McResCtrl_SetRegVal");
+#endif
+
+	switch(wRegType)
+	{
+	case	MCDRV_PACKET_REGTYPE_A:
+		gsGlobalInfo.abRegValA[wRegAddr]		= bRegVal;
+		break;
+	case	MCDRV_PACKET_REGTYPE_B_BASE:
+		gsGlobalInfo.abRegValB_BASE[wRegAddr]	= bRegVal;
+		break;
+	case	MCDRV_PACKET_REGTYPE_B_MIXER:
+		gsGlobalInfo.abRegValB_MIXER[wRegAddr]	= bRegVal;
+		break;
+	case	MCDRV_PACKET_REGTYPE_B_AE:
+		gsGlobalInfo.abRegValB_AE[wRegAddr]		= bRegVal;
+		break;
+	case	MCDRV_PACKET_REGTYPE_B_CDSP:
+		gsGlobalInfo.abRegValB_CDSP[wRegAddr]	= bRegVal;
+		break;
+	case	MCDRV_PACKET_REGTYPE_B_CODEC:
+		gsGlobalInfo.abRegValB_CODEC[wRegAddr]	= bRegVal;
+		break;
+	case	MCDRV_PACKET_REGTYPE_B_ANA:
+		gsGlobalInfo.abRegValB_ANA[wRegAddr]	= bRegVal;
+		break;
+	default:
+		break;
+	}
+
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncOut("McResCtrl_SetRegVal", 0);
+#endif
+}
+
+/****************************************************************************
+ *	McResCtrl_GetInitInfo
+ *
+ *	Description:
+ *			Get Initialize information.
+ *	Arguments:
+ *			psInitInfo	Initialize information
+ *	Return:
+ *			none
+ *
+ ****************************************************************************/
+void	McResCtrl_GetInitInfo
+(
+	MCDRV_INIT_INFO*	psInitInfo
+)
+{
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncIn("McResCtrl_GetInitInfo");
+#endif
+
+	*psInitInfo	= gsGlobalInfo.sInitInfo;
+
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncOut("McResCtrl_GetInitInfo", 0);
+#endif
+}
+
+/****************************************************************************
+ *	McResCtrl_SetClockInfo
+ *
+ *	Description:
+ *			Set clock information.
+ *	Arguments:
+ *			psClockInfo	clock information
+ *	Return:
+ *			none
+ *
+ ****************************************************************************/
+void	McResCtrl_SetClockInfo
+(
+	const MCDRV_CLOCK_INFO* psClockInfo
+)
+{
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncIn("McResCtrl_SetClockInfo");
+#endif
+
+
+	gsGlobalInfo.sInitInfo.bCkSel	= psClockInfo->bCkSel;
+	gsGlobalInfo.sInitInfo.bDivR0	= psClockInfo->bDivR0;
+	gsGlobalInfo.sInitInfo.bDivF0	= psClockInfo->bDivF0;
+	gsGlobalInfo.sInitInfo.bDivR1	= psClockInfo->bDivR1;
+	gsGlobalInfo.sInitInfo.bDivF1	= psClockInfo->bDivF1;
+	if(McDevProf_IsValid(eMCDRV_FUNC_RANGE) == 1)
+	{
+		gsGlobalInfo.sInitInfo.bRange0	= psClockInfo->bRange0;
+		gsGlobalInfo.sInitInfo.bRange1	= psClockInfo->bRange1;
+	}
+	if(McDevProf_IsValid(eMCDRV_FUNC_BYPASS) == 1)
+	{
+		gsGlobalInfo.sInitInfo.bBypass	= psClockInfo->bBypass;
+	}
+
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncOut("McResCtrl_SetClockInfo", 0);
+#endif
+}
+
+/****************************************************************************
+ *	McResCtrl_SetPathInfo
+ *
+ *	Description:
+ *			Set path information.
+ *	Arguments:
+ *			psPathInfo	path information
+ *	Return:
+ *			none
+ *
+ ****************************************************************************/
+void	McResCtrl_SetPathInfo
+(
+	const MCDRV_PATH_INFO*	psPathInfo
+)
+{
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncIn("McResCtrl_SetPathInfo");
+#endif
+
+
+	gsGlobalInfo.sPathInfo	= gsGlobalInfo.sPathInfoVirtual;
+
+	/*	HP source on/off	*/
+	SetHPSourceOnOff(psPathInfo);
+
+	/*	SP source on/off	*/
+	SetSPSourceOnOff(psPathInfo);
+
+	/*	RCV source on/off	*/
+	SetRCVSourceOnOff(psPathInfo);
+
+	/*	LOut1 source on/off	*/
+	SetLO1SourceOnOff(psPathInfo);
+
+	/*	LOut2 source on/off	*/
+	SetLO2SourceOnOff(psPathInfo);
+
+	/*	Peak source on/off	*/
+	SetPMSourceOnOff(psPathInfo);
+
+	/*	DIT0 source on/off	*/
+	SetDIT0SourceOnOff(psPathInfo);
+
+	/*	DIT1 source on/off	*/
+	SetDIT1SourceOnOff(psPathInfo);
+
+	/*	DIT2 source on/off	*/
+	SetDIT2SourceOnOff(psPathInfo);
+
+	/*	DAC source on/off	*/
+	SetDACSourceOnOff(psPathInfo);
+
+	/*	AE source on/off	*/
+	SetAESourceOnOff(psPathInfo);
+
+	/*	CDSP source on/off	*/
+	SetCDSPSourceOnOff(psPathInfo);
+
+	/*	ADC0 source on/off	*/
+	SetADC0SourceOnOff(psPathInfo);
+
+	/*	ADC1 source on/off	*/
+	SetADC1SourceOnOff(psPathInfo);
+
+	/*	Mix source on/off	*/
+	SetMixSourceOnOff(psPathInfo);
+
+	/*	Bias source on/off	*/
+	SetBiasSourceOnOff(psPathInfo);
+
+	gsGlobalInfo.sPathInfoVirtual	= gsGlobalInfo.sPathInfo;
+
+	ValidateADC();
+	ValidateDAC();
+
+	ValidateAE();
+	ValidateMix();
+	ValidateAE();
+
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncOut("McResCtrl_SetPathInfo", 0);
+#endif
+}
+
+/****************************************************************************
+ *	ValidateADC
+ *
+ *	Description:
+ *			Validate ADC setting.
+ *	Arguments:
+ *			none
+ *	Return:
+ *			none
+ *
+ ****************************************************************************/
+static void	ValidateADC
+(
+	void
+)
+{
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncIn("ValidateADC");
+#endif
+
+	if((McResCtrl_IsDstUsed(eMCDRV_DST_ADC0, eMCDRV_DST_CH0) == 0)
+	&& (McResCtrl_IsDstUsed(eMCDRV_DST_ADC0, eMCDRV_DST_CH1) == 0))
+	{/*	ADC0 source all off	*/
+		gsGlobalInfo.sPathInfo.asDit0[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK]	&= (UINT8)~MCDRV_SRC4_ADC0_ON;
+		gsGlobalInfo.sPathInfo.asDit1[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK]	&= (UINT8)~MCDRV_SRC4_ADC0_ON;
+		gsGlobalInfo.sPathInfo.asDit2[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK]	&= (UINT8)~MCDRV_SRC4_ADC0_ON;
+		gsGlobalInfo.sPathInfo.asDac[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK]	&= (UINT8)~MCDRV_SRC4_ADC0_ON;
+		gsGlobalInfo.sPathInfo.asDac[1].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK]	&= (UINT8)~MCDRV_SRC4_ADC0_ON;
+		gsGlobalInfo.sPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK]		&= (UINT8)~MCDRV_SRC4_ADC0_ON;
+		gsGlobalInfo.sPathInfo.asMix[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK]	&= (UINT8)~MCDRV_SRC4_ADC0_ON;
+		gsGlobalInfo.sPathInfo.asDit0[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK]	|= MCDRV_SRC4_ADC0_OFF;
+		gsGlobalInfo.sPathInfo.asDit1[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK]	|= MCDRV_SRC4_ADC0_OFF;
+		gsGlobalInfo.sPathInfo.asDit2[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK]	|= MCDRV_SRC4_ADC0_OFF;
+		gsGlobalInfo.sPathInfo.asDac[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK]	|= MCDRV_SRC4_ADC0_OFF;
+		gsGlobalInfo.sPathInfo.asDac[1].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK]	|= MCDRV_SRC4_ADC0_OFF;
+		gsGlobalInfo.sPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK]		|= MCDRV_SRC4_ADC0_OFF;
+		gsGlobalInfo.sPathInfo.asMix[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK]	|= MCDRV_SRC4_ADC0_OFF;
+	}
+
+	if(McResCtrl_IsSrcUsed(eMCDRV_SRC_ADC0) == 0)
+	{
+		gsGlobalInfo.sPathInfo.asAdc0[0].abSrcOnOff[MCDRV_SRC_MIC1_BLOCK]		&= (UINT8)~MCDRV_SRC0_MIC1_ON;
+		gsGlobalInfo.sPathInfo.asAdc0[0].abSrcOnOff[MCDRV_SRC_MIC2_BLOCK]		&= (UINT8)~MCDRV_SRC0_MIC2_ON;
+		gsGlobalInfo.sPathInfo.asAdc0[0].abSrcOnOff[MCDRV_SRC_MIC3_BLOCK]		&= (UINT8)~MCDRV_SRC0_MIC3_ON;
+		gsGlobalInfo.sPathInfo.asAdc0[0].abSrcOnOff[MCDRV_SRC_LINE1_L_BLOCK]	&= (UINT8)~MCDRV_SRC1_LINE1_L_ON;
+		gsGlobalInfo.sPathInfo.asAdc0[0].abSrcOnOff[MCDRV_SRC_LINE1_M_BLOCK]	&= (UINT8)~MCDRV_SRC1_LINE1_M_ON;
+		gsGlobalInfo.sPathInfo.asAdc0[1].abSrcOnOff[MCDRV_SRC_MIC1_BLOCK]		&= (UINT8)~MCDRV_SRC0_MIC1_ON;
+		gsGlobalInfo.sPathInfo.asAdc0[1].abSrcOnOff[MCDRV_SRC_MIC2_BLOCK]		&= (UINT8)~MCDRV_SRC0_MIC2_ON;
+		gsGlobalInfo.sPathInfo.asAdc0[1].abSrcOnOff[MCDRV_SRC_MIC3_BLOCK]		&= (UINT8)~MCDRV_SRC0_MIC3_ON;
+		gsGlobalInfo.sPathInfo.asAdc0[1].abSrcOnOff[MCDRV_SRC_LINE1_R_BLOCK]	&= (UINT8)~MCDRV_SRC1_LINE1_R_ON;
+		gsGlobalInfo.sPathInfo.asAdc0[1].abSrcOnOff[MCDRV_SRC_LINE1_M_BLOCK]	&= (UINT8)~MCDRV_SRC1_LINE1_M_ON;
+
+		gsGlobalInfo.sPathInfo.asAdc0[0].abSrcOnOff[MCDRV_SRC_MIC1_BLOCK]		|= MCDRV_SRC0_MIC1_OFF;
+		gsGlobalInfo.sPathInfo.asAdc0[0].abSrcOnOff[MCDRV_SRC_MIC2_BLOCK]		|= MCDRV_SRC0_MIC2_OFF;
+		gsGlobalInfo.sPathInfo.asAdc0[0].abSrcOnOff[MCDRV_SRC_MIC3_BLOCK]		|= MCDRV_SRC0_MIC3_OFF;
+		gsGlobalInfo.sPathInfo.asAdc0[0].abSrcOnOff[MCDRV_SRC_LINE1_L_BLOCK]	|= MCDRV_SRC1_LINE1_L_OFF;
+		gsGlobalInfo.sPathInfo.asAdc0[0].abSrcOnOff[MCDRV_SRC_LINE1_M_BLOCK]	|= MCDRV_SRC1_LINE1_M_OFF;
+		gsGlobalInfo.sPathInfo.asAdc0[1].abSrcOnOff[MCDRV_SRC_MIC1_BLOCK]		|= MCDRV_SRC0_MIC1_OFF;
+		gsGlobalInfo.sPathInfo.asAdc0[1].abSrcOnOff[MCDRV_SRC_MIC2_BLOCK]		|= MCDRV_SRC0_MIC2_OFF;
+		gsGlobalInfo.sPathInfo.asAdc0[1].abSrcOnOff[MCDRV_SRC_MIC3_BLOCK]		|= MCDRV_SRC0_MIC3_OFF;
+		gsGlobalInfo.sPathInfo.asAdc0[1].abSrcOnOff[MCDRV_SRC_LINE1_R_BLOCK]	|= MCDRV_SRC1_LINE1_R_OFF;
+		gsGlobalInfo.sPathInfo.asAdc0[1].abSrcOnOff[MCDRV_SRC_LINE1_M_BLOCK]	|= MCDRV_SRC1_LINE1_M_OFF;
+	}
+
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncOut("ValidateADC", 0);
+#endif
+}
+
+/****************************************************************************
+ *	ValidateDAC
+ *
+ *	Description:
+ *			Validate DAC setting.
+ *	Arguments:
+ *			none
+ *	Return:
+ *			none
+ *
+ ****************************************************************************/
+static void	ValidateDAC
+(
+	void
+)
+{
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncIn("ValidateDAC");
+#endif
+
+	if((McResCtrl_IsSrcUsed(eMCDRV_SRC_DAC_L) == 0)
+	&& (McResCtrl_IsSrcUsed(eMCDRV_SRC_DAC_M) == 0)
+	&& (McResCtrl_IsSrcUsed(eMCDRV_SRC_DAC_R) == 0))
+	{/*	DAC is unused	*/
+		gsGlobalInfo.sPathInfo.asDac[0].abSrcOnOff[MCDRV_SRC_PDM_BLOCK]		&= (UINT8)~MCDRV_SRC4_PDM_ON;
+		gsGlobalInfo.sPathInfo.asDac[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK]	&= (UINT8)~MCDRV_SRC4_ADC0_ON;
+		gsGlobalInfo.sPathInfo.asDac[0].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR0_ON;
+		gsGlobalInfo.sPathInfo.asDac[0].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR1_ON;
+		gsGlobalInfo.sPathInfo.asDac[0].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR2_ON;
+		gsGlobalInfo.sPathInfo.asDac[0].abSrcOnOff[MCDRV_SRC_AE_BLOCK]		&= (UINT8)~MCDRV_SRC6_AE_ON;
+		gsGlobalInfo.sPathInfo.asDac[0].abSrcOnOff[MCDRV_SRC_MIX_BLOCK]		&= (UINT8)~MCDRV_SRC6_MIX_ON;
+		gsGlobalInfo.sPathInfo.asDac[1].abSrcOnOff[MCDRV_SRC_PDM_BLOCK]		&= (UINT8)~MCDRV_SRC4_PDM_ON;
+		gsGlobalInfo.sPathInfo.asDac[1].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK]	&= (UINT8)~MCDRV_SRC4_ADC0_ON;
+		gsGlobalInfo.sPathInfo.asDac[1].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR0_ON;
+		gsGlobalInfo.sPathInfo.asDac[1].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR1_ON;
+		gsGlobalInfo.sPathInfo.asDac[1].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR2_ON;
+		gsGlobalInfo.sPathInfo.asDac[1].abSrcOnOff[MCDRV_SRC_AE_BLOCK]		&= (UINT8)~MCDRV_SRC6_AE_ON;
+		gsGlobalInfo.sPathInfo.asDac[1].abSrcOnOff[MCDRV_SRC_MIX_BLOCK]		&= (UINT8)~MCDRV_SRC6_MIX_ON;
+		gsGlobalInfo.sPathInfo.asDac[0].abSrcOnOff[MCDRV_SRC_PDM_BLOCK]		|= MCDRV_SRC4_PDM_OFF;
+		gsGlobalInfo.sPathInfo.asDac[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK]	|= MCDRV_SRC4_ADC0_OFF;
+		gsGlobalInfo.sPathInfo.asDac[0].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK]	|= MCDRV_SRC3_DIR0_OFF;
+		gsGlobalInfo.sPathInfo.asDac[0].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK]	|= MCDRV_SRC3_DIR1_OFF;
+		gsGlobalInfo.sPathInfo.asDac[0].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK]	|= MCDRV_SRC3_DIR2_OFF;
+		gsGlobalInfo.sPathInfo.asDac[0].abSrcOnOff[MCDRV_SRC_AE_BLOCK]		|= MCDRV_SRC6_AE_OFF;
+		gsGlobalInfo.sPathInfo.asDac[0].abSrcOnOff[MCDRV_SRC_MIX_BLOCK]		|= MCDRV_SRC6_MIX_OFF;
+		gsGlobalInfo.sPathInfo.asDac[1].abSrcOnOff[MCDRV_SRC_PDM_BLOCK]		|= MCDRV_SRC4_PDM_OFF;
+		gsGlobalInfo.sPathInfo.asDac[1].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK]	|= MCDRV_SRC4_ADC0_OFF;
+		gsGlobalInfo.sPathInfo.asDac[1].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK]	|= MCDRV_SRC3_DIR0_OFF;
+		gsGlobalInfo.sPathInfo.asDac[1].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK]	|= MCDRV_SRC3_DIR1_OFF;
+		gsGlobalInfo.sPathInfo.asDac[1].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK]	|= MCDRV_SRC3_DIR2_OFF;
+		gsGlobalInfo.sPathInfo.asDac[1].abSrcOnOff[MCDRV_SRC_AE_BLOCK]		|= MCDRV_SRC6_AE_OFF;
+		gsGlobalInfo.sPathInfo.asDac[1].abSrcOnOff[MCDRV_SRC_MIX_BLOCK]		|= MCDRV_SRC6_MIX_OFF;
+
+		ValidateADC();
+	}
+
+	if((McResCtrl_GetDACSource(eMCDRV_DAC_MASTER) == eMCDRV_SRC_NONE)
+	&& (McResCtrl_GetDACSource(eMCDRV_DAC_VOICE) == eMCDRV_SRC_NONE))
+	{/*	DAC source all off	*/
+		gsGlobalInfo.sPathInfo.asHpOut[0].abSrcOnOff[MCDRV_SRC_DAC_L_BLOCK]	&= (UINT8)~MCDRV_SRC5_DAC_L_ON;
+		gsGlobalInfo.sPathInfo.asHpOut[0].abSrcOnOff[MCDRV_SRC_DAC_M_BLOCK]	&= (UINT8)~MCDRV_SRC5_DAC_M_ON;
+		gsGlobalInfo.sPathInfo.asHpOut[1].abSrcOnOff[MCDRV_SRC_DAC_R_BLOCK]	&= (UINT8)~MCDRV_SRC5_DAC_R_ON;
+		gsGlobalInfo.sPathInfo.asSpOut[0].abSrcOnOff[MCDRV_SRC_DAC_L_BLOCK]	&= (UINT8)~MCDRV_SRC5_DAC_L_ON;
+		gsGlobalInfo.sPathInfo.asSpOut[0].abSrcOnOff[MCDRV_SRC_DAC_M_BLOCK]	&= (UINT8)~MCDRV_SRC5_DAC_M_ON;
+		gsGlobalInfo.sPathInfo.asSpOut[1].abSrcOnOff[MCDRV_SRC_DAC_R_BLOCK]	&= (UINT8)~MCDRV_SRC5_DAC_R_ON;
+		gsGlobalInfo.sPathInfo.asSpOut[1].abSrcOnOff[MCDRV_SRC_DAC_M_BLOCK]	&= (UINT8)~MCDRV_SRC5_DAC_M_ON;
+		gsGlobalInfo.sPathInfo.asRcOut[0].abSrcOnOff[MCDRV_SRC_DAC_L_BLOCK]	&= (UINT8)~MCDRV_SRC5_DAC_L_ON;
+		gsGlobalInfo.sPathInfo.asRcOut[0].abSrcOnOff[MCDRV_SRC_DAC_R_BLOCK]	&= (UINT8)~MCDRV_SRC5_DAC_R_ON;
+		gsGlobalInfo.sPathInfo.asLout1[0].abSrcOnOff[MCDRV_SRC_DAC_L_BLOCK]	&= (UINT8)~MCDRV_SRC5_DAC_L_ON;
+		gsGlobalInfo.sPathInfo.asLout1[0].abSrcOnOff[MCDRV_SRC_DAC_M_BLOCK]	&= (UINT8)~MCDRV_SRC5_DAC_M_ON;
+		gsGlobalInfo.sPathInfo.asLout1[1].abSrcOnOff[MCDRV_SRC_DAC_R_BLOCK]	&= (UINT8)~MCDRV_SRC5_DAC_R_ON;
+		gsGlobalInfo.sPathInfo.asLout2[0].abSrcOnOff[MCDRV_SRC_DAC_L_BLOCK]	&= (UINT8)~MCDRV_SRC5_DAC_L_ON;
+		gsGlobalInfo.sPathInfo.asLout2[0].abSrcOnOff[MCDRV_SRC_DAC_M_BLOCK]	&= (UINT8)~MCDRV_SRC5_DAC_M_ON;
+		gsGlobalInfo.sPathInfo.asLout2[1].abSrcOnOff[MCDRV_SRC_DAC_R_BLOCK]	&= (UINT8)~MCDRV_SRC5_DAC_R_ON;
+		gsGlobalInfo.sPathInfo.asHpOut[0].abSrcOnOff[MCDRV_SRC_DAC_L_BLOCK]	|= MCDRV_SRC5_DAC_L_OFF;
+		gsGlobalInfo.sPathInfo.asHpOut[0].abSrcOnOff[MCDRV_SRC_DAC_M_BLOCK]	|= MCDRV_SRC5_DAC_M_OFF;
+		gsGlobalInfo.sPathInfo.asHpOut[1].abSrcOnOff[MCDRV_SRC_DAC_R_BLOCK]	|= MCDRV_SRC5_DAC_R_OFF;
+		gsGlobalInfo.sPathInfo.asSpOut[0].abSrcOnOff[MCDRV_SRC_DAC_L_BLOCK]	|= MCDRV_SRC5_DAC_L_OFF;
+		gsGlobalInfo.sPathInfo.asSpOut[0].abSrcOnOff[MCDRV_SRC_DAC_M_BLOCK]	|= MCDRV_SRC5_DAC_M_OFF;
+		gsGlobalInfo.sPathInfo.asSpOut[1].abSrcOnOff[MCDRV_SRC_DAC_R_BLOCK]	|= MCDRV_SRC5_DAC_R_OFF;
+		gsGlobalInfo.sPathInfo.asSpOut[1].abSrcOnOff[MCDRV_SRC_DAC_M_BLOCK]	|= MCDRV_SRC5_DAC_M_OFF;
+		gsGlobalInfo.sPathInfo.asRcOut[0].abSrcOnOff[MCDRV_SRC_DAC_L_BLOCK]	|= MCDRV_SRC5_DAC_L_OFF;
+		gsGlobalInfo.sPathInfo.asRcOut[0].abSrcOnOff[MCDRV_SRC_DAC_R_BLOCK]	|= MCDRV_SRC5_DAC_R_OFF;
+		gsGlobalInfo.sPathInfo.asLout1[0].abSrcOnOff[MCDRV_SRC_DAC_L_BLOCK]	|= MCDRV_SRC5_DAC_L_OFF;
+		gsGlobalInfo.sPathInfo.asLout1[0].abSrcOnOff[MCDRV_SRC_DAC_M_BLOCK]	|= MCDRV_SRC5_DAC_M_OFF;
+		gsGlobalInfo.sPathInfo.asLout1[1].abSrcOnOff[MCDRV_SRC_DAC_R_BLOCK]	|= MCDRV_SRC5_DAC_R_OFF;
+		gsGlobalInfo.sPathInfo.asLout2[0].abSrcOnOff[MCDRV_SRC_DAC_L_BLOCK]	|= MCDRV_SRC5_DAC_L_OFF;
+		gsGlobalInfo.sPathInfo.asLout2[0].abSrcOnOff[MCDRV_SRC_DAC_M_BLOCK]	|= MCDRV_SRC5_DAC_M_OFF;
+		gsGlobalInfo.sPathInfo.asLout2[1].abSrcOnOff[MCDRV_SRC_DAC_R_BLOCK]	|= MCDRV_SRC5_DAC_R_OFF;
+	}
+
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncOut("ValidateDAC", 0);
+#endif
+}
+
+/****************************************************************************
+ *	VlidateAE
+ *
+ *	Description:
+ *			Validate AE path setting.
+ *	Arguments:
+ *			eCh	AE path channel
+ *	Return:
+ *			none
+ *
+ ****************************************************************************/
+static void	ValidateAE
+(
+	void
+)
+{
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncIn("ValidateAE");
+#endif
+
+	if(McResCtrl_GetAESource() == eMCDRV_SRC_NONE)
+	{/*	AE source all off	*/
+		gsGlobalInfo.sPathInfo.asDit0[0].abSrcOnOff[MCDRV_SRC_AE_BLOCK]	&= (UINT8)~MCDRV_SRC6_AE_ON;
+		gsGlobalInfo.sPathInfo.asDit1[0].abSrcOnOff[MCDRV_SRC_AE_BLOCK]	&= (UINT8)~MCDRV_SRC6_AE_ON;
+		gsGlobalInfo.sPathInfo.asDit2[0].abSrcOnOff[MCDRV_SRC_AE_BLOCK]	&= (UINT8)~MCDRV_SRC6_AE_ON;
+		gsGlobalInfo.sPathInfo.asDac[0].abSrcOnOff[MCDRV_SRC_AE_BLOCK]	&= (UINT8)~MCDRV_SRC6_AE_ON;
+		gsGlobalInfo.sPathInfo.asDac[1].abSrcOnOff[MCDRV_SRC_AE_BLOCK]	&= (UINT8)~MCDRV_SRC6_AE_ON;
+		gsGlobalInfo.sPathInfo.asMix[0].abSrcOnOff[MCDRV_SRC_AE_BLOCK]	&= (UINT8)~MCDRV_SRC6_AE_ON;
+		gsGlobalInfo.sPathInfo.asDit0[0].abSrcOnOff[MCDRV_SRC_AE_BLOCK]	|= MCDRV_SRC6_AE_OFF;
+		gsGlobalInfo.sPathInfo.asDit1[0].abSrcOnOff[MCDRV_SRC_AE_BLOCK]	|= MCDRV_SRC6_AE_OFF;
+		gsGlobalInfo.sPathInfo.asDit2[0].abSrcOnOff[MCDRV_SRC_AE_BLOCK]	|= MCDRV_SRC6_AE_OFF;
+		gsGlobalInfo.sPathInfo.asDac[0].abSrcOnOff[MCDRV_SRC_AE_BLOCK]	|= MCDRV_SRC6_AE_OFF;
+		gsGlobalInfo.sPathInfo.asDac[1].abSrcOnOff[MCDRV_SRC_AE_BLOCK]	|= MCDRV_SRC6_AE_OFF;
+		gsGlobalInfo.sPathInfo.asMix[0].abSrcOnOff[MCDRV_SRC_AE_BLOCK]	|= MCDRV_SRC6_AE_OFF;
+
+		ValidateDAC();
+	}
+	else if(McResCtrl_IsSrcUsed(eMCDRV_SRC_AE) == 0)
+	{
+		gsGlobalInfo.sPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_PDM_BLOCK]	&= (UINT8)~MCDRV_SRC4_PDM_ON;
+		gsGlobalInfo.sPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK]	&= (UINT8)~MCDRV_SRC4_ADC0_ON;
+		gsGlobalInfo.sPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR0_ON;
+		gsGlobalInfo.sPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR1_ON;
+		gsGlobalInfo.sPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR2_ON;
+		gsGlobalInfo.sPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_MIX_BLOCK]	&= (UINT8)~MCDRV_SRC6_MIX_ON;
+		gsGlobalInfo.sPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_PDM_BLOCK]	|= MCDRV_SRC4_PDM_OFF;
+		gsGlobalInfo.sPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK]	|= MCDRV_SRC4_ADC0_OFF;
+		gsGlobalInfo.sPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK]	|= MCDRV_SRC3_DIR0_OFF;
+		gsGlobalInfo.sPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK]	|= MCDRV_SRC3_DIR1_OFF;
+		gsGlobalInfo.sPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK]	|= MCDRV_SRC3_DIR2_OFF;
+		gsGlobalInfo.sPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_MIX_BLOCK]	|= MCDRV_SRC6_MIX_OFF;
+	}
+	else
+	{
+	}
+
+	ValidateMix();
+
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncOut("ValidateAE", 0);
+#endif
+}
+
+/****************************************************************************
+ *	ValidateMix
+ *
+ *	Description:
+ *			Validate Mix path setting.
+ *	Arguments:
+ *			none
+ *	Return:
+ *			none
+ *
+ ****************************************************************************/
+static void	ValidateMix
+(
+	void
+)
+{
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncIn("ValidateMix");
+#endif
+
+	if(McResCtrl_IsDstUsed(eMCDRV_DST_MIX, eMCDRV_DST_CH0) == 0)
+	{/*	MIX source all off	*/
+		gsGlobalInfo.sPathInfo.asDit0[0].abSrcOnOff[MCDRV_SRC_MIX_BLOCK]	&= (UINT8)~MCDRV_SRC6_MIX_ON;
+		gsGlobalInfo.sPathInfo.asDit1[0].abSrcOnOff[MCDRV_SRC_MIX_BLOCK]	&= (UINT8)~MCDRV_SRC6_MIX_ON;
+		gsGlobalInfo.sPathInfo.asDit2[0].abSrcOnOff[MCDRV_SRC_MIX_BLOCK]	&= (UINT8)~MCDRV_SRC6_MIX_ON;
+		gsGlobalInfo.sPathInfo.asDac[0].abSrcOnOff[MCDRV_SRC_MIX_BLOCK]		&= (UINT8)~MCDRV_SRC6_MIX_ON;
+		gsGlobalInfo.sPathInfo.asDac[1].abSrcOnOff[MCDRV_SRC_MIX_BLOCK]		&= (UINT8)~MCDRV_SRC6_MIX_ON;
+		gsGlobalInfo.sPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_MIX_BLOCK]		&= (UINT8)~MCDRV_SRC6_MIX_ON;
+		gsGlobalInfo.sPathInfo.asDit0[0].abSrcOnOff[MCDRV_SRC_MIX_BLOCK]	|= MCDRV_SRC6_MIX_OFF;
+		gsGlobalInfo.sPathInfo.asDit1[0].abSrcOnOff[MCDRV_SRC_MIX_BLOCK]	|= MCDRV_SRC6_MIX_OFF;
+		gsGlobalInfo.sPathInfo.asDit2[0].abSrcOnOff[MCDRV_SRC_MIX_BLOCK]	|= MCDRV_SRC6_MIX_OFF;
+		gsGlobalInfo.sPathInfo.asDac[0].abSrcOnOff[MCDRV_SRC_MIX_BLOCK]		|= MCDRV_SRC6_MIX_OFF;
+		gsGlobalInfo.sPathInfo.asDac[1].abSrcOnOff[MCDRV_SRC_MIX_BLOCK]		|= MCDRV_SRC6_MIX_OFF;
+		gsGlobalInfo.sPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_MIX_BLOCK]		|= MCDRV_SRC6_MIX_OFF;
+
+		ValidateDAC();
+	}
+	else if(McResCtrl_IsSrcUsed(eMCDRV_SRC_MIX) == 0)
+	{
+		gsGlobalInfo.sPathInfo.asMix[0].abSrcOnOff[MCDRV_SRC_PDM_BLOCK]		&= (UINT8)~MCDRV_SRC4_PDM_ON;
+		gsGlobalInfo.sPathInfo.asMix[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK]	&= (UINT8)~MCDRV_SRC4_ADC0_ON;
+		gsGlobalInfo.sPathInfo.asMix[0].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR0_ON;
+		gsGlobalInfo.sPathInfo.asMix[0].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR1_ON;
+		gsGlobalInfo.sPathInfo.asMix[0].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR2_ON;
+		gsGlobalInfo.sPathInfo.asMix[0].abSrcOnOff[MCDRV_SRC_AE_BLOCK]		&= (UINT8)~MCDRV_SRC6_AE_ON;
+		gsGlobalInfo.sPathInfo.asMix[0].abSrcOnOff[MCDRV_SRC_PDM_BLOCK]		|= MCDRV_SRC4_PDM_OFF;
+		gsGlobalInfo.sPathInfo.asMix[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK]	|= MCDRV_SRC4_ADC0_OFF;
+		gsGlobalInfo.sPathInfo.asMix[0].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK]	|= MCDRV_SRC3_DIR0_OFF;
+		gsGlobalInfo.sPathInfo.asMix[0].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK]	|= MCDRV_SRC3_DIR1_OFF;
+		gsGlobalInfo.sPathInfo.asMix[0].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK]	|= MCDRV_SRC3_DIR2_OFF;
+		gsGlobalInfo.sPathInfo.asMix[0].abSrcOnOff[MCDRV_SRC_AE_BLOCK]		|= MCDRV_SRC6_AE_OFF;
+	}
+	else
+	{
+	}
+
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncOut("ValidateMix", 0);
+#endif
+}
+
+/****************************************************************************
+ *	SetHPSourceOnOff
+ *
+ *	Description:
+ *			Set HP source On/Off.
+ *	Arguments:
+ *			psPathInfo	path information
+ *	Return:
+ *			none
+ *
+ ****************************************************************************/
+static void	SetHPSourceOnOff
+(
+	const MCDRV_PATH_INFO*	psPathInfo
+)
+{
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncIn("SetHPSourceOnOff");
+#endif
+
+	if((psPathInfo->asHpOut[0].abSrcOnOff[MCDRV_SRC_MIC1_BLOCK] & (MCDRV_SRC0_MIC1_ON|MCDRV_SRC0_MIC1_OFF)) == MCDRV_SRC0_MIC1_ON)
+	{
+		gsGlobalInfo.sPathInfo.asHpOut[0].abSrcOnOff[MCDRV_SRC_MIC1_BLOCK]	&= (UINT8)~MCDRV_SRC0_MIC1_OFF;
+		gsGlobalInfo.sPathInfo.asHpOut[0].abSrcOnOff[MCDRV_SRC_MIC1_BLOCK]	|= MCDRV_SRC0_MIC1_ON;
+	}
+	else if((psPathInfo->asHpOut[0].abSrcOnOff[MCDRV_SRC_MIC1_BLOCK] & (MCDRV_SRC0_MIC1_ON|MCDRV_SRC0_MIC1_OFF)) == MCDRV_SRC0_MIC1_OFF)
+	{
+		gsGlobalInfo.sPathInfo.asHpOut[0].abSrcOnOff[MCDRV_SRC_MIC1_BLOCK]	&= (UINT8)~MCDRV_SRC0_MIC1_ON;
+		gsGlobalInfo.sPathInfo.asHpOut[0].abSrcOnOff[MCDRV_SRC_MIC1_BLOCK]	|= MCDRV_SRC0_MIC1_OFF;
+	}
+	else
+	{
+	}
+
+	if((psPathInfo->asHpOut[0].abSrcOnOff[MCDRV_SRC_MIC2_BLOCK] & (MCDRV_SRC0_MIC2_ON|MCDRV_SRC0_MIC2_OFF)) == MCDRV_SRC0_MIC2_ON)
+	{
+		gsGlobalInfo.sPathInfo.asHpOut[0].abSrcOnOff[MCDRV_SRC_MIC2_BLOCK]	&= (UINT8)~MCDRV_SRC0_MIC2_OFF;
+		gsGlobalInfo.sPathInfo.asHpOut[0].abSrcOnOff[MCDRV_SRC_MIC2_BLOCK]	|= MCDRV_SRC0_MIC2_ON;
+	}
+	else if((psPathInfo->asHpOut[0].abSrcOnOff[MCDRV_SRC_MIC2_BLOCK] & (MCDRV_SRC0_MIC2_ON|MCDRV_SRC0_MIC2_OFF)) == MCDRV_SRC0_MIC2_OFF)
+	{
+		gsGlobalInfo.sPathInfo.asHpOut[0].abSrcOnOff[MCDRV_SRC_MIC2_BLOCK]	&= (UINT8)~MCDRV_SRC0_MIC2_ON;
+		gsGlobalInfo.sPathInfo.asHpOut[0].abSrcOnOff[MCDRV_SRC_MIC2_BLOCK]	|= MCDRV_SRC0_MIC2_OFF;
+	}
+	else
+	{
+	}
+
+	if((psPathInfo->asHpOut[0].abSrcOnOff[MCDRV_SRC_MIC3_BLOCK] & (MCDRV_SRC0_MIC3_ON|MCDRV_SRC0_MIC3_OFF)) == MCDRV_SRC0_MIC3_ON)
+	{
+		gsGlobalInfo.sPathInfo.asHpOut[0].abSrcOnOff[MCDRV_SRC_MIC3_BLOCK]	&= (UINT8)~MCDRV_SRC0_MIC3_OFF;
+		gsGlobalInfo.sPathInfo.asHpOut[0].abSrcOnOff[MCDRV_SRC_MIC3_BLOCK]	|= MCDRV_SRC0_MIC3_ON;
+	}
+	else if((psPathInfo->asHpOut[0].abSrcOnOff[MCDRV_SRC_MIC3_BLOCK] & (MCDRV_SRC0_MIC3_ON|MCDRV_SRC0_MIC3_OFF)) == MCDRV_SRC0_MIC3_OFF)
+	{
+		gsGlobalInfo.sPathInfo.asHpOut[0].abSrcOnOff[MCDRV_SRC_MIC3_BLOCK]	&= (UINT8)~MCDRV_SRC0_MIC3_ON;
+		gsGlobalInfo.sPathInfo.asHpOut[0].abSrcOnOff[MCDRV_SRC_MIC3_BLOCK]	|= MCDRV_SRC0_MIC3_OFF;
+	}
+	else
+	{
+	}
+
+	if((psPathInfo->asHpOut[0].abSrcOnOff[MCDRV_SRC_LINE1_L_BLOCK] & (MCDRV_SRC1_LINE1_L_ON|MCDRV_SRC1_LINE1_L_OFF)) == MCDRV_SRC1_LINE1_L_ON)
+	{
+		gsGlobalInfo.sPathInfo.asHpOut[0].abSrcOnOff[MCDRV_SRC_LINE1_L_BLOCK]	&= (UINT8)~MCDRV_SRC1_LINE1_L_OFF;
+		gsGlobalInfo.sPathInfo.asHpOut[0].abSrcOnOff[MCDRV_SRC_LINE1_L_BLOCK]	|= MCDRV_SRC1_LINE1_L_ON;
+	}
+	else if((psPathInfo->asHpOut[0].abSrcOnOff[MCDRV_SRC_LINE1_L_BLOCK] & (MCDRV_SRC1_LINE1_L_ON|MCDRV_SRC1_LINE1_L_OFF)) == MCDRV_SRC1_LINE1_L_OFF)
+	{
+		gsGlobalInfo.sPathInfo.asHpOut[0].abSrcOnOff[MCDRV_SRC_LINE1_L_BLOCK]	&= (UINT8)~MCDRV_SRC1_LINE1_L_ON;
+		gsGlobalInfo.sPathInfo.asHpOut[0].abSrcOnOff[MCDRV_SRC_LINE1_L_BLOCK]	|= MCDRV_SRC1_LINE1_L_OFF;
+	}
+	else
+	{
+	}
+
+	if((psPathInfo->asHpOut[0].abSrcOnOff[MCDRV_SRC_LINE1_M_BLOCK] & (MCDRV_SRC1_LINE1_M_ON|MCDRV_SRC1_LINE1_M_OFF)) == MCDRV_SRC1_LINE1_M_ON)
+	{
+		gsGlobalInfo.sPathInfo.asHpOut[0].abSrcOnOff[MCDRV_SRC_LINE1_M_BLOCK]	&= (UINT8)~MCDRV_SRC1_LINE1_M_OFF;
+		gsGlobalInfo.sPathInfo.asHpOut[0].abSrcOnOff[MCDRV_SRC_LINE1_M_BLOCK]	|= MCDRV_SRC1_LINE1_M_ON;
+	}
+	else if((psPathInfo->asHpOut[0].abSrcOnOff[MCDRV_SRC_LINE1_M_BLOCK] & (MCDRV_SRC1_LINE1_M_ON|MCDRV_SRC1_LINE1_M_OFF)) == MCDRV_SRC1_LINE1_M_OFF)
+	{
+		gsGlobalInfo.sPathInfo.asHpOut[0].abSrcOnOff[MCDRV_SRC_LINE1_M_BLOCK]	&= (UINT8)~MCDRV_SRC1_LINE1_M_ON;
+		gsGlobalInfo.sPathInfo.asHpOut[0].abSrcOnOff[MCDRV_SRC_LINE1_M_BLOCK]	|= MCDRV_SRC1_LINE1_M_OFF;
+	}
+	else
+	{
+	}
+
+	if((psPathInfo->asHpOut[0].abSrcOnOff[MCDRV_SRC_DAC_L_BLOCK] & (MCDRV_SRC5_DAC_L_ON|MCDRV_SRC5_DAC_L_OFF)) == MCDRV_SRC5_DAC_L_ON)
+	{
+		gsGlobalInfo.sPathInfo.asHpOut[0].abSrcOnOff[MCDRV_SRC_DAC_L_BLOCK]	&= (UINT8)~MCDRV_SRC5_DAC_L_OFF;
+		gsGlobalInfo.sPathInfo.asHpOut[0].abSrcOnOff[MCDRV_SRC_DAC_L_BLOCK]	|= MCDRV_SRC5_DAC_L_ON;
+	}
+	else if((psPathInfo->asHpOut[0].abSrcOnOff[MCDRV_SRC_DAC_L_BLOCK] & (MCDRV_SRC5_DAC_L_ON|MCDRV_SRC5_DAC_L_OFF)) == MCDRV_SRC5_DAC_L_OFF)
+	{
+		gsGlobalInfo.sPathInfo.asHpOut[0].abSrcOnOff[MCDRV_SRC_DAC_L_BLOCK]	&= (UINT8)~MCDRV_SRC5_DAC_L_ON;
+		gsGlobalInfo.sPathInfo.asHpOut[0].abSrcOnOff[MCDRV_SRC_DAC_L_BLOCK]	|= MCDRV_SRC5_DAC_L_OFF;
+	}
+	else
+	{
+	}
+
+	if((psPathInfo->asHpOut[0].abSrcOnOff[MCDRV_SRC_DAC_M_BLOCK] & (MCDRV_SRC5_DAC_M_ON|MCDRV_SRC5_DAC_M_OFF)) == MCDRV_SRC5_DAC_M_ON)
+	{
+		gsGlobalInfo.sPathInfo.asHpOut[0].abSrcOnOff[MCDRV_SRC_DAC_M_BLOCK]	&= (UINT8)~MCDRV_SRC5_DAC_M_OFF;
+		gsGlobalInfo.sPathInfo.asHpOut[0].abSrcOnOff[MCDRV_SRC_DAC_M_BLOCK]	|= MCDRV_SRC5_DAC_M_ON;
+	}
+	else if((psPathInfo->asHpOut[0].abSrcOnOff[MCDRV_SRC_DAC_M_BLOCK] & (MCDRV_SRC5_DAC_M_ON|MCDRV_SRC5_DAC_M_OFF)) == MCDRV_SRC5_DAC_M_OFF)
+	{
+		gsGlobalInfo.sPathInfo.asHpOut[0].abSrcOnOff[MCDRV_SRC_DAC_M_BLOCK]	&= (UINT8)~MCDRV_SRC5_DAC_M_ON;
+		gsGlobalInfo.sPathInfo.asHpOut[0].abSrcOnOff[MCDRV_SRC_DAC_M_BLOCK]	|= MCDRV_SRC5_DAC_M_OFF;
+	}
+	else
+	{
+	}
+
+	if((psPathInfo->asHpOut[1].abSrcOnOff[MCDRV_SRC_MIC1_BLOCK] & (MCDRV_SRC0_MIC1_ON|MCDRV_SRC0_MIC1_OFF)) == MCDRV_SRC0_MIC1_ON)
+	{
+		gsGlobalInfo.sPathInfo.asHpOut[1].abSrcOnOff[MCDRV_SRC_MIC1_BLOCK]	&= (UINT8)~MCDRV_SRC0_MIC1_OFF;
+		gsGlobalInfo.sPathInfo.asHpOut[1].abSrcOnOff[MCDRV_SRC_MIC1_BLOCK]	|= MCDRV_SRC0_MIC1_ON;
+	}
+	else if((psPathInfo->asHpOut[1].abSrcOnOff[MCDRV_SRC_MIC1_BLOCK] & (MCDRV_SRC0_MIC1_ON|MCDRV_SRC0_MIC1_OFF)) == MCDRV_SRC0_MIC1_OFF)
+	{
+		gsGlobalInfo.sPathInfo.asHpOut[1].abSrcOnOff[MCDRV_SRC_MIC1_BLOCK]	&= (UINT8)~MCDRV_SRC0_MIC1_ON;
+		gsGlobalInfo.sPathInfo.asHpOut[1].abSrcOnOff[MCDRV_SRC_MIC1_BLOCK]	|= MCDRV_SRC0_MIC1_OFF;
+	}
+	else
+	{
+	}
+
+	if((psPathInfo->asHpOut[1].abSrcOnOff[MCDRV_SRC_MIC2_BLOCK] & (MCDRV_SRC0_MIC2_ON|MCDRV_SRC0_MIC2_OFF)) == MCDRV_SRC0_MIC2_ON)
+	{
+		gsGlobalInfo.sPathInfo.asHpOut[1].abSrcOnOff[MCDRV_SRC_MIC2_BLOCK]	&= (UINT8)~MCDRV_SRC0_MIC2_OFF;
+		gsGlobalInfo.sPathInfo.asHpOut[1].abSrcOnOff[MCDRV_SRC_MIC2_BLOCK]	|= MCDRV_SRC0_MIC2_ON;
+	}
+	else if((psPathInfo->asHpOut[1].abSrcOnOff[MCDRV_SRC_MIC2_BLOCK] & (MCDRV_SRC0_MIC2_ON|MCDRV_SRC0_MIC2_OFF)) == MCDRV_SRC0_MIC2_OFF)
+	{
+		gsGlobalInfo.sPathInfo.asHpOut[1].abSrcOnOff[MCDRV_SRC_MIC2_BLOCK]	&= (UINT8)~MCDRV_SRC0_MIC2_ON;
+		gsGlobalInfo.sPathInfo.asHpOut[1].abSrcOnOff[MCDRV_SRC_MIC2_BLOCK]	|= MCDRV_SRC0_MIC2_OFF;
+	}
+	else
+	{
+	}
+
+	if((psPathInfo->asHpOut[1].abSrcOnOff[MCDRV_SRC_MIC3_BLOCK] & (MCDRV_SRC0_MIC3_ON|MCDRV_SRC0_MIC3_OFF)) == MCDRV_SRC0_MIC3_ON)
+	{
+		gsGlobalInfo.sPathInfo.asHpOut[1].abSrcOnOff[MCDRV_SRC_MIC3_BLOCK]	&= (UINT8)~MCDRV_SRC0_MIC3_OFF;
+		gsGlobalInfo.sPathInfo.asHpOut[1].abSrcOnOff[MCDRV_SRC_MIC3_BLOCK]	|= MCDRV_SRC0_MIC3_ON;
+	}
+	else if((psPathInfo->asHpOut[1].abSrcOnOff[MCDRV_SRC_MIC3_BLOCK] & (MCDRV_SRC0_MIC3_ON|MCDRV_SRC0_MIC3_OFF)) == MCDRV_SRC0_MIC3_OFF)
+	{
+		gsGlobalInfo.sPathInfo.asHpOut[1].abSrcOnOff[MCDRV_SRC_MIC3_BLOCK]	&= (UINT8)~MCDRV_SRC0_MIC3_ON;
+		gsGlobalInfo.sPathInfo.asHpOut[1].abSrcOnOff[MCDRV_SRC_MIC3_BLOCK]	|= MCDRV_SRC0_MIC3_OFF;
+	}
+	else
+	{
+	}
+
+	if((psPathInfo->asHpOut[1].abSrcOnOff[MCDRV_SRC_LINE1_R_BLOCK] & (MCDRV_SRC1_LINE1_R_ON|MCDRV_SRC1_LINE1_R_OFF)) == MCDRV_SRC1_LINE1_R_ON)
+	{
+		gsGlobalInfo.sPathInfo.asHpOut[1].abSrcOnOff[MCDRV_SRC_LINE1_R_BLOCK]	&= (UINT8)~MCDRV_SRC1_LINE1_R_OFF;
+		gsGlobalInfo.sPathInfo.asHpOut[1].abSrcOnOff[MCDRV_SRC_LINE1_R_BLOCK]	|= MCDRV_SRC1_LINE1_R_ON;
+	}
+	else if((psPathInfo->asHpOut[1].abSrcOnOff[MCDRV_SRC_LINE1_R_BLOCK] & (MCDRV_SRC1_LINE1_R_ON|MCDRV_SRC1_LINE1_R_OFF)) == MCDRV_SRC1_LINE1_R_OFF)
+	{
+		gsGlobalInfo.sPathInfo.asHpOut[1].abSrcOnOff[MCDRV_SRC_LINE1_R_BLOCK]	&= (UINT8)~MCDRV_SRC1_LINE1_R_ON;
+		gsGlobalInfo.sPathInfo.asHpOut[1].abSrcOnOff[MCDRV_SRC_LINE1_R_BLOCK]	|= MCDRV_SRC1_LINE1_R_OFF;
+	}
+	else
+	{
+	}
+
+	if((psPathInfo->asHpOut[1].abSrcOnOff[MCDRV_SRC_DAC_R_BLOCK] & (MCDRV_SRC5_DAC_R_ON|MCDRV_SRC5_DAC_R_OFF)) == MCDRV_SRC5_DAC_R_ON)
+	{
+		gsGlobalInfo.sPathInfo.asHpOut[1].abSrcOnOff[MCDRV_SRC_DAC_R_BLOCK]	&= (UINT8)~MCDRV_SRC5_DAC_R_OFF;
+		gsGlobalInfo.sPathInfo.asHpOut[1].abSrcOnOff[MCDRV_SRC_DAC_R_BLOCK]	|= MCDRV_SRC5_DAC_R_ON;
+	}
+	else if((psPathInfo->asHpOut[1].abSrcOnOff[MCDRV_SRC_DAC_R_BLOCK] & (MCDRV_SRC5_DAC_R_ON|MCDRV_SRC5_DAC_R_OFF)) == MCDRV_SRC5_DAC_R_OFF)
+	{
+		gsGlobalInfo.sPathInfo.asHpOut[1].abSrcOnOff[MCDRV_SRC_DAC_R_BLOCK]	&= (UINT8)~MCDRV_SRC5_DAC_R_ON;
+		gsGlobalInfo.sPathInfo.asHpOut[1].abSrcOnOff[MCDRV_SRC_DAC_R_BLOCK]	|= MCDRV_SRC5_DAC_R_OFF;
+	}
+	else
+	{
+	}
+
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncOut("SetHPSourceOnOff", 0);
+#endif
+}
+
+/****************************************************************************
+ *	SetSPSourceOnOff
+ *
+ *	Description:
+ *			Set SP source On/Off.
+ *	Arguments:
+ *			psPathInfo	path information
+ *	Return:
+ *			none
+ *
+ ****************************************************************************/
+static void	SetSPSourceOnOff
+(
+	const MCDRV_PATH_INFO*	psPathInfo
+)
+{
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncIn("SetSPSourceOnOff");
+#endif
+
+	if((psPathInfo->asSpOut[0].abSrcOnOff[MCDRV_SRC_LINE1_L_BLOCK] & (MCDRV_SRC1_LINE1_L_ON|MCDRV_SRC1_LINE1_L_OFF)) == MCDRV_SRC1_LINE1_L_ON)
+	{
+		gsGlobalInfo.sPathInfo.asSpOut[0].abSrcOnOff[MCDRV_SRC_LINE1_L_BLOCK]	&= (UINT8)~MCDRV_SRC1_LINE1_L_OFF;
+		gsGlobalInfo.sPathInfo.asSpOut[0].abSrcOnOff[MCDRV_SRC_LINE1_L_BLOCK]	|= MCDRV_SRC1_LINE1_L_ON;
+	}
+	else if((psPathInfo->asSpOut[0].abSrcOnOff[MCDRV_SRC_LINE1_L_BLOCK] & (MCDRV_SRC1_LINE1_L_ON|MCDRV_SRC1_LINE1_L_OFF)) == MCDRV_SRC1_LINE1_L_OFF)
+	{
+		gsGlobalInfo.sPathInfo.asSpOut[0].abSrcOnOff[MCDRV_SRC_LINE1_L_BLOCK]	&= (UINT8)~MCDRV_SRC1_LINE1_L_ON;
+		gsGlobalInfo.sPathInfo.asSpOut[0].abSrcOnOff[MCDRV_SRC_LINE1_L_BLOCK]	|= MCDRV_SRC1_LINE1_L_OFF;
+	}
+	else
+	{
+	}
+
+	if((psPathInfo->asSpOut[0].abSrcOnOff[MCDRV_SRC_LINE1_M_BLOCK] & (MCDRV_SRC1_LINE1_M_ON|MCDRV_SRC1_LINE1_M_OFF)) == MCDRV_SRC1_LINE1_M_ON)
+	{
+		gsGlobalInfo.sPathInfo.asSpOut[0].abSrcOnOff[MCDRV_SRC_LINE1_M_BLOCK]	&= (UINT8)~MCDRV_SRC1_LINE1_M_OFF;
+		gsGlobalInfo.sPathInfo.asSpOut[0].abSrcOnOff[MCDRV_SRC_LINE1_M_BLOCK]	|= MCDRV_SRC1_LINE1_M_ON;
+	}
+	else if((psPathInfo->asSpOut[0].abSrcOnOff[MCDRV_SRC_LINE1_M_BLOCK] & (MCDRV_SRC1_LINE1_M_ON|MCDRV_SRC1_LINE1_M_OFF)) == MCDRV_SRC1_LINE1_M_OFF)
+	{
+		gsGlobalInfo.sPathInfo.asSpOut[0].abSrcOnOff[MCDRV_SRC_LINE1_M_BLOCK]	&= (UINT8)~MCDRV_SRC1_LINE1_M_ON;
+		gsGlobalInfo.sPathInfo.asSpOut[0].abSrcOnOff[MCDRV_SRC_LINE1_M_BLOCK]	|= MCDRV_SRC1_LINE1_M_OFF;
+	}
+	else
+	{
+	}
+
+	if((psPathInfo->asSpOut[0].abSrcOnOff[MCDRV_SRC_DAC_L_BLOCK] & (MCDRV_SRC5_DAC_L_ON|MCDRV_SRC5_DAC_L_OFF)) == MCDRV_SRC5_DAC_L_ON)
+	{
+		gsGlobalInfo.sPathInfo.asSpOut[0].abSrcOnOff[MCDRV_SRC_DAC_L_BLOCK]	&= (UINT8)~MCDRV_SRC5_DAC_L_OFF;
+		gsGlobalInfo.sPathInfo.asSpOut[0].abSrcOnOff[MCDRV_SRC_DAC_L_BLOCK]	|= MCDRV_SRC5_DAC_L_ON;
+	}
+	else if((psPathInfo->asSpOut[0].abSrcOnOff[MCDRV_SRC_DAC_L_BLOCK] & (MCDRV_SRC5_DAC_L_ON|MCDRV_SRC5_DAC_L_OFF)) == MCDRV_SRC5_DAC_L_OFF)
+	{
+		gsGlobalInfo.sPathInfo.asSpOut[0].abSrcOnOff[MCDRV_SRC_DAC_L_BLOCK]	&= (UINT8)~MCDRV_SRC5_DAC_L_ON;
+		gsGlobalInfo.sPathInfo.asSpOut[0].abSrcOnOff[MCDRV_SRC_DAC_L_BLOCK]	|= MCDRV_SRC5_DAC_L_OFF;
+	}
+	else
+	{
+	}
+
+	if((psPathInfo->asSpOut[0].abSrcOnOff[MCDRV_SRC_DAC_M_BLOCK] & (MCDRV_SRC5_DAC_M_ON|MCDRV_SRC5_DAC_M_OFF)) == MCDRV_SRC5_DAC_M_ON)
+	{
+		gsGlobalInfo.sPathInfo.asSpOut[0].abSrcOnOff[MCDRV_SRC_DAC_M_BLOCK]	&= (UINT8)~MCDRV_SRC5_DAC_M_OFF;
+		gsGlobalInfo.sPathInfo.asSpOut[0].abSrcOnOff[MCDRV_SRC_DAC_M_BLOCK]	|= MCDRV_SRC5_DAC_M_ON;
+	}
+	else if((psPathInfo->asSpOut[0].abSrcOnOff[MCDRV_SRC_DAC_M_BLOCK] & (MCDRV_SRC5_DAC_M_ON|MCDRV_SRC5_DAC_M_OFF)) == MCDRV_SRC5_DAC_M_OFF)
+	{
+		gsGlobalInfo.sPathInfo.asSpOut[0].abSrcOnOff[MCDRV_SRC_DAC_M_BLOCK]	&= (UINT8)~MCDRV_SRC5_DAC_M_ON;
+		gsGlobalInfo.sPathInfo.asSpOut[0].abSrcOnOff[MCDRV_SRC_DAC_M_BLOCK]	|= MCDRV_SRC5_DAC_M_OFF;
+	}
+	else
+	{
+	}
+
+	if((psPathInfo->asSpOut[1].abSrcOnOff[MCDRV_SRC_LINE1_R_BLOCK] & (MCDRV_SRC1_LINE1_R_ON|MCDRV_SRC1_LINE1_R_OFF)) == MCDRV_SRC1_LINE1_R_ON)
+	{
+		gsGlobalInfo.sPathInfo.asSpOut[1].abSrcOnOff[MCDRV_SRC_LINE1_R_BLOCK]	&= (UINT8)~MCDRV_SRC1_LINE1_R_OFF;
+		gsGlobalInfo.sPathInfo.asSpOut[1].abSrcOnOff[MCDRV_SRC_LINE1_R_BLOCK]	|= MCDRV_SRC1_LINE1_R_ON;
+	}
+	else if((psPathInfo->asSpOut[1].abSrcOnOff[MCDRV_SRC_LINE1_R_BLOCK] & (MCDRV_SRC1_LINE1_R_ON|MCDRV_SRC1_LINE1_R_OFF)) == MCDRV_SRC1_LINE1_R_OFF)
+	{
+		gsGlobalInfo.sPathInfo.asSpOut[1].abSrcOnOff[MCDRV_SRC_LINE1_R_BLOCK]	&= (UINT8)~MCDRV_SRC1_LINE1_R_ON;
+		gsGlobalInfo.sPathInfo.asSpOut[1].abSrcOnOff[MCDRV_SRC_LINE1_R_BLOCK]	|= MCDRV_SRC1_LINE1_R_OFF;
+	}
+	else
+	{
+	}
+
+	if((psPathInfo->asSpOut[1].abSrcOnOff[MCDRV_SRC_LINE1_M_BLOCK] & (MCDRV_SRC1_LINE1_M_ON|MCDRV_SRC1_LINE1_M_OFF)) == MCDRV_SRC1_LINE1_M_ON)
+	{
+		gsGlobalInfo.sPathInfo.asSpOut[1].abSrcOnOff[MCDRV_SRC_LINE1_M_BLOCK]	&= (UINT8)~MCDRV_SRC1_LINE1_M_OFF;
+		gsGlobalInfo.sPathInfo.asSpOut[1].abSrcOnOff[MCDRV_SRC_LINE1_M_BLOCK]	|= MCDRV_SRC1_LINE1_M_ON;
+	}
+	else if((psPathInfo->asSpOut[1].abSrcOnOff[MCDRV_SRC_LINE1_M_BLOCK] & (MCDRV_SRC1_LINE1_M_ON|MCDRV_SRC1_LINE1_M_OFF)) == MCDRV_SRC1_LINE1_M_OFF)
+	{
+		gsGlobalInfo.sPathInfo.asSpOut[1].abSrcOnOff[MCDRV_SRC_LINE1_M_BLOCK]	&= (UINT8)~MCDRV_SRC1_LINE1_M_ON;
+		gsGlobalInfo.sPathInfo.asSpOut[1].abSrcOnOff[MCDRV_SRC_LINE1_M_BLOCK]	|= MCDRV_SRC1_LINE1_M_OFF;
+	}
+	else
+	{
+	}
+
+	if((psPathInfo->asSpOut[1].abSrcOnOff[MCDRV_SRC_DAC_R_BLOCK] & (MCDRV_SRC5_DAC_R_ON|MCDRV_SRC5_DAC_R_OFF)) == MCDRV_SRC5_DAC_R_ON)
+	{
+		gsGlobalInfo.sPathInfo.asSpOut[1].abSrcOnOff[MCDRV_SRC_DAC_R_BLOCK]	&= (UINT8)~MCDRV_SRC5_DAC_R_OFF;
+		gsGlobalInfo.sPathInfo.asSpOut[1].abSrcOnOff[MCDRV_SRC_DAC_R_BLOCK]	|= MCDRV_SRC5_DAC_R_ON;
+	}
+	else if((psPathInfo->asSpOut[1].abSrcOnOff[MCDRV_SRC_DAC_R_BLOCK] & (MCDRV_SRC5_DAC_R_ON|MCDRV_SRC5_DAC_R_OFF)) == MCDRV_SRC5_DAC_R_OFF)
+	{
+		gsGlobalInfo.sPathInfo.asSpOut[1].abSrcOnOff[MCDRV_SRC_DAC_R_BLOCK]	&= (UINT8)~MCDRV_SRC5_DAC_R_ON;
+		gsGlobalInfo.sPathInfo.asSpOut[1].abSrcOnOff[MCDRV_SRC_DAC_R_BLOCK]	|= MCDRV_SRC5_DAC_R_OFF;
+	}
+	else
+	{
+	}
+
+	if((psPathInfo->asSpOut[1].abSrcOnOff[MCDRV_SRC_DAC_M_BLOCK] & (MCDRV_SRC5_DAC_M_ON|MCDRV_SRC5_DAC_M_OFF)) == MCDRV_SRC5_DAC_M_ON)
+	{
+		gsGlobalInfo.sPathInfo.asSpOut[1].abSrcOnOff[MCDRV_SRC_DAC_M_BLOCK]	&= (UINT8)~MCDRV_SRC5_DAC_M_OFF;
+		gsGlobalInfo.sPathInfo.asSpOut[1].abSrcOnOff[MCDRV_SRC_DAC_M_BLOCK]	|= MCDRV_SRC5_DAC_M_ON;
+	}
+	else if((psPathInfo->asSpOut[1].abSrcOnOff[MCDRV_SRC_DAC_M_BLOCK] & (MCDRV_SRC5_DAC_M_ON|MCDRV_SRC5_DAC_M_OFF)) == MCDRV_SRC5_DAC_M_OFF)
+	{
+		gsGlobalInfo.sPathInfo.asSpOut[1].abSrcOnOff[MCDRV_SRC_DAC_M_BLOCK]	&= (UINT8)~MCDRV_SRC5_DAC_M_ON;
+		gsGlobalInfo.sPathInfo.asSpOut[1].abSrcOnOff[MCDRV_SRC_DAC_M_BLOCK]	|= MCDRV_SRC5_DAC_M_OFF;
+	}
+	else
+	{
+	}
+
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncOut("SetSPSourceOnOff", 0);
+#endif
+}
+
+/****************************************************************************
+ *	SetRCVSourceOnOff
+ *
+ *	Description:
+ *			Set RCV source On/Off.
+ *	Arguments:
+ *			psPathInfo	path information
+ *	Return:
+ *			none
+ *
+ ****************************************************************************/
+static void	SetRCVSourceOnOff
+(
+	const MCDRV_PATH_INFO*	psPathInfo
+)
+{
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncIn("SetRCVSourceOnOff");
+#endif
+
+	if((psPathInfo->asRcOut[0].abSrcOnOff[MCDRV_SRC_MIC1_BLOCK] & (MCDRV_SRC0_MIC1_ON|MCDRV_SRC0_MIC1_OFF)) == MCDRV_SRC0_MIC1_ON)
+	{
+		gsGlobalInfo.sPathInfo.asRcOut[0].abSrcOnOff[MCDRV_SRC_MIC1_BLOCK]	&= (UINT8)~MCDRV_SRC0_MIC1_OFF;
+		gsGlobalInfo.sPathInfo.asRcOut[0].abSrcOnOff[MCDRV_SRC_MIC1_BLOCK]	|= MCDRV_SRC0_MIC1_ON;
+	}
+	else if((psPathInfo->asRcOut[0].abSrcOnOff[MCDRV_SRC_MIC1_BLOCK] & (MCDRV_SRC0_MIC1_ON|MCDRV_SRC0_MIC1_OFF)) == MCDRV_SRC0_MIC1_OFF)
+	{
+		gsGlobalInfo.sPathInfo.asRcOut[0].abSrcOnOff[MCDRV_SRC_MIC1_BLOCK]	&= (UINT8)~MCDRV_SRC0_MIC1_ON;
+		gsGlobalInfo.sPathInfo.asRcOut[0].abSrcOnOff[MCDRV_SRC_MIC1_BLOCK]	|= MCDRV_SRC0_MIC1_OFF;
+	}
+	else
+	{
+	}
+
+	if((psPathInfo->asRcOut[0].abSrcOnOff[MCDRV_SRC_MIC2_BLOCK] & (MCDRV_SRC0_MIC2_ON|MCDRV_SRC0_MIC2_OFF)) == MCDRV_SRC0_MIC2_ON)
+	{
+		gsGlobalInfo.sPathInfo.asRcOut[0].abSrcOnOff[MCDRV_SRC_MIC2_BLOCK]	&= (UINT8)~MCDRV_SRC0_MIC2_OFF;
+		gsGlobalInfo.sPathInfo.asRcOut[0].abSrcOnOff[MCDRV_SRC_MIC2_BLOCK]	|= MCDRV_SRC0_MIC2_ON;
+	}
+	else if((psPathInfo->asRcOut[0].abSrcOnOff[MCDRV_SRC_MIC2_BLOCK] & (MCDRV_SRC0_MIC2_ON|MCDRV_SRC0_MIC2_OFF)) == MCDRV_SRC0_MIC2_OFF)
+	{
+		gsGlobalInfo.sPathInfo.asRcOut[0].abSrcOnOff[MCDRV_SRC_MIC2_BLOCK]	&= (UINT8)~MCDRV_SRC0_MIC2_ON;
+		gsGlobalInfo.sPathInfo.asRcOut[0].abSrcOnOff[MCDRV_SRC_MIC2_BLOCK]	|= MCDRV_SRC0_MIC2_OFF;
+	}
+	else
+	{
+	}
+
+	if((psPathInfo->asRcOut[0].abSrcOnOff[MCDRV_SRC_MIC3_BLOCK] & (MCDRV_SRC0_MIC3_ON|MCDRV_SRC0_MIC3_OFF)) == MCDRV_SRC0_MIC3_ON)
+	{
+		gsGlobalInfo.sPathInfo.asRcOut[0].abSrcOnOff[MCDRV_SRC_MIC3_BLOCK]	&= (UINT8)~MCDRV_SRC0_MIC3_OFF;
+		gsGlobalInfo.sPathInfo.asRcOut[0].abSrcOnOff[MCDRV_SRC_MIC3_BLOCK]	|= MCDRV_SRC0_MIC3_ON;
+	}
+	else if((psPathInfo->asRcOut[0].abSrcOnOff[MCDRV_SRC_MIC3_BLOCK] & (MCDRV_SRC0_MIC3_ON|MCDRV_SRC0_MIC3_OFF)) == MCDRV_SRC0_MIC3_OFF)
+	{
+		gsGlobalInfo.sPathInfo.asRcOut[0].abSrcOnOff[MCDRV_SRC_MIC3_BLOCK]	&= (UINT8)~MCDRV_SRC0_MIC3_ON;
+		gsGlobalInfo.sPathInfo.asRcOut[0].abSrcOnOff[MCDRV_SRC_MIC3_BLOCK]	|= MCDRV_SRC0_MIC3_OFF;
+	}
+	else
+	{
+	}
+
+	if((psPathInfo->asRcOut[0].abSrcOnOff[MCDRV_SRC_LINE1_M_BLOCK] & (MCDRV_SRC1_LINE1_M_ON|MCDRV_SRC1_LINE1_M_OFF)) == MCDRV_SRC1_LINE1_M_ON)
+	{
+		gsGlobalInfo.sPathInfo.asRcOut[0].abSrcOnOff[MCDRV_SRC_LINE1_M_BLOCK]	&= (UINT8)~MCDRV_SRC1_LINE1_M_OFF;
+		gsGlobalInfo.sPathInfo.asRcOut[0].abSrcOnOff[MCDRV_SRC_LINE1_M_BLOCK]	|= MCDRV_SRC1_LINE1_M_ON;
+	}
+	else if((psPathInfo->asRcOut[0].abSrcOnOff[MCDRV_SRC_LINE1_M_BLOCK] & (MCDRV_SRC1_LINE1_M_ON|MCDRV_SRC1_LINE1_M_OFF)) == MCDRV_SRC1_LINE1_M_OFF)
+	{
+		gsGlobalInfo.sPathInfo.asRcOut[0].abSrcOnOff[MCDRV_SRC_LINE1_M_BLOCK]	&= (UINT8)~MCDRV_SRC1_LINE1_M_ON;
+		gsGlobalInfo.sPathInfo.asRcOut[0].abSrcOnOff[MCDRV_SRC_LINE1_M_BLOCK]	|= MCDRV_SRC1_LINE1_M_OFF;
+	}
+	else
+	{
+	}
+
+	if((psPathInfo->asRcOut[0].abSrcOnOff[MCDRV_SRC_DAC_L_BLOCK] & (MCDRV_SRC5_DAC_L_ON|MCDRV_SRC5_DAC_L_OFF)) == MCDRV_SRC5_DAC_L_ON)
+	{
+		gsGlobalInfo.sPathInfo.asRcOut[0].abSrcOnOff[MCDRV_SRC_DAC_L_BLOCK]	&= (UINT8)~MCDRV_SRC5_DAC_L_OFF;
+		gsGlobalInfo.sPathInfo.asRcOut[0].abSrcOnOff[MCDRV_SRC_DAC_L_BLOCK]	|= MCDRV_SRC5_DAC_L_ON;
+	}
+	else if((psPathInfo->asRcOut[0].abSrcOnOff[MCDRV_SRC_DAC_L_BLOCK] & (MCDRV_SRC5_DAC_L_ON|MCDRV_SRC5_DAC_L_OFF)) == MCDRV_SRC5_DAC_L_OFF)
+	{
+		gsGlobalInfo.sPathInfo.asRcOut[0].abSrcOnOff[MCDRV_SRC_DAC_L_BLOCK]	&= (UINT8)~MCDRV_SRC5_DAC_L_ON;
+		gsGlobalInfo.sPathInfo.asRcOut[0].abSrcOnOff[MCDRV_SRC_DAC_L_BLOCK]	|= MCDRV_SRC5_DAC_L_OFF;
+	}
+	else
+	{
+	}
+
+	if((psPathInfo->asRcOut[0].abSrcOnOff[MCDRV_SRC_DAC_R_BLOCK] & (MCDRV_SRC5_DAC_R_ON|MCDRV_SRC5_DAC_R_OFF)) == MCDRV_SRC5_DAC_R_ON)
+	{
+		gsGlobalInfo.sPathInfo.asRcOut[0].abSrcOnOff[MCDRV_SRC_DAC_R_BLOCK]	&= (UINT8)~MCDRV_SRC5_DAC_R_OFF;
+		gsGlobalInfo.sPathInfo.asRcOut[0].abSrcOnOff[MCDRV_SRC_DAC_R_BLOCK]	|= MCDRV_SRC5_DAC_R_ON;
+	}
+	else if((psPathInfo->asRcOut[0].abSrcOnOff[MCDRV_SRC_DAC_R_BLOCK] & (MCDRV_SRC5_DAC_R_ON|MCDRV_SRC5_DAC_R_OFF)) == MCDRV_SRC5_DAC_R_OFF)
+	{
+		gsGlobalInfo.sPathInfo.asRcOut[0].abSrcOnOff[MCDRV_SRC_DAC_R_BLOCK]	&= (UINT8)~MCDRV_SRC5_DAC_R_ON;
+		gsGlobalInfo.sPathInfo.asRcOut[0].abSrcOnOff[MCDRV_SRC_DAC_R_BLOCK]	|= MCDRV_SRC5_DAC_R_OFF;
+	}
+	else
+	{
+	}
+
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncOut("SetRCVSourceOnOff", 0);
+#endif
+}
+
+/****************************************************************************
+ *	SetLO1SourceOnOff
+ *
+ *	Description:
+ *			Set LOut1 source On/Off.
+ *	Arguments:
+ *			psPathInfo	path information
+ *	Return:
+ *			none
+ *
+ ****************************************************************************/
+static void	SetLO1SourceOnOff
+(
+	const MCDRV_PATH_INFO*	psPathInfo
+)
+{
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncIn("SetLO1SourceOnOff");
+#endif
+
+	if((psPathInfo->asLout1[0].abSrcOnOff[MCDRV_SRC_MIC1_BLOCK] & (MCDRV_SRC0_MIC1_ON|MCDRV_SRC0_MIC1_OFF)) == MCDRV_SRC0_MIC1_ON)
+	{
+		gsGlobalInfo.sPathInfo.asLout1[0].abSrcOnOff[MCDRV_SRC_MIC1_BLOCK]	&= (UINT8)~MCDRV_SRC0_MIC1_OFF;
+		gsGlobalInfo.sPathInfo.asLout1[0].abSrcOnOff[MCDRV_SRC_MIC1_BLOCK]	|= MCDRV_SRC0_MIC1_ON;
+	}
+	else if((psPathInfo->asLout1[0].abSrcOnOff[MCDRV_SRC_MIC1_BLOCK] & (MCDRV_SRC0_MIC1_ON|MCDRV_SRC0_MIC1_OFF)) == MCDRV_SRC0_MIC1_OFF)
+	{
+		gsGlobalInfo.sPathInfo.asLout1[0].abSrcOnOff[MCDRV_SRC_MIC1_BLOCK]	&= (UINT8)~MCDRV_SRC0_MIC1_ON;
+		gsGlobalInfo.sPathInfo.asLout1[0].abSrcOnOff[MCDRV_SRC_MIC1_BLOCK]	|= MCDRV_SRC0_MIC1_OFF;
+	}
+	else
+	{
+	}
+
+	if((psPathInfo->asLout1[0].abSrcOnOff[MCDRV_SRC_MIC2_BLOCK] & (MCDRV_SRC0_MIC2_ON|MCDRV_SRC0_MIC2_OFF)) == MCDRV_SRC0_MIC2_ON)
+	{
+		gsGlobalInfo.sPathInfo.asLout1[0].abSrcOnOff[MCDRV_SRC_MIC2_BLOCK]	&= (UINT8)~MCDRV_SRC0_MIC2_OFF;
+		gsGlobalInfo.sPathInfo.asLout1[0].abSrcOnOff[MCDRV_SRC_MIC2_BLOCK]	|= MCDRV_SRC0_MIC2_ON;
+	}
+	else if((psPathInfo->asLout1[0].abSrcOnOff[MCDRV_SRC_MIC2_BLOCK] & (MCDRV_SRC0_MIC2_ON|MCDRV_SRC0_MIC2_OFF)) == MCDRV_SRC0_MIC2_OFF)
+	{
+		gsGlobalInfo.sPathInfo.asLout1[0].abSrcOnOff[MCDRV_SRC_MIC2_BLOCK]	&= (UINT8)~MCDRV_SRC0_MIC2_ON;
+		gsGlobalInfo.sPathInfo.asLout1[0].abSrcOnOff[MCDRV_SRC_MIC2_BLOCK]	|= MCDRV_SRC0_MIC2_OFF;
+	}
+	else
+	{
+	}
+
+	if((psPathInfo->asLout1[0].abSrcOnOff[MCDRV_SRC_MIC3_BLOCK] & (MCDRV_SRC0_MIC3_ON|MCDRV_SRC0_MIC3_OFF)) == MCDRV_SRC0_MIC3_ON)
+	{
+		gsGlobalInfo.sPathInfo.asLout1[0].abSrcOnOff[MCDRV_SRC_MIC3_BLOCK]	&= (UINT8)~MCDRV_SRC0_MIC3_OFF;
+		gsGlobalInfo.sPathInfo.asLout1[0].abSrcOnOff[MCDRV_SRC_MIC3_BLOCK]	|= MCDRV_SRC0_MIC3_ON;
+	}
+	else if((psPathInfo->asLout1[0].abSrcOnOff[MCDRV_SRC_MIC3_BLOCK] & (MCDRV_SRC0_MIC3_ON|MCDRV_SRC0_MIC3_OFF)) == MCDRV_SRC0_MIC3_OFF)
+	{
+		gsGlobalInfo.sPathInfo.asLout1[0].abSrcOnOff[MCDRV_SRC_MIC3_BLOCK]	&= (UINT8)~MCDRV_SRC0_MIC3_ON;
+		gsGlobalInfo.sPathInfo.asLout1[0].abSrcOnOff[MCDRV_SRC_MIC3_BLOCK]	|= MCDRV_SRC0_MIC3_OFF;
+	}
+	else
+	{
+	}
+
+	if((psPathInfo->asLout1[0].abSrcOnOff[MCDRV_SRC_LINE1_L_BLOCK] & (MCDRV_SRC1_LINE1_L_ON|MCDRV_SRC1_LINE1_L_OFF)) == MCDRV_SRC1_LINE1_L_ON)
+	{
+		gsGlobalInfo.sPathInfo.asLout1[0].abSrcOnOff[MCDRV_SRC_LINE1_L_BLOCK]	&= (UINT8)~MCDRV_SRC1_LINE1_L_OFF;
+		gsGlobalInfo.sPathInfo.asLout1[0].abSrcOnOff[MCDRV_SRC_LINE1_L_BLOCK]	|= MCDRV_SRC1_LINE1_L_ON;
+	}
+	else if((psPathInfo->asLout1[0].abSrcOnOff[MCDRV_SRC_LINE1_L_BLOCK] & (MCDRV_SRC1_LINE1_L_ON|MCDRV_SRC1_LINE1_L_OFF)) == MCDRV_SRC1_LINE1_L_OFF)
+	{
+		gsGlobalInfo.sPathInfo.asLout1[0].abSrcOnOff[MCDRV_SRC_LINE1_L_BLOCK]	&= (UINT8)~MCDRV_SRC1_LINE1_L_ON;
+		gsGlobalInfo.sPathInfo.asLout1[0].abSrcOnOff[MCDRV_SRC_LINE1_L_BLOCK]	|= MCDRV_SRC1_LINE1_L_OFF;
+	}
+	else
+	{
+	}
+
+	if((psPathInfo->asLout1[0].abSrcOnOff[MCDRV_SRC_LINE1_M_BLOCK] & (MCDRV_SRC1_LINE1_M_ON|MCDRV_SRC1_LINE1_M_OFF)) == MCDRV_SRC1_LINE1_M_ON)
+	{
+		gsGlobalInfo.sPathInfo.asLout1[0].abSrcOnOff[MCDRV_SRC_LINE1_M_BLOCK]	&= (UINT8)~MCDRV_SRC1_LINE1_M_OFF;
+		gsGlobalInfo.sPathInfo.asLout1[0].abSrcOnOff[MCDRV_SRC_LINE1_M_BLOCK]	|= MCDRV_SRC1_LINE1_M_ON;
+	}
+	else if((psPathInfo->asLout1[0].abSrcOnOff[MCDRV_SRC_LINE1_M_BLOCK] & (MCDRV_SRC1_LINE1_M_ON|MCDRV_SRC1_LINE1_M_OFF)) == MCDRV_SRC1_LINE1_M_OFF)
+	{
+		gsGlobalInfo.sPathInfo.asLout1[0].abSrcOnOff[MCDRV_SRC_LINE1_M_BLOCK]	&= (UINT8)~MCDRV_SRC1_LINE1_M_ON;
+		gsGlobalInfo.sPathInfo.asLout1[0].abSrcOnOff[MCDRV_SRC_LINE1_M_BLOCK]	|= MCDRV_SRC1_LINE1_M_OFF;
+	}
+	else
+	{
+	}
+
+	if((psPathInfo->asLout1[0].abSrcOnOff[MCDRV_SRC_DAC_L_BLOCK] & (MCDRV_SRC5_DAC_L_ON|MCDRV_SRC5_DAC_L_OFF)) == MCDRV_SRC5_DAC_L_ON)
+	{
+		gsGlobalInfo.sPathInfo.asLout1[0].abSrcOnOff[MCDRV_SRC_DAC_L_BLOCK]	&= (UINT8)~MCDRV_SRC5_DAC_L_OFF;
+		gsGlobalInfo.sPathInfo.asLout1[0].abSrcOnOff[MCDRV_SRC_DAC_L_BLOCK]	|= MCDRV_SRC5_DAC_L_ON;
+	}
+	else if((psPathInfo->asLout1[0].abSrcOnOff[MCDRV_SRC_DAC_L_BLOCK] & (MCDRV_SRC5_DAC_L_ON|MCDRV_SRC5_DAC_L_OFF)) == MCDRV_SRC5_DAC_L_OFF)
+	{
+		gsGlobalInfo.sPathInfo.asLout1[0].abSrcOnOff[MCDRV_SRC_DAC_L_BLOCK]	&= (UINT8)~MCDRV_SRC5_DAC_L_ON;
+		gsGlobalInfo.sPathInfo.asLout1[0].abSrcOnOff[MCDRV_SRC_DAC_L_BLOCK]	|= MCDRV_SRC5_DAC_L_OFF;
+	}
+	else
+	{
+	}
+
+	if((psPathInfo->asLout1[0].abSrcOnOff[MCDRV_SRC_DAC_M_BLOCK] & (MCDRV_SRC5_DAC_M_ON|MCDRV_SRC5_DAC_M_OFF)) == MCDRV_SRC5_DAC_M_ON)
+	{
+		gsGlobalInfo.sPathInfo.asLout1[0].abSrcOnOff[MCDRV_SRC_DAC_M_BLOCK]	&= (UINT8)~MCDRV_SRC5_DAC_M_OFF;
+		gsGlobalInfo.sPathInfo.asLout1[0].abSrcOnOff[MCDRV_SRC_DAC_M_BLOCK]	|= MCDRV_SRC5_DAC_M_ON;
+	}
+	else if((psPathInfo->asLout1[0].abSrcOnOff[MCDRV_SRC_DAC_M_BLOCK] & (MCDRV_SRC5_DAC_M_ON|MCDRV_SRC5_DAC_M_OFF)) == MCDRV_SRC5_DAC_M_OFF)
+	{
+		gsGlobalInfo.sPathInfo.asLout1[0].abSrcOnOff[MCDRV_SRC_DAC_M_BLOCK]	&= (UINT8)~MCDRV_SRC5_DAC_M_ON;
+		gsGlobalInfo.sPathInfo.asLout1[0].abSrcOnOff[MCDRV_SRC_DAC_M_BLOCK]	|= MCDRV_SRC5_DAC_M_OFF;
+	}
+	else
+	{
+	}
+
+	if((psPathInfo->asLout1[1].abSrcOnOff[MCDRV_SRC_MIC1_BLOCK] & (MCDRV_SRC0_MIC1_ON|MCDRV_SRC0_MIC1_OFF)) == MCDRV_SRC0_MIC1_ON)
+	{
+		gsGlobalInfo.sPathInfo.asLout1[1].abSrcOnOff[MCDRV_SRC_MIC1_BLOCK]	&= (UINT8)~MCDRV_SRC0_MIC1_OFF;
+		gsGlobalInfo.sPathInfo.asLout1[1].abSrcOnOff[MCDRV_SRC_MIC1_BLOCK]	|= MCDRV_SRC0_MIC1_ON;
+	}
+	else if((psPathInfo->asLout1[1].abSrcOnOff[MCDRV_SRC_MIC1_BLOCK] & (MCDRV_SRC0_MIC1_ON|MCDRV_SRC0_MIC1_OFF)) == MCDRV_SRC0_MIC1_OFF)
+	{
+		gsGlobalInfo.sPathInfo.asLout1[1].abSrcOnOff[MCDRV_SRC_MIC1_BLOCK]	&= (UINT8)~MCDRV_SRC0_MIC1_ON;
+		gsGlobalInfo.sPathInfo.asLout1[1].abSrcOnOff[MCDRV_SRC_MIC1_BLOCK]	|= MCDRV_SRC0_MIC1_OFF;
+	}
+	else
+	{
+	}
+
+	if((psPathInfo->asLout1[1].abSrcOnOff[MCDRV_SRC_MIC2_BLOCK] & (MCDRV_SRC0_MIC2_ON|MCDRV_SRC0_MIC2_OFF)) == MCDRV_SRC0_MIC2_ON)
+	{
+		gsGlobalInfo.sPathInfo.asLout1[1].abSrcOnOff[MCDRV_SRC_MIC2_BLOCK]	&= (UINT8)~MCDRV_SRC0_MIC2_OFF;
+		gsGlobalInfo.sPathInfo.asLout1[1].abSrcOnOff[MCDRV_SRC_MIC2_BLOCK]	|= MCDRV_SRC0_MIC2_ON;
+	}
+	else if((psPathInfo->asLout1[1].abSrcOnOff[MCDRV_SRC_MIC2_BLOCK] & (MCDRV_SRC0_MIC2_ON|MCDRV_SRC0_MIC2_OFF)) == MCDRV_SRC0_MIC2_OFF)
+	{
+		gsGlobalInfo.sPathInfo.asLout1[1].abSrcOnOff[MCDRV_SRC_MIC2_BLOCK]	&= (UINT8)~MCDRV_SRC0_MIC2_ON;
+		gsGlobalInfo.sPathInfo.asLout1[1].abSrcOnOff[MCDRV_SRC_MIC2_BLOCK]	|= MCDRV_SRC0_MIC2_OFF;
+	}
+	else
+	{
+	}
+
+	if((psPathInfo->asLout1[1].abSrcOnOff[MCDRV_SRC_MIC3_BLOCK] & (MCDRV_SRC0_MIC3_ON|MCDRV_SRC0_MIC3_OFF)) == MCDRV_SRC0_MIC3_ON)
+	{
+		gsGlobalInfo.sPathInfo.asLout1[1].abSrcOnOff[MCDRV_SRC_MIC3_BLOCK]	&= (UINT8)~MCDRV_SRC0_MIC3_OFF;
+		gsGlobalInfo.sPathInfo.asLout1[1].abSrcOnOff[MCDRV_SRC_MIC3_BLOCK]	|= MCDRV_SRC0_MIC3_ON;
+	}
+	else if((psPathInfo->asLout1[1].abSrcOnOff[MCDRV_SRC_MIC3_BLOCK] & (MCDRV_SRC0_MIC3_ON|MCDRV_SRC0_MIC3_OFF)) == MCDRV_SRC0_MIC3_OFF)
+	{
+		gsGlobalInfo.sPathInfo.asLout1[1].abSrcOnOff[MCDRV_SRC_MIC3_BLOCK]	&= (UINT8)~MCDRV_SRC0_MIC3_ON;
+		gsGlobalInfo.sPathInfo.asLout1[1].abSrcOnOff[MCDRV_SRC_MIC3_BLOCK]	|= MCDRV_SRC0_MIC3_OFF;
+	}
+	else
+	{
+	}
+
+	if((psPathInfo->asLout1[1].abSrcOnOff[MCDRV_SRC_LINE1_R_BLOCK] & (MCDRV_SRC1_LINE1_R_ON|MCDRV_SRC1_LINE1_R_OFF)) == MCDRV_SRC1_LINE1_R_ON)
+	{
+		gsGlobalInfo.sPathInfo.asLout1[1].abSrcOnOff[MCDRV_SRC_LINE1_R_BLOCK]	&= (UINT8)~MCDRV_SRC1_LINE1_R_OFF;
+		gsGlobalInfo.sPathInfo.asLout1[1].abSrcOnOff[MCDRV_SRC_LINE1_R_BLOCK]	|= MCDRV_SRC1_LINE1_R_ON;
+	}
+	else if((psPathInfo->asLout1[1].abSrcOnOff[MCDRV_SRC_LINE1_R_BLOCK] & (MCDRV_SRC1_LINE1_R_ON|MCDRV_SRC1_LINE1_R_OFF)) == MCDRV_SRC1_LINE1_R_OFF)
+	{
+		gsGlobalInfo.sPathInfo.asLout1[1].abSrcOnOff[MCDRV_SRC_LINE1_R_BLOCK]	&= (UINT8)~MCDRV_SRC1_LINE1_R_ON;
+		gsGlobalInfo.sPathInfo.asLout1[1].abSrcOnOff[MCDRV_SRC_LINE1_R_BLOCK]	|= MCDRV_SRC1_LINE1_R_OFF;
+	}
+	else
+	{
+	}
+
+	if((psPathInfo->asLout1[1].abSrcOnOff[MCDRV_SRC_DAC_R_BLOCK] & (MCDRV_SRC5_DAC_R_ON|MCDRV_SRC5_DAC_R_OFF)) == MCDRV_SRC5_DAC_R_ON)
+	{
+		gsGlobalInfo.sPathInfo.asLout1[1].abSrcOnOff[MCDRV_SRC_DAC_R_BLOCK]	&= (UINT8)~MCDRV_SRC5_DAC_R_OFF;
+		gsGlobalInfo.sPathInfo.asLout1[1].abSrcOnOff[MCDRV_SRC_DAC_R_BLOCK]	|= MCDRV_SRC5_DAC_R_ON;
+	}
+	else if((psPathInfo->asLout1[1].abSrcOnOff[MCDRV_SRC_DAC_R_BLOCK] & (MCDRV_SRC5_DAC_R_ON|MCDRV_SRC5_DAC_R_OFF)) == MCDRV_SRC5_DAC_R_OFF)
+	{
+		gsGlobalInfo.sPathInfo.asLout1[1].abSrcOnOff[MCDRV_SRC_DAC_R_BLOCK]	&= (UINT8)~MCDRV_SRC5_DAC_R_ON;
+		gsGlobalInfo.sPathInfo.asLout1[1].abSrcOnOff[MCDRV_SRC_DAC_R_BLOCK]	|= MCDRV_SRC5_DAC_R_OFF;
+	}
+	else
+	{
+	}
+
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncOut("SetLO1SourceOnOff", 0);
+#endif
+}
+
+/****************************************************************************
+ *	SetLO2SourceOnOff
+ *
+ *	Description:
+ *			Set LOut2 source On/Off.
+ *	Arguments:
+ *			psPathInfo	path information
+ *	Return:
+ *			none
+ *
+ ****************************************************************************/
+static void	SetLO2SourceOnOff
+(
+	const MCDRV_PATH_INFO*	psPathInfo
+)
+{
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncIn("SetLO2SourceOnOff");
+#endif
+
+	if((psPathInfo->asLout2[0].abSrcOnOff[MCDRV_SRC_MIC1_BLOCK] & (MCDRV_SRC0_MIC1_ON|MCDRV_SRC0_MIC1_OFF)) == MCDRV_SRC0_MIC1_ON)
+	{
+		gsGlobalInfo.sPathInfo.asLout2[0].abSrcOnOff[MCDRV_SRC_MIC1_BLOCK]	&= (UINT8)~MCDRV_SRC0_MIC1_OFF;
+		gsGlobalInfo.sPathInfo.asLout2[0].abSrcOnOff[MCDRV_SRC_MIC1_BLOCK]	|= MCDRV_SRC0_MIC1_ON;
+	}
+	else if((psPathInfo->asLout2[0].abSrcOnOff[MCDRV_SRC_MIC1_BLOCK] & (MCDRV_SRC0_MIC1_ON|MCDRV_SRC0_MIC1_OFF)) == MCDRV_SRC0_MIC1_OFF)
+	{
+		gsGlobalInfo.sPathInfo.asLout2[0].abSrcOnOff[MCDRV_SRC_MIC1_BLOCK]	&= (UINT8)~MCDRV_SRC0_MIC1_ON;
+		gsGlobalInfo.sPathInfo.asLout2[0].abSrcOnOff[MCDRV_SRC_MIC1_BLOCK]	|= MCDRV_SRC0_MIC1_OFF;
+	}
+	else
+	{
+	}
+
+	if((psPathInfo->asLout2[0].abSrcOnOff[MCDRV_SRC_MIC2_BLOCK] & (MCDRV_SRC0_MIC2_ON|MCDRV_SRC0_MIC2_OFF)) == MCDRV_SRC0_MIC2_ON)
+	{
+		gsGlobalInfo.sPathInfo.asLout2[0].abSrcOnOff[MCDRV_SRC_MIC2_BLOCK]	&= (UINT8)~MCDRV_SRC0_MIC2_OFF;
+		gsGlobalInfo.sPathInfo.asLout2[0].abSrcOnOff[MCDRV_SRC_MIC2_BLOCK]	|= MCDRV_SRC0_MIC2_ON;
+	}
+	else if((psPathInfo->asLout2[0].abSrcOnOff[MCDRV_SRC_MIC2_BLOCK] & (MCDRV_SRC0_MIC2_ON|MCDRV_SRC0_MIC2_OFF)) == MCDRV_SRC0_MIC2_OFF)
+	{
+		gsGlobalInfo.sPathInfo.asLout2[0].abSrcOnOff[MCDRV_SRC_MIC2_BLOCK]	&= (UINT8)~MCDRV_SRC0_MIC2_ON;
+		gsGlobalInfo.sPathInfo.asLout2[0].abSrcOnOff[MCDRV_SRC_MIC2_BLOCK]	|= MCDRV_SRC0_MIC2_OFF;
+	}
+	else
+	{
+	}
+
+	if((psPathInfo->asLout2[0].abSrcOnOff[MCDRV_SRC_MIC3_BLOCK] & (MCDRV_SRC0_MIC3_ON|MCDRV_SRC0_MIC3_OFF)) == MCDRV_SRC0_MIC3_ON)
+	{
+		gsGlobalInfo.sPathInfo.asLout2[0].abSrcOnOff[MCDRV_SRC_MIC3_BLOCK]	&= (UINT8)~MCDRV_SRC0_MIC3_OFF;
+		gsGlobalInfo.sPathInfo.asLout2[0].abSrcOnOff[MCDRV_SRC_MIC3_BLOCK]	|= MCDRV_SRC0_MIC3_ON;
+	}
+	else if((psPathInfo->asLout2[0].abSrcOnOff[MCDRV_SRC_MIC3_BLOCK] & (MCDRV_SRC0_MIC3_ON|MCDRV_SRC0_MIC3_OFF)) == MCDRV_SRC0_MIC3_OFF)
+	{
+		gsGlobalInfo.sPathInfo.asLout2[0].abSrcOnOff[MCDRV_SRC_MIC3_BLOCK]	&= (UINT8)~MCDRV_SRC0_MIC3_ON;
+		gsGlobalInfo.sPathInfo.asLout2[0].abSrcOnOff[MCDRV_SRC_MIC3_BLOCK]	|= MCDRV_SRC0_MIC3_OFF;
+	}
+	else
+	{
+	}
+
+	if((psPathInfo->asLout2[0].abSrcOnOff[MCDRV_SRC_LINE1_L_BLOCK] & (MCDRV_SRC1_LINE1_L_ON|MCDRV_SRC1_LINE1_L_OFF)) == MCDRV_SRC1_LINE1_L_ON)
+	{
+		gsGlobalInfo.sPathInfo.asLout2[0].abSrcOnOff[MCDRV_SRC_LINE1_L_BLOCK]	&= (UINT8)~MCDRV_SRC1_LINE1_L_OFF;
+		gsGlobalInfo.sPathInfo.asLout2[0].abSrcOnOff[MCDRV_SRC_LINE1_L_BLOCK]	|= MCDRV_SRC1_LINE1_L_ON;
+	}
+	else if((psPathInfo->asLout2[0].abSrcOnOff[MCDRV_SRC_LINE1_L_BLOCK] & (MCDRV_SRC1_LINE1_L_ON|MCDRV_SRC1_LINE1_L_OFF)) == MCDRV_SRC1_LINE1_L_OFF)
+	{
+		gsGlobalInfo.sPathInfo.asLout2[0].abSrcOnOff[MCDRV_SRC_LINE1_L_BLOCK]	&= (UINT8)~MCDRV_SRC1_LINE1_L_ON;
+		gsGlobalInfo.sPathInfo.asLout2[0].abSrcOnOff[MCDRV_SRC_LINE1_L_BLOCK]	|= MCDRV_SRC1_LINE1_L_OFF;
+	}
+	else
+	{
+	}
+
+	if((psPathInfo->asLout2[0].abSrcOnOff[MCDRV_SRC_LINE1_M_BLOCK] & (MCDRV_SRC1_LINE1_M_ON|MCDRV_SRC1_LINE1_M_OFF)) == MCDRV_SRC1_LINE1_M_ON)
+	{
+		gsGlobalInfo.sPathInfo.asLout2[0].abSrcOnOff[MCDRV_SRC_LINE1_M_BLOCK]	&= (UINT8)~MCDRV_SRC1_LINE1_M_OFF;
+		gsGlobalInfo.sPathInfo.asLout2[0].abSrcOnOff[MCDRV_SRC_LINE1_M_BLOCK]	|= MCDRV_SRC1_LINE1_M_ON;
+	}
+	else if((psPathInfo->asLout2[0].abSrcOnOff[MCDRV_SRC_LINE1_M_BLOCK] & (MCDRV_SRC1_LINE1_M_ON|MCDRV_SRC1_LINE1_M_OFF)) == MCDRV_SRC1_LINE1_M_OFF)
+	{
+		gsGlobalInfo.sPathInfo.asLout2[0].abSrcOnOff[MCDRV_SRC_LINE1_M_BLOCK]	&= (UINT8)~MCDRV_SRC1_LINE1_M_ON;
+		gsGlobalInfo.sPathInfo.asLout2[0].abSrcOnOff[MCDRV_SRC_LINE1_M_BLOCK]	|= MCDRV_SRC1_LINE1_M_OFF;
+	}
+	else
+	{
+	}
+
+	if((psPathInfo->asLout2[0].abSrcOnOff[MCDRV_SRC_DAC_L_BLOCK] & (MCDRV_SRC5_DAC_L_ON|MCDRV_SRC5_DAC_L_OFF)) == MCDRV_SRC5_DAC_L_ON)
+	{
+		gsGlobalInfo.sPathInfo.asLout2[0].abSrcOnOff[MCDRV_SRC_DAC_L_BLOCK]	&= (UINT8)~MCDRV_SRC5_DAC_L_OFF;
+		gsGlobalInfo.sPathInfo.asLout2[0].abSrcOnOff[MCDRV_SRC_DAC_L_BLOCK]	|= MCDRV_SRC5_DAC_L_ON;
+	}
+	else if((psPathInfo->asLout2[0].abSrcOnOff[MCDRV_SRC_DAC_L_BLOCK] & (MCDRV_SRC5_DAC_L_ON|MCDRV_SRC5_DAC_L_OFF)) == MCDRV_SRC5_DAC_L_OFF)
+	{
+		gsGlobalInfo.sPathInfo.asLout2[0].abSrcOnOff[MCDRV_SRC_DAC_L_BLOCK]	&= (UINT8)~MCDRV_SRC5_DAC_L_ON;
+		gsGlobalInfo.sPathInfo.asLout2[0].abSrcOnOff[MCDRV_SRC_DAC_L_BLOCK]	|= MCDRV_SRC5_DAC_L_OFF;
+	}
+	else
+	{
+	}
+
+	if((psPathInfo->asLout2[0].abSrcOnOff[MCDRV_SRC_DAC_M_BLOCK] & (MCDRV_SRC5_DAC_M_ON|MCDRV_SRC5_DAC_M_OFF)) == MCDRV_SRC5_DAC_M_ON)
+	{
+		gsGlobalInfo.sPathInfo.asLout2[0].abSrcOnOff[MCDRV_SRC_DAC_M_BLOCK]	&= (UINT8)~MCDRV_SRC5_DAC_M_OFF;
+		gsGlobalInfo.sPathInfo.asLout2[0].abSrcOnOff[MCDRV_SRC_DAC_M_BLOCK]	|= MCDRV_SRC5_DAC_M_ON;
+	}
+	else if((psPathInfo->asLout2[0].abSrcOnOff[MCDRV_SRC_DAC_M_BLOCK] & (MCDRV_SRC5_DAC_M_ON|MCDRV_SRC5_DAC_M_OFF)) == MCDRV_SRC5_DAC_M_OFF)
+	{
+		gsGlobalInfo.sPathInfo.asLout2[0].abSrcOnOff[MCDRV_SRC_DAC_M_BLOCK]	&= (UINT8)~MCDRV_SRC5_DAC_M_ON;
+		gsGlobalInfo.sPathInfo.asLout2[0].abSrcOnOff[MCDRV_SRC_DAC_M_BLOCK]	|= MCDRV_SRC5_DAC_M_OFF;
+	}
+	else
+	{
+	}
+
+	if((psPathInfo->asLout2[1].abSrcOnOff[MCDRV_SRC_MIC1_BLOCK] & (MCDRV_SRC0_MIC1_ON|MCDRV_SRC0_MIC1_OFF)) == MCDRV_SRC0_MIC1_ON)
+	{
+		gsGlobalInfo.sPathInfo.asLout2[1].abSrcOnOff[MCDRV_SRC_MIC1_BLOCK]	&= (UINT8)~MCDRV_SRC0_MIC1_OFF;
+		gsGlobalInfo.sPathInfo.asLout2[1].abSrcOnOff[MCDRV_SRC_MIC1_BLOCK]	|= MCDRV_SRC0_MIC1_ON;
+	}
+	else if((psPathInfo->asLout2[1].abSrcOnOff[MCDRV_SRC_MIC1_BLOCK] & (MCDRV_SRC0_MIC1_ON|MCDRV_SRC0_MIC1_OFF)) == MCDRV_SRC0_MIC1_OFF)
+	{
+		gsGlobalInfo.sPathInfo.asLout2[1].abSrcOnOff[MCDRV_SRC_MIC1_BLOCK]	&= (UINT8)~MCDRV_SRC0_MIC1_ON;
+		gsGlobalInfo.sPathInfo.asLout2[1].abSrcOnOff[MCDRV_SRC_MIC1_BLOCK]	|= MCDRV_SRC0_MIC1_OFF;
+	}
+	else
+	{
+	}
+
+	if((psPathInfo->asLout2[1].abSrcOnOff[MCDRV_SRC_MIC2_BLOCK] & (MCDRV_SRC0_MIC2_ON|MCDRV_SRC0_MIC2_OFF)) == MCDRV_SRC0_MIC2_ON)
+	{
+		gsGlobalInfo.sPathInfo.asLout2[1].abSrcOnOff[MCDRV_SRC_MIC2_BLOCK]	&= (UINT8)~MCDRV_SRC0_MIC2_OFF;
+		gsGlobalInfo.sPathInfo.asLout2[1].abSrcOnOff[MCDRV_SRC_MIC2_BLOCK]	|= MCDRV_SRC0_MIC2_ON;
+	}
+	else if((psPathInfo->asLout2[1].abSrcOnOff[MCDRV_SRC_MIC2_BLOCK] & (MCDRV_SRC0_MIC2_ON|MCDRV_SRC0_MIC2_OFF)) == MCDRV_SRC0_MIC2_OFF)
+	{
+		gsGlobalInfo.sPathInfo.asLout2[1].abSrcOnOff[MCDRV_SRC_MIC2_BLOCK]	&= (UINT8)~MCDRV_SRC0_MIC2_ON;
+		gsGlobalInfo.sPathInfo.asLout2[1].abSrcOnOff[MCDRV_SRC_MIC2_BLOCK]	|= MCDRV_SRC0_MIC2_OFF;
+	}
+	else
+	{
+	}
+
+	if((psPathInfo->asLout2[1].abSrcOnOff[MCDRV_SRC_MIC3_BLOCK] & (MCDRV_SRC0_MIC3_ON|MCDRV_SRC0_MIC3_OFF)) == MCDRV_SRC0_MIC3_ON)
+	{
+		gsGlobalInfo.sPathInfo.asLout2[1].abSrcOnOff[MCDRV_SRC_MIC3_BLOCK]	&= (UINT8)~MCDRV_SRC0_MIC3_OFF;
+		gsGlobalInfo.sPathInfo.asLout2[1].abSrcOnOff[MCDRV_SRC_MIC3_BLOCK]	|= MCDRV_SRC0_MIC3_ON;
+	}
+	else if((psPathInfo->asLout2[1].abSrcOnOff[MCDRV_SRC_MIC3_BLOCK] & (MCDRV_SRC0_MIC3_ON|MCDRV_SRC0_MIC3_OFF)) == MCDRV_SRC0_MIC3_OFF)
+	{
+		gsGlobalInfo.sPathInfo.asLout2[1].abSrcOnOff[MCDRV_SRC_MIC3_BLOCK]	&= (UINT8)~MCDRV_SRC0_MIC3_ON;
+		gsGlobalInfo.sPathInfo.asLout2[1].abSrcOnOff[MCDRV_SRC_MIC3_BLOCK]	|= MCDRV_SRC0_MIC3_OFF;
+	}
+	else
+	{
+	}
+
+	if((psPathInfo->asLout2[1].abSrcOnOff[MCDRV_SRC_LINE1_R_BLOCK] & (MCDRV_SRC1_LINE1_R_ON|MCDRV_SRC1_LINE1_R_OFF)) == MCDRV_SRC1_LINE1_R_ON)
+	{
+		gsGlobalInfo.sPathInfo.asLout2[1].abSrcOnOff[MCDRV_SRC_LINE1_R_BLOCK]	&= (UINT8)~MCDRV_SRC1_LINE1_R_OFF;
+		gsGlobalInfo.sPathInfo.asLout2[1].abSrcOnOff[MCDRV_SRC_LINE1_R_BLOCK]	|= MCDRV_SRC1_LINE1_R_ON;
+	}
+	else if((psPathInfo->asLout2[1].abSrcOnOff[MCDRV_SRC_LINE1_R_BLOCK] & (MCDRV_SRC1_LINE1_R_ON|MCDRV_SRC1_LINE1_R_OFF)) == MCDRV_SRC1_LINE1_R_OFF)
+	{
+		gsGlobalInfo.sPathInfo.asLout2[1].abSrcOnOff[MCDRV_SRC_LINE1_R_BLOCK]	&= (UINT8)~MCDRV_SRC1_LINE1_R_ON;
+		gsGlobalInfo.sPathInfo.asLout2[1].abSrcOnOff[MCDRV_SRC_LINE1_R_BLOCK]	|= MCDRV_SRC1_LINE1_R_OFF;
+	}
+	else
+	{
+	}
+
+	if((psPathInfo->asLout2[1].abSrcOnOff[MCDRV_SRC_DAC_R_BLOCK] & (MCDRV_SRC5_DAC_R_ON|MCDRV_SRC5_DAC_R_OFF)) == MCDRV_SRC5_DAC_R_ON)
+	{
+		gsGlobalInfo.sPathInfo.asLout2[1].abSrcOnOff[MCDRV_SRC_DAC_R_BLOCK]	&= (UINT8)~MCDRV_SRC5_DAC_R_OFF;
+		gsGlobalInfo.sPathInfo.asLout2[1].abSrcOnOff[MCDRV_SRC_DAC_R_BLOCK]	|= MCDRV_SRC5_DAC_R_ON;
+	}
+	else if((psPathInfo->asLout2[1].abSrcOnOff[MCDRV_SRC_DAC_R_BLOCK] & (MCDRV_SRC5_DAC_R_ON|MCDRV_SRC5_DAC_R_OFF)) == MCDRV_SRC5_DAC_R_OFF)
+	{
+		gsGlobalInfo.sPathInfo.asLout2[1].abSrcOnOff[MCDRV_SRC_DAC_R_BLOCK]	&= (UINT8)~MCDRV_SRC5_DAC_R_ON;
+		gsGlobalInfo.sPathInfo.asLout2[1].abSrcOnOff[MCDRV_SRC_DAC_R_BLOCK]	|= MCDRV_SRC5_DAC_R_OFF;
+	}
+	else
+	{
+	}
+
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncOut("SetLO2SourceOnOff", 0);
+#endif
+}
+
+/****************************************************************************
+ *	SetPMSourceOnOff
+ *
+ *	Description:
+ *			Set PeakMeter source On/Off.
+ *	Arguments:
+ *			psPathInfo	path information
+ *	Return:
+ *			none
+ *
+ ****************************************************************************/
+static void	SetPMSourceOnOff
+(
+	const MCDRV_PATH_INFO*	psPathInfo
+)
+{
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncIn("SetPMSourceOnOff");
+#endif
+
+	(void)psPathInfo;
+
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncOut("SetPMSourceOnOff", 0);
+#endif
+}
+
+/****************************************************************************
+ *	SetDIT0SourceOnOff
+ *
+ *	Description:
+ *			Set DIT0 source On/Off.
+ *	Arguments:
+ *			psPathInfo	path information
+ *	Return:
+ *			none
+ *
+ ****************************************************************************/
+static void	SetDIT0SourceOnOff
+(
+	const MCDRV_PATH_INFO*	psPathInfo
+)
+{
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncIn("SetDIT0SourceOnOff");
+#endif
+
+	if(((psPathInfo->asDit0[0].abSrcOnOff[MCDRV_SRC_PDM_BLOCK] & (MCDRV_SRC4_PDM_ON|MCDRV_SRC4_PDM_OFF)) == MCDRV_SRC4_PDM_ON)
+	&& (gsGlobalInfo.sInitInfo.bPad0Func == MCDRV_PAD_PDMCK))
+	{
+		gsGlobalInfo.sPathInfo.asDit0[0].abSrcOnOff[MCDRV_SRC_PDM_BLOCK]	&= (UINT8)~MCDRV_SRC4_PDM_OFF;
+		gsGlobalInfo.sPathInfo.asDit0[0].abSrcOnOff[MCDRV_SRC_PDM_BLOCK]	|= MCDRV_SRC4_PDM_ON;
+		gsGlobalInfo.sPathInfo.asDit0[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK]	&= (UINT8)~MCDRV_SRC4_ADC0_ON;
+		gsGlobalInfo.sPathInfo.asDit0[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK]	|= MCDRV_SRC4_ADC0_OFF;
+		gsGlobalInfo.sPathInfo.asDit0[0].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR0_ON;
+		gsGlobalInfo.sPathInfo.asDit0[0].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK]	|= MCDRV_SRC3_DIR0_OFF;
+		gsGlobalInfo.sPathInfo.asDit0[0].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR1_ON;
+		gsGlobalInfo.sPathInfo.asDit0[0].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK]	|= MCDRV_SRC3_DIR1_OFF;
+		gsGlobalInfo.sPathInfo.asDit0[0].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR2_ON;
+		gsGlobalInfo.sPathInfo.asDit0[0].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK]	|= MCDRV_SRC3_DIR2_OFF;
+		gsGlobalInfo.sPathInfo.asDit0[0].abSrcOnOff[MCDRV_SRC_AE_BLOCK]		&= (UINT8)~MCDRV_SRC6_AE_ON;
+		gsGlobalInfo.sPathInfo.asDit0[0].abSrcOnOff[MCDRV_SRC_AE_BLOCK]		|= MCDRV_SRC6_AE_OFF;
+		gsGlobalInfo.sPathInfo.asDit0[0].abSrcOnOff[MCDRV_SRC_MIX_BLOCK]	&= (UINT8)~MCDRV_SRC6_MIX_ON;
+		gsGlobalInfo.sPathInfo.asDit0[0].abSrcOnOff[MCDRV_SRC_MIX_BLOCK]	|= MCDRV_SRC6_MIX_OFF;
+	}
+	else if((psPathInfo->asDit0[0].abSrcOnOff[MCDRV_SRC_PDM_BLOCK] & (MCDRV_SRC4_PDM_ON|MCDRV_SRC4_PDM_OFF)) == MCDRV_SRC4_PDM_OFF)
+	{
+		gsGlobalInfo.sPathInfo.asDit0[0].abSrcOnOff[MCDRV_SRC_PDM_BLOCK]	&= (UINT8)~MCDRV_SRC4_PDM_ON;
+		gsGlobalInfo.sPathInfo.asDit0[0].abSrcOnOff[MCDRV_SRC_PDM_BLOCK]	|= MCDRV_SRC4_PDM_OFF;
+	}
+	else
+	{
+	}
+
+	if((psPathInfo->asDit0[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK] & (MCDRV_SRC4_ADC0_ON|MCDRV_SRC4_ADC0_OFF)) == MCDRV_SRC4_ADC0_ON)
+	{
+		gsGlobalInfo.sPathInfo.asDit0[0].abSrcOnOff[MCDRV_SRC_PDM_BLOCK]	&= (UINT8)~MCDRV_SRC4_PDM_ON;
+		gsGlobalInfo.sPathInfo.asDit0[0].abSrcOnOff[MCDRV_SRC_PDM_BLOCK]	|= MCDRV_SRC4_PDM_OFF;
+		gsGlobalInfo.sPathInfo.asDit0[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK]	&= (UINT8)~MCDRV_SRC4_ADC0_OFF;
+		gsGlobalInfo.sPathInfo.asDit0[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK]	|= MCDRV_SRC4_ADC0_ON;
+		gsGlobalInfo.sPathInfo.asDit0[0].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR0_ON;
+		gsGlobalInfo.sPathInfo.asDit0[0].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK]	|= MCDRV_SRC3_DIR0_OFF;
+		gsGlobalInfo.sPathInfo.asDit0[0].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR1_ON;
+		gsGlobalInfo.sPathInfo.asDit0[0].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK]	|= MCDRV_SRC3_DIR1_OFF;
+		gsGlobalInfo.sPathInfo.asDit0[0].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR2_ON;
+		gsGlobalInfo.sPathInfo.asDit0[0].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK]	|= MCDRV_SRC3_DIR2_OFF;
+		gsGlobalInfo.sPathInfo.asDit0[0].abSrcOnOff[MCDRV_SRC_AE_BLOCK]		&= (UINT8)~MCDRV_SRC6_AE_ON;
+		gsGlobalInfo.sPathInfo.asDit0[0].abSrcOnOff[MCDRV_SRC_AE_BLOCK]		|= MCDRV_SRC6_AE_OFF;
+		gsGlobalInfo.sPathInfo.asDit0[0].abSrcOnOff[MCDRV_SRC_MIX_BLOCK]	&= (UINT8)~MCDRV_SRC6_MIX_ON;
+		gsGlobalInfo.sPathInfo.asDit0[0].abSrcOnOff[MCDRV_SRC_MIX_BLOCK]	|= MCDRV_SRC6_MIX_OFF;
+	}
+	else if((psPathInfo->asDit0[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK] & (MCDRV_SRC4_ADC0_ON|MCDRV_SRC4_ADC0_OFF)) == MCDRV_SRC4_ADC0_OFF)
+	{
+		gsGlobalInfo.sPathInfo.asDit0[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK]	&= (UINT8)~MCDRV_SRC4_ADC0_ON;
+		gsGlobalInfo.sPathInfo.asDit0[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK]	|= MCDRV_SRC4_ADC0_OFF;
+	}
+	else
+	{
+	}
+
+	if((psPathInfo->asDit0[0].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK] & (MCDRV_SRC3_DIR0_ON|MCDRV_SRC3_DIR0_OFF)) == MCDRV_SRC3_DIR0_ON)
+	{
+		gsGlobalInfo.sPathInfo.asDit0[0].abSrcOnOff[MCDRV_SRC_PDM_BLOCK]	&= (UINT8)~MCDRV_SRC4_PDM_ON;
+		gsGlobalInfo.sPathInfo.asDit0[0].abSrcOnOff[MCDRV_SRC_PDM_BLOCK]	|= MCDRV_SRC4_PDM_OFF;
+		gsGlobalInfo.sPathInfo.asDit0[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK]	&= (UINT8)~MCDRV_SRC4_ADC0_ON;
+		gsGlobalInfo.sPathInfo.asDit0[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK]	|= MCDRV_SRC4_ADC0_OFF;
+		gsGlobalInfo.sPathInfo.asDit0[0].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR0_OFF;
+		gsGlobalInfo.sPathInfo.asDit0[0].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK]	|= MCDRV_SRC3_DIR0_ON;
+		gsGlobalInfo.sPathInfo.asDit0[0].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR1_ON;
+		gsGlobalInfo.sPathInfo.asDit0[0].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK]	|= MCDRV_SRC3_DIR1_OFF;
+		gsGlobalInfo.sPathInfo.asDit0[0].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR2_ON;
+		gsGlobalInfo.sPathInfo.asDit0[0].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK]	|= MCDRV_SRC3_DIR2_OFF;
+		gsGlobalInfo.sPathInfo.asDit0[0].abSrcOnOff[MCDRV_SRC_AE_BLOCK]		&= (UINT8)~MCDRV_SRC6_AE_ON;
+		gsGlobalInfo.sPathInfo.asDit0[0].abSrcOnOff[MCDRV_SRC_AE_BLOCK]		|= MCDRV_SRC6_AE_OFF;
+		gsGlobalInfo.sPathInfo.asDit0[0].abSrcOnOff[MCDRV_SRC_MIX_BLOCK]	&= (UINT8)~MCDRV_SRC6_MIX_ON;
+		gsGlobalInfo.sPathInfo.asDit0[0].abSrcOnOff[MCDRV_SRC_MIX_BLOCK]	|= MCDRV_SRC6_MIX_OFF;
+	}
+	else if((psPathInfo->asDit0[0].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK] & (MCDRV_SRC3_DIR0_ON|MCDRV_SRC3_DIR0_OFF)) == MCDRV_SRC3_DIR0_OFF)
+	{
+		gsGlobalInfo.sPathInfo.asDit0[0].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR0_ON;
+		gsGlobalInfo.sPathInfo.asDit0[0].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK]	|= MCDRV_SRC3_DIR0_OFF;
+	}
+	else
+	{
+	}
+
+	if((psPathInfo->asDit0[0].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK] & (MCDRV_SRC3_DIR1_ON|MCDRV_SRC3_DIR1_OFF)) == MCDRV_SRC3_DIR1_ON)
+	{
+		gsGlobalInfo.sPathInfo.asDit0[0].abSrcOnOff[MCDRV_SRC_PDM_BLOCK]	&= (UINT8)~MCDRV_SRC4_PDM_ON;
+		gsGlobalInfo.sPathInfo.asDit0[0].abSrcOnOff[MCDRV_SRC_PDM_BLOCK]	|= MCDRV_SRC4_PDM_OFF;
+		gsGlobalInfo.sPathInfo.asDit0[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK]	&= (UINT8)~MCDRV_SRC4_ADC0_ON;
+		gsGlobalInfo.sPathInfo.asDit0[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK]	|= MCDRV_SRC4_ADC0_OFF;
+		gsGlobalInfo.sPathInfo.asDit0[0].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR0_ON;
+		gsGlobalInfo.sPathInfo.asDit0[0].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK]	|= MCDRV_SRC3_DIR0_OFF;
+		gsGlobalInfo.sPathInfo.asDit0[0].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR1_OFF;
+		gsGlobalInfo.sPathInfo.asDit0[0].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK]	|= MCDRV_SRC3_DIR1_ON;
+		gsGlobalInfo.sPathInfo.asDit0[0].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR2_ON;
+		gsGlobalInfo.sPathInfo.asDit0[0].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK]	|= MCDRV_SRC3_DIR2_OFF;
+		gsGlobalInfo.sPathInfo.asDit0[0].abSrcOnOff[MCDRV_SRC_AE_BLOCK]		&= (UINT8)~MCDRV_SRC6_AE_ON;
+		gsGlobalInfo.sPathInfo.asDit0[0].abSrcOnOff[MCDRV_SRC_AE_BLOCK]		|= MCDRV_SRC6_AE_OFF;
+		gsGlobalInfo.sPathInfo.asDit0[0].abSrcOnOff[MCDRV_SRC_MIX_BLOCK]	&= (UINT8)~MCDRV_SRC6_MIX_ON;
+		gsGlobalInfo.sPathInfo.asDit0[0].abSrcOnOff[MCDRV_SRC_MIX_BLOCK]	|= MCDRV_SRC6_MIX_OFF;
+	}
+	else if((psPathInfo->asDit0[0].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK] & (MCDRV_SRC3_DIR1_ON|MCDRV_SRC3_DIR1_OFF)) == MCDRV_SRC3_DIR1_OFF)
+	{
+		gsGlobalInfo.sPathInfo.asDit0[0].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR1_ON;
+		gsGlobalInfo.sPathInfo.asDit0[0].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK]	|= MCDRV_SRC3_DIR1_OFF;
+	}
+	else
+	{
+	}
+
+	if((psPathInfo->asDit0[0].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK] & (MCDRV_SRC3_DIR2_ON|MCDRV_SRC3_DIR2_OFF)) == MCDRV_SRC3_DIR2_ON)
+	{
+		gsGlobalInfo.sPathInfo.asDit0[0].abSrcOnOff[MCDRV_SRC_PDM_BLOCK]	&= (UINT8)~MCDRV_SRC4_PDM_ON;
+		gsGlobalInfo.sPathInfo.asDit0[0].abSrcOnOff[MCDRV_SRC_PDM_BLOCK]	|= MCDRV_SRC4_PDM_OFF;
+		gsGlobalInfo.sPathInfo.asDit0[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK]	&= (UINT8)~MCDRV_SRC4_ADC0_ON;
+		gsGlobalInfo.sPathInfo.asDit0[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK]	|= MCDRV_SRC4_ADC0_OFF;
+		gsGlobalInfo.sPathInfo.asDit0[0].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR0_ON;
+		gsGlobalInfo.sPathInfo.asDit0[0].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK]	|= MCDRV_SRC3_DIR0_OFF;
+		gsGlobalInfo.sPathInfo.asDit0[0].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR1_ON;
+		gsGlobalInfo.sPathInfo.asDit0[0].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK]	|= MCDRV_SRC3_DIR1_OFF;
+		gsGlobalInfo.sPathInfo.asDit0[0].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR2_OFF;
+		gsGlobalInfo.sPathInfo.asDit0[0].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK]	|= MCDRV_SRC3_DIR2_ON;
+		gsGlobalInfo.sPathInfo.asDit0[0].abSrcOnOff[MCDRV_SRC_AE_BLOCK]		&= (UINT8)~MCDRV_SRC6_AE_ON;
+		gsGlobalInfo.sPathInfo.asDit0[0].abSrcOnOff[MCDRV_SRC_AE_BLOCK]		|= MCDRV_SRC6_AE_OFF;
+		gsGlobalInfo.sPathInfo.asDit0[0].abSrcOnOff[MCDRV_SRC_MIX_BLOCK]	&= (UINT8)~MCDRV_SRC6_MIX_ON;
+		gsGlobalInfo.sPathInfo.asDit0[0].abSrcOnOff[MCDRV_SRC_MIX_BLOCK]	|= MCDRV_SRC6_MIX_OFF;
+	}
+	else if((psPathInfo->asDit0[0].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK] & (MCDRV_SRC3_DIR2_ON|MCDRV_SRC3_DIR2_OFF)) == MCDRV_SRC3_DIR2_OFF)
+	{
+		gsGlobalInfo.sPathInfo.asDit0[0].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR2_ON;
+		gsGlobalInfo.sPathInfo.asDit0[0].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK]	|= MCDRV_SRC3_DIR2_OFF;
+	}
+	else
+	{
+	}
+
+	if((psPathInfo->asDit0[0].abSrcOnOff[MCDRV_SRC_AE_BLOCK] & (MCDRV_SRC6_AE_ON|MCDRV_SRC6_AE_OFF)) == MCDRV_SRC6_AE_ON)
+	{
+		gsGlobalInfo.sPathInfo.asDit0[0].abSrcOnOff[MCDRV_SRC_PDM_BLOCK]	&= (UINT8)~MCDRV_SRC4_PDM_ON;
+		gsGlobalInfo.sPathInfo.asDit0[0].abSrcOnOff[MCDRV_SRC_PDM_BLOCK]	|= MCDRV_SRC4_PDM_OFF;
+		gsGlobalInfo.sPathInfo.asDit0[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK]	&= (UINT8)~MCDRV_SRC4_ADC0_ON;
+		gsGlobalInfo.sPathInfo.asDit0[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK]	|= MCDRV_SRC4_ADC0_OFF;
+		gsGlobalInfo.sPathInfo.asDit0[0].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR0_ON;
+		gsGlobalInfo.sPathInfo.asDit0[0].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK]	|= MCDRV_SRC3_DIR0_OFF;
+		gsGlobalInfo.sPathInfo.asDit0[0].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR1_ON;
+		gsGlobalInfo.sPathInfo.asDit0[0].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK]	|= MCDRV_SRC3_DIR1_OFF;
+		gsGlobalInfo.sPathInfo.asDit0[0].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR2_ON;
+		gsGlobalInfo.sPathInfo.asDit0[0].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK]	|= MCDRV_SRC3_DIR2_OFF;
+		gsGlobalInfo.sPathInfo.asDit0[0].abSrcOnOff[MCDRV_SRC_AE_BLOCK]		&= (UINT8)~MCDRV_SRC6_AE_OFF;
+		gsGlobalInfo.sPathInfo.asDit0[0].abSrcOnOff[MCDRV_SRC_AE_BLOCK]		|= MCDRV_SRC6_AE_ON;
+		gsGlobalInfo.sPathInfo.asDit0[0].abSrcOnOff[MCDRV_SRC_MIX_BLOCK]	&= (UINT8)~MCDRV_SRC6_MIX_ON;
+		gsGlobalInfo.sPathInfo.asDit0[0].abSrcOnOff[MCDRV_SRC_MIX_BLOCK]	|= MCDRV_SRC6_MIX_OFF;
+	}
+	else if((psPathInfo->asDit0[0].abSrcOnOff[MCDRV_SRC_AE_BLOCK] & (MCDRV_SRC6_AE_ON|MCDRV_SRC6_AE_OFF)) == MCDRV_SRC6_AE_OFF)
+	{
+		gsGlobalInfo.sPathInfo.asDit0[0].abSrcOnOff[MCDRV_SRC_AE_BLOCK]		&= (UINT8)~MCDRV_SRC6_AE_ON;
+		gsGlobalInfo.sPathInfo.asDit0[0].abSrcOnOff[MCDRV_SRC_AE_BLOCK]		|= MCDRV_SRC6_AE_OFF;
+	}
+	else
+	{
+	}
+
+	if((psPathInfo->asDit0[0].abSrcOnOff[MCDRV_SRC_MIX_BLOCK] & (MCDRV_SRC6_MIX_ON|MCDRV_SRC6_MIX_OFF)) == MCDRV_SRC6_MIX_ON)
+	{
+		gsGlobalInfo.sPathInfo.asDit0[0].abSrcOnOff[MCDRV_SRC_PDM_BLOCK]	&= (UINT8)~MCDRV_SRC4_PDM_ON;
+		gsGlobalInfo.sPathInfo.asDit0[0].abSrcOnOff[MCDRV_SRC_PDM_BLOCK]	|= MCDRV_SRC4_PDM_OFF;
+		gsGlobalInfo.sPathInfo.asDit0[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK]	&= (UINT8)~MCDRV_SRC4_ADC0_ON;
+		gsGlobalInfo.sPathInfo.asDit0[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK]	|= MCDRV_SRC4_ADC0_OFF;
+		gsGlobalInfo.sPathInfo.asDit0[0].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR0_ON;
+		gsGlobalInfo.sPathInfo.asDit0[0].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK]	|= MCDRV_SRC3_DIR0_OFF;
+		gsGlobalInfo.sPathInfo.asDit0[0].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR1_ON;
+		gsGlobalInfo.sPathInfo.asDit0[0].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK]	|= MCDRV_SRC3_DIR1_OFF;
+		gsGlobalInfo.sPathInfo.asDit0[0].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR2_ON;
+		gsGlobalInfo.sPathInfo.asDit0[0].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK]	|= MCDRV_SRC3_DIR2_OFF;
+		gsGlobalInfo.sPathInfo.asDit0[0].abSrcOnOff[MCDRV_SRC_AE_BLOCK]		&= (UINT8)~MCDRV_SRC6_AE_ON;
+		gsGlobalInfo.sPathInfo.asDit0[0].abSrcOnOff[MCDRV_SRC_AE_BLOCK]		|= MCDRV_SRC6_AE_OFF;
+		gsGlobalInfo.sPathInfo.asDit0[0].abSrcOnOff[MCDRV_SRC_MIX_BLOCK]	&= (UINT8)~MCDRV_SRC6_MIX_OFF;
+		gsGlobalInfo.sPathInfo.asDit0[0].abSrcOnOff[MCDRV_SRC_MIX_BLOCK]	|= MCDRV_SRC6_MIX_ON;
+	}
+	else if((psPathInfo->asDit0[0].abSrcOnOff[MCDRV_SRC_MIX_BLOCK] & (MCDRV_SRC6_MIX_ON|MCDRV_SRC6_MIX_OFF)) == MCDRV_SRC6_MIX_OFF)
+	{
+		gsGlobalInfo.sPathInfo.asDit0[0].abSrcOnOff[MCDRV_SRC_MIX_BLOCK]	&= (UINT8)~MCDRV_SRC6_MIX_ON;
+		gsGlobalInfo.sPathInfo.asDit0[0].abSrcOnOff[MCDRV_SRC_MIX_BLOCK]	|= MCDRV_SRC6_MIX_OFF;
+	}
+	else
+	{
+	}
+
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncOut("SetDIT0SourceOnOff", 0);
+#endif
+}
+
+/****************************************************************************
+ *	SetDIT1SourceOnOff
+ *
+ *	Description:
+ *			Set DIT1 source On/Off.
+ *	Arguments:
+ *			psPathInfo	path information
+ *	Return:
+ *			none
+ *
+ ****************************************************************************/
+static void	SetDIT1SourceOnOff
+(
+	const MCDRV_PATH_INFO*	psPathInfo
+)
+{
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncIn("SetDIT1SourceOnOff");
+#endif
+
+	if(((psPathInfo->asDit1[0].abSrcOnOff[MCDRV_SRC_PDM_BLOCK] & (MCDRV_SRC4_PDM_ON|MCDRV_SRC4_PDM_OFF)) == MCDRV_SRC4_PDM_ON)
+	&& (gsGlobalInfo.sInitInfo.bPad0Func == MCDRV_PAD_PDMCK))
+	{
+		gsGlobalInfo.sPathInfo.asDit1[0].abSrcOnOff[MCDRV_SRC_PDM_BLOCK]	&= (UINT8)~MCDRV_SRC4_PDM_OFF;
+		gsGlobalInfo.sPathInfo.asDit1[0].abSrcOnOff[MCDRV_SRC_PDM_BLOCK]	|= MCDRV_SRC4_PDM_ON;
+		gsGlobalInfo.sPathInfo.asDit1[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK]	&= (UINT8)~MCDRV_SRC4_ADC0_ON;
+		gsGlobalInfo.sPathInfo.asDit1[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK]	|= MCDRV_SRC4_ADC0_OFF;
+		gsGlobalInfo.sPathInfo.asDit1[0].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR0_ON;
+		gsGlobalInfo.sPathInfo.asDit1[0].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK]	|= MCDRV_SRC3_DIR0_OFF;
+		gsGlobalInfo.sPathInfo.asDit1[0].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR1_ON;
+		gsGlobalInfo.sPathInfo.asDit1[0].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK]	|= MCDRV_SRC3_DIR1_OFF;
+		gsGlobalInfo.sPathInfo.asDit1[0].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR2_ON;
+		gsGlobalInfo.sPathInfo.asDit1[0].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK]	|= MCDRV_SRC3_DIR2_OFF;
+		gsGlobalInfo.sPathInfo.asDit1[0].abSrcOnOff[MCDRV_SRC_AE_BLOCK]		&= (UINT8)~MCDRV_SRC6_AE_ON;
+		gsGlobalInfo.sPathInfo.asDit1[0].abSrcOnOff[MCDRV_SRC_AE_BLOCK]		|= MCDRV_SRC6_AE_OFF;
+		gsGlobalInfo.sPathInfo.asDit1[0].abSrcOnOff[MCDRV_SRC_MIX_BLOCK]	&= (UINT8)~MCDRV_SRC6_MIX_ON;
+		gsGlobalInfo.sPathInfo.asDit1[0].abSrcOnOff[MCDRV_SRC_MIX_BLOCK]	|= MCDRV_SRC6_MIX_OFF;
+	}
+	else if((psPathInfo->asDit1[0].abSrcOnOff[MCDRV_SRC_PDM_BLOCK] & (MCDRV_SRC4_PDM_ON|MCDRV_SRC4_PDM_OFF)) == MCDRV_SRC4_PDM_OFF)
+	{
+		gsGlobalInfo.sPathInfo.asDit1[0].abSrcOnOff[MCDRV_SRC_PDM_BLOCK]	&= (UINT8)~MCDRV_SRC4_PDM_ON;
+		gsGlobalInfo.sPathInfo.asDit1[0].abSrcOnOff[MCDRV_SRC_PDM_BLOCK]	|= MCDRV_SRC4_PDM_OFF;
+	}
+	else
+	{
+	}
+
+	if((psPathInfo->asDit1[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK] & (MCDRV_SRC4_ADC0_ON|MCDRV_SRC4_ADC0_OFF)) == MCDRV_SRC4_ADC0_ON)
+	{
+		gsGlobalInfo.sPathInfo.asDit1[0].abSrcOnOff[MCDRV_SRC_PDM_BLOCK]	&= (UINT8)~MCDRV_SRC4_PDM_ON;
+		gsGlobalInfo.sPathInfo.asDit1[0].abSrcOnOff[MCDRV_SRC_PDM_BLOCK]	|= MCDRV_SRC4_PDM_OFF;
+		gsGlobalInfo.sPathInfo.asDit1[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK]	&= (UINT8)~MCDRV_SRC4_ADC0_OFF;
+		gsGlobalInfo.sPathInfo.asDit1[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK]	|= MCDRV_SRC4_ADC0_ON;
+		gsGlobalInfo.sPathInfo.asDit1[0].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR0_ON;
+		gsGlobalInfo.sPathInfo.asDit1[0].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK]	|= MCDRV_SRC3_DIR0_OFF;
+		gsGlobalInfo.sPathInfo.asDit1[0].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR1_ON;
+		gsGlobalInfo.sPathInfo.asDit1[0].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK]	|= MCDRV_SRC3_DIR1_OFF;
+		gsGlobalInfo.sPathInfo.asDit1[0].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR2_ON;
+		gsGlobalInfo.sPathInfo.asDit1[0].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK]	|= MCDRV_SRC3_DIR2_OFF;
+		gsGlobalInfo.sPathInfo.asDit1[0].abSrcOnOff[MCDRV_SRC_AE_BLOCK]		&= (UINT8)~MCDRV_SRC6_AE_ON;
+		gsGlobalInfo.sPathInfo.asDit1[0].abSrcOnOff[MCDRV_SRC_AE_BLOCK]		|= MCDRV_SRC6_AE_OFF;
+		gsGlobalInfo.sPathInfo.asDit1[0].abSrcOnOff[MCDRV_SRC_MIX_BLOCK]	&= (UINT8)~MCDRV_SRC6_MIX_ON;
+		gsGlobalInfo.sPathInfo.asDit1[0].abSrcOnOff[MCDRV_SRC_MIX_BLOCK]	|= MCDRV_SRC6_MIX_OFF;
+	}
+	else if((psPathInfo->asDit1[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK] & (MCDRV_SRC4_ADC0_ON|MCDRV_SRC4_ADC0_OFF)) == MCDRV_SRC4_ADC0_OFF)
+	{
+		gsGlobalInfo.sPathInfo.asDit1[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK]	&= (UINT8)~MCDRV_SRC4_ADC0_ON;
+		gsGlobalInfo.sPathInfo.asDit1[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK]	|= MCDRV_SRC4_ADC0_OFF;
+	}
+	else
+	{
+	}
+
+	if((psPathInfo->asDit1[0].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK] & (MCDRV_SRC3_DIR0_ON|MCDRV_SRC3_DIR0_OFF)) == MCDRV_SRC3_DIR0_ON)
+	{
+		gsGlobalInfo.sPathInfo.asDit1[0].abSrcOnOff[MCDRV_SRC_PDM_BLOCK]	&= (UINT8)~MCDRV_SRC4_PDM_ON;
+		gsGlobalInfo.sPathInfo.asDit1[0].abSrcOnOff[MCDRV_SRC_PDM_BLOCK]	|= MCDRV_SRC4_PDM_OFF;
+		gsGlobalInfo.sPathInfo.asDit1[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK]	&= (UINT8)~MCDRV_SRC4_ADC0_ON;
+		gsGlobalInfo.sPathInfo.asDit1[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK]	|= MCDRV_SRC4_ADC0_OFF;
+		gsGlobalInfo.sPathInfo.asDit1[0].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR0_OFF;
+		gsGlobalInfo.sPathInfo.asDit1[0].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK]	|= MCDRV_SRC3_DIR0_ON;
+		gsGlobalInfo.sPathInfo.asDit1[0].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR1_ON;
+		gsGlobalInfo.sPathInfo.asDit1[0].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK]	|= MCDRV_SRC3_DIR1_OFF;
+		gsGlobalInfo.sPathInfo.asDit1[0].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR2_ON;
+		gsGlobalInfo.sPathInfo.asDit1[0].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK]	|= MCDRV_SRC3_DIR2_OFF;
+		gsGlobalInfo.sPathInfo.asDit1[0].abSrcOnOff[MCDRV_SRC_AE_BLOCK]		&= (UINT8)~MCDRV_SRC6_AE_ON;
+		gsGlobalInfo.sPathInfo.asDit1[0].abSrcOnOff[MCDRV_SRC_AE_BLOCK]		|= MCDRV_SRC6_AE_OFF;
+		gsGlobalInfo.sPathInfo.asDit1[0].abSrcOnOff[MCDRV_SRC_MIX_BLOCK]	&= (UINT8)~MCDRV_SRC6_MIX_ON;
+		gsGlobalInfo.sPathInfo.asDit1[0].abSrcOnOff[MCDRV_SRC_MIX_BLOCK]	|= MCDRV_SRC6_MIX_OFF;
+	}
+	else if((psPathInfo->asDit1[0].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK] & (MCDRV_SRC3_DIR0_ON|MCDRV_SRC3_DIR0_OFF)) == MCDRV_SRC3_DIR0_OFF)
+	{
+		gsGlobalInfo.sPathInfo.asDit1[0].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR0_ON;
+		gsGlobalInfo.sPathInfo.asDit1[0].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK]	|= MCDRV_SRC3_DIR0_OFF;
+	}
+	else
+	{
+	}
+
+	if((psPathInfo->asDit1[0].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK] & (MCDRV_SRC3_DIR1_ON|MCDRV_SRC3_DIR1_OFF)) == MCDRV_SRC3_DIR1_ON)
+	{
+		gsGlobalInfo.sPathInfo.asDit1[0].abSrcOnOff[MCDRV_SRC_PDM_BLOCK]	&= (UINT8)~MCDRV_SRC4_PDM_ON;
+		gsGlobalInfo.sPathInfo.asDit1[0].abSrcOnOff[MCDRV_SRC_PDM_BLOCK]	|= MCDRV_SRC4_PDM_OFF;
+		gsGlobalInfo.sPathInfo.asDit1[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK]	&= (UINT8)~MCDRV_SRC4_ADC0_ON;
+		gsGlobalInfo.sPathInfo.asDit1[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK]	|= MCDRV_SRC4_ADC0_OFF;
+		gsGlobalInfo.sPathInfo.asDit1[0].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR0_ON;
+		gsGlobalInfo.sPathInfo.asDit1[0].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK]	|= MCDRV_SRC3_DIR0_OFF;
+		gsGlobalInfo.sPathInfo.asDit1[0].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR1_OFF;
+		gsGlobalInfo.sPathInfo.asDit1[0].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK]	|= MCDRV_SRC3_DIR1_ON;
+		gsGlobalInfo.sPathInfo.asDit1[0].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR2_ON;
+		gsGlobalInfo.sPathInfo.asDit1[0].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK]	|= MCDRV_SRC3_DIR2_OFF;
+		gsGlobalInfo.sPathInfo.asDit1[0].abSrcOnOff[MCDRV_SRC_AE_BLOCK]		&= (UINT8)~MCDRV_SRC6_AE_ON;
+		gsGlobalInfo.sPathInfo.asDit1[0].abSrcOnOff[MCDRV_SRC_AE_BLOCK]		|= MCDRV_SRC6_AE_OFF;
+		gsGlobalInfo.sPathInfo.asDit1[0].abSrcOnOff[MCDRV_SRC_MIX_BLOCK]	&= (UINT8)~MCDRV_SRC6_MIX_ON;
+		gsGlobalInfo.sPathInfo.asDit1[0].abSrcOnOff[MCDRV_SRC_MIX_BLOCK]	|= MCDRV_SRC6_MIX_OFF;
+	}
+	else if((psPathInfo->asDit1[0].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK] & (MCDRV_SRC3_DIR1_ON|MCDRV_SRC3_DIR1_OFF)) == MCDRV_SRC3_DIR1_OFF)
+	{
+		gsGlobalInfo.sPathInfo.asDit1[0].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR1_ON;
+		gsGlobalInfo.sPathInfo.asDit1[0].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK]	|= MCDRV_SRC3_DIR1_OFF;
+	}
+	else
+	{
+	}
+
+	if((psPathInfo->asDit1[0].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK] & (MCDRV_SRC3_DIR2_ON|MCDRV_SRC3_DIR2_OFF)) == MCDRV_SRC3_DIR2_ON)
+	{
+		gsGlobalInfo.sPathInfo.asDit1[0].abSrcOnOff[MCDRV_SRC_PDM_BLOCK]	&= (UINT8)~MCDRV_SRC4_PDM_ON;
+		gsGlobalInfo.sPathInfo.asDit1[0].abSrcOnOff[MCDRV_SRC_PDM_BLOCK]	|= MCDRV_SRC4_PDM_OFF;
+		gsGlobalInfo.sPathInfo.asDit1[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK]	&= (UINT8)~MCDRV_SRC4_ADC0_ON;
+		gsGlobalInfo.sPathInfo.asDit1[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK]	|= MCDRV_SRC4_ADC0_OFF;
+		gsGlobalInfo.sPathInfo.asDit1[0].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR0_ON;
+		gsGlobalInfo.sPathInfo.asDit1[0].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK]	|= MCDRV_SRC3_DIR0_OFF;
+		gsGlobalInfo.sPathInfo.asDit1[0].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR1_ON;
+		gsGlobalInfo.sPathInfo.asDit1[0].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK]	|= MCDRV_SRC3_DIR1_OFF;
+		gsGlobalInfo.sPathInfo.asDit1[0].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR2_OFF;
+		gsGlobalInfo.sPathInfo.asDit1[0].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK]	|= MCDRV_SRC3_DIR2_ON;
+		gsGlobalInfo.sPathInfo.asDit1[0].abSrcOnOff[MCDRV_SRC_AE_BLOCK]		&= (UINT8)~MCDRV_SRC6_AE_ON;
+		gsGlobalInfo.sPathInfo.asDit1[0].abSrcOnOff[MCDRV_SRC_AE_BLOCK]		|= MCDRV_SRC6_AE_OFF;
+		gsGlobalInfo.sPathInfo.asDit1[0].abSrcOnOff[MCDRV_SRC_MIX_BLOCK]	&= (UINT8)~MCDRV_SRC6_MIX_ON;
+		gsGlobalInfo.sPathInfo.asDit1[0].abSrcOnOff[MCDRV_SRC_MIX_BLOCK]	|= MCDRV_SRC6_MIX_OFF;
+	}
+	else if((psPathInfo->asDit1[0].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK] & (MCDRV_SRC3_DIR2_ON|MCDRV_SRC3_DIR2_OFF)) == MCDRV_SRC3_DIR2_OFF)
+	{
+		gsGlobalInfo.sPathInfo.asDit1[0].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR2_ON;
+		gsGlobalInfo.sPathInfo.asDit1[0].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK]	|= MCDRV_SRC3_DIR2_OFF;
+	}
+	else
+	{
+	}
+
+	if((psPathInfo->asDit1[0].abSrcOnOff[MCDRV_SRC_AE_BLOCK] & (MCDRV_SRC6_AE_ON|MCDRV_SRC6_AE_OFF)) == MCDRV_SRC6_AE_ON)
+	{
+		gsGlobalInfo.sPathInfo.asDit1[0].abSrcOnOff[MCDRV_SRC_PDM_BLOCK]	&= (UINT8)~MCDRV_SRC4_PDM_ON;
+		gsGlobalInfo.sPathInfo.asDit1[0].abSrcOnOff[MCDRV_SRC_PDM_BLOCK]	|= MCDRV_SRC4_PDM_OFF;
+		gsGlobalInfo.sPathInfo.asDit1[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK]	&= (UINT8)~MCDRV_SRC4_ADC0_ON;
+		gsGlobalInfo.sPathInfo.asDit1[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK]	|= MCDRV_SRC4_ADC0_OFF;
+		gsGlobalInfo.sPathInfo.asDit1[0].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR0_ON;
+		gsGlobalInfo.sPathInfo.asDit1[0].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK]	|= MCDRV_SRC3_DIR0_OFF;
+		gsGlobalInfo.sPathInfo.asDit1[0].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR1_ON;
+		gsGlobalInfo.sPathInfo.asDit1[0].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK]	|= MCDRV_SRC3_DIR1_OFF;
+		gsGlobalInfo.sPathInfo.asDit1[0].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR2_ON;
+		gsGlobalInfo.sPathInfo.asDit1[0].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK]	|= MCDRV_SRC3_DIR2_OFF;
+		gsGlobalInfo.sPathInfo.asDit1[0].abSrcOnOff[MCDRV_SRC_AE_BLOCK]		&= (UINT8)~MCDRV_SRC6_AE_OFF;
+		gsGlobalInfo.sPathInfo.asDit1[0].abSrcOnOff[MCDRV_SRC_AE_BLOCK]		|= MCDRV_SRC6_AE_ON;
+		gsGlobalInfo.sPathInfo.asDit1[0].abSrcOnOff[MCDRV_SRC_MIX_BLOCK]	&= (UINT8)~MCDRV_SRC6_MIX_ON;
+		gsGlobalInfo.sPathInfo.asDit1[0].abSrcOnOff[MCDRV_SRC_MIX_BLOCK]	|= MCDRV_SRC6_MIX_OFF;
+	}
+	else if((psPathInfo->asDit1[0].abSrcOnOff[MCDRV_SRC_AE_BLOCK] & (MCDRV_SRC6_AE_ON|MCDRV_SRC6_AE_OFF)) == MCDRV_SRC6_AE_OFF)
+	{
+		gsGlobalInfo.sPathInfo.asDit1[0].abSrcOnOff[MCDRV_SRC_AE_BLOCK]		&= (UINT8)~MCDRV_SRC6_AE_ON;
+		gsGlobalInfo.sPathInfo.asDit1[0].abSrcOnOff[MCDRV_SRC_AE_BLOCK]		|= MCDRV_SRC6_AE_OFF;
+	}
+	else
+	{
+	}
+
+	if((psPathInfo->asDit1[0].abSrcOnOff[MCDRV_SRC_MIX_BLOCK] & (MCDRV_SRC6_MIX_ON|MCDRV_SRC6_MIX_OFF)) == MCDRV_SRC6_MIX_ON)
+	{
+		gsGlobalInfo.sPathInfo.asDit1[0].abSrcOnOff[MCDRV_SRC_PDM_BLOCK]	&= (UINT8)~MCDRV_SRC4_PDM_ON;
+		gsGlobalInfo.sPathInfo.asDit1[0].abSrcOnOff[MCDRV_SRC_PDM_BLOCK]	|= MCDRV_SRC4_PDM_OFF;
+		gsGlobalInfo.sPathInfo.asDit1[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK]	&= (UINT8)~MCDRV_SRC4_ADC0_ON;
+		gsGlobalInfo.sPathInfo.asDit1[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK]	|= MCDRV_SRC4_ADC0_OFF;
+		gsGlobalInfo.sPathInfo.asDit1[0].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR0_ON;
+		gsGlobalInfo.sPathInfo.asDit1[0].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK]	|= MCDRV_SRC3_DIR0_OFF;
+		gsGlobalInfo.sPathInfo.asDit1[0].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR1_ON;
+		gsGlobalInfo.sPathInfo.asDit1[0].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK]	|= MCDRV_SRC3_DIR1_OFF;
+		gsGlobalInfo.sPathInfo.asDit1[0].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR2_ON;
+		gsGlobalInfo.sPathInfo.asDit1[0].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK]	|= MCDRV_SRC3_DIR2_OFF;
+		gsGlobalInfo.sPathInfo.asDit1[0].abSrcOnOff[MCDRV_SRC_AE_BLOCK]		&= (UINT8)~MCDRV_SRC6_AE_ON;
+		gsGlobalInfo.sPathInfo.asDit1[0].abSrcOnOff[MCDRV_SRC_AE_BLOCK]		|= MCDRV_SRC6_AE_OFF;
+		gsGlobalInfo.sPathInfo.asDit1[0].abSrcOnOff[MCDRV_SRC_MIX_BLOCK]	&= (UINT8)~MCDRV_SRC6_MIX_OFF;
+		gsGlobalInfo.sPathInfo.asDit1[0].abSrcOnOff[MCDRV_SRC_MIX_BLOCK]	|= MCDRV_SRC6_MIX_ON;
+	}
+	else if((psPathInfo->asDit1[0].abSrcOnOff[MCDRV_SRC_MIX_BLOCK] & (MCDRV_SRC6_MIX_ON|MCDRV_SRC6_MIX_OFF)) == MCDRV_SRC6_MIX_OFF)
+	{
+		gsGlobalInfo.sPathInfo.asDit1[0].abSrcOnOff[MCDRV_SRC_MIX_BLOCK]	&= (UINT8)~MCDRV_SRC6_MIX_ON;
+		gsGlobalInfo.sPathInfo.asDit1[0].abSrcOnOff[MCDRV_SRC_MIX_BLOCK]	|= MCDRV_SRC6_MIX_OFF;
+	}
+	else
+	{
+	}
+
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncOut("SetDIT1SourceOnOff", 0);
+#endif
+}
+
+/****************************************************************************
+ *	SetDIT2SourceOnOff
+ *
+ *	Description:
+ *			Set DIT2 source On/Off.
+ *	Arguments:
+ *			psPathInfo	path information
+ *	Return:
+ *			none
+ *
+ ****************************************************************************/
+static void	SetDIT2SourceOnOff
+(
+	const MCDRV_PATH_INFO*	psPathInfo
+)
+{
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncIn("SetDIT2SourceOnOff");
+#endif
+
+	if(((psPathInfo->asDit2[0].abSrcOnOff[MCDRV_SRC_PDM_BLOCK] & (MCDRV_SRC4_PDM_ON|MCDRV_SRC4_PDM_OFF)) == MCDRV_SRC4_PDM_ON)
+	&& (gsGlobalInfo.sInitInfo.bPad0Func == MCDRV_PAD_PDMCK))
+	{
+		gsGlobalInfo.sPathInfo.asDit2[0].abSrcOnOff[MCDRV_SRC_PDM_BLOCK]	&= (UINT8)~MCDRV_SRC4_PDM_OFF;
+		gsGlobalInfo.sPathInfo.asDit2[0].abSrcOnOff[MCDRV_SRC_PDM_BLOCK]	|= MCDRV_SRC4_PDM_ON;
+		gsGlobalInfo.sPathInfo.asDit2[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK]	&= (UINT8)~MCDRV_SRC4_ADC0_ON;
+		gsGlobalInfo.sPathInfo.asDit2[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK]	|= MCDRV_SRC4_ADC0_OFF;
+		gsGlobalInfo.sPathInfo.asDit2[0].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR0_ON;
+		gsGlobalInfo.sPathInfo.asDit2[0].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK]	|= MCDRV_SRC3_DIR0_OFF;
+		gsGlobalInfo.sPathInfo.asDit2[0].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR1_ON;
+		gsGlobalInfo.sPathInfo.asDit2[0].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK]	|= MCDRV_SRC3_DIR1_OFF;
+		gsGlobalInfo.sPathInfo.asDit2[0].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR2_ON;
+		gsGlobalInfo.sPathInfo.asDit2[0].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK]	|= MCDRV_SRC3_DIR2_OFF;
+		gsGlobalInfo.sPathInfo.asDit2[0].abSrcOnOff[MCDRV_SRC_AE_BLOCK]		&= (UINT8)~MCDRV_SRC6_AE_ON;
+		gsGlobalInfo.sPathInfo.asDit2[0].abSrcOnOff[MCDRV_SRC_AE_BLOCK]		|= MCDRV_SRC6_AE_OFF;
+		gsGlobalInfo.sPathInfo.asDit2[0].abSrcOnOff[MCDRV_SRC_MIX_BLOCK]	&= (UINT8)~MCDRV_SRC6_MIX_ON;
+		gsGlobalInfo.sPathInfo.asDit2[0].abSrcOnOff[MCDRV_SRC_MIX_BLOCK]	|= MCDRV_SRC6_MIX_OFF;
+	}
+	else if((psPathInfo->asDit2[0].abSrcOnOff[MCDRV_SRC_PDM_BLOCK] & (MCDRV_SRC4_PDM_ON|MCDRV_SRC4_PDM_OFF)) == MCDRV_SRC4_PDM_OFF)
+	{
+		gsGlobalInfo.sPathInfo.asDit2[0].abSrcOnOff[MCDRV_SRC_PDM_BLOCK]	&= (UINT8)~MCDRV_SRC4_PDM_ON;
+		gsGlobalInfo.sPathInfo.asDit2[0].abSrcOnOff[MCDRV_SRC_PDM_BLOCK]	|= MCDRV_SRC4_PDM_OFF;
+	}
+	else
+	{
+	}
+
+	if((psPathInfo->asDit2[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK] & (MCDRV_SRC4_ADC0_ON|MCDRV_SRC4_ADC0_OFF)) == MCDRV_SRC4_ADC0_ON)
+	{
+		gsGlobalInfo.sPathInfo.asDit2[0].abSrcOnOff[MCDRV_SRC_PDM_BLOCK]	&= (UINT8)~MCDRV_SRC4_PDM_ON;
+		gsGlobalInfo.sPathInfo.asDit2[0].abSrcOnOff[MCDRV_SRC_PDM_BLOCK]	|= MCDRV_SRC4_PDM_OFF;
+		gsGlobalInfo.sPathInfo.asDit2[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK]	&= (UINT8)~MCDRV_SRC4_ADC0_OFF;
+		gsGlobalInfo.sPathInfo.asDit2[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK]	|= MCDRV_SRC4_ADC0_ON;
+		gsGlobalInfo.sPathInfo.asDit2[0].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR0_ON;
+		gsGlobalInfo.sPathInfo.asDit2[0].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK]	|= MCDRV_SRC3_DIR0_OFF;
+		gsGlobalInfo.sPathInfo.asDit2[0].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR1_ON;
+		gsGlobalInfo.sPathInfo.asDit2[0].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK]	|= MCDRV_SRC3_DIR1_OFF;
+		gsGlobalInfo.sPathInfo.asDit2[0].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR2_ON;
+		gsGlobalInfo.sPathInfo.asDit2[0].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK]	|= MCDRV_SRC3_DIR2_OFF;
+		gsGlobalInfo.sPathInfo.asDit2[0].abSrcOnOff[MCDRV_SRC_AE_BLOCK]		&= (UINT8)~MCDRV_SRC6_AE_ON;
+		gsGlobalInfo.sPathInfo.asDit2[0].abSrcOnOff[MCDRV_SRC_AE_BLOCK]		|= MCDRV_SRC6_AE_OFF;
+		gsGlobalInfo.sPathInfo.asDit2[0].abSrcOnOff[MCDRV_SRC_MIX_BLOCK]	&= (UINT8)~MCDRV_SRC6_MIX_ON;
+		gsGlobalInfo.sPathInfo.asDit2[0].abSrcOnOff[MCDRV_SRC_MIX_BLOCK]	|= MCDRV_SRC6_MIX_OFF;
+	}
+	else if((psPathInfo->asDit2[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK] & (MCDRV_SRC4_ADC0_ON|MCDRV_SRC4_ADC0_OFF)) == MCDRV_SRC4_ADC0_OFF)
+	{
+		gsGlobalInfo.sPathInfo.asDit2[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK]	&= (UINT8)~MCDRV_SRC4_ADC0_ON;
+		gsGlobalInfo.sPathInfo.asDit2[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK]	|= MCDRV_SRC4_ADC0_OFF;
+	}
+	else
+	{
+	}
+
+	if((psPathInfo->asDit2[0].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK] & (MCDRV_SRC3_DIR0_ON|MCDRV_SRC3_DIR0_OFF)) == MCDRV_SRC3_DIR0_ON)
+	{
+		gsGlobalInfo.sPathInfo.asDit2[0].abSrcOnOff[MCDRV_SRC_PDM_BLOCK]	&= (UINT8)~MCDRV_SRC4_PDM_ON;
+		gsGlobalInfo.sPathInfo.asDit2[0].abSrcOnOff[MCDRV_SRC_PDM_BLOCK]	|= MCDRV_SRC4_PDM_OFF;
+		gsGlobalInfo.sPathInfo.asDit2[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK]	&= (UINT8)~MCDRV_SRC4_ADC0_ON;
+		gsGlobalInfo.sPathInfo.asDit2[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK]	|= MCDRV_SRC4_ADC0_OFF;
+		gsGlobalInfo.sPathInfo.asDit2[0].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR0_OFF;
+		gsGlobalInfo.sPathInfo.asDit2[0].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK]	|= MCDRV_SRC3_DIR0_ON;
+		gsGlobalInfo.sPathInfo.asDit2[0].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR1_ON;
+		gsGlobalInfo.sPathInfo.asDit2[0].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK]	|= MCDRV_SRC3_DIR1_OFF;
+		gsGlobalInfo.sPathInfo.asDit2[0].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR2_ON;
+		gsGlobalInfo.sPathInfo.asDit2[0].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK]	|= MCDRV_SRC3_DIR2_OFF;
+		gsGlobalInfo.sPathInfo.asDit2[0].abSrcOnOff[MCDRV_SRC_AE_BLOCK]		&= (UINT8)~MCDRV_SRC6_AE_ON;
+		gsGlobalInfo.sPathInfo.asDit2[0].abSrcOnOff[MCDRV_SRC_AE_BLOCK]		|= MCDRV_SRC6_AE_OFF;
+		gsGlobalInfo.sPathInfo.asDit2[0].abSrcOnOff[MCDRV_SRC_MIX_BLOCK]	&= (UINT8)~MCDRV_SRC6_MIX_ON;
+		gsGlobalInfo.sPathInfo.asDit2[0].abSrcOnOff[MCDRV_SRC_MIX_BLOCK]	|= MCDRV_SRC6_MIX_OFF;
+	}
+	else if((psPathInfo->asDit2[0].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK] & (MCDRV_SRC3_DIR0_ON|MCDRV_SRC3_DIR0_OFF)) == MCDRV_SRC3_DIR0_OFF)
+	{
+		gsGlobalInfo.sPathInfo.asDit2[0].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR0_ON;
+		gsGlobalInfo.sPathInfo.asDit2[0].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK]	|= MCDRV_SRC3_DIR0_OFF;
+	}
+	else
+	{
+	}
+
+	if((psPathInfo->asDit2[0].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK] & (MCDRV_SRC3_DIR1_ON|MCDRV_SRC3_DIR1_OFF)) == MCDRV_SRC3_DIR1_ON)
+	{
+		gsGlobalInfo.sPathInfo.asDit2[0].abSrcOnOff[MCDRV_SRC_PDM_BLOCK]	&= (UINT8)~MCDRV_SRC4_PDM_ON;
+		gsGlobalInfo.sPathInfo.asDit2[0].abSrcOnOff[MCDRV_SRC_PDM_BLOCK]	|= MCDRV_SRC4_PDM_OFF;
+		gsGlobalInfo.sPathInfo.asDit2[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK]	&= (UINT8)~MCDRV_SRC4_ADC0_ON;
+		gsGlobalInfo.sPathInfo.asDit2[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK]	|= MCDRV_SRC4_ADC0_OFF;
+		gsGlobalInfo.sPathInfo.asDit2[0].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR0_ON;
+		gsGlobalInfo.sPathInfo.asDit2[0].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK]	|= MCDRV_SRC3_DIR0_OFF;
+		gsGlobalInfo.sPathInfo.asDit2[0].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR1_OFF;
+		gsGlobalInfo.sPathInfo.asDit2[0].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK]	|= MCDRV_SRC3_DIR1_ON;
+		gsGlobalInfo.sPathInfo.asDit2[0].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR2_ON;
+		gsGlobalInfo.sPathInfo.asDit2[0].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK]	|= MCDRV_SRC3_DIR2_OFF;
+		gsGlobalInfo.sPathInfo.asDit2[0].abSrcOnOff[MCDRV_SRC_AE_BLOCK]		&= (UINT8)~MCDRV_SRC6_AE_ON;
+		gsGlobalInfo.sPathInfo.asDit2[0].abSrcOnOff[MCDRV_SRC_AE_BLOCK]		|= MCDRV_SRC6_AE_OFF;
+		gsGlobalInfo.sPathInfo.asDit2[0].abSrcOnOff[MCDRV_SRC_MIX_BLOCK]	&= (UINT8)~MCDRV_SRC6_MIX_ON;
+		gsGlobalInfo.sPathInfo.asDit2[0].abSrcOnOff[MCDRV_SRC_MIX_BLOCK]	|= MCDRV_SRC6_MIX_OFF;
+	}
+	else if((psPathInfo->asDit2[0].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK] & (MCDRV_SRC3_DIR1_ON|MCDRV_SRC3_DIR1_OFF)) == MCDRV_SRC3_DIR1_OFF)
+	{
+		gsGlobalInfo.sPathInfo.asDit2[0].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR1_ON;
+		gsGlobalInfo.sPathInfo.asDit2[0].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK]	|= MCDRV_SRC3_DIR1_OFF;
+	}
+	else
+	{
+	}
+
+	if((psPathInfo->asDit2[0].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK] & (MCDRV_SRC3_DIR2_ON|MCDRV_SRC3_DIR2_OFF)) == MCDRV_SRC3_DIR2_ON)
+	{
+		gsGlobalInfo.sPathInfo.asDit2[0].abSrcOnOff[MCDRV_SRC_PDM_BLOCK]	&= (UINT8)~MCDRV_SRC4_PDM_ON;
+		gsGlobalInfo.sPathInfo.asDit2[0].abSrcOnOff[MCDRV_SRC_PDM_BLOCK]	|= MCDRV_SRC4_PDM_OFF;
+		gsGlobalInfo.sPathInfo.asDit2[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK]	&= (UINT8)~MCDRV_SRC4_ADC0_ON;
+		gsGlobalInfo.sPathInfo.asDit2[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK]	|= MCDRV_SRC4_ADC0_OFF;
+		gsGlobalInfo.sPathInfo.asDit2[0].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR0_ON;
+		gsGlobalInfo.sPathInfo.asDit2[0].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK]	|= MCDRV_SRC3_DIR0_OFF;
+		gsGlobalInfo.sPathInfo.asDit2[0].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR1_ON;
+		gsGlobalInfo.sPathInfo.asDit2[0].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK]	|= MCDRV_SRC3_DIR1_OFF;
+		gsGlobalInfo.sPathInfo.asDit2[0].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR2_OFF;
+		gsGlobalInfo.sPathInfo.asDit2[0].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK]	|= MCDRV_SRC3_DIR2_ON;
+		gsGlobalInfo.sPathInfo.asDit2[0].abSrcOnOff[MCDRV_SRC_AE_BLOCK]		&= (UINT8)~MCDRV_SRC6_AE_ON;
+		gsGlobalInfo.sPathInfo.asDit2[0].abSrcOnOff[MCDRV_SRC_AE_BLOCK]		|= MCDRV_SRC6_AE_OFF;
+		gsGlobalInfo.sPathInfo.asDit2[0].abSrcOnOff[MCDRV_SRC_MIX_BLOCK]	&= (UINT8)~MCDRV_SRC6_MIX_ON;
+		gsGlobalInfo.sPathInfo.asDit2[0].abSrcOnOff[MCDRV_SRC_MIX_BLOCK]	|= MCDRV_SRC6_MIX_OFF;
+	}
+	else if((psPathInfo->asDit2[0].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK] & (MCDRV_SRC3_DIR2_ON|MCDRV_SRC3_DIR2_OFF)) == MCDRV_SRC3_DIR2_OFF)
+	{
+		gsGlobalInfo.sPathInfo.asDit2[0].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR2_ON;
+		gsGlobalInfo.sPathInfo.asDit2[0].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK]	|= MCDRV_SRC3_DIR2_OFF;
+	}
+	else
+	{
+	}
+
+	if((psPathInfo->asDit2[0].abSrcOnOff[MCDRV_SRC_AE_BLOCK] & (MCDRV_SRC6_AE_ON|MCDRV_SRC6_AE_OFF)) == MCDRV_SRC6_AE_ON)
+	{
+		gsGlobalInfo.sPathInfo.asDit2[0].abSrcOnOff[MCDRV_SRC_PDM_BLOCK]	&= (UINT8)~MCDRV_SRC4_PDM_ON;
+		gsGlobalInfo.sPathInfo.asDit2[0].abSrcOnOff[MCDRV_SRC_PDM_BLOCK]	|= MCDRV_SRC4_PDM_OFF;
+		gsGlobalInfo.sPathInfo.asDit2[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK]	&= (UINT8)~MCDRV_SRC4_ADC0_ON;
+		gsGlobalInfo.sPathInfo.asDit2[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK]	|= MCDRV_SRC4_ADC0_OFF;
+		gsGlobalInfo.sPathInfo.asDit2[0].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR0_ON;
+		gsGlobalInfo.sPathInfo.asDit2[0].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK]	|= MCDRV_SRC3_DIR0_OFF;
+		gsGlobalInfo.sPathInfo.asDit2[0].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR1_ON;
+		gsGlobalInfo.sPathInfo.asDit2[0].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK]	|= MCDRV_SRC3_DIR1_OFF;
+		gsGlobalInfo.sPathInfo.asDit2[0].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR2_ON;
+		gsGlobalInfo.sPathInfo.asDit2[0].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK]	|= MCDRV_SRC3_DIR2_OFF;
+		gsGlobalInfo.sPathInfo.asDit2[0].abSrcOnOff[MCDRV_SRC_AE_BLOCK]		&= (UINT8)~MCDRV_SRC6_AE_OFF;
+		gsGlobalInfo.sPathInfo.asDit2[0].abSrcOnOff[MCDRV_SRC_AE_BLOCK]		|= MCDRV_SRC6_AE_ON;
+		gsGlobalInfo.sPathInfo.asDit2[0].abSrcOnOff[MCDRV_SRC_MIX_BLOCK]	&= (UINT8)~MCDRV_SRC6_MIX_ON;
+		gsGlobalInfo.sPathInfo.asDit2[0].abSrcOnOff[MCDRV_SRC_MIX_BLOCK]	|= MCDRV_SRC6_MIX_OFF;
+	}
+	else if((psPathInfo->asDit2[0].abSrcOnOff[MCDRV_SRC_AE_BLOCK] & (MCDRV_SRC6_AE_ON|MCDRV_SRC6_AE_OFF)) == MCDRV_SRC6_AE_OFF)
+	{
+		gsGlobalInfo.sPathInfo.asDit2[0].abSrcOnOff[MCDRV_SRC_AE_BLOCK]		&= (UINT8)~MCDRV_SRC6_AE_ON;
+		gsGlobalInfo.sPathInfo.asDit2[0].abSrcOnOff[MCDRV_SRC_AE_BLOCK]		|= MCDRV_SRC6_AE_OFF;
+	}
+	else
+	{
+	}
+
+	if((psPathInfo->asDit2[0].abSrcOnOff[MCDRV_SRC_MIX_BLOCK] & (MCDRV_SRC6_MIX_ON|MCDRV_SRC6_MIX_OFF)) == MCDRV_SRC6_MIX_ON)
+	{
+		gsGlobalInfo.sPathInfo.asDit2[0].abSrcOnOff[MCDRV_SRC_PDM_BLOCK]	&= (UINT8)~MCDRV_SRC4_PDM_ON;
+		gsGlobalInfo.sPathInfo.asDit2[0].abSrcOnOff[MCDRV_SRC_PDM_BLOCK]	|= MCDRV_SRC4_PDM_OFF;
+		gsGlobalInfo.sPathInfo.asDit2[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK]	&= (UINT8)~MCDRV_SRC4_ADC0_ON;
+		gsGlobalInfo.sPathInfo.asDit2[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK]	|= MCDRV_SRC4_ADC0_OFF;
+		gsGlobalInfo.sPathInfo.asDit2[0].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR0_ON;
+		gsGlobalInfo.sPathInfo.asDit2[0].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK]	|= MCDRV_SRC3_DIR0_OFF;
+		gsGlobalInfo.sPathInfo.asDit2[0].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR1_ON;
+		gsGlobalInfo.sPathInfo.asDit2[0].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK]	|= MCDRV_SRC3_DIR1_OFF;
+		gsGlobalInfo.sPathInfo.asDit2[0].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR2_ON;
+		gsGlobalInfo.sPathInfo.asDit2[0].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK]	|= MCDRV_SRC3_DIR2_OFF;
+		gsGlobalInfo.sPathInfo.asDit2[0].abSrcOnOff[MCDRV_SRC_AE_BLOCK]		&= (UINT8)~MCDRV_SRC6_AE_ON;
+		gsGlobalInfo.sPathInfo.asDit2[0].abSrcOnOff[MCDRV_SRC_AE_BLOCK]		|= MCDRV_SRC6_AE_OFF;
+		gsGlobalInfo.sPathInfo.asDit2[0].abSrcOnOff[MCDRV_SRC_MIX_BLOCK]	&= (UINT8)~MCDRV_SRC6_MIX_OFF;
+		gsGlobalInfo.sPathInfo.asDit2[0].abSrcOnOff[MCDRV_SRC_MIX_BLOCK]	|= MCDRV_SRC6_MIX_ON;
+	}
+	else if((psPathInfo->asDit2[0].abSrcOnOff[MCDRV_SRC_MIX_BLOCK] & (MCDRV_SRC6_MIX_ON|MCDRV_SRC6_MIX_OFF)) == MCDRV_SRC6_MIX_OFF)
+	{
+		gsGlobalInfo.sPathInfo.asDit2[0].abSrcOnOff[MCDRV_SRC_MIX_BLOCK]	&= (UINT8)~MCDRV_SRC6_MIX_ON;
+		gsGlobalInfo.sPathInfo.asDit2[0].abSrcOnOff[MCDRV_SRC_MIX_BLOCK]	|= MCDRV_SRC6_MIX_OFF;
+	}
+	else
+	{
+	}
+
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncOut("SetDIT2SourceOnOff", 0);
+#endif
+}
+
+/****************************************************************************
+ *	SetDACSourceOnOff
+ *
+ *	Description:
+ *			Set DAC source On/Off.
+ *	Arguments:
+ *			psPathInfo	path information
+ *	Return:
+ *			none
+ *
+ ****************************************************************************/
+static void	SetDACSourceOnOff
+(
+	const MCDRV_PATH_INFO*	psPathInfo
+)
+{
+	UINT8	bCh;
+
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncIn("SetDACSourceOnOff");
+#endif
+
+	for(bCh = 0; bCh < DAC_PATH_CHANNELS; bCh++)
+	{
+		if(((psPathInfo->asDac[bCh].abSrcOnOff[MCDRV_SRC_PDM_BLOCK] & (MCDRV_SRC4_PDM_ON|MCDRV_SRC4_PDM_OFF)) == MCDRV_SRC4_PDM_ON)
+		&& (gsGlobalInfo.sInitInfo.bPad0Func == MCDRV_PAD_PDMCK))
+		{
+			gsGlobalInfo.sPathInfo.asDac[bCh].abSrcOnOff[MCDRV_SRC_PDM_BLOCK]	&= (UINT8)~MCDRV_SRC4_PDM_OFF;
+			gsGlobalInfo.sPathInfo.asDac[bCh].abSrcOnOff[MCDRV_SRC_PDM_BLOCK]	|= MCDRV_SRC4_PDM_ON;
+			gsGlobalInfo.sPathInfo.asDac[bCh].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK]	&= (UINT8)~MCDRV_SRC4_ADC0_ON;
+			gsGlobalInfo.sPathInfo.asDac[bCh].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK]	|= MCDRV_SRC4_ADC0_OFF;
+			gsGlobalInfo.sPathInfo.asDac[bCh].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR0_ON;
+			gsGlobalInfo.sPathInfo.asDac[bCh].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK]	|= MCDRV_SRC3_DIR0_OFF;
+			gsGlobalInfo.sPathInfo.asDac[bCh].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR1_ON;
+			gsGlobalInfo.sPathInfo.asDac[bCh].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK]	|= MCDRV_SRC3_DIR1_OFF;
+			gsGlobalInfo.sPathInfo.asDac[bCh].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR2_ON;
+			gsGlobalInfo.sPathInfo.asDac[bCh].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK]	|= MCDRV_SRC3_DIR2_OFF;
+			gsGlobalInfo.sPathInfo.asDac[bCh].abSrcOnOff[MCDRV_SRC_AE_BLOCK]	&= (UINT8)~MCDRV_SRC6_AE_ON;
+			gsGlobalInfo.sPathInfo.asDac[bCh].abSrcOnOff[MCDRV_SRC_AE_BLOCK]	|= MCDRV_SRC6_AE_OFF;
+			gsGlobalInfo.sPathInfo.asDac[bCh].abSrcOnOff[MCDRV_SRC_MIX_BLOCK]	&= (UINT8)~MCDRV_SRC6_MIX_ON;
+			gsGlobalInfo.sPathInfo.asDac[bCh].abSrcOnOff[MCDRV_SRC_MIX_BLOCK]	|= MCDRV_SRC6_MIX_OFF;
+		}
+		else if((psPathInfo->asDac[bCh].abSrcOnOff[MCDRV_SRC_PDM_BLOCK] & (MCDRV_SRC4_PDM_ON|MCDRV_SRC4_PDM_OFF)) == MCDRV_SRC4_PDM_OFF)
+		{
+			gsGlobalInfo.sPathInfo.asDac[bCh].abSrcOnOff[MCDRV_SRC_PDM_BLOCK]	&= (UINT8)~MCDRV_SRC4_PDM_ON;
+			gsGlobalInfo.sPathInfo.asDac[bCh].abSrcOnOff[MCDRV_SRC_PDM_BLOCK]	|= MCDRV_SRC4_PDM_OFF;
+		}
+		else
+		{
+		}
+
+		if((psPathInfo->asDac[bCh].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK] & (MCDRV_SRC4_ADC0_ON|MCDRV_SRC4_ADC0_OFF)) == MCDRV_SRC4_ADC0_ON)
+		{
+			gsGlobalInfo.sPathInfo.asDac[bCh].abSrcOnOff[MCDRV_SRC_PDM_BLOCK]	&= (UINT8)~MCDRV_SRC4_PDM_ON;
+			gsGlobalInfo.sPathInfo.asDac[bCh].abSrcOnOff[MCDRV_SRC_PDM_BLOCK]	|= MCDRV_SRC4_PDM_OFF;
+			gsGlobalInfo.sPathInfo.asDac[bCh].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK]	&= (UINT8)~MCDRV_SRC4_ADC0_OFF;
+			gsGlobalInfo.sPathInfo.asDac[bCh].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK]	|= MCDRV_SRC4_ADC0_ON;
+			gsGlobalInfo.sPathInfo.asDac[bCh].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR0_ON;
+			gsGlobalInfo.sPathInfo.asDac[bCh].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK]	|= MCDRV_SRC3_DIR0_OFF;
+			gsGlobalInfo.sPathInfo.asDac[bCh].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR1_ON;
+			gsGlobalInfo.sPathInfo.asDac[bCh].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK]	|= MCDRV_SRC3_DIR1_OFF;
+			gsGlobalInfo.sPathInfo.asDac[bCh].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR2_ON;
+			gsGlobalInfo.sPathInfo.asDac[bCh].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK]	|= MCDRV_SRC3_DIR2_OFF;
+			gsGlobalInfo.sPathInfo.asDac[bCh].abSrcOnOff[MCDRV_SRC_AE_BLOCK]	&= (UINT8)~MCDRV_SRC6_AE_ON;
+			gsGlobalInfo.sPathInfo.asDac[bCh].abSrcOnOff[MCDRV_SRC_AE_BLOCK]	|= MCDRV_SRC6_AE_OFF;
+			gsGlobalInfo.sPathInfo.asDac[bCh].abSrcOnOff[MCDRV_SRC_MIX_BLOCK]	&= (UINT8)~MCDRV_SRC6_MIX_ON;
+			gsGlobalInfo.sPathInfo.asDac[bCh].abSrcOnOff[MCDRV_SRC_MIX_BLOCK]	|= MCDRV_SRC6_MIX_OFF;
+		}
+		else if((psPathInfo->asDac[bCh].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK] & (MCDRV_SRC4_ADC0_ON|MCDRV_SRC4_ADC0_OFF)) == MCDRV_SRC4_ADC0_OFF)
+		{
+			gsGlobalInfo.sPathInfo.asDac[bCh].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK]	&= (UINT8)~MCDRV_SRC4_ADC0_ON;
+			gsGlobalInfo.sPathInfo.asDac[bCh].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK]	|= MCDRV_SRC4_ADC0_OFF;
+		}
+		else
+		{
+		}
+
+		if((psPathInfo->asDac[bCh].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK] & (MCDRV_SRC3_DIR0_ON|MCDRV_SRC3_DIR0_OFF)) == MCDRV_SRC3_DIR0_ON)
+		{
+			gsGlobalInfo.sPathInfo.asDac[bCh].abSrcOnOff[MCDRV_SRC_PDM_BLOCK]	&= (UINT8)~MCDRV_SRC4_PDM_ON;
+			gsGlobalInfo.sPathInfo.asDac[bCh].abSrcOnOff[MCDRV_SRC_PDM_BLOCK]	|= MCDRV_SRC4_PDM_OFF;
+			gsGlobalInfo.sPathInfo.asDac[bCh].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK]	&= (UINT8)~MCDRV_SRC4_ADC0_ON;
+			gsGlobalInfo.sPathInfo.asDac[bCh].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK]	|= MCDRV_SRC4_ADC0_OFF;
+			gsGlobalInfo.sPathInfo.asDac[bCh].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR0_OFF;
+			gsGlobalInfo.sPathInfo.asDac[bCh].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK]	|= MCDRV_SRC3_DIR0_ON;
+			gsGlobalInfo.sPathInfo.asDac[bCh].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR1_ON;
+			gsGlobalInfo.sPathInfo.asDac[bCh].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK]	|= MCDRV_SRC3_DIR1_OFF;
+			gsGlobalInfo.sPathInfo.asDac[bCh].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR2_ON;
+			gsGlobalInfo.sPathInfo.asDac[bCh].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK]	|= MCDRV_SRC3_DIR2_OFF;
+			gsGlobalInfo.sPathInfo.asDac[bCh].abSrcOnOff[MCDRV_SRC_AE_BLOCK]	&= (UINT8)~MCDRV_SRC6_AE_ON;
+			gsGlobalInfo.sPathInfo.asDac[bCh].abSrcOnOff[MCDRV_SRC_AE_BLOCK]	|= MCDRV_SRC6_AE_OFF;
+			gsGlobalInfo.sPathInfo.asDac[bCh].abSrcOnOff[MCDRV_SRC_MIX_BLOCK]	&= (UINT8)~MCDRV_SRC6_MIX_ON;
+			gsGlobalInfo.sPathInfo.asDac[bCh].abSrcOnOff[MCDRV_SRC_MIX_BLOCK]	|= MCDRV_SRC6_MIX_OFF;
+		}
+		else if((psPathInfo->asDac[bCh].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK] & (MCDRV_SRC3_DIR0_ON|MCDRV_SRC3_DIR0_OFF)) == MCDRV_SRC3_DIR0_OFF)
+		{
+			gsGlobalInfo.sPathInfo.asDac[bCh].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR0_ON;
+			gsGlobalInfo.sPathInfo.asDac[bCh].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK]	|= MCDRV_SRC3_DIR0_OFF;
+		}
+		else
+		{
+		}
+
+		if((psPathInfo->asDac[bCh].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK] & (MCDRV_SRC3_DIR1_ON|MCDRV_SRC3_DIR1_OFF)) == MCDRV_SRC3_DIR1_ON)
+		{
+			gsGlobalInfo.sPathInfo.asDac[bCh].abSrcOnOff[MCDRV_SRC_PDM_BLOCK]	&= (UINT8)~MCDRV_SRC4_PDM_ON;
+			gsGlobalInfo.sPathInfo.asDac[bCh].abSrcOnOff[MCDRV_SRC_PDM_BLOCK]	|= MCDRV_SRC4_PDM_OFF;
+			gsGlobalInfo.sPathInfo.asDac[bCh].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK]	&= (UINT8)~MCDRV_SRC4_ADC0_ON;
+			gsGlobalInfo.sPathInfo.asDac[bCh].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK]	|= MCDRV_SRC4_ADC0_OFF;
+			gsGlobalInfo.sPathInfo.asDac[bCh].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR0_ON;
+			gsGlobalInfo.sPathInfo.asDac[bCh].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK]	|= MCDRV_SRC3_DIR0_OFF;
+			gsGlobalInfo.sPathInfo.asDac[bCh].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR1_OFF;
+			gsGlobalInfo.sPathInfo.asDac[bCh].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK]	|= MCDRV_SRC3_DIR1_ON;
+			gsGlobalInfo.sPathInfo.asDac[bCh].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR2_ON;
+			gsGlobalInfo.sPathInfo.asDac[bCh].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK]	|= MCDRV_SRC3_DIR2_OFF;
+			gsGlobalInfo.sPathInfo.asDac[bCh].abSrcOnOff[MCDRV_SRC_AE_BLOCK]	&= (UINT8)~MCDRV_SRC6_AE_ON;
+			gsGlobalInfo.sPathInfo.asDac[bCh].abSrcOnOff[MCDRV_SRC_AE_BLOCK]	|= MCDRV_SRC6_AE_OFF;
+			gsGlobalInfo.sPathInfo.asDac[bCh].abSrcOnOff[MCDRV_SRC_MIX_BLOCK]	&= (UINT8)~MCDRV_SRC6_MIX_ON;
+			gsGlobalInfo.sPathInfo.asDac[bCh].abSrcOnOff[MCDRV_SRC_MIX_BLOCK]	|= MCDRV_SRC6_MIX_OFF;
+		}
+		else if((psPathInfo->asDac[bCh].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK] & (MCDRV_SRC3_DIR1_ON|MCDRV_SRC3_DIR1_OFF)) == MCDRV_SRC3_DIR1_OFF)
+		{
+			gsGlobalInfo.sPathInfo.asDac[bCh].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR1_ON;
+			gsGlobalInfo.sPathInfo.asDac[bCh].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK]	|= MCDRV_SRC3_DIR1_OFF;
+		}
+		else
+		{
+		}
+
+		if((psPathInfo->asDac[bCh].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK] & (MCDRV_SRC3_DIR2_ON|MCDRV_SRC3_DIR2_OFF)) == MCDRV_SRC3_DIR2_ON)
+		{
+			gsGlobalInfo.sPathInfo.asDac[bCh].abSrcOnOff[MCDRV_SRC_PDM_BLOCK]	&= (UINT8)~MCDRV_SRC4_PDM_ON;
+			gsGlobalInfo.sPathInfo.asDac[bCh].abSrcOnOff[MCDRV_SRC_PDM_BLOCK]	|= MCDRV_SRC4_PDM_OFF;
+			gsGlobalInfo.sPathInfo.asDac[bCh].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK]	&= (UINT8)~MCDRV_SRC4_ADC0_ON;
+			gsGlobalInfo.sPathInfo.asDac[bCh].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK]	|= MCDRV_SRC4_ADC0_OFF;
+			gsGlobalInfo.sPathInfo.asDac[bCh].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR0_ON;
+			gsGlobalInfo.sPathInfo.asDac[bCh].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK]	|= MCDRV_SRC3_DIR0_OFF;
+			gsGlobalInfo.sPathInfo.asDac[bCh].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR1_ON;
+			gsGlobalInfo.sPathInfo.asDac[bCh].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK]	|= MCDRV_SRC3_DIR1_OFF;
+			gsGlobalInfo.sPathInfo.asDac[bCh].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR2_OFF;
+			gsGlobalInfo.sPathInfo.asDac[bCh].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK]	|= MCDRV_SRC3_DIR2_ON;
+			gsGlobalInfo.sPathInfo.asDac[bCh].abSrcOnOff[MCDRV_SRC_AE_BLOCK]	&= (UINT8)~MCDRV_SRC6_AE_ON;
+			gsGlobalInfo.sPathInfo.asDac[bCh].abSrcOnOff[MCDRV_SRC_AE_BLOCK]	|= MCDRV_SRC6_AE_OFF;
+			gsGlobalInfo.sPathInfo.asDac[bCh].abSrcOnOff[MCDRV_SRC_MIX_BLOCK]	&= (UINT8)~MCDRV_SRC6_MIX_ON;
+			gsGlobalInfo.sPathInfo.asDac[bCh].abSrcOnOff[MCDRV_SRC_MIX_BLOCK]	|= MCDRV_SRC6_MIX_OFF;
+		}
+		else if((psPathInfo->asDac[bCh].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK] & (MCDRV_SRC3_DIR2_ON|MCDRV_SRC3_DIR2_OFF)) == MCDRV_SRC3_DIR2_OFF)
+		{
+			gsGlobalInfo.sPathInfo.asDac[bCh].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR2_ON;
+			gsGlobalInfo.sPathInfo.asDac[bCh].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK]	|= MCDRV_SRC3_DIR2_OFF;
+		}
+		else
+		{
+		}
+
+		if((psPathInfo->asDac[bCh].abSrcOnOff[MCDRV_SRC_AE_BLOCK] & (MCDRV_SRC6_AE_ON|MCDRV_SRC6_AE_OFF)) == MCDRV_SRC6_AE_ON)
+		{
+			gsGlobalInfo.sPathInfo.asDac[bCh].abSrcOnOff[MCDRV_SRC_PDM_BLOCK]	&= (UINT8)~MCDRV_SRC4_PDM_ON;
+			gsGlobalInfo.sPathInfo.asDac[bCh].abSrcOnOff[MCDRV_SRC_PDM_BLOCK]	|= MCDRV_SRC4_PDM_OFF;
+			gsGlobalInfo.sPathInfo.asDac[bCh].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK]	&= (UINT8)~MCDRV_SRC4_ADC0_ON;
+			gsGlobalInfo.sPathInfo.asDac[bCh].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK]	|= MCDRV_SRC4_ADC0_OFF;
+			gsGlobalInfo.sPathInfo.asDac[bCh].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR0_ON;
+			gsGlobalInfo.sPathInfo.asDac[bCh].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK]	|= MCDRV_SRC3_DIR0_OFF;
+			gsGlobalInfo.sPathInfo.asDac[bCh].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR1_ON;
+			gsGlobalInfo.sPathInfo.asDac[bCh].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK]	|= MCDRV_SRC3_DIR1_OFF;
+			gsGlobalInfo.sPathInfo.asDac[bCh].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR2_ON;
+			gsGlobalInfo.sPathInfo.asDac[bCh].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK]	|= MCDRV_SRC3_DIR2_OFF;
+			gsGlobalInfo.sPathInfo.asDac[bCh].abSrcOnOff[MCDRV_SRC_AE_BLOCK]	&= (UINT8)~MCDRV_SRC6_AE_OFF;
+			gsGlobalInfo.sPathInfo.asDac[bCh].abSrcOnOff[MCDRV_SRC_AE_BLOCK]	|= MCDRV_SRC6_AE_ON;
+			gsGlobalInfo.sPathInfo.asDac[bCh].abSrcOnOff[MCDRV_SRC_MIX_BLOCK]	&= (UINT8)~MCDRV_SRC6_MIX_ON;
+			gsGlobalInfo.sPathInfo.asDac[bCh].abSrcOnOff[MCDRV_SRC_MIX_BLOCK]	|= MCDRV_SRC6_MIX_OFF;
+		}
+		else if((psPathInfo->asDac[bCh].abSrcOnOff[MCDRV_SRC_AE_BLOCK] & (MCDRV_SRC6_AE_ON|MCDRV_SRC6_AE_OFF)) == MCDRV_SRC6_AE_OFF)
+		{
+			gsGlobalInfo.sPathInfo.asDac[bCh].abSrcOnOff[MCDRV_SRC_AE_BLOCK]	&= (UINT8)~MCDRV_SRC6_AE_ON;
+			gsGlobalInfo.sPathInfo.asDac[bCh].abSrcOnOff[MCDRV_SRC_AE_BLOCK]	|= MCDRV_SRC6_AE_OFF;
+		}
+		else
+		{
+		}
+
+		if((psPathInfo->asDac[bCh].abSrcOnOff[MCDRV_SRC_MIX_BLOCK] & (MCDRV_SRC6_MIX_ON|MCDRV_SRC6_MIX_OFF)) == MCDRV_SRC6_MIX_ON)
+		{
+			gsGlobalInfo.sPathInfo.asDac[bCh].abSrcOnOff[MCDRV_SRC_PDM_BLOCK]	&= (UINT8)~MCDRV_SRC4_PDM_ON;
+			gsGlobalInfo.sPathInfo.asDac[bCh].abSrcOnOff[MCDRV_SRC_PDM_BLOCK]	|= MCDRV_SRC4_PDM_OFF;
+			gsGlobalInfo.sPathInfo.asDac[bCh].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK]	&= (UINT8)~MCDRV_SRC4_ADC0_ON;
+			gsGlobalInfo.sPathInfo.asDac[bCh].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK]	|= MCDRV_SRC4_ADC0_OFF;
+			gsGlobalInfo.sPathInfo.asDac[bCh].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR0_ON;
+			gsGlobalInfo.sPathInfo.asDac[bCh].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK]	|= MCDRV_SRC3_DIR0_OFF;
+			gsGlobalInfo.sPathInfo.asDac[bCh].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR1_ON;
+			gsGlobalInfo.sPathInfo.asDac[bCh].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK]	|= MCDRV_SRC3_DIR1_OFF;
+			gsGlobalInfo.sPathInfo.asDac[bCh].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR2_ON;
+			gsGlobalInfo.sPathInfo.asDac[bCh].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK]	|= MCDRV_SRC3_DIR2_OFF;
+			gsGlobalInfo.sPathInfo.asDac[bCh].abSrcOnOff[MCDRV_SRC_AE_BLOCK]	&= (UINT8)~MCDRV_SRC6_AE_ON;
+			gsGlobalInfo.sPathInfo.asDac[bCh].abSrcOnOff[MCDRV_SRC_AE_BLOCK]	|= MCDRV_SRC6_AE_OFF;
+			gsGlobalInfo.sPathInfo.asDac[bCh].abSrcOnOff[MCDRV_SRC_MIX_BLOCK]	&= (UINT8)~MCDRV_SRC6_MIX_OFF;
+			gsGlobalInfo.sPathInfo.asDac[bCh].abSrcOnOff[MCDRV_SRC_MIX_BLOCK]	|= MCDRV_SRC6_MIX_ON;
+		}
+		else if((psPathInfo->asDac[bCh].abSrcOnOff[MCDRV_SRC_MIX_BLOCK] & (MCDRV_SRC6_MIX_ON|MCDRV_SRC6_MIX_OFF)) == MCDRV_SRC6_MIX_OFF)
+		{
+			gsGlobalInfo.sPathInfo.asDac[bCh].abSrcOnOff[MCDRV_SRC_MIX_BLOCK]	&= (UINT8)~MCDRV_SRC6_MIX_ON;
+			gsGlobalInfo.sPathInfo.asDac[bCh].abSrcOnOff[MCDRV_SRC_MIX_BLOCK]	|= MCDRV_SRC6_MIX_OFF;
+		}
+		else
+		{
+		}
+	}
+
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncOut("SetDACSourceOnOff", 0);
+#endif
+}
+
+/****************************************************************************
+ *	SetAESourceOnOff
+ *
+ *	Description:
+ *			Set AE source On/Off.
+ *	Arguments:
+ *			psPathInfo	path information
+ *	Return:
+ *			none
+ *
+ ****************************************************************************/
+static void	SetAESourceOnOff
+(
+	const MCDRV_PATH_INFO*	psPathInfo
+)
+{
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncIn("SetAESourceOnOff");
+#endif
+
+	if(((psPathInfo->asAe[0].abSrcOnOff[MCDRV_SRC_PDM_BLOCK] & (MCDRV_SRC4_PDM_ON|MCDRV_SRC4_PDM_OFF)) == MCDRV_SRC4_PDM_ON)
+	&& (gsGlobalInfo.sInitInfo.bPad0Func == MCDRV_PAD_PDMCK))
+	{
+		gsGlobalInfo.sPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_PDM_BLOCK]	&= (UINT8)~MCDRV_SRC4_PDM_OFF;
+		gsGlobalInfo.sPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_PDM_BLOCK]	|= MCDRV_SRC4_PDM_ON;
+		gsGlobalInfo.sPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK]	&= (UINT8)~MCDRV_SRC4_ADC0_ON;
+		gsGlobalInfo.sPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK]	|= MCDRV_SRC4_ADC0_OFF;
+		gsGlobalInfo.sPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR0_ON;
+		gsGlobalInfo.sPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK]	|= MCDRV_SRC3_DIR0_OFF;
+		gsGlobalInfo.sPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR1_ON;
+		gsGlobalInfo.sPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK]	|= MCDRV_SRC3_DIR1_OFF;
+		gsGlobalInfo.sPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR2_ON;
+		gsGlobalInfo.sPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK]	|= MCDRV_SRC3_DIR2_OFF;
+		gsGlobalInfo.sPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_MIX_BLOCK]	&= (UINT8)~MCDRV_SRC6_MIX_ON;
+		gsGlobalInfo.sPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_MIX_BLOCK]	|= MCDRV_SRC6_MIX_OFF;
+	}
+	else if((psPathInfo->asAe[0].abSrcOnOff[MCDRV_SRC_PDM_BLOCK] & (MCDRV_SRC4_PDM_ON|MCDRV_SRC4_PDM_OFF)) == MCDRV_SRC4_PDM_OFF)
+	{
+		gsGlobalInfo.sPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_PDM_BLOCK]	&= (UINT8)~MCDRV_SRC4_PDM_ON;
+		gsGlobalInfo.sPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_PDM_BLOCK]	|= MCDRV_SRC4_PDM_OFF;
+	}
+	else
+	{
+	}
+
+	if((psPathInfo->asAe[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK] & (MCDRV_SRC4_ADC0_ON|MCDRV_SRC4_ADC0_OFF)) == MCDRV_SRC4_ADC0_ON)
+	{
+		gsGlobalInfo.sPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_PDM_BLOCK]	&= (UINT8)~MCDRV_SRC4_PDM_ON;
+		gsGlobalInfo.sPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_PDM_BLOCK]	|= MCDRV_SRC4_PDM_OFF;
+		gsGlobalInfo.sPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK]	&= (UINT8)~MCDRV_SRC4_ADC0_OFF;
+		gsGlobalInfo.sPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK]	|= MCDRV_SRC4_ADC0_ON;
+		gsGlobalInfo.sPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR0_ON;
+		gsGlobalInfo.sPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK]	|= MCDRV_SRC3_DIR0_OFF;
+		gsGlobalInfo.sPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR1_ON;
+		gsGlobalInfo.sPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK]	|= MCDRV_SRC3_DIR1_OFF;
+		gsGlobalInfo.sPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR2_ON;
+		gsGlobalInfo.sPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK]	|= MCDRV_SRC3_DIR2_OFF;
+		gsGlobalInfo.sPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_MIX_BLOCK]	&= (UINT8)~MCDRV_SRC6_MIX_ON;
+		gsGlobalInfo.sPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_MIX_BLOCK]	|= MCDRV_SRC6_MIX_OFF;
+	}
+	else if((psPathInfo->asAe[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK] & (MCDRV_SRC4_ADC0_ON|MCDRV_SRC4_ADC0_OFF)) == MCDRV_SRC4_ADC0_OFF)
+	{
+		gsGlobalInfo.sPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK]	&= (UINT8)~MCDRV_SRC4_ADC0_ON;
+		gsGlobalInfo.sPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK]	|= MCDRV_SRC4_ADC0_OFF;
+	}
+	else
+	{
+	}
+
+	if((psPathInfo->asAe[0].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK] & (MCDRV_SRC3_DIR0_ON|MCDRV_SRC3_DIR0_OFF)) == MCDRV_SRC3_DIR0_ON)
+	{
+		gsGlobalInfo.sPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_PDM_BLOCK]	&= (UINT8)~MCDRV_SRC4_PDM_ON;
+		gsGlobalInfo.sPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_PDM_BLOCK]	|= MCDRV_SRC4_PDM_OFF;
+		gsGlobalInfo.sPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK]	&= (UINT8)~MCDRV_SRC4_ADC0_ON;
+		gsGlobalInfo.sPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK]	|= MCDRV_SRC4_ADC0_OFF;
+		gsGlobalInfo.sPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR0_OFF;
+		gsGlobalInfo.sPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK]	|= MCDRV_SRC3_DIR0_ON;
+		gsGlobalInfo.sPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR1_ON;
+		gsGlobalInfo.sPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK]	|= MCDRV_SRC3_DIR1_OFF;
+		gsGlobalInfo.sPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR2_ON;
+		gsGlobalInfo.sPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK]	|= MCDRV_SRC3_DIR2_OFF;
+		gsGlobalInfo.sPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_MIX_BLOCK]	&= (UINT8)~MCDRV_SRC6_MIX_ON;
+		gsGlobalInfo.sPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_MIX_BLOCK]	|= MCDRV_SRC6_MIX_OFF;
+	}
+	else if((psPathInfo->asAe[0].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK] & (MCDRV_SRC3_DIR0_ON|MCDRV_SRC3_DIR0_OFF)) == MCDRV_SRC3_DIR0_OFF)
+	{
+		gsGlobalInfo.sPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR0_ON;
+		gsGlobalInfo.sPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK]	|= MCDRV_SRC3_DIR0_OFF;
+	}
+	else
+	{
+	}
+
+	if((psPathInfo->asAe[0].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK] & (MCDRV_SRC3_DIR1_ON|MCDRV_SRC3_DIR1_OFF)) == MCDRV_SRC3_DIR1_ON)
+	{
+		gsGlobalInfo.sPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_PDM_BLOCK]	&= (UINT8)~MCDRV_SRC4_PDM_ON;
+		gsGlobalInfo.sPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_PDM_BLOCK]	|= MCDRV_SRC4_PDM_OFF;
+		gsGlobalInfo.sPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK]	&= (UINT8)~MCDRV_SRC4_ADC0_ON;
+		gsGlobalInfo.sPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK]	|= MCDRV_SRC4_ADC0_OFF;
+		gsGlobalInfo.sPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR0_ON;
+		gsGlobalInfo.sPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK]	|= MCDRV_SRC3_DIR0_OFF;
+		gsGlobalInfo.sPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR1_OFF;
+		gsGlobalInfo.sPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK]	|= MCDRV_SRC3_DIR1_ON;
+		gsGlobalInfo.sPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR2_ON;
+		gsGlobalInfo.sPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK]	|= MCDRV_SRC3_DIR2_OFF;
+		gsGlobalInfo.sPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_MIX_BLOCK]	&= (UINT8)~MCDRV_SRC6_MIX_ON;
+		gsGlobalInfo.sPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_MIX_BLOCK]	|= MCDRV_SRC6_MIX_OFF;
+	}
+	else if((psPathInfo->asAe[0].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK] & (MCDRV_SRC3_DIR1_ON|MCDRV_SRC3_DIR1_OFF)) == MCDRV_SRC3_DIR1_OFF)
+	{
+		gsGlobalInfo.sPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR1_ON;
+		gsGlobalInfo.sPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK]	|= MCDRV_SRC3_DIR1_OFF;
+	}
+	else
+	{
+	}
+
+	if((psPathInfo->asAe[0].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK] & (MCDRV_SRC3_DIR2_ON|MCDRV_SRC3_DIR2_OFF)) == MCDRV_SRC3_DIR2_ON)
+	{
+		gsGlobalInfo.sPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_PDM_BLOCK]	&= (UINT8)~MCDRV_SRC4_PDM_ON;
+		gsGlobalInfo.sPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_PDM_BLOCK]	|= MCDRV_SRC4_PDM_OFF;
+		gsGlobalInfo.sPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK]	&= (UINT8)~MCDRV_SRC4_ADC0_ON;
+		gsGlobalInfo.sPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK]	|= MCDRV_SRC4_ADC0_OFF;
+		gsGlobalInfo.sPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR0_ON;
+		gsGlobalInfo.sPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK]	|= MCDRV_SRC3_DIR0_OFF;
+		gsGlobalInfo.sPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR1_ON;
+		gsGlobalInfo.sPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK]	|= MCDRV_SRC3_DIR1_OFF;
+		gsGlobalInfo.sPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR2_OFF;
+		gsGlobalInfo.sPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK]	|= MCDRV_SRC3_DIR2_ON;
+		gsGlobalInfo.sPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_MIX_BLOCK]	&= (UINT8)~MCDRV_SRC6_MIX_ON;
+		gsGlobalInfo.sPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_MIX_BLOCK]	|= MCDRV_SRC6_MIX_OFF;
+	}
+	else if((psPathInfo->asAe[0].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK] & (MCDRV_SRC3_DIR2_ON|MCDRV_SRC3_DIR2_OFF)) == MCDRV_SRC3_DIR2_OFF)
+	{
+		gsGlobalInfo.sPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR2_ON;
+		gsGlobalInfo.sPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK]	|= MCDRV_SRC3_DIR2_OFF;
+	}
+	else
+	{
+	}
+
+	if((psPathInfo->asAe[0].abSrcOnOff[MCDRV_SRC_MIX_BLOCK] & (MCDRV_SRC6_MIX_ON|MCDRV_SRC6_MIX_OFF)) == MCDRV_SRC6_MIX_ON)
+	{
+		gsGlobalInfo.sPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_PDM_BLOCK]	&= (UINT8)~MCDRV_SRC4_PDM_ON;
+		gsGlobalInfo.sPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_PDM_BLOCK]	|= MCDRV_SRC4_PDM_OFF;
+		gsGlobalInfo.sPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK]	&= (UINT8)~MCDRV_SRC4_ADC0_ON;
+		gsGlobalInfo.sPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK]	|= MCDRV_SRC4_ADC0_OFF;
+		gsGlobalInfo.sPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR0_ON;
+		gsGlobalInfo.sPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK]	|= MCDRV_SRC3_DIR0_OFF;
+		gsGlobalInfo.sPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR1_ON;
+		gsGlobalInfo.sPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK]	|= MCDRV_SRC3_DIR1_OFF;
+		gsGlobalInfo.sPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR2_ON;
+		gsGlobalInfo.sPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK]	|= MCDRV_SRC3_DIR2_OFF;
+		gsGlobalInfo.sPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_MIX_BLOCK]	&= (UINT8)~MCDRV_SRC6_MIX_OFF;
+		gsGlobalInfo.sPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_MIX_BLOCK]	|= MCDRV_SRC6_MIX_ON;
+	}
+	else if((psPathInfo->asAe[0].abSrcOnOff[MCDRV_SRC_MIX_BLOCK] & (MCDRV_SRC6_MIX_ON|MCDRV_SRC6_MIX_OFF)) == MCDRV_SRC6_MIX_OFF)
+	{
+		gsGlobalInfo.sPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_MIX_BLOCK]	&= (UINT8)~MCDRV_SRC6_MIX_ON;
+		gsGlobalInfo.sPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_MIX_BLOCK]	|= MCDRV_SRC6_MIX_OFF;
+	}
+	else
+	{
+	}
+
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncOut("SetAESourceOnOff", 0);
+#endif
+}
+
+/****************************************************************************
+ *	SetCDSPSourceOnOff
+ *
+ *	Description:
+ *			Set CDSP source On/Off.
+ *	Arguments:
+ *			psPathInfo	path information
+ *	Return:
+ *			none
+ *
+ ****************************************************************************/
+static void	SetCDSPSourceOnOff
+(
+	const MCDRV_PATH_INFO*	psPathInfo
+)
+{
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncIn("SetCDSPSourceOnOff");
+#endif
+
+	(void)psPathInfo;
+
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncOut("SetCDSPSourceOnOff", 0);
+#endif
+}
+
+/****************************************************************************
+ *	SetADC0SourceOnOff
+ *
+ *	Description:
+ *			Set ADC0 source On/Off.
+ *	Arguments:
+ *			psPathInfo	path information
+ *	Return:
+ *			none
+ *
+ ****************************************************************************/
+static void	SetADC0SourceOnOff
+(
+	const MCDRV_PATH_INFO*	psPathInfo
+)
+{
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncIn("SetADC0SourceOnOff");
+#endif
+
+	if((psPathInfo->asAdc0[0].abSrcOnOff[MCDRV_SRC_MIC1_BLOCK] & (MCDRV_SRC0_MIC1_ON|MCDRV_SRC0_MIC1_OFF)) == MCDRV_SRC0_MIC1_ON)
+	{
+		gsGlobalInfo.sPathInfo.asAdc0[0].abSrcOnOff[MCDRV_SRC_MIC1_BLOCK]	&= (UINT8)~MCDRV_SRC0_MIC1_OFF;
+		gsGlobalInfo.sPathInfo.asAdc0[0].abSrcOnOff[MCDRV_SRC_MIC1_BLOCK]	|= MCDRV_SRC0_MIC1_ON;
+	}
+	else if((psPathInfo->asAdc0[0].abSrcOnOff[MCDRV_SRC_MIC1_BLOCK] & (MCDRV_SRC0_MIC1_ON|MCDRV_SRC0_MIC1_OFF)) == MCDRV_SRC0_MIC1_OFF)
+	{
+		gsGlobalInfo.sPathInfo.asAdc0[0].abSrcOnOff[MCDRV_SRC_MIC1_BLOCK]	&= (UINT8)~MCDRV_SRC0_MIC1_ON;
+		gsGlobalInfo.sPathInfo.asAdc0[0].abSrcOnOff[MCDRV_SRC_MIC1_BLOCK]	|= MCDRV_SRC0_MIC1_OFF;
+	}
+	else
+	{
+	}
+
+	if((psPathInfo->asAdc0[0].abSrcOnOff[MCDRV_SRC_MIC2_BLOCK] & (MCDRV_SRC0_MIC2_ON|MCDRV_SRC0_MIC2_OFF)) == MCDRV_SRC0_MIC2_ON)
+	{
+		gsGlobalInfo.sPathInfo.asAdc0[0].abSrcOnOff[MCDRV_SRC_MIC2_BLOCK]	&= (UINT8)~MCDRV_SRC0_MIC2_OFF;
+		gsGlobalInfo.sPathInfo.asAdc0[0].abSrcOnOff[MCDRV_SRC_MIC2_BLOCK]	|= MCDRV_SRC0_MIC2_ON;
+	}
+	else if((psPathInfo->asAdc0[0].abSrcOnOff[MCDRV_SRC_MIC2_BLOCK] & (MCDRV_SRC0_MIC2_ON|MCDRV_SRC0_MIC2_OFF)) == MCDRV_SRC0_MIC2_OFF)
+	{
+		gsGlobalInfo.sPathInfo.asAdc0[0].abSrcOnOff[MCDRV_SRC_MIC2_BLOCK]	&= (UINT8)~MCDRV_SRC0_MIC2_ON;
+		gsGlobalInfo.sPathInfo.asAdc0[0].abSrcOnOff[MCDRV_SRC_MIC2_BLOCK]	|= MCDRV_SRC0_MIC2_OFF;
+	}
+	else
+	{
+	}
+
+	if((psPathInfo->asAdc0[0].abSrcOnOff[MCDRV_SRC_MIC3_BLOCK] & (MCDRV_SRC0_MIC3_ON|MCDRV_SRC0_MIC3_OFF)) == MCDRV_SRC0_MIC3_ON)
+	{
+		gsGlobalInfo.sPathInfo.asAdc0[0].abSrcOnOff[MCDRV_SRC_MIC3_BLOCK]	&= (UINT8)~MCDRV_SRC0_MIC3_OFF;
+		gsGlobalInfo.sPathInfo.asAdc0[0].abSrcOnOff[MCDRV_SRC_MIC3_BLOCK]	|= MCDRV_SRC0_MIC3_ON;
+	}
+	else if((psPathInfo->asAdc0[0].abSrcOnOff[MCDRV_SRC_MIC3_BLOCK] & (MCDRV_SRC0_MIC3_ON|MCDRV_SRC0_MIC3_OFF)) == MCDRV_SRC0_MIC3_OFF)
+	{
+		gsGlobalInfo.sPathInfo.asAdc0[0].abSrcOnOff[MCDRV_SRC_MIC3_BLOCK]	&= (UINT8)~MCDRV_SRC0_MIC3_ON;
+		gsGlobalInfo.sPathInfo.asAdc0[0].abSrcOnOff[MCDRV_SRC_MIC3_BLOCK]	|= MCDRV_SRC0_MIC3_OFF;
+	}
+	else
+	{
+	}
+
+	if((psPathInfo->asAdc0[0].abSrcOnOff[MCDRV_SRC_LINE1_L_BLOCK] & (MCDRV_SRC1_LINE1_L_ON|MCDRV_SRC1_LINE1_L_OFF)) == MCDRV_SRC1_LINE1_L_ON)
+	{
+		gsGlobalInfo.sPathInfo.asAdc0[0].abSrcOnOff[MCDRV_SRC_LINE1_L_BLOCK]	&= (UINT8)~MCDRV_SRC1_LINE1_L_OFF;
+		gsGlobalInfo.sPathInfo.asAdc0[0].abSrcOnOff[MCDRV_SRC_LINE1_L_BLOCK]	|= MCDRV_SRC1_LINE1_L_ON;
+	}
+	else if((psPathInfo->asAdc0[0].abSrcOnOff[MCDRV_SRC_LINE1_L_BLOCK] & (MCDRV_SRC1_LINE1_L_ON|MCDRV_SRC1_LINE1_L_OFF)) == MCDRV_SRC1_LINE1_L_OFF)
+	{
+		gsGlobalInfo.sPathInfo.asAdc0[0].abSrcOnOff[MCDRV_SRC_LINE1_L_BLOCK]	&= (UINT8)~MCDRV_SRC1_LINE1_L_ON;
+		gsGlobalInfo.sPathInfo.asAdc0[0].abSrcOnOff[MCDRV_SRC_LINE1_L_BLOCK]	|= MCDRV_SRC1_LINE1_L_OFF;
+	}
+	else
+	{
+	}
+
+	if((psPathInfo->asAdc0[0].abSrcOnOff[MCDRV_SRC_LINE1_M_BLOCK] & (MCDRV_SRC1_LINE1_M_ON|MCDRV_SRC1_LINE1_M_OFF)) == MCDRV_SRC1_LINE1_M_ON)
+	{
+		gsGlobalInfo.sPathInfo.asAdc0[0].abSrcOnOff[MCDRV_SRC_LINE1_M_BLOCK]	&= (UINT8)~MCDRV_SRC1_LINE1_M_OFF;
+		gsGlobalInfo.sPathInfo.asAdc0[0].abSrcOnOff[MCDRV_SRC_LINE1_M_BLOCK]	|= MCDRV_SRC1_LINE1_M_ON;
+	}
+	else if((psPathInfo->asAdc0[0].abSrcOnOff[MCDRV_SRC_LINE1_M_BLOCK] & (MCDRV_SRC1_LINE1_M_ON|MCDRV_SRC1_LINE1_M_OFF)) == MCDRV_SRC1_LINE1_M_OFF)
+	{
+		gsGlobalInfo.sPathInfo.asAdc0[0].abSrcOnOff[MCDRV_SRC_LINE1_M_BLOCK]	&= (UINT8)~MCDRV_SRC1_LINE1_M_ON;
+		gsGlobalInfo.sPathInfo.asAdc0[0].abSrcOnOff[MCDRV_SRC_LINE1_M_BLOCK]	|= MCDRV_SRC1_LINE1_M_OFF;
+	}
+	else
+	{
+	}
+
+	if((psPathInfo->asAdc0[1].abSrcOnOff[MCDRV_SRC_MIC1_BLOCK] & (MCDRV_SRC0_MIC1_ON|MCDRV_SRC0_MIC1_OFF)) == MCDRV_SRC0_MIC1_ON)
+	{
+		gsGlobalInfo.sPathInfo.asAdc0[1].abSrcOnOff[MCDRV_SRC_MIC1_BLOCK]	&= (UINT8)~MCDRV_SRC0_MIC1_OFF;
+		gsGlobalInfo.sPathInfo.asAdc0[1].abSrcOnOff[MCDRV_SRC_MIC1_BLOCK]	|= MCDRV_SRC0_MIC1_ON;
+	}
+	else if((psPathInfo->asAdc0[1].abSrcOnOff[MCDRV_SRC_MIC1_BLOCK] & (MCDRV_SRC0_MIC1_ON|MCDRV_SRC0_MIC1_OFF)) == MCDRV_SRC0_MIC1_OFF)
+	{
+		gsGlobalInfo.sPathInfo.asAdc0[1].abSrcOnOff[MCDRV_SRC_MIC1_BLOCK]	&= (UINT8)~MCDRV_SRC0_MIC1_ON;
+		gsGlobalInfo.sPathInfo.asAdc0[1].abSrcOnOff[MCDRV_SRC_MIC1_BLOCK]	|= MCDRV_SRC0_MIC1_OFF;
+	}
+	else
+	{
+	}
+
+	if((psPathInfo->asAdc0[1].abSrcOnOff[MCDRV_SRC_MIC2_BLOCK] & (MCDRV_SRC0_MIC2_ON|MCDRV_SRC0_MIC2_OFF)) == MCDRV_SRC0_MIC2_ON)
+	{
+		gsGlobalInfo.sPathInfo.asAdc0[1].abSrcOnOff[MCDRV_SRC_MIC2_BLOCK]	&= (UINT8)~MCDRV_SRC0_MIC2_OFF;
+		gsGlobalInfo.sPathInfo.asAdc0[1].abSrcOnOff[MCDRV_SRC_MIC2_BLOCK]	|= MCDRV_SRC0_MIC2_ON;
+	}
+	else if((psPathInfo->asAdc0[1].abSrcOnOff[MCDRV_SRC_MIC2_BLOCK] & (MCDRV_SRC0_MIC2_ON|MCDRV_SRC0_MIC2_OFF)) == MCDRV_SRC0_MIC2_OFF)
+	{
+		gsGlobalInfo.sPathInfo.asAdc0[1].abSrcOnOff[MCDRV_SRC_MIC2_BLOCK]	&= (UINT8)~MCDRV_SRC0_MIC2_ON;
+		gsGlobalInfo.sPathInfo.asAdc0[1].abSrcOnOff[MCDRV_SRC_MIC2_BLOCK]	|= MCDRV_SRC0_MIC2_OFF;
+	}
+	else
+	{
+	}
+
+	if((psPathInfo->asAdc0[1].abSrcOnOff[MCDRV_SRC_MIC3_BLOCK] & (MCDRV_SRC0_MIC3_ON|MCDRV_SRC0_MIC3_OFF)) == MCDRV_SRC0_MIC3_ON)
+	{
+		gsGlobalInfo.sPathInfo.asAdc0[1].abSrcOnOff[MCDRV_SRC_MIC3_BLOCK]	&= (UINT8)~MCDRV_SRC0_MIC3_OFF;
+		gsGlobalInfo.sPathInfo.asAdc0[1].abSrcOnOff[MCDRV_SRC_MIC3_BLOCK]	|= MCDRV_SRC0_MIC3_ON;
+	}
+	else if((psPathInfo->asAdc0[1].abSrcOnOff[MCDRV_SRC_MIC3_BLOCK] & (MCDRV_SRC0_MIC3_ON|MCDRV_SRC0_MIC3_OFF)) == MCDRV_SRC0_MIC3_OFF)
+	{
+		gsGlobalInfo.sPathInfo.asAdc0[1].abSrcOnOff[MCDRV_SRC_MIC3_BLOCK]	&= (UINT8)~MCDRV_SRC0_MIC3_ON;
+		gsGlobalInfo.sPathInfo.asAdc0[1].abSrcOnOff[MCDRV_SRC_MIC3_BLOCK]	|= MCDRV_SRC0_MIC3_OFF;
+	}
+	else
+	{
+	}
+
+	if((psPathInfo->asAdc0[1].abSrcOnOff[MCDRV_SRC_LINE1_R_BLOCK] & (MCDRV_SRC1_LINE1_R_ON|MCDRV_SRC1_LINE1_R_OFF)) == MCDRV_SRC1_LINE1_R_ON)
+	{
+		gsGlobalInfo.sPathInfo.asAdc0[1].abSrcOnOff[MCDRV_SRC_LINE1_R_BLOCK]	&= (UINT8)~MCDRV_SRC1_LINE1_R_OFF;
+		gsGlobalInfo.sPathInfo.asAdc0[1].abSrcOnOff[MCDRV_SRC_LINE1_R_BLOCK]	|= MCDRV_SRC1_LINE1_R_ON;
+	}
+	else if((psPathInfo->asAdc0[1].abSrcOnOff[MCDRV_SRC_LINE1_R_BLOCK] & (MCDRV_SRC1_LINE1_R_ON|MCDRV_SRC1_LINE1_R_OFF)) == MCDRV_SRC1_LINE1_R_OFF)
+	{
+		gsGlobalInfo.sPathInfo.asAdc0[1].abSrcOnOff[MCDRV_SRC_LINE1_R_BLOCK]	&= (UINT8)~MCDRV_SRC1_LINE1_R_ON;
+		gsGlobalInfo.sPathInfo.asAdc0[1].abSrcOnOff[MCDRV_SRC_LINE1_R_BLOCK]	|= MCDRV_SRC1_LINE1_R_OFF;
+	}
+	else
+	{
+	}
+
+	if((psPathInfo->asAdc0[1].abSrcOnOff[MCDRV_SRC_LINE1_M_BLOCK] & (MCDRV_SRC1_LINE1_M_ON|MCDRV_SRC1_LINE1_M_OFF)) == MCDRV_SRC1_LINE1_M_ON)
+	{
+		gsGlobalInfo.sPathInfo.asAdc0[1].abSrcOnOff[MCDRV_SRC_LINE1_M_BLOCK]	&= (UINT8)~MCDRV_SRC1_LINE1_M_OFF;
+		gsGlobalInfo.sPathInfo.asAdc0[1].abSrcOnOff[MCDRV_SRC_LINE1_M_BLOCK]	|= MCDRV_SRC1_LINE1_M_ON;
+	}
+	else if((psPathInfo->asAdc0[1].abSrcOnOff[MCDRV_SRC_LINE1_M_BLOCK] & (MCDRV_SRC1_LINE1_M_ON|MCDRV_SRC1_LINE1_M_OFF)) == MCDRV_SRC1_LINE1_M_OFF)
+	{
+		gsGlobalInfo.sPathInfo.asAdc0[1].abSrcOnOff[MCDRV_SRC_LINE1_M_BLOCK]	&= (UINT8)~MCDRV_SRC1_LINE1_M_ON;
+		gsGlobalInfo.sPathInfo.asAdc0[1].abSrcOnOff[MCDRV_SRC_LINE1_M_BLOCK]	|= MCDRV_SRC1_LINE1_M_OFF;
+	}
+	else
+	{
+	}
+
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncOut("SetADC0SourceOnOff", 0);
+#endif
+}
+
+/****************************************************************************
+ *	SetADC1SourceOnOff
+ *
+ *	Description:
+ *			Set ADC1 source On/Off.
+ *	Arguments:
+ *			psPathInfo	path information
+ *	Return:
+ *			none
+ *
+ ****************************************************************************/
+static void	SetADC1SourceOnOff
+(
+	const MCDRV_PATH_INFO*	psPathInfo
+)
+{
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncIn("SetADC1SourceOnOff");
+#endif
+
+	(void)psPathInfo;
+
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncOut("SetADC1SourceOnOff", 0);
+#endif
+}
+
+/****************************************************************************
+ *	SetMixSourceOnOff
+ *
+ *	Description:
+ *			Set Mix source On/Off.
+ *	Arguments:
+ *			psPathInfo	path information
+ *	Return:
+ *			none
+ *
+ ****************************************************************************/
+static void	SetMixSourceOnOff
+(
+	const MCDRV_PATH_INFO*	psPathInfo
+)
+{
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncIn("SetMixSourceOnOff");
+#endif
+
+	if(((psPathInfo->asMix[0].abSrcOnOff[MCDRV_SRC_PDM_BLOCK] & (MCDRV_SRC4_PDM_ON|MCDRV_SRC4_PDM_OFF)) == MCDRV_SRC4_PDM_ON)
+	&& (gsGlobalInfo.sInitInfo.bPad0Func == MCDRV_PAD_PDMCK))
+	{
+		gsGlobalInfo.sPathInfo.asMix[0].abSrcOnOff[MCDRV_SRC_PDM_BLOCK]	&= (UINT8)~MCDRV_SRC4_PDM_OFF;
+		gsGlobalInfo.sPathInfo.asMix[0].abSrcOnOff[MCDRV_SRC_PDM_BLOCK]	|= MCDRV_SRC4_PDM_ON;
+	}
+	else if((psPathInfo->asMix[0].abSrcOnOff[MCDRV_SRC_PDM_BLOCK] & (MCDRV_SRC4_PDM_ON|MCDRV_SRC4_PDM_OFF)) == MCDRV_SRC4_PDM_OFF)
+	{
+		gsGlobalInfo.sPathInfo.asMix[0].abSrcOnOff[MCDRV_SRC_PDM_BLOCK]	&= (UINT8)~MCDRV_SRC4_PDM_ON;
+		gsGlobalInfo.sPathInfo.asMix[0].abSrcOnOff[MCDRV_SRC_PDM_BLOCK]	|= MCDRV_SRC4_PDM_OFF;
+	}
+	else
+	{
+	}
+
+	if((psPathInfo->asMix[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK] & (MCDRV_SRC4_ADC0_ON|MCDRV_SRC4_ADC0_OFF)) == MCDRV_SRC4_ADC0_ON)
+	{
+		gsGlobalInfo.sPathInfo.asMix[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK]	&= (UINT8)~MCDRV_SRC4_ADC0_OFF;
+		gsGlobalInfo.sPathInfo.asMix[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK]	|= MCDRV_SRC4_ADC0_ON;
+	}
+	else if((psPathInfo->asMix[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK] & (MCDRV_SRC4_ADC0_ON|MCDRV_SRC4_ADC0_OFF)) == MCDRV_SRC4_ADC0_OFF)
+	{
+		gsGlobalInfo.sPathInfo.asMix[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK]	&= (UINT8)~MCDRV_SRC4_ADC0_ON;
+		gsGlobalInfo.sPathInfo.asMix[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK]	|= MCDRV_SRC4_ADC0_OFF;
+	}
+	else
+	{
+	}
+
+	if((psPathInfo->asMix[0].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK] & (MCDRV_SRC3_DIR0_ON|MCDRV_SRC3_DIR0_OFF)) == MCDRV_SRC3_DIR0_ON)
+	{
+		gsGlobalInfo.sPathInfo.asMix[0].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR0_OFF;
+		gsGlobalInfo.sPathInfo.asMix[0].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK]	|= MCDRV_SRC3_DIR0_ON;
+	}
+	else if((psPathInfo->asMix[0].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK] & (MCDRV_SRC3_DIR0_ON|MCDRV_SRC3_DIR0_OFF)) == MCDRV_SRC3_DIR0_OFF)
+	{
+		gsGlobalInfo.sPathInfo.asMix[0].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR0_ON;
+		gsGlobalInfo.sPathInfo.asMix[0].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK]	|= MCDRV_SRC3_DIR0_OFF;
+	}
+	else
+	{
+	}
+
+	if((psPathInfo->asMix[0].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK] & (MCDRV_SRC3_DIR1_ON|MCDRV_SRC3_DIR1_OFF)) == MCDRV_SRC3_DIR1_ON)
+	{
+		gsGlobalInfo.sPathInfo.asMix[0].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR1_OFF;
+		gsGlobalInfo.sPathInfo.asMix[0].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK]	|= MCDRV_SRC3_DIR1_ON;
+	}
+	else if((psPathInfo->asMix[0].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK] & (MCDRV_SRC3_DIR1_ON|MCDRV_SRC3_DIR1_OFF)) == MCDRV_SRC3_DIR1_OFF)
+	{
+		gsGlobalInfo.sPathInfo.asMix[0].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR1_ON;
+		gsGlobalInfo.sPathInfo.asMix[0].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK]	|= MCDRV_SRC3_DIR1_OFF;
+	}
+	else
+	{
+	}
+
+	if((psPathInfo->asMix[0].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK] & (MCDRV_SRC3_DIR2_ON|MCDRV_SRC3_DIR2_OFF)) == MCDRV_SRC3_DIR2_ON)
+	{
+		gsGlobalInfo.sPathInfo.asMix[0].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR2_OFF;
+		gsGlobalInfo.sPathInfo.asMix[0].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK]	|= MCDRV_SRC3_DIR2_ON;
+	}
+	else if((psPathInfo->asMix[0].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK] & (MCDRV_SRC3_DIR2_ON|MCDRV_SRC3_DIR2_OFF)) == MCDRV_SRC3_DIR2_OFF)
+	{
+		gsGlobalInfo.sPathInfo.asMix[0].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK]	&= (UINT8)~MCDRV_SRC3_DIR2_ON;
+		gsGlobalInfo.sPathInfo.asMix[0].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK]	|= MCDRV_SRC3_DIR2_OFF;
+	}
+	else
+	{
+	}
+
+	if((psPathInfo->asMix[0].abSrcOnOff[MCDRV_SRC_AE_BLOCK] & (MCDRV_SRC6_AE_ON|MCDRV_SRC6_AE_OFF)) == MCDRV_SRC6_AE_ON)
+	{
+		gsGlobalInfo.sPathInfo.asMix[0].abSrcOnOff[MCDRV_SRC_AE_BLOCK]	&= (UINT8)~MCDRV_SRC6_AE_OFF;
+		gsGlobalInfo.sPathInfo.asMix[0].abSrcOnOff[MCDRV_SRC_AE_BLOCK]	|= MCDRV_SRC6_AE_ON;
+	}
+	else if((psPathInfo->asMix[0].abSrcOnOff[MCDRV_SRC_AE_BLOCK] & (MCDRV_SRC6_AE_ON|MCDRV_SRC6_AE_OFF)) == MCDRV_SRC6_AE_OFF)
+	{
+		gsGlobalInfo.sPathInfo.asMix[0].abSrcOnOff[MCDRV_SRC_AE_BLOCK]	&= (UINT8)~MCDRV_SRC6_AE_ON;
+		gsGlobalInfo.sPathInfo.asMix[0].abSrcOnOff[MCDRV_SRC_AE_BLOCK]	|= MCDRV_SRC6_AE_OFF;
+	}
+	else
+	{
+	}
+
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncOut("SetMixSourceOnOff", 0);
+#endif
+}
+
+/****************************************************************************
+ *	SetExtBiasOnOff
+ *
+ *	Description:
+ *			Set Bias source On/Off.
+ *	Arguments:
+ *			psPathInfo	path information
+ *	Return:
+ *			none
+ *
+ ****************************************************************************/
+static void	SetBiasSourceOnOff
+(
+	const MCDRV_PATH_INFO*	psPathInfo
+)
+{
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncIn("SetBiasSourceOnOff");
+#endif
+
+	if((psPathInfo->asBias[0].abSrcOnOff[MCDRV_SRC_MIC1_BLOCK] & (MCDRV_SRC0_MIC1_ON|MCDRV_SRC0_MIC1_OFF)) == MCDRV_SRC0_MIC1_ON)
+	{
+		gsGlobalInfo.sPathInfo.asBias[0].abSrcOnOff[MCDRV_SRC_MIC1_BLOCK]	&= (UINT8)~MCDRV_SRC0_MIC1_OFF;
+		gsGlobalInfo.sPathInfo.asBias[0].abSrcOnOff[MCDRV_SRC_MIC1_BLOCK]	|= MCDRV_SRC0_MIC1_ON;
+	}
+	else if((psPathInfo->asBias[0].abSrcOnOff[MCDRV_SRC_MIC1_BLOCK] & (MCDRV_SRC0_MIC1_ON|MCDRV_SRC0_MIC1_OFF)) == MCDRV_SRC0_MIC1_OFF)
+	{
+		gsGlobalInfo.sPathInfo.asBias[0].abSrcOnOff[MCDRV_SRC_MIC1_BLOCK]	&= (UINT8)~MCDRV_SRC0_MIC1_ON;
+		gsGlobalInfo.sPathInfo.asBias[0].abSrcOnOff[MCDRV_SRC_MIC1_BLOCK]	|= MCDRV_SRC0_MIC1_OFF;
+	}
+	else
+	{
+	}
+
+	if((psPathInfo->asBias[0].abSrcOnOff[MCDRV_SRC_MIC2_BLOCK] & (MCDRV_SRC0_MIC2_ON|MCDRV_SRC0_MIC2_OFF)) == MCDRV_SRC0_MIC2_ON)
+	{
+		gsGlobalInfo.sPathInfo.asBias[0].abSrcOnOff[MCDRV_SRC_MIC2_BLOCK]	&= (UINT8)~MCDRV_SRC0_MIC2_OFF;
+		gsGlobalInfo.sPathInfo.asBias[0].abSrcOnOff[MCDRV_SRC_MIC2_BLOCK]	|= MCDRV_SRC0_MIC2_ON;
+	}
+	else if((psPathInfo->asBias[0].abSrcOnOff[MCDRV_SRC_MIC2_BLOCK] & (MCDRV_SRC0_MIC2_ON|MCDRV_SRC0_MIC2_OFF)) == MCDRV_SRC0_MIC2_OFF)
+	{
+		gsGlobalInfo.sPathInfo.asBias[0].abSrcOnOff[MCDRV_SRC_MIC2_BLOCK]	&= (UINT8)~MCDRV_SRC0_MIC2_ON;
+		gsGlobalInfo.sPathInfo.asBias[0].abSrcOnOff[MCDRV_SRC_MIC2_BLOCK]	|= MCDRV_SRC0_MIC2_OFF;
+	}
+	else
+	{
+	}
+
+	if((psPathInfo->asBias[0].abSrcOnOff[MCDRV_SRC_MIC3_BLOCK] & (MCDRV_SRC0_MIC3_ON|MCDRV_SRC0_MIC3_OFF)) == MCDRV_SRC0_MIC3_ON)
+	{
+		gsGlobalInfo.sPathInfo.asBias[0].abSrcOnOff[MCDRV_SRC_MIC3_BLOCK]	&= (UINT8)~MCDRV_SRC0_MIC3_OFF;
+		gsGlobalInfo.sPathInfo.asBias[0].abSrcOnOff[MCDRV_SRC_MIC3_BLOCK]	|= MCDRV_SRC0_MIC3_ON;
+	}
+	else if((psPathInfo->asBias[0].abSrcOnOff[MCDRV_SRC_MIC3_BLOCK] & (MCDRV_SRC0_MIC3_ON|MCDRV_SRC0_MIC3_OFF)) == MCDRV_SRC0_MIC3_OFF)
+	{
+		gsGlobalInfo.sPathInfo.asBias[0].abSrcOnOff[MCDRV_SRC_MIC3_BLOCK]	&= (UINT8)~MCDRV_SRC0_MIC3_ON;
+		gsGlobalInfo.sPathInfo.asBias[0].abSrcOnOff[MCDRV_SRC_MIC3_BLOCK]	|= MCDRV_SRC0_MIC3_OFF;
+	}
+	else
+	{
+	}
+
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncOut("SetBiasSourceOnOff", 0);
+#endif
+}
+
+/****************************************************************************
+ *	McResCtrl_GetPathInfo
+ *
+ *	Description:
+ *			Get path information.
+ *	Arguments:
+ *			psPathInfo	path information
+ *	Return:
+ *			none
+ *
+ ****************************************************************************/
+void	McResCtrl_GetPathInfo
+(
+	MCDRV_PATH_INFO*	psPathInfo
+)
+{
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncIn("McResCtrl_GetPathInfo");
+#endif
+
+	*psPathInfo	= gsGlobalInfo.sPathInfo;
+
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncOut("McResCtrl_GetPathInfo", 0);
+#endif
+}
+
+/****************************************************************************
+ *	McResCtrl_GetPathInfoVirtual
+ *
+ *	Description:
+ *			Get virtaul path information.
+ *	Arguments:
+ *			psPathInfo	virtaul path information
+ *	Return:
+ *			none
+ *
+ ****************************************************************************/
+void	McResCtrl_GetPathInfoVirtual
+(
+	MCDRV_PATH_INFO*	psPathInfo
+)
+{
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncIn("McResCtrl_GetPathInfoVirtual");
+#endif
+
+	*psPathInfo	= gsGlobalInfo.sPathInfoVirtual;
+
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncOut("McResCtrl_GetPathInfoVirtual", 0);
+#endif
+}
+
+/****************************************************************************
+ *	McResCtrl_SetDioInfo
+ *
+ *	Description:
+ *			Set digital io information.
+ *	Arguments:
+ *			psDioInfo	digital io information
+ *			dUpdateInfo	update information
+ *	Return:
+ *			none
+ *
+ ****************************************************************************/
+void	McResCtrl_SetDioInfo
+(
+	const MCDRV_DIO_INFO*	psDioInfo,
+	UINT32	dUpdateInfo
+)
+{
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncIn("McResCtrl_SetDioInfo");
+#endif
+
+
+	if((dUpdateInfo & MCDRV_DIO0_COM_UPDATE_FLAG) != 0UL)
+	{
+		SetDIOCommon(psDioInfo, 0);
+	}
+	if((dUpdateInfo & MCDRV_DIO1_COM_UPDATE_FLAG) != 0UL)
+	{
+		SetDIOCommon(psDioInfo, 1);
+	}
+	if((dUpdateInfo & MCDRV_DIO2_COM_UPDATE_FLAG) != 0UL)
+	{
+		SetDIOCommon(psDioInfo, 2);
+	}
+
+	if((dUpdateInfo & MCDRV_DIO0_DIR_UPDATE_FLAG) != 0UL)
+	{
+		SetDIODIR(psDioInfo, 0);
+	}
+	if((dUpdateInfo & MCDRV_DIO1_DIR_UPDATE_FLAG) != 0UL)
+	{
+		SetDIODIR(psDioInfo, 1);
+	}
+	if((dUpdateInfo & MCDRV_DIO2_DIR_UPDATE_FLAG) != 0UL)
+	{
+		SetDIODIR(psDioInfo, 2);
+	}
+
+	if((dUpdateInfo & MCDRV_DIO0_DIT_UPDATE_FLAG) != 0UL)
+	{
+		SetDIODIT(psDioInfo, 0);
+	}
+	if((dUpdateInfo & MCDRV_DIO1_DIT_UPDATE_FLAG) != 0UL)
+	{
+		SetDIODIT(psDioInfo, 1);
+	}
+	if((dUpdateInfo & MCDRV_DIO2_DIT_UPDATE_FLAG) != 0UL)
+	{
+		SetDIODIT(psDioInfo, 2);
+	}
+
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncOut("McResCtrl_SetDioInfo", 0);
+#endif
+}
+
+/****************************************************************************
+ *	SetDIOCommon
+ *
+ *	Description:
+ *			Set digital io common information.
+ *	Arguments:
+ *			psDioInfo	digital io information
+ *			bPort		port number
+ *	Return:
+ *			none
+ *
+ ****************************************************************************/
+static void	SetDIOCommon
+(
+	const MCDRV_DIO_INFO*	psDioInfo,
+	UINT8	bPort
+)
+{
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncIn("SetDIOCommon");
+#endif
+
+	if((psDioInfo->asPortInfo[bPort].sDioCommon.bMasterSlave == MCDRV_DIO_SLAVE)
+	|| (psDioInfo->asPortInfo[bPort].sDioCommon.bMasterSlave == MCDRV_DIO_MASTER))
+	{
+		gsGlobalInfo.sDioInfo.asPortInfo[bPort].sDioCommon.bMasterSlave	= psDioInfo->asPortInfo[bPort].sDioCommon.bMasterSlave;
+	}
+	if((psDioInfo->asPortInfo[bPort].sDioCommon.bAutoFs == MCDRV_AUTOFS_OFF)
+	|| (psDioInfo->asPortInfo[bPort].sDioCommon.bAutoFs == MCDRV_AUTOFS_ON))
+	{
+		gsGlobalInfo.sDioInfo.asPortInfo[bPort].sDioCommon.bAutoFs	= psDioInfo->asPortInfo[bPort].sDioCommon.bAutoFs;
+	}
+	if((psDioInfo->asPortInfo[bPort].sDioCommon.bFs == MCDRV_FS_48000)
+	|| (psDioInfo->asPortInfo[bPort].sDioCommon.bFs == MCDRV_FS_44100)
+	|| (psDioInfo->asPortInfo[bPort].sDioCommon.bFs == MCDRV_FS_32000)
+	|| (psDioInfo->asPortInfo[bPort].sDioCommon.bFs == MCDRV_FS_24000)
+	|| (psDioInfo->asPortInfo[bPort].sDioCommon.bFs == MCDRV_FS_22050)
+	|| (psDioInfo->asPortInfo[bPort].sDioCommon.bFs == MCDRV_FS_16000)
+	|| (psDioInfo->asPortInfo[bPort].sDioCommon.bFs == MCDRV_FS_12000)
+	|| (psDioInfo->asPortInfo[bPort].sDioCommon.bFs == MCDRV_FS_11025)
+	|| (psDioInfo->asPortInfo[bPort].sDioCommon.bFs == MCDRV_FS_8000))
+	{
+		gsGlobalInfo.sDioInfo.asPortInfo[bPort].sDioCommon.bFs	= psDioInfo->asPortInfo[bPort].sDioCommon.bFs;
+	}
+	if((psDioInfo->asPortInfo[bPort].sDioCommon.bBckFs == MCDRV_BCKFS_64)
+	|| (psDioInfo->asPortInfo[bPort].sDioCommon.bBckFs == MCDRV_BCKFS_48)
+	|| (psDioInfo->asPortInfo[bPort].sDioCommon.bBckFs == MCDRV_BCKFS_32)
+	|| (psDioInfo->asPortInfo[bPort].sDioCommon.bBckFs == MCDRV_BCKFS_512)
+	|| (psDioInfo->asPortInfo[bPort].sDioCommon.bBckFs == MCDRV_BCKFS_256)
+	|| (psDioInfo->asPortInfo[bPort].sDioCommon.bBckFs == MCDRV_BCKFS_128)
+	|| (psDioInfo->asPortInfo[bPort].sDioCommon.bBckFs == MCDRV_BCKFS_16))
+	{
+		gsGlobalInfo.sDioInfo.asPortInfo[bPort].sDioCommon.bBckFs	= psDioInfo->asPortInfo[bPort].sDioCommon.bBckFs;
+	}
+	if((psDioInfo->asPortInfo[bPort].sDioCommon.bInterface == MCDRV_DIO_DA)
+	|| (psDioInfo->asPortInfo[bPort].sDioCommon.bInterface == MCDRV_DIO_PCM))
+	{
+		gsGlobalInfo.sDioInfo.asPortInfo[bPort].sDioCommon.bInterface	= psDioInfo->asPortInfo[bPort].sDioCommon.bInterface;
+	}
+	if((psDioInfo->asPortInfo[bPort].sDioCommon.bBckInvert == MCDRV_BCLK_NORMAL)
+	|| (psDioInfo->asPortInfo[bPort].sDioCommon.bBckInvert == MCDRV_BCLK_INVERT))
+	{
+		gsGlobalInfo.sDioInfo.asPortInfo[bPort].sDioCommon.bBckInvert	= psDioInfo->asPortInfo[bPort].sDioCommon.bBckInvert;
+	}
+	if(psDioInfo->asPortInfo[bPort].sDioCommon.bInterface == MCDRV_DIO_PCM)
+	{
+		if((psDioInfo->asPortInfo[bPort].sDioCommon.bPcmHizTim == MCDRV_PCMHIZTIM_FALLING)
+		|| (psDioInfo->asPortInfo[bPort].sDioCommon.bPcmHizTim == MCDRV_PCMHIZTIM_RISING))
+		{
+			gsGlobalInfo.sDioInfo.asPortInfo[bPort].sDioCommon.bPcmHizTim	= psDioInfo->asPortInfo[bPort].sDioCommon.bPcmHizTim;
+		}
+		if((psDioInfo->asPortInfo[bPort].sDioCommon.bPcmClkDown == MCDRV_PCM_CLKDOWN_OFF)
+		|| (psDioInfo->asPortInfo[bPort].sDioCommon.bPcmClkDown == MCDRV_PCM_CLKDOWN_HALF))
+		{
+			gsGlobalInfo.sDioInfo.asPortInfo[bPort].sDioCommon.bPcmClkDown	= psDioInfo->asPortInfo[bPort].sDioCommon.bPcmClkDown;
+		}
+		if((psDioInfo->asPortInfo[bPort].sDioCommon.bPcmFrame == MCDRV_PCM_SHORTFRAME)
+		|| (psDioInfo->asPortInfo[bPort].sDioCommon.bPcmFrame == MCDRV_PCM_LONGFRAME))
+		{
+			gsGlobalInfo.sDioInfo.asPortInfo[bPort].sDioCommon.bPcmFrame	= psDioInfo->asPortInfo[bPort].sDioCommon.bPcmFrame;
+		}
+		if(psDioInfo->asPortInfo[bPort].sDioCommon.bPcmHighPeriod <= 31)
+		{
+			gsGlobalInfo.sDioInfo.asPortInfo[bPort].sDioCommon.bPcmHighPeriod	= psDioInfo->asPortInfo[bPort].sDioCommon.bPcmHighPeriod;
+		}
+	}
+
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncOut("SetDIOCommon", 0);
+#endif
+}
+
+/****************************************************************************
+ *	SetDIODIR
+ *
+ *	Description:
+ *			Set digital io dir information.
+ *	Arguments:
+ *			psDioInfo	digital io information
+ *			bPort		port number
+ *	Return:
+ *			none
+ *
+ ****************************************************************************/
+static void	SetDIODIR
+(
+	const MCDRV_DIO_INFO*	psDioInfo,
+	UINT8	bPort
+)
+{
+	UINT8	bDIOCh;
+
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncIn("SetDIODIR");
+#endif
+
+	gsGlobalInfo.sDioInfo.asPortInfo[bPort].sDir.wSrcRate	= psDioInfo->asPortInfo[bPort].sDir.wSrcRate;
+	if(gsGlobalInfo.sDioInfo.asPortInfo[bPort].sDioCommon.bInterface == MCDRV_DIO_DA)
+	{
+		if((psDioInfo->asPortInfo[bPort].sDir.sDaFormat.bBitSel == MCDRV_BITSEL_16)
+		|| (psDioInfo->asPortInfo[bPort].sDir.sDaFormat.bBitSel == MCDRV_BITSEL_20)
+		|| (psDioInfo->asPortInfo[bPort].sDir.sDaFormat.bBitSel == MCDRV_BITSEL_24))
+		{
+			gsGlobalInfo.sDioInfo.asPortInfo[bPort].sDir.sDaFormat.bBitSel	= psDioInfo->asPortInfo[bPort].sDir.sDaFormat.bBitSel;
+		}
+		if((psDioInfo->asPortInfo[bPort].sDir.sDaFormat.bMode == MCDRV_DAMODE_HEADALIGN)
+		|| (psDioInfo->asPortInfo[bPort].sDir.sDaFormat.bMode == MCDRV_DAMODE_I2S)
+		|| (psDioInfo->asPortInfo[bPort].sDir.sDaFormat.bMode == MCDRV_DAMODE_TAILALIGN))
+		{
+			gsGlobalInfo.sDioInfo.asPortInfo[bPort].sDir.sDaFormat.bMode	= psDioInfo->asPortInfo[bPort].sDir.sDaFormat.bMode;
+		}
+	}
+	else if(gsGlobalInfo.sDioInfo.asPortInfo[bPort].sDioCommon.bInterface == MCDRV_DIO_PCM)
+	{
+		if((psDioInfo->asPortInfo[bPort].sDir.sPcmFormat.bMono == MCDRV_PCM_STEREO)
+		|| (psDioInfo->asPortInfo[bPort].sDir.sPcmFormat.bMono == MCDRV_PCM_MONO))
+		{
+			gsGlobalInfo.sDioInfo.asPortInfo[bPort].sDir.sPcmFormat.bMono	= psDioInfo->asPortInfo[bPort].sDir.sPcmFormat.bMono;
+		}
+		if((psDioInfo->asPortInfo[bPort].sDir.sPcmFormat.bOrder == MCDRV_PCM_MSB_FIRST)
+		|| (psDioInfo->asPortInfo[bPort].sDir.sPcmFormat.bOrder == MCDRV_PCM_LSB_FIRST)
+		|| (psDioInfo->asPortInfo[bPort].sDir.sPcmFormat.bOrder == MCDRV_PCM_MSB_FIRST_SIGN)
+		|| (psDioInfo->asPortInfo[bPort].sDir.sPcmFormat.bOrder == MCDRV_PCM_LSB_FIRST_SIGN)
+		|| (psDioInfo->asPortInfo[bPort].sDir.sPcmFormat.bOrder == MCDRV_PCM_MSB_FIRST_ZERO)
+		|| (psDioInfo->asPortInfo[bPort].sDir.sPcmFormat.bOrder == MCDRV_PCM_LSB_FIRST_ZERO))
+		{
+			gsGlobalInfo.sDioInfo.asPortInfo[bPort].sDir.sPcmFormat.bOrder	= psDioInfo->asPortInfo[bPort].sDir.sPcmFormat.bOrder;
+		}
+		if((psDioInfo->asPortInfo[bPort].sDir.sPcmFormat.bLaw == MCDRV_PCM_LINEAR)
+		|| (psDioInfo->asPortInfo[bPort].sDir.sPcmFormat.bLaw == MCDRV_PCM_ALAW)
+		|| (psDioInfo->asPortInfo[bPort].sDir.sPcmFormat.bLaw == MCDRV_PCM_MULAW))
+		{
+			gsGlobalInfo.sDioInfo.asPortInfo[bPort].sDir.sPcmFormat.bLaw	= psDioInfo->asPortInfo[bPort].sDir.sPcmFormat.bLaw;
+		}
+		if((psDioInfo->asPortInfo[bPort].sDir.sPcmFormat.bBitSel == MCDRV_PCM_BITSEL_8)
+		|| (psDioInfo->asPortInfo[bPort].sDir.sPcmFormat.bBitSel == MCDRV_PCM_BITSEL_13)
+		|| (psDioInfo->asPortInfo[bPort].sDir.sPcmFormat.bBitSel == MCDRV_PCM_BITSEL_14)
+		|| (psDioInfo->asPortInfo[bPort].sDir.sPcmFormat.bBitSel == MCDRV_PCM_BITSEL_16))
+		{
+			gsGlobalInfo.sDioInfo.asPortInfo[bPort].sDir.sPcmFormat.bBitSel	= psDioInfo->asPortInfo[bPort].sDir.sPcmFormat.bBitSel;
+		}
+	}
+	else
+	{
+	}
+
+	for(bDIOCh = 0; bDIOCh < DIO_CHANNELS; bDIOCh++)
+	{
+		if(psDioInfo->asPortInfo[bPort].sDir.abSlot[bDIOCh] < 2)
+		{
+			gsGlobalInfo.sDioInfo.asPortInfo[bPort].sDir.abSlot[bDIOCh]	= psDioInfo->asPortInfo[bPort].sDir.abSlot[bDIOCh];
+		}
+	}
+
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncOut("SetDIODIR", 0);
+#endif
+}
+
+/****************************************************************************
+ *	SetDIODIT
+ *
+ *	Description:
+ *			Set digital io dit information.
+ *	Arguments:
+ *			psDioInfo	digital io information
+ *			bPort		port number
+ *	Return:
+ *			none
+ *
+ ****************************************************************************/
+static void	SetDIODIT
+(
+	const MCDRV_DIO_INFO*	psDioInfo,
+	UINT8	bPort
+)
+{
+	UINT8	bDIOCh;
+
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncIn("SetDIODIT");
+#endif
+
+	gsGlobalInfo.sDioInfo.asPortInfo[bPort].sDit.wSrcRate	= psDioInfo->asPortInfo[bPort].sDit.wSrcRate;
+	if(gsGlobalInfo.sDioInfo.asPortInfo[bPort].sDioCommon.bInterface == MCDRV_DIO_DA)
+	{
+		if((psDioInfo->asPortInfo[bPort].sDit.sDaFormat.bBitSel == MCDRV_BITSEL_16)
+		|| (psDioInfo->asPortInfo[bPort].sDit.sDaFormat.bBitSel == MCDRV_BITSEL_20)
+		|| (psDioInfo->asPortInfo[bPort].sDit.sDaFormat.bBitSel == MCDRV_BITSEL_24))
+		{
+			gsGlobalInfo.sDioInfo.asPortInfo[bPort].sDit.sDaFormat.bBitSel	= psDioInfo->asPortInfo[bPort].sDit.sDaFormat.bBitSel;
+		}
+		if((psDioInfo->asPortInfo[bPort].sDit.sDaFormat.bMode == MCDRV_DAMODE_HEADALIGN)
+		|| (psDioInfo->asPortInfo[bPort].sDit.sDaFormat.bMode == MCDRV_DAMODE_I2S)
+		|| (psDioInfo->asPortInfo[bPort].sDit.sDaFormat.bMode == MCDRV_DAMODE_TAILALIGN))
+		{
+			gsGlobalInfo.sDioInfo.asPortInfo[bPort].sDit.sDaFormat.bMode	= psDioInfo->asPortInfo[bPort].sDit.sDaFormat.bMode;
+		}
+	}
+	else if(gsGlobalInfo.sDioInfo.asPortInfo[bPort].sDioCommon.bInterface == MCDRV_DIO_PCM)
+	{
+		if((psDioInfo->asPortInfo[bPort].sDit.sPcmFormat.bMono == MCDRV_PCM_STEREO)
+		|| (psDioInfo->asPortInfo[bPort].sDit.sPcmFormat.bMono == MCDRV_PCM_MONO))
+		{
+			gsGlobalInfo.sDioInfo.asPortInfo[bPort].sDit.sPcmFormat.bMono	= psDioInfo->asPortInfo[bPort].sDit.sPcmFormat.bMono;
+		}
+		if((psDioInfo->asPortInfo[bPort].sDit.sPcmFormat.bOrder == MCDRV_PCM_MSB_FIRST)
+		|| (psDioInfo->asPortInfo[bPort].sDit.sPcmFormat.bOrder == MCDRV_PCM_LSB_FIRST)
+		|| (psDioInfo->asPortInfo[bPort].sDit.sPcmFormat.bOrder == MCDRV_PCM_MSB_FIRST_SIGN)
+		|| (psDioInfo->asPortInfo[bPort].sDit.sPcmFormat.bOrder == MCDRV_PCM_LSB_FIRST_SIGN)
+		|| (psDioInfo->asPortInfo[bPort].sDit.sPcmFormat.bOrder == MCDRV_PCM_MSB_FIRST_ZERO)
+		|| (psDioInfo->asPortInfo[bPort].sDit.sPcmFormat.bOrder == MCDRV_PCM_LSB_FIRST_ZERO))
+		{
+			gsGlobalInfo.sDioInfo.asPortInfo[bPort].sDit.sPcmFormat.bOrder	= psDioInfo->asPortInfo[bPort].sDit.sPcmFormat.bOrder;
+		}
+		if((psDioInfo->asPortInfo[bPort].sDit.sPcmFormat.bLaw == MCDRV_PCM_LINEAR)
+		|| (psDioInfo->asPortInfo[bPort].sDit.sPcmFormat.bLaw == MCDRV_PCM_ALAW)
+		|| (psDioInfo->asPortInfo[bPort].sDit.sPcmFormat.bLaw == MCDRV_PCM_MULAW))
+		{
+			gsGlobalInfo.sDioInfo.asPortInfo[bPort].sDit.sPcmFormat.bLaw	= psDioInfo->asPortInfo[bPort].sDit.sPcmFormat.bLaw;
+		}
+		if((psDioInfo->asPortInfo[bPort].sDit.sPcmFormat.bBitSel == MCDRV_PCM_BITSEL_8)
+		|| (psDioInfo->asPortInfo[bPort].sDit.sPcmFormat.bBitSel == MCDRV_PCM_BITSEL_13)
+		|| (psDioInfo->asPortInfo[bPort].sDit.sPcmFormat.bBitSel == MCDRV_PCM_BITSEL_14)
+		|| (psDioInfo->asPortInfo[bPort].sDit.sPcmFormat.bBitSel == MCDRV_PCM_BITSEL_16))
+		{
+			gsGlobalInfo.sDioInfo.asPortInfo[bPort].sDit.sPcmFormat.bBitSel	= psDioInfo->asPortInfo[bPort].sDit.sPcmFormat.bBitSel;
+		}
+	}
+	else
+	{
+	}
+
+	for(bDIOCh = 0; bDIOCh < DIO_CHANNELS; bDIOCh++)
+	{
+		if(psDioInfo->asPortInfo[bPort].sDit.abSlot[bDIOCh] < 2)
+		{
+			gsGlobalInfo.sDioInfo.asPortInfo[bPort].sDit.abSlot[bDIOCh]	= psDioInfo->asPortInfo[bPort].sDit.abSlot[bDIOCh];
+		}
+	}
+
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncOut("SetDIODIT", 0);
+#endif
+}
+
+/****************************************************************************
+ *	McResCtrl_GetDioInfo
+ *
+ *	Description:
+ *			Get digital io information.
+ *	Arguments:
+ *			psDioInfo	digital io information
+ *	Return:
+ *			none
+ *
+ ****************************************************************************/
+void	McResCtrl_GetDioInfo
+(
+	MCDRV_DIO_INFO*	psDioInfo
+)
+{
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncIn("McResCtrl_GetDioInfo");
+#endif
+
+	*psDioInfo	= gsGlobalInfo.sDioInfo;
+
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncOut("McResCtrl_GetDioInfo", 0);
+#endif
+}
+
+/****************************************************************************
+ *	McResCtrl_SetVolInfo
+ *
+ *	Description:
+ *			Update volume.
+ *	Arguments:
+ *			psVolInfo		volume setting
+ *	Return:
+ *			none
+ *
+ ****************************************************************************/
+void	McResCtrl_SetVolInfo
+(
+	const MCDRV_VOL_INFO*	psVolInfo
+)
+{
+	UINT8	bCh;
+
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncIn("McResCtrl_SetVolInfo");
+#endif
+
+
+	for(bCh = 0; bCh < AD0_VOL_CHANNELS; bCh++)
+	{
+		if(((UINT16)psVolInfo->aswD_Ad0[bCh] & 0x01) != 0)
+		{
+			gsGlobalInfo.sVolInfo.aswD_Ad0[bCh]	= (SINT16)((UINT16)psVolInfo->aswD_Ad0[bCh] & 0xFFFE);
+		}
+		if(((UINT16)psVolInfo->aswD_Ad0Att[bCh] & 0x01) != 0)
+		{
+			gsGlobalInfo.sVolInfo.aswD_Ad0Att[bCh]	= (SINT16)((UINT16)psVolInfo->aswD_Ad0Att[bCh] & 0xFFFE);
+		}
+		if(((UINT16)psVolInfo->aswA_Ad0[bCh] & 0x01) != 0)
+		{
+			gsGlobalInfo.sVolInfo.aswA_Ad0[bCh]	= (SINT16)((UINT16)psVolInfo->aswA_Ad0[bCh] & 0xFFFE);
+		}
+	}
+	for(bCh = 0; bCh < AD1_VOL_CHANNELS; bCh++)
+	{
+		if(((UINT16)psVolInfo->aswD_Ad1[bCh] & 0x01) != 0)
+		{
+			gsGlobalInfo.sVolInfo.aswD_Ad1[bCh]	= (SINT16)((UINT16)psVolInfo->aswD_Ad1[bCh] & 0xFFFE);
+		}
+		if(((UINT16)psVolInfo->aswD_Ad1Att[bCh] & 0x01) != 0)
+		{
+			gsGlobalInfo.sVolInfo.aswD_Ad1Att[bCh]	= (SINT16)((UINT16)psVolInfo->aswD_Ad1Att[bCh] & 0xFFFE);
+		}
+		if(((UINT16)psVolInfo->aswA_Ad1[bCh] & 0x01) != 0)
+		{
+			gsGlobalInfo.sVolInfo.aswA_Ad1[bCh]	= (SINT16)((UINT16)psVolInfo->aswA_Ad1[bCh] & 0xFFFE);
+		}
+	}
+
+	for(bCh = 0; bCh < AENG6_VOL_CHANNELS; bCh++)
+	{
+		if(((UINT16)psVolInfo->aswD_Aeng6[bCh] & 0x01) != 0)
+		{
+			gsGlobalInfo.sVolInfo.aswD_Aeng6[bCh]	= (SINT16)((UINT16)psVolInfo->aswD_Aeng6[bCh] & 0xFFFE);
+		}
+	}
+
+	for(bCh = 0; bCh < PDM_VOL_CHANNELS; bCh++)
+	{
+		if(((UINT16)psVolInfo->aswD_Pdm[bCh] & 0x01) != 0)
+		{
+			gsGlobalInfo.sVolInfo.aswD_Pdm[bCh]	= (SINT16)((UINT16)psVolInfo->aswD_Pdm[bCh] & 0xFFFE);
+		}
+		if(((UINT16)psVolInfo->aswD_SideTone[bCh] & 0x01) != 0)
+		{
+			gsGlobalInfo.sVolInfo.aswD_SideTone[bCh]	= (SINT16)((UINT16)psVolInfo->aswD_SideTone[bCh] & 0xFFFE);
+		}
+	}
+
+	for(bCh = 0; bCh < DTMF_VOL_CHANNELS; bCh++)
+	{
+		if(((UINT16)psVolInfo->aswD_Dtmfb[bCh] & 0x01) != 0)
+		{
+			gsGlobalInfo.sVolInfo.aswD_Dtmfb[bCh]	= (SINT16)((UINT16)psVolInfo->aswD_Dtmfb[bCh] & 0xFFFE);
+		}
+		if(((UINT16)psVolInfo->aswD_DtmfAtt[bCh] & 0x01) != 0)
+		{
+			gsGlobalInfo.sVolInfo.aswD_DtmfAtt[bCh]	= (SINT16)((UINT16)psVolInfo->aswD_DtmfAtt[bCh] & 0xFFFE);
+		}
+	}
+
+	for(bCh = 0; bCh < DIO0_VOL_CHANNELS; bCh++)
+	{
+		if(((UINT16)psVolInfo->aswD_Dir0[bCh] & 0x01) != 0)
+		{
+			gsGlobalInfo.sVolInfo.aswD_Dir0[bCh]	= (SINT16)((UINT16)psVolInfo->aswD_Dir0[bCh] & 0xFFFE);
+		}
+		if(((UINT16)psVolInfo->aswD_Dir0Att[bCh] & 0x01) != 0)
+		{
+			gsGlobalInfo.sVolInfo.aswD_Dir0Att[bCh]	= (SINT16)((UINT16)psVolInfo->aswD_Dir0Att[bCh] & 0xFFFE);
+		}
+		if(((UINT16)psVolInfo->aswD_Dit0[bCh] & 0x01) != 0)
+		{
+			gsGlobalInfo.sVolInfo.aswD_Dit0[bCh]	= (SINT16)((UINT16)psVolInfo->aswD_Dit0[bCh] & 0xFFFE);
+		}
+	}
+
+	for(bCh = 0; bCh < DIO1_VOL_CHANNELS; bCh++)
+	{
+		if(((UINT16)psVolInfo->aswD_Dir1[bCh] & 0x01) != 0)
+		{
+			gsGlobalInfo.sVolInfo.aswD_Dir1[bCh]	= (SINT16)((UINT16)psVolInfo->aswD_Dir1[bCh] & 0xFFFE);
+		}
+		if(((UINT16)psVolInfo->aswD_Dir1Att[bCh] & 0x01) != 0)
+		{
+			gsGlobalInfo.sVolInfo.aswD_Dir1Att[bCh]	= (SINT16)((UINT16)psVolInfo->aswD_Dir1Att[bCh] & 0xFFFE);
+		}
+		if(((UINT16)psVolInfo->aswD_Dit1[bCh] & 0x01) != 0)
+		{
+			gsGlobalInfo.sVolInfo.aswD_Dit1[bCh]	= (SINT16)((UINT16)psVolInfo->aswD_Dit1[bCh] & 0xFFFE);
+		}
+	}
+
+	for(bCh = 0; bCh < DIO2_VOL_CHANNELS; bCh++)
+	{
+		if(((UINT16)psVolInfo->aswD_Dir2[bCh] & 0x01) != 0)
+		{
+			gsGlobalInfo.sVolInfo.aswD_Dir2[bCh]	= (SINT16)((UINT16)psVolInfo->aswD_Dir2[bCh] & 0xFFFE);
+		}
+		if(((UINT16)psVolInfo->aswD_Dir2Att[bCh] & 0x01) != 0)
+		{
+			gsGlobalInfo.sVolInfo.aswD_Dir2Att[bCh]	= (SINT16)((UINT16)psVolInfo->aswD_Dir2Att[bCh] & 0xFFFE);
+		}
+		if(((UINT16)psVolInfo->aswD_Dit2[bCh] & 0x01) != 0)
+		{
+			gsGlobalInfo.sVolInfo.aswD_Dit2[bCh]	= (SINT16)((UINT16)psVolInfo->aswD_Dit2[bCh] & 0xFFFE);
+		}
+	}
+
+	for(bCh = 0; bCh < DAC_VOL_CHANNELS; bCh++)
+	{
+		if(((UINT16)psVolInfo->aswD_DacMaster[bCh] & 0x01) != 0)
+		{
+			gsGlobalInfo.sVolInfo.aswD_DacMaster[bCh]	= (SINT16)((UINT16)psVolInfo->aswD_DacMaster[bCh] & 0xFFFE);
+		}
+		if(((UINT16)psVolInfo->aswD_DacVoice[bCh] & 0x01) != 0)
+		{
+			gsGlobalInfo.sVolInfo.aswD_DacVoice[bCh]	= (SINT16)((UINT16)psVolInfo->aswD_DacVoice[bCh] & 0xFFFE);
+		}
+		if(((UINT16)psVolInfo->aswD_DacAtt[bCh] & 0x01) != 0)
+		{
+			gsGlobalInfo.sVolInfo.aswD_DacAtt[bCh]	= (SINT16)((UINT16)psVolInfo->aswD_DacAtt[bCh] & 0xFFFE);
+		}
+	}
+
+	for(bCh = 0; bCh < LIN1_VOL_CHANNELS; bCh++)
+	{
+		if(((UINT16)psVolInfo->aswA_Lin1[bCh] & 0x01) != 0)
+		{
+			gsGlobalInfo.sVolInfo.aswA_Lin1[bCh]	= (SINT16)((UINT16)psVolInfo->aswA_Lin1[bCh] & 0xFFFE);
+		}
+	}
+
+	for(bCh = 0; bCh < LIN2_VOL_CHANNELS; bCh++)
+	{
+		if(((UINT16)psVolInfo->aswA_Lin2[bCh] & 0x01) != 0)
+		{
+			gsGlobalInfo.sVolInfo.aswA_Lin2[bCh]	= (SINT16)((UINT16)psVolInfo->aswA_Lin2[bCh] & 0xFFFE);
+		}
+	}
+
+	for(bCh = 0; bCh < MIC1_VOL_CHANNELS; bCh++)
+	{
+		if(((UINT16)psVolInfo->aswA_Mic1[bCh] & 0x01) != 0)
+		{
+			gsGlobalInfo.sVolInfo.aswA_Mic1[bCh]	= (SINT16)((UINT16)psVolInfo->aswA_Mic1[bCh] & 0xFFFE);
+		}
+	}
+
+	for(bCh = 0; bCh < MIC2_VOL_CHANNELS; bCh++)
+	{
+		if(((UINT16)psVolInfo->aswA_Mic2[bCh] & 0x01) != 0)
+		{
+			gsGlobalInfo.sVolInfo.aswA_Mic2[bCh]	= (SINT16)((UINT16)psVolInfo->aswA_Mic2[bCh] & 0xFFFE);
+		}
+	}
+
+	for(bCh = 0; bCh < MIC3_VOL_CHANNELS; bCh++)
+	{
+		if(((UINT16)psVolInfo->aswA_Mic3[bCh] & 0x01) != 0)
+		{
+			gsGlobalInfo.sVolInfo.aswA_Mic3[bCh]	= (SINT16)((UINT16)psVolInfo->aswA_Mic3[bCh] & 0xFFFE);
+		}
+	}
+
+	for(bCh = 0; bCh < HP_VOL_CHANNELS; bCh++)
+	{
+		if(((UINT16)psVolInfo->aswA_Hp[bCh] & 0x01) != 0)
+		{
+			gsGlobalInfo.sVolInfo.aswA_Hp[bCh]	= (SINT16)((UINT16)psVolInfo->aswA_Hp[bCh] & 0xFFFE);
+		}
+	}
+
+	for(bCh = 0; bCh < SP_VOL_CHANNELS; bCh++)
+	{
+		if(((UINT16)psVolInfo->aswA_Sp[bCh] & 0x01) != 0)
+		{
+			gsGlobalInfo.sVolInfo.aswA_Sp[bCh]	= (SINT16)((UINT16)psVolInfo->aswA_Sp[bCh] & 0xFFFE);
+		}
+	}
+
+	for(bCh = 0; bCh < RC_VOL_CHANNELS; bCh++)
+	{
+		if(((UINT16)psVolInfo->aswA_Rc[bCh] & 0x01) != 0)
+		{
+			gsGlobalInfo.sVolInfo.aswA_Rc[bCh]	= (SINT16)((UINT16)psVolInfo->aswA_Rc[bCh] & 0xFFFE);
+		}
+	}
+
+	for(bCh = 0; bCh < LOUT1_VOL_CHANNELS; bCh++)
+	{
+		if(((UINT16)psVolInfo->aswA_Lout1[bCh] & 0x01) != 0)
+		{
+			gsGlobalInfo.sVolInfo.aswA_Lout1[bCh]	= (SINT16)((UINT16)psVolInfo->aswA_Lout1[bCh] & 0xFFFE);
+		}
+	}
+
+	for(bCh = 0; bCh < LOUT2_VOL_CHANNELS; bCh++)
+	{
+		if(((UINT16)psVolInfo->aswA_Lout2[bCh] & 0x01) != 0)
+		{
+			gsGlobalInfo.sVolInfo.aswA_Lout2[bCh]	= (SINT16)((UINT16)psVolInfo->aswA_Lout2[bCh] & 0xFFFE);
+		}
+	}
+
+	for(bCh = 0; bCh < MIC1_VOL_CHANNELS; bCh++)
+	{
+		if(((UINT16)psVolInfo->aswA_Mic1Gain[bCh] & 0x01) != 0)
+		{
+			gsGlobalInfo.sVolInfo.aswA_Mic1Gain[bCh]	= (SINT16)((UINT16)psVolInfo->aswA_Mic1Gain[bCh] & 0xFFFE);
+		}
+	}
+
+	for(bCh = 0; bCh < MIC2_VOL_CHANNELS; bCh++)
+	{
+		if(((UINT16)psVolInfo->aswA_Mic2Gain[bCh] & 0x01) != 0)
+		{
+			gsGlobalInfo.sVolInfo.aswA_Mic2Gain[bCh]	= (SINT16)((UINT16)psVolInfo->aswA_Mic2Gain[bCh] & 0xFFFE);
+		}
+	}
+
+	for(bCh = 0; bCh < MIC3_VOL_CHANNELS; bCh++)
+	{
+		if(((UINT16)psVolInfo->aswA_Mic3Gain[bCh] & 0x01) != 0)
+		{
+			gsGlobalInfo.sVolInfo.aswA_Mic3Gain[bCh]	= (SINT16)((UINT16)psVolInfo->aswA_Mic3Gain[bCh] & 0xFFFE);
+		}
+	}
+
+	for(bCh = 0; bCh < HPGAIN_VOL_CHANNELS; bCh++)
+	{
+		if(((UINT16)psVolInfo->aswA_HpGain[bCh] & 0x01) != 0)
+		{
+			gsGlobalInfo.sVolInfo.aswA_HpGain[bCh]	= (SINT16)((UINT16)psVolInfo->aswA_HpGain[bCh] & 0xFFFE);
+		}
+	}
+
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncOut("McResCtrl_SetVolInfo", 0);
+#endif
+}
+
+/****************************************************************************
+ *	McResCtrl_GetVolInfo
+ *
+ *	Description:
+ *			Get volume setting.
+ *	Arguments:
+ *			psVolInfo		volume setting
+ *	Return:
+ *			none
+ *
+ ****************************************************************************/
+void	McResCtrl_GetVolInfo
+(
+	MCDRV_VOL_INFO*	psVolInfo
+)
+{
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncIn("McResCtrl_GetVolInfo");
+#endif
+
+	*psVolInfo	= gsGlobalInfo.sVolInfo;
+
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncOut("McResCtrl_GetVolInfo", 0);
+#endif
+}
+
+/****************************************************************************
+ *	McResCtrl_SetDacInfo
+ *
+ *	Description:
+ *			Set DAC information.
+ *	Arguments:
+ *			psDacInfo	DAC information
+ *			dUpdateInfo	update information
+ *	Return:
+ *			none
+ *
+ ****************************************************************************/
+void	McResCtrl_SetDacInfo
+(
+	const MCDRV_DAC_INFO*	psDacInfo,
+	UINT32	dUpdateInfo
+)
+{
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncIn("McResCtrl_SetDacInfo");
+#endif
+
+
+	if((dUpdateInfo & MCDRV_DAC_MSWP_UPDATE_FLAG) != 0UL)
+	{
+		switch(psDacInfo->bMasterSwap)
+		{
+		case	MCDRV_DSWAP_OFF:
+		case	MCDRV_DSWAP_SWAP:
+		case	MCDRV_DSWAP_MUTE:
+		case	MCDRV_DSWAP_RMVCENTER:
+		case	MCDRV_DSWAP_MONO:
+		case	MCDRV_DSWAP_MONOHALF:
+		case	MCDRV_DSWAP_BOTHL:
+		case	MCDRV_DSWAP_BOTHR:
+			gsGlobalInfo.sDacInfo.bMasterSwap	= psDacInfo->bMasterSwap;
+			break;
+		default:
+			break;
+		}
+	}
+	if((dUpdateInfo & MCDRV_DAC_VSWP_UPDATE_FLAG) != 0UL)
+	{
+		switch(psDacInfo->bVoiceSwap)
+		{
+		case	MCDRV_DSWAP_OFF:
+		case	MCDRV_DSWAP_SWAP:
+		case	MCDRV_DSWAP_MUTE:
+		case	MCDRV_DSWAP_RMVCENTER:
+		case	MCDRV_DSWAP_MONO:
+		case	MCDRV_DSWAP_MONOHALF:
+		case	MCDRV_DSWAP_BOTHL:
+		case	MCDRV_DSWAP_BOTHR:
+			gsGlobalInfo.sDacInfo.bVoiceSwap	= psDacInfo->bVoiceSwap;
+			break;
+		default:
+			break;
+		}
+	}
+	if((dUpdateInfo & MCDRV_DAC_HPF_UPDATE_FLAG) != 0UL)
+	{
+		if((psDacInfo->bDcCut == MCDRV_DCCUT_ON) || (psDacInfo->bDcCut == MCDRV_DCCUT_OFF))
+		{
+			gsGlobalInfo.sDacInfo.bDcCut	= psDacInfo->bDcCut;
+		}
+	}
+
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncOut("McResCtrl_SetDacInfo", 0);
+#endif
+}
+
+/****************************************************************************
+ *	McResCtrl_GetDacInfo
+ *
+ *	Description:
+ *			Get DAC information.
+ *	Arguments:
+ *			psDacInfo	DAC information
+ *	Return:
+ *			none
+ *
+ ****************************************************************************/
+void	McResCtrl_GetDacInfo
+(
+	MCDRV_DAC_INFO*	psDacInfo
+)
+{
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncIn("McResCtrl_GetDacInfo");
+#endif
+
+	*psDacInfo	= gsGlobalInfo.sDacInfo;
+
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncOut("McResCtrl_GetDacInfo", 0);
+#endif
+}
+
+/****************************************************************************
+ *	McResCtrl_SetAdcInfo
+ *
+ *	Description:
+ *			Set ADC information.
+ *	Arguments:
+ *			psAdcInfo	ADC information
+ *			dUpdateInfo	update information
+ *	Return:
+ *			none
+ *
+ ****************************************************************************/
+void	McResCtrl_SetAdcInfo
+(
+	const MCDRV_ADC_INFO*	psAdcInfo,
+	UINT32	dUpdateInfo
+)
+{
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncIn("McResCtrl_SetAdcInfo");
+#endif
+
+
+	if((dUpdateInfo & MCDRV_ADCADJ_UPDATE_FLAG) != 0UL)
+	{
+		switch(psAdcInfo->bAgcAdjust)
+		{
+		case	MCDRV_AGCADJ_24:
+		case	MCDRV_AGCADJ_18:
+		case	MCDRV_AGCADJ_12:
+		case	MCDRV_AGCADJ_0:
+			gsGlobalInfo.sAdcInfo.bAgcAdjust	= psAdcInfo->bAgcAdjust;
+			break;
+		default:
+			break;
+		}
+	}
+	if((dUpdateInfo & MCDRV_ADCAGC_UPDATE_FLAG) != 0UL)
+	{
+		if((psAdcInfo->bAgcOn == MCDRV_AGC_OFF) || (psAdcInfo->bAgcOn == MCDRV_AGC_ON))
+		{
+			gsGlobalInfo.sAdcInfo.bAgcOn	= psAdcInfo->bAgcOn;
+		}
+	}
+	if((dUpdateInfo & MCDRV_ADCMONO_UPDATE_FLAG) != 0UL)
+	{
+		if((psAdcInfo->bMono == MCDRV_ADC_STEREO) || (psAdcInfo->bMono == MCDRV_ADC_MONO))
+		{
+			gsGlobalInfo.sAdcInfo.bMono	= psAdcInfo->bMono;
+		}
+	}
+
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncOut("McResCtrl_SetAdcInfo", 0);
+#endif
+}
+
+/****************************************************************************
+ *	McResCtrl_GetAdcInfo
+ *
+ *	Description:
+ *			Get ADC information.
+ *	Arguments:
+ *			psAdcInfo	ADC information
+ *	Return:
+ *			none
+ *
+ ****************************************************************************/
+void	McResCtrl_GetAdcInfo
+(
+	MCDRV_ADC_INFO*	psAdcInfo
+)
+{
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncIn("McResCtrl_GetAdcInfo");
+#endif
+
+	*psAdcInfo	= gsGlobalInfo.sAdcInfo;
+
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncOut("McResCtrl_GetAdcInfo", 0);
+#endif
+}
+
+/****************************************************************************
+ *	McResCtrl_SetSpInfo
+ *
+ *	Description:
+ *			Set SP information.
+ *	Arguments:
+ *			psSpInfo	SP information
+ *	Return:
+ *			none
+ *
+ ****************************************************************************/
+void	McResCtrl_SetSpInfo
+(
+	const MCDRV_SP_INFO*	psSpInfo
+)
+{
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncIn("McResCtrl_SetSpInfo");
+#endif
+
+
+	if((psSpInfo->bSwap == MCDRV_SPSWAP_OFF) || (psSpInfo->bSwap == MCDRV_SPSWAP_SWAP))
+	{
+		gsGlobalInfo.sSpInfo.bSwap	= psSpInfo->bSwap;
+	}
+
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncOut("McResCtrl_SetSpInfo", 0);
+#endif
+}
+
+/****************************************************************************
+ *	McResCtrl_GetSpInfo
+ *
+ *	Description:
+ *			Get SP information.
+ *	Arguments:
+ *			psSpInfo	SP information
+ *	Return:
+ *			none
+ *
+ ****************************************************************************/
+void	McResCtrl_GetSpInfo
+(
+	MCDRV_SP_INFO*	psSpInfo
+)
+{
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncIn("McResCtrl_GetSpInfo");
+#endif
+
+	*psSpInfo	= gsGlobalInfo.sSpInfo;
+
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncOut("McResCtrl_GetSpInfo", 0);
+#endif
+}
+
+/****************************************************************************
+ *	McResCtrl_SetDngInfo
+ *
+ *	Description:
+ *			Set Digital Noise Gate information.
+ *	Arguments:
+ *			psDngInfo	DNG information
+ *			dUpdateInfo	update information
+ *	Return:
+ *			none
+ *
+ ****************************************************************************/
+void	McResCtrl_SetDngInfo
+(
+	const MCDRV_DNG_INFO*	psDngInfo,
+	UINT32	dUpdateInfo
+)
+{
+	UINT8	bItem;
+
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncIn("McResCtrl_SetDngInfo");
+#endif
+
+
+	for(bItem = MCDRV_DNG_ITEM_HP; bItem <= MCDRV_DNG_ITEM_RC; bItem++)
+	{
+		if((dUpdateInfo & (MCDRV_DNGSW_HP_UPDATE_FLAG<<(8*bItem))) != 0UL)
+		{
+			if((psDngInfo->abOnOff[bItem] == MCDRV_DNG_OFF) || (psDngInfo->abOnOff[bItem] == MCDRV_DNG_ON))
+			{
+				gsGlobalInfo.sDngInfo.abOnOff[bItem]	= psDngInfo->abOnOff[bItem];
+			}
+		}
+		if((dUpdateInfo & (MCDRV_DNGTHRES_HP_UPDATE_FLAG<<(8*bItem))) != 0UL)
+		{
+			switch(psDngInfo->abThreshold[bItem])
+			{
+			case	MCDRV_DNG_THRES_30:
+			case	MCDRV_DNG_THRES_36:
+			case	MCDRV_DNG_THRES_42:
+			case	MCDRV_DNG_THRES_48:
+			case	MCDRV_DNG_THRES_54:
+			case	MCDRV_DNG_THRES_60:
+			case	MCDRV_DNG_THRES_66:
+			case	MCDRV_DNG_THRES_72:
+			case	MCDRV_DNG_THRES_78:
+			case	MCDRV_DNG_THRES_84:
+				gsGlobalInfo.sDngInfo.abThreshold[bItem]	= psDngInfo->abThreshold[bItem];
+				break;
+			default:
+				break;
+			}
+		}
+		if((dUpdateInfo & (MCDRV_DNGHOLD_HP_UPDATE_FLAG<<(8*bItem))) != 0UL)
+		{
+			switch(psDngInfo->abHold[bItem])
+			{
+			case	MCDRV_DNG_HOLD_30:
+			case	MCDRV_DNG_HOLD_120:
+			case	MCDRV_DNG_HOLD_500:
+				gsGlobalInfo.sDngInfo.abHold[bItem]	= psDngInfo->abHold[bItem];
+				break;
+			default:
+				break;
+			}
+		}
+		if((dUpdateInfo & (MCDRV_DNGATK_HP_UPDATE_FLAG<<(8*bItem))) != 0UL)
+		{
+			switch(psDngInfo->abAttack[bItem])
+			{
+			case	MCDRV_DNG_ATTACK_25:
+			case	MCDRV_DNG_ATTACK_100:
+			case	MCDRV_DNG_ATTACK_400:
+			case	MCDRV_DNG_ATTACK_800:
+				gsGlobalInfo.sDngInfo.abAttack[bItem]	= psDngInfo->abAttack[bItem];
+				break;
+			default:
+				break;
+			}
+		}
+		if((dUpdateInfo & (MCDRV_DNGREL_HP_UPDATE_FLAG<<(8*bItem))) != 0UL)
+		{
+			switch(psDngInfo->abRelease[bItem])
+			{
+			case	MCDRV_DNG_RELEASE_7950:
+			case	MCDRV_DNG_RELEASE_470:
+			case	MCDRV_DNG_RELEASE_940:
+				gsGlobalInfo.sDngInfo.abRelease[bItem]	= psDngInfo->abRelease[bItem];
+				break;
+			default:
+				break;
+			}
+		}
+		if((dUpdateInfo & (MCDRV_DNGTARGET_HP_UPDATE_FLAG<<(8*bItem))) != 0UL)
+		{
+			switch(psDngInfo->abTarget[bItem])
+			{
+			case	MCDRV_DNG_TARGET_6:
+			case	MCDRV_DNG_TARGET_9:
+			case	MCDRV_DNG_TARGET_12:
+			case	MCDRV_DNG_TARGET_15:
+			case	MCDRV_DNG_TARGET_18:
+			case	MCDRV_DNG_TARGET_MUTE:
+				gsGlobalInfo.sDngInfo.abTarget[bItem]	= psDngInfo->abTarget[bItem];
+				break;
+			default:
+				break;
+			}
+		}
+	}
+
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncOut("McResCtrl_SetDngInfo", 0);
+#endif
+}
+
+/****************************************************************************
+ *	McResCtrl_GetDngInfo
+ *
+ *	Description:
+ *			Get Digital Noise Gate information.
+ *	Arguments:
+ *			psDngInfo	DNG information
+ *	Return:
+ *			none
+ *
+ ****************************************************************************/
+void	McResCtrl_GetDngInfo
+(
+	MCDRV_DNG_INFO*	psDngInfo
+)
+{
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncIn("McResCtrl_GetDngInfo");
+#endif
+
+	*psDngInfo	= gsGlobalInfo.sDngInfo;
+
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncOut("McResCtrl_GetDngInfo", 0);
+#endif
+}
+
+/****************************************************************************
+ *	McResCtrl_SetAeInfo
+ *
+ *	Description:
+ *			Set Audio Engine information.
+ *	Arguments:
+ *			psAeInfo	AE information
+ *			dUpdateInfo	update information
+ *	Return:
+ *			none
+ *
+ ****************************************************************************/
+void	McResCtrl_SetAeInfo
+(
+	const MCDRV_AE_INFO*	psAeInfo,
+	UINT32	dUpdateInfo
+)
+{
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncIn("McResCtrl_SetAeInfo");
+#endif
+
+
+	if((McDevProf_IsValid(eMCDRV_FUNC_DBEX) == 1)
+	&& ((dUpdateInfo & MCDRV_AEUPDATE_FLAG_BEXWIDE_ONOFF) != 0UL))
+	{
+		if((psAeInfo->bOnOff & MCDRV_BEXWIDE_ON) != 0)
+		{
+			gsGlobalInfo.sAeInfo.bOnOff	|= MCDRV_BEXWIDE_ON;
+		}
+		else
+		{
+			gsGlobalInfo.sAeInfo.bOnOff &= (UINT8)~MCDRV_BEXWIDE_ON;
+		}
+	}
+	if((dUpdateInfo & MCDRV_AEUPDATE_FLAG_DRC_ONOFF) != 0UL)
+	{
+		if((psAeInfo->bOnOff & MCDRV_DRC_ON) != 0)
+		{
+			gsGlobalInfo.sAeInfo.bOnOff	|= MCDRV_DRC_ON;
+		}
+		else
+		{
+			gsGlobalInfo.sAeInfo.bOnOff &= (UINT8)~MCDRV_DRC_ON;
+		}
+	}
+	if((dUpdateInfo & MCDRV_AEUPDATE_FLAG_EQ5_ONOFF) != 0UL)
+	{
+		if((psAeInfo->bOnOff & MCDRV_EQ5_ON) != 0)
+		{
+			gsGlobalInfo.sAeInfo.bOnOff	|= MCDRV_EQ5_ON;
+		}
+		else
+		{
+			gsGlobalInfo.sAeInfo.bOnOff &= (UINT8)~MCDRV_EQ5_ON;
+		}
+	}
+	if((dUpdateInfo & MCDRV_AEUPDATE_FLAG_EQ3_ONOFF) != 0UL)
+	{
+		if((psAeInfo->bOnOff & MCDRV_EQ3_ON) != 0)
+		{
+			gsGlobalInfo.sAeInfo.bOnOff	|= MCDRV_EQ3_ON;
+		}
+		else
+		{
+			gsGlobalInfo.sAeInfo.bOnOff &= (UINT8)~MCDRV_EQ3_ON;
+		}
+	}
+
+	if((dUpdateInfo & MCDRV_AEUPDATE_FLAG_BEX) != 0UL)
+	{
+		McSrv_MemCopy(psAeInfo->abBex, gsGlobalInfo.sAeInfo.abBex, BEX_PARAM_SIZE);
+	}
+
+	if((dUpdateInfo & MCDRV_AEUPDATE_FLAG_WIDE) != 0UL)
+	{
+		McSrv_MemCopy(psAeInfo->abWide, gsGlobalInfo.sAeInfo.abWide, WIDE_PARAM_SIZE);
+	}
+
+	if((dUpdateInfo & MCDRV_AEUPDATE_FLAG_DRC) != 0UL)
+	{
+		McSrv_MemCopy(psAeInfo->abDrc, gsGlobalInfo.sAeInfo.abDrc, DRC_PARAM_SIZE);
+	}
+
+	if((dUpdateInfo & MCDRV_AEUPDATE_FLAG_EQ5) != 0UL)
+	{
+		McSrv_MemCopy(psAeInfo->abEq5, gsGlobalInfo.sAeInfo.abEq5, EQ5_PARAM_SIZE);
+	}
+
+	if((dUpdateInfo & MCDRV_AEUPDATE_FLAG_EQ3) != 0UL)
+	{
+		McSrv_MemCopy(psAeInfo->abEq3, gsGlobalInfo.sAeInfo.abEq3, EQ3_PARAM_SIZE);
+	}
+
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncOut("McResCtrl_SetAeInfo", 0);
+#endif
+}
+
+/****************************************************************************
+ *	McResCtrl_GetAeInfo
+ *
+ *	Description:
+ *			Get Audio Engine information.
+ *	Arguments:
+ *			psAeInfo	AE information
+ *	Return:
+ *			none
+ *
+ ****************************************************************************/
+void	McResCtrl_GetAeInfo
+(
+	MCDRV_AE_INFO*	psAeInfo
+)
+{
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncIn("McResCtrl_GetAeInfo");
+#endif
+
+	*psAeInfo	= gsGlobalInfo.sAeInfo;
+
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncOut("McResCtrl_GetAeInfo", 0);
+#endif
+}
+
+/****************************************************************************
+ *	McResCtrl_SetPdmInfo
+ *
+ *	Description:
+ *			Set PDM information.
+ *	Arguments:
+ *			psPdmInfo	PDM information
+ *			dUpdateInfo	update information
+ *	Return:
+ *			none
+ *
+ ****************************************************************************/
+void	McResCtrl_SetPdmInfo
+(
+	const MCDRV_PDM_INFO*	psPdmInfo,
+	UINT32	dUpdateInfo
+)
+{
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncIn("McResCtrl_SetPdmInfo");
+#endif
+
+
+	if((dUpdateInfo & MCDRV_PDMCLK_UPDATE_FLAG) != 0UL)
+	{
+		switch(psPdmInfo->bClk)
+		{
+		case	MCDRV_PDM_CLK_128:
+		case	MCDRV_PDM_CLK_64:
+		case	MCDRV_PDM_CLK_32:
+			gsGlobalInfo.sPdmInfo.bClk	= psPdmInfo->bClk;
+			break;
+		default:
+			break;
+		}
+	}
+	if((dUpdateInfo & MCDRV_PDMADJ_UPDATE_FLAG) != 0UL)
+	{
+		switch(psPdmInfo->bAgcAdjust)
+		{
+		case	MCDRV_AGCADJ_24:
+		case	MCDRV_AGCADJ_18:
+		case	MCDRV_AGCADJ_12:
+		case	MCDRV_AGCADJ_0:
+			gsGlobalInfo.sPdmInfo.bAgcAdjust	= psPdmInfo->bAgcAdjust;
+			break;
+		default:
+			break;
+		}
+	}
+	if((dUpdateInfo & MCDRV_PDMAGC_UPDATE_FLAG) != 0UL)
+	{
+		switch(psPdmInfo->bAgcOn)
+		{
+		case	MCDRV_AGC_OFF:
+		case	MCDRV_AGC_ON:
+			gsGlobalInfo.sPdmInfo.bAgcOn	= psPdmInfo->bAgcOn;
+			break;
+		default:
+			break;
+		}
+	}
+	if((dUpdateInfo & MCDRV_PDMEDGE_UPDATE_FLAG) != 0UL)
+	{
+		switch(psPdmInfo->bPdmEdge)
+		{
+		case	MCDRV_PDMEDGE_LH:
+		case	MCDRV_PDMEDGE_HL:
+			gsGlobalInfo.sPdmInfo.bPdmEdge	= psPdmInfo->bPdmEdge;
+			break;
+		default:
+			break;
+		}
+	}
+	if((dUpdateInfo & MCDRV_PDMWAIT_UPDATE_FLAG) != 0UL)
+	{
+		switch(psPdmInfo->bPdmWait)
+		{
+		case	MCDRV_PDMWAIT_0:
+		case	MCDRV_PDMWAIT_1:
+		case	MCDRV_PDMWAIT_10:
+		case	MCDRV_PDMWAIT_20:
+			gsGlobalInfo.sPdmInfo.bPdmWait	= psPdmInfo->bPdmWait;
+			break;
+		default:
+			break;
+		}
+	}
+	if((dUpdateInfo & MCDRV_PDMSEL_UPDATE_FLAG) != 0UL)
+	{
+		switch(psPdmInfo->bPdmSel)
+		{
+		case	MCDRV_PDMSEL_L1R2:
+		case	MCDRV_PDMSEL_L2R1:
+		case	MCDRV_PDMSEL_L1R1:
+		case	MCDRV_PDMSEL_L2R2:
+			gsGlobalInfo.sPdmInfo.bPdmSel	= psPdmInfo->bPdmSel;
+			break;
+		default:
+			break;
+		}
+	}
+	if((dUpdateInfo & MCDRV_PDMMONO_UPDATE_FLAG) != 0UL)
+	{
+		switch(psPdmInfo->bMono)
+		{
+		case	MCDRV_PDM_STEREO:
+		case	MCDRV_PDM_MONO:
+			gsGlobalInfo.sPdmInfo.bMono	= psPdmInfo->bMono;
+			break;
+		default:
+			break;
+		}
+	}
+
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncOut("McResCtrl_SetPdmInfo", 0);
+#endif
+}
+
+/****************************************************************************
+ *	McResCtrl_GetPdmInfo
+ *
+ *	Description:
+ *			Get PDM information.
+ *	Arguments:
+ *			psPdmInfo	PDM information
+ *	Return:
+ *			none
+ *
+ ****************************************************************************/
+void	McResCtrl_GetPdmInfo
+(
+	MCDRV_PDM_INFO*	psPdmInfo
+)
+{
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncIn("McResCtrl_GetPdmInfo");
+#endif
+
+	*psPdmInfo	= gsGlobalInfo.sPdmInfo;
+
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncOut("McResCtrl_GetPdmInfo", 0);
+#endif
+}
+
+/****************************************************************************
+ *	McResCtrl_SetGPMode
+ *
+ *	Description:
+ *			Set GP mode.
+ *	Arguments:
+ *			psGpMode	GP mode
+ *	Return:
+ *			none
+ *
+ ****************************************************************************/
+void	McResCtrl_SetGPMode
+(
+	const MCDRV_GP_MODE*	psGpMode
+)
+{
+	UINT8	bPad;
+
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncIn("McResCtrl_SetGPMode");
+#endif
+
+
+	for(bPad = 0; bPad < GPIO_PAD_NUM; bPad++)
+	{
+		if((psGpMode->abGpDdr[bPad] == MCDRV_GPDDR_IN)
+		|| (psGpMode->abGpDdr[bPad] == MCDRV_GPDDR_OUT))
+		{
+			gsGlobalInfo.sGpMode.abGpDdr[bPad]	= psGpMode->abGpDdr[bPad];
+		}
+		if(McDevProf_IsValid(eMCDRV_FUNC_GPMODE) == 1)
+		{
+			if((psGpMode->abGpMode[bPad] == MCDRV_GPMODE_RISING)
+			|| (psGpMode->abGpMode[bPad] == MCDRV_GPMODE_FALLING)
+			|| (psGpMode->abGpMode[bPad] == MCDRV_GPMODE_BOTH))
+			{
+				gsGlobalInfo.sGpMode.abGpMode[bPad]	= psGpMode->abGpMode[bPad];
+			}
+			if((psGpMode->abGpHost[bPad] == MCDRV_GPHOST_SCU)
+			|| (psGpMode->abGpHost[bPad] == MCDRV_GPHOST_CDSP))
+			{
+				gsGlobalInfo.sGpMode.abGpHost[bPad]	= psGpMode->abGpHost[bPad];
+			}
+			if((psGpMode->abGpInvert[bPad] == MCDRV_GPINV_NORMAL)
+			|| (psGpMode->abGpInvert[bPad] == MCDRV_GPINV_INVERT))
+			{
+				gsGlobalInfo.sGpMode.abGpInvert[bPad]	= psGpMode->abGpInvert[bPad];
+			}
+		}
+	}
+
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncOut("McResCtrl_SetGPMode", 0);
+#endif
+}
+
+/****************************************************************************
+ *	McResCtrl_GetGPMode
+ *
+ *	Description:
+ *			Get GP mode.
+ *	Arguments:
+ *			psGpMode	GP mode
+ *	Return:
+ *			none
+ *
+ ****************************************************************************/
+void	McResCtrl_GetGPMode
+(
+	MCDRV_GP_MODE*	psGpMode
+)
+{
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncIn("McResCtrl_GetGPMode");
+#endif
+
+	*psGpMode	= gsGlobalInfo.sGpMode;
+
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncOut("McResCtrl_GetGPMode", 0);
+#endif
+}
+
+/****************************************************************************
+ *	McResCtrl_SetGPMask
+ *
+ *	Description:
+ *			Set GP mask.
+ *	Arguments:
+ *			bMask	GP mask
+ *			dPadNo	PAD Number
+ *	Return:
+ *			none
+ *
+ ****************************************************************************/
+void	McResCtrl_SetGPMask
+(
+	UINT8	bMask,
+	UINT32	dPadNo
+)
+{
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncIn("McResCtrl_SetGPMask");
+#endif
+
+	if(dPadNo == MCDRV_GP_PAD0)
+	{
+		if((gsGlobalInfo.sInitInfo.bPad0Func == MCDRV_PAD_GPIO)
+		&& (gsGlobalInfo.sGpMode.abGpDdr[dPadNo] == MCDRV_GPDDR_IN))
+		{
+			if((bMask == MCDRV_GPMASK_ON) || (bMask == MCDRV_GPMASK_OFF))
+			{
+				gsGlobalInfo.abGpMask[dPadNo]	= bMask;
+			}
+		}
+	}
+	else if(dPadNo == MCDRV_GP_PAD1)
+	{
+		if((gsGlobalInfo.sInitInfo.bPad1Func == MCDRV_PAD_GPIO)
+		&& (gsGlobalInfo.sGpMode.abGpDdr[dPadNo] == MCDRV_GPDDR_IN))
+		{
+			if((bMask == MCDRV_GPMASK_ON) || (bMask == MCDRV_GPMASK_OFF))
+			{
+				gsGlobalInfo.abGpMask[dPadNo]	= bMask;
+			}
+		}
+	}
+	else
+	{
+	}
+
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncOut("McResCtrl_SetGPMask", 0);
+#endif
+}
+
+/****************************************************************************
+ *	McResCtrl_GetGPMask
+ *
+ *	Description:
+ *			Get GP mask.
+ *	Arguments:
+ *			pabMask	GP mask
+ *	Return:
+ *			none
+ *
+ ****************************************************************************/
+void	McResCtrl_GetGPMask
+(
+	UINT8*	pabMask
+)
+{
+	UINT8	bPadNo;
+
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncIn("McResCtrl_GetGPMask");
+#endif
+
+	for(bPadNo = 0; bPadNo < GPIO_PAD_NUM; bPadNo++)
+	{
+		pabMask[bPadNo]	= gsGlobalInfo.abGpMask[bPadNo];
+	}
+
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncOut("McResCtrl_GetGPMask", 0);
+#endif
+}
+
+/****************************************************************************
+ *	McResCtrl_GetSysEq
+ *
+ *	Description:
+ *			Get System EQ.
+ *	Arguments:
+ *			psSysEq		pointer to MCDRV_SYSEQ_INFO struct
+ *	Return:
+ *			none
+ *
+ ****************************************************************************/
+void	McResCtrl_GetSysEq
+(
+	MCDRV_SYSEQ_INFO*	psSysEq
+)
+{
+	UINT8	i;
+
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncIn("McResCtrl_GetSysEq");
+#endif
+
+	psSysEq->bOnOff	= gsGlobalInfo.sSysEq.bOnOff;
+	for(i = 0; i < sizeof(gsGlobalInfo.sSysEq.abParam); i++)
+	{
+		psSysEq->abParam[i]	= gsGlobalInfo.sSysEq.abParam[i];
+	}
+
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncOut("McResCtrl_GetSysEq", 0);
+#endif
+}
+
+/****************************************************************************
+ *	McResCtrl_SetSysEq
+ *
+ *	Description:
+ *			Set System EQ.
+ *	Arguments:
+ *			psSysEq		pointer to MCDRV_SYSEQ_INFO struct
+ *			dUpdateInfo	update information
+ *	Return:
+ *			none
+ *
+ ****************************************************************************/
+void	McResCtrl_SetSysEq
+(
+	const MCDRV_SYSEQ_INFO*	psSysEq,
+	UINT32					dUpdateInfo
+)
+{
+	UINT8	i;
+
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncIn("McResCtrl_SetSysEq");
+#endif
+
+	if((dUpdateInfo & MCDRV_SYSEQ_ONOFF_UPDATE_FLAG) != 0UL)
+	{
+		if((psSysEq->bOnOff == MCDRV_SYSEQ_OFF) || (psSysEq->bOnOff == MCDRV_SYSEQ_ON))
+		{
+			gsGlobalInfo.sSysEq.bOnOff	= psSysEq->bOnOff;
+		}
+	}
+
+	if((dUpdateInfo & MCDRV_SYSEQ_PARAM_UPDATE_FLAG) != 0UL)
+	{
+		for(i = 0; i < sizeof(gsGlobalInfo.sSysEq.abParam); i++)
+		{
+			gsGlobalInfo.sSysEq.abParam[i]	= psSysEq->abParam[i];
+		}
+	}
+
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncOut("McResCtrl_SetSysEq", 0);
+#endif
+}
+
+/****************************************************************************
+ *	McResCtrl_GetClockSwitch
+ *
+ *	Description:
+ *			Get switch clock info.
+ *	Arguments:
+ *			psClockInfo		pointer to MCDRV_CLKSW_INFO struct
+ *	Return:
+ *			none
+ *
+ ****************************************************************************/
+void	McResCtrl_GetClockSwitch
+(
+	MCDRV_CLKSW_INFO*	psClockInfo
+)
+{
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncIn("McResCtrl_GetClockSwitch");
+#endif
+
+	psClockInfo->bClkSrc	= gsGlobalInfo.sClockSwitch.bClkSrc;
+
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncOut("McResCtrl_GetClockSwitch", 0);
+#endif
+}
+
+/****************************************************************************
+ *	McResCtrl_SetClockSwitch
+ *
+ *	Description:
+ *			Get switch clock info.
+ *	Arguments:
+ *			psClockInfo		pointer to MCDRV_CLKSW_INFO struct
+ *	Return:
+ *			none
+ *
+ ****************************************************************************/
+void	McResCtrl_SetClockSwitch
+(
+	const MCDRV_CLKSW_INFO*	psClockInfo
+)
+{
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncIn("McResCtrl_SetClockSwitch");
+#endif
+
+	gsGlobalInfo.sClockSwitch.bClkSrc	= psClockInfo->bClkSrc;
+
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncOut("McResCtrl_SetClockSwitch", 0);
+#endif
+}
+
+
+/****************************************************************************
+ *	McResCtrl_GetVolReg
+ *
+ *	Description:
+ *			Get value of volume registers.
+ *	Arguments:
+ *			psVolInfo	volume information
+ *	Return:
+ *			none
+ *
+ ****************************************************************************/
+void	McResCtrl_GetVolReg
+(
+	MCDRV_VOL_INFO*	psVolInfo
+)
+{
+	UINT8	bCh;
+	MCDRV_DST_CH	abDSTCh[]	= {eMCDRV_DST_CH0, eMCDRV_DST_CH1};
+	SINT16	swGainUp;
+
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncIn("McResCtrl_GetVolReg");
+#endif
+
+
+	*psVolInfo	= gsGlobalInfo.sVolInfo;
+
+	if(gsGlobalInfo.sInitInfo.bDclGain == MCDRV_DCLGAIN_6)
+	{
+		swGainUp	= 6 * 256;
+	}
+	else if(gsGlobalInfo.sInitInfo.bDclGain == MCDRV_DCLGAIN_12)
+	{
+		swGainUp	= 12 * 256;
+	}
+	else if(gsGlobalInfo.sInitInfo.bDclGain == MCDRV_DCLGAIN_18)
+	{
+		swGainUp	= 18 * 256;
+	}
+	else
+	{
+		swGainUp	= 0;
+	}
+
+	psVolInfo->aswA_HpGain[0]	= MCDRV_REG_MUTE;
+	if(McResCtrl_IsDstUsed(eMCDRV_DST_HP, eMCDRV_DST_CH0) == 0)
+	{
+		psVolInfo->aswA_Hp[0]	= MCDRV_REG_MUTE;
+	}
+	else
+	{
+		psVolInfo->aswA_Hp[0]		= GetHpVolReg(gsGlobalInfo.sVolInfo.aswA_Hp[0]);
+		psVolInfo->aswA_HpGain[0]	= GetHpGainReg(gsGlobalInfo.sVolInfo.aswA_HpGain[0]);
+	}
+	if(McResCtrl_IsDstUsed(eMCDRV_DST_HP, eMCDRV_DST_CH1) == 0)
+	{
+		psVolInfo->aswA_Hp[1]	= MCDRV_REG_MUTE;
+	}
+	else
+	{
+		psVolInfo->aswA_Hp[1]	= GetHpVolReg(gsGlobalInfo.sVolInfo.aswA_Hp[1]);
+		psVolInfo->aswA_HpGain[0]	= GetHpGainReg(gsGlobalInfo.sVolInfo.aswA_HpGain[0]);
+	}
+
+	if(McResCtrl_IsDstUsed(eMCDRV_DST_SP, eMCDRV_DST_CH0) == 0)
+	{
+		psVolInfo->aswA_Sp[0]	= MCDRV_REG_MUTE;
+	}
+	else
+	{
+		psVolInfo->aswA_Sp[0]	= GetSpVolReg(gsGlobalInfo.sVolInfo.aswA_Sp[0]);
+	}
+	if(McResCtrl_IsDstUsed(eMCDRV_DST_SP, eMCDRV_DST_CH1) == 0)
+	{
+		psVolInfo->aswA_Sp[1]	= MCDRV_REG_MUTE;
+	}
+	else
+	{
+		psVolInfo->aswA_Sp[1]	= GetSpVolReg(gsGlobalInfo.sVolInfo.aswA_Sp[1]);
+	}
+
+	if(McResCtrl_IsDstUsed(eMCDRV_DST_RCV, eMCDRV_DST_CH0) == 0)
+	{
+		psVolInfo->aswA_Rc[0]	= MCDRV_REG_MUTE;
+	}
+	else
+	{
+		psVolInfo->aswA_Rc[0]	= GetRcVolReg(gsGlobalInfo.sVolInfo.aswA_Rc[0]);
+	}
+
+	if(McResCtrl_IsDstUsed(eMCDRV_DST_LOUT1, eMCDRV_DST_CH0) == 0)
+	{
+		psVolInfo->aswA_Lout1[0]	= MCDRV_REG_MUTE;
+	}
+	else
+	{
+		psVolInfo->aswA_Lout1[0]	= GetLoVolReg(gsGlobalInfo.sVolInfo.aswA_Lout1[0]);
+	}
+	if(McResCtrl_IsDstUsed(eMCDRV_DST_LOUT1, eMCDRV_DST_CH1) == 0)
+	{
+		psVolInfo->aswA_Lout1[1]	= MCDRV_REG_MUTE;
+	}
+	else
+	{
+		psVolInfo->aswA_Lout1[1]	= GetLoVolReg(gsGlobalInfo.sVolInfo.aswA_Lout1[1]);
+	}
+
+	if(McResCtrl_IsDstUsed(eMCDRV_DST_LOUT2, eMCDRV_DST_CH0) == 0)
+	{
+		psVolInfo->aswA_Lout2[0]	= MCDRV_REG_MUTE;
+	}
+	else
+	{
+		psVolInfo->aswA_Lout2[0]	= GetLoVolReg(gsGlobalInfo.sVolInfo.aswA_Lout2[0]);
+	}
+	if(McResCtrl_IsDstUsed(eMCDRV_DST_LOUT2, eMCDRV_DST_CH1) == 0)
+	{
+		psVolInfo->aswA_Lout2[1]	= MCDRV_REG_MUTE;
+	}
+	else
+	{
+		psVolInfo->aswA_Lout2[1]	= GetLoVolReg(gsGlobalInfo.sVolInfo.aswA_Lout2[1]);
+	}
+
+	for(bCh = 0; bCh < AD0_VOL_CHANNELS; bCh++)
+	{
+		if(McResCtrl_IsDstUsed(eMCDRV_DST_ADC0, abDSTCh[bCh]) == 0)
+		{/*	ADC0 source all off	*/
+			psVolInfo->aswA_Ad0[bCh]	= MCDRV_REG_MUTE;
+			psVolInfo->aswD_Ad0[bCh]	= MCDRV_REG_MUTE;
+		}
+		else
+		{
+			psVolInfo->aswA_Ad0[bCh]	= GetADVolReg(gsGlobalInfo.sVolInfo.aswA_Ad0[bCh]);
+			psVolInfo->aswD_Ad0[bCh]	= GetDigitalVolReg(gsGlobalInfo.sVolInfo.aswD_Ad0[bCh] - swGainUp);
+		}
+	}
+	if(((gsGlobalInfo.sPathInfo.asMix[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK] & MCDRV_SRC4_ADC0_ON) == MCDRV_SRC4_ADC0_ON)
+	|| ((gsGlobalInfo.sPathInfo.asMix[0].abSrcOnOff[MCDRV_SRC_PDM_BLOCK] & MCDRV_SRC4_PDM_ON) == MCDRV_SRC4_PDM_ON)
+	|| (((gsGlobalInfo.sPathInfo.asMix[0].abSrcOnOff[MCDRV_SRC_AE_BLOCK] & MCDRV_SRC6_AE_ON) == MCDRV_SRC6_AE_ON)
+		&& ((McResCtrl_GetAESource() == eMCDRV_SRC_PDM) || (McResCtrl_GetAESource() == eMCDRV_SRC_ADC0))))
+	{
+		for(bCh = 0; bCh < AD0_VOL_CHANNELS; bCh++)
+		{
+			psVolInfo->aswD_Ad0Att[bCh]	= GetDigitalVolReg(gsGlobalInfo.sVolInfo.aswD_Ad0Att[bCh]);
+		}
+	}
+	else
+	{
+		for(bCh = 0; bCh < AD0_VOL_CHANNELS; bCh++)
+		{
+			psVolInfo->aswD_Ad0Att[bCh]	= MCDRV_REG_MUTE;
+		}
+	}
+
+	if(McDevProf_IsValid(eMCDRV_FUNC_ADC1) == 1)
+	{
+		if(McResCtrl_IsDstUsed(eMCDRV_DST_ADC1, eMCDRV_DST_CH0) == 0)
+		{/*	ADC1 source all off	*/
+			for(bCh = 0; bCh < AD1_VOL_CHANNELS; bCh++)
+			{
+				psVolInfo->aswA_Ad1[bCh]	= MCDRV_REG_MUTE;
+				psVolInfo->aswD_Ad1[bCh]	= MCDRV_REG_MUTE;
+			}
+		}
+		else
+		{
+			for(bCh = 0; bCh < AD1_VOL_CHANNELS; bCh++)
+			{
+				psVolInfo->aswA_Ad1[bCh]	= GetADVolReg(gsGlobalInfo.sVolInfo.aswA_Ad1[bCh]);
+				psVolInfo->aswD_Ad1[bCh]	= GetDigitalVolReg(gsGlobalInfo.sVolInfo.aswD_Ad1[bCh] - swGainUp);
+			}
+		}
+		if((gsGlobalInfo.sPathInfo.asMix[0].abSrcOnOff[MCDRV_SRC_ADC1_BLOCK] & MCDRV_SRC4_ADC1_ON) == MCDRV_SRC4_ADC1_ON)
+		{
+			for(bCh = 0; bCh < AD1_VOL_CHANNELS; bCh++)
+			{
+				psVolInfo->aswD_Ad1Att[bCh]	= GetDigitalVolReg(gsGlobalInfo.sVolInfo.aswD_Ad1Att[bCh]);
+			}
+		}
+		else
+		{
+			for(bCh = 0; bCh < AD1_VOL_CHANNELS; bCh++)
+			{
+				psVolInfo->aswD_Ad1Att[bCh]	= MCDRV_REG_MUTE;
+			}
+		}
+	}
+
+	if(((gsGlobalInfo.sPathInfo.asHpOut[0].abSrcOnOff[MCDRV_SRC_LINE1_L_BLOCK] & MCDRV_SRC1_LINE1_L_ON) == MCDRV_SRC1_LINE1_L_ON)
+	|| ((gsGlobalInfo.sPathInfo.asSpOut[0].abSrcOnOff[MCDRV_SRC_LINE1_L_BLOCK] & MCDRV_SRC1_LINE1_L_ON) == MCDRV_SRC1_LINE1_L_ON)
+	|| ((gsGlobalInfo.sPathInfo.asLout1[0].abSrcOnOff[MCDRV_SRC_LINE1_L_BLOCK] & MCDRV_SRC1_LINE1_L_ON) == MCDRV_SRC1_LINE1_L_ON)
+	|| ((gsGlobalInfo.sPathInfo.asLout1[0].abSrcOnOff[MCDRV_SRC_LINE1_L_BLOCK] & MCDRV_SRC1_LINE1_L_ON) == MCDRV_SRC1_LINE1_L_ON)
+	|| ((gsGlobalInfo.sPathInfo.asLout2[0].abSrcOnOff[MCDRV_SRC_LINE1_L_BLOCK] & MCDRV_SRC1_LINE1_L_ON) == MCDRV_SRC1_LINE1_L_ON)
+	|| ((gsGlobalInfo.sPathInfo.asHpOut[0].abSrcOnOff[MCDRV_SRC_LINE1_M_BLOCK] & MCDRV_SRC1_LINE1_M_ON) == MCDRV_SRC1_LINE1_M_ON)
+	|| ((gsGlobalInfo.sPathInfo.asSpOut[0].abSrcOnOff[MCDRV_SRC_LINE1_M_BLOCK] & MCDRV_SRC1_LINE1_M_ON) == MCDRV_SRC1_LINE1_M_ON)
+	|| ((gsGlobalInfo.sPathInfo.asSpOut[1].abSrcOnOff[MCDRV_SRC_LINE1_M_BLOCK] & MCDRV_SRC1_LINE1_M_ON) == MCDRV_SRC1_LINE1_M_ON)
+	|| ((gsGlobalInfo.sPathInfo.asRcOut[0].abSrcOnOff[MCDRV_SRC_LINE1_M_BLOCK] & MCDRV_SRC1_LINE1_M_ON) == MCDRV_SRC1_LINE1_M_ON)
+	|| ((gsGlobalInfo.sPathInfo.asLout1[0].abSrcOnOff[MCDRV_SRC_LINE1_M_BLOCK] & MCDRV_SRC1_LINE1_M_ON) == MCDRV_SRC1_LINE1_M_ON)
+	|| ((gsGlobalInfo.sPathInfo.asLout1[0].abSrcOnOff[MCDRV_SRC_LINE1_M_BLOCK] & MCDRV_SRC1_LINE1_M_ON) == MCDRV_SRC1_LINE1_M_ON)
+	|| ((gsGlobalInfo.sPathInfo.asLout2[0].abSrcOnOff[MCDRV_SRC_LINE1_M_BLOCK] & MCDRV_SRC1_LINE1_M_ON) == MCDRV_SRC1_LINE1_M_ON))
+	{
+		psVolInfo->aswA_Lin1[0]	= GetLIVolReg(gsGlobalInfo.sVolInfo.aswA_Lin1[0]);
+	}
+	else
+	{
+		psVolInfo->aswA_Lin1[0]	= MCDRV_REG_MUTE;
+	}
+
+	if(((gsGlobalInfo.sPathInfo.asHpOut[1].abSrcOnOff[MCDRV_SRC_LINE1_R_BLOCK] & MCDRV_SRC1_LINE1_R_ON) == MCDRV_SRC1_LINE1_R_ON)
+	|| ((gsGlobalInfo.sPathInfo.asSpOut[1].abSrcOnOff[MCDRV_SRC_LINE1_R_BLOCK] & MCDRV_SRC1_LINE1_R_ON) == MCDRV_SRC1_LINE1_R_ON)
+	|| ((gsGlobalInfo.sPathInfo.asLout1[1].abSrcOnOff[MCDRV_SRC_LINE1_R_BLOCK] & MCDRV_SRC1_LINE1_R_ON) == MCDRV_SRC1_LINE1_R_ON)
+	|| ((gsGlobalInfo.sPathInfo.asLout2[1].abSrcOnOff[MCDRV_SRC_LINE1_R_BLOCK] & MCDRV_SRC1_LINE1_R_ON) == MCDRV_SRC1_LINE1_R_ON)
+	|| ((gsGlobalInfo.sPathInfo.asHpOut[0].abSrcOnOff[MCDRV_SRC_LINE1_M_BLOCK] & MCDRV_SRC1_LINE1_M_ON) == MCDRV_SRC1_LINE1_M_ON)
+	|| ((gsGlobalInfo.sPathInfo.asSpOut[0].abSrcOnOff[MCDRV_SRC_LINE1_M_BLOCK] & MCDRV_SRC1_LINE1_M_ON) == MCDRV_SRC1_LINE1_M_ON)
+	|| ((gsGlobalInfo.sPathInfo.asSpOut[1].abSrcOnOff[MCDRV_SRC_LINE1_M_BLOCK] & MCDRV_SRC1_LINE1_M_ON) == MCDRV_SRC1_LINE1_M_ON)
+	|| ((gsGlobalInfo.sPathInfo.asRcOut[0].abSrcOnOff[MCDRV_SRC_LINE1_M_BLOCK] & MCDRV_SRC1_LINE1_M_ON) == MCDRV_SRC1_LINE1_M_ON)
+	|| ((gsGlobalInfo.sPathInfo.asLout1[0].abSrcOnOff[MCDRV_SRC_LINE1_M_BLOCK] & MCDRV_SRC1_LINE1_M_ON) == MCDRV_SRC1_LINE1_M_ON)
+	|| ((gsGlobalInfo.sPathInfo.asLout1[0].abSrcOnOff[MCDRV_SRC_LINE1_M_BLOCK] & MCDRV_SRC1_LINE1_M_ON) == MCDRV_SRC1_LINE1_M_ON)
+	|| ((gsGlobalInfo.sPathInfo.asLout2[0].abSrcOnOff[MCDRV_SRC_LINE1_M_BLOCK] & MCDRV_SRC1_LINE1_M_ON) == MCDRV_SRC1_LINE1_M_ON))
+	{
+		psVolInfo->aswA_Lin1[1]	= GetLIVolReg(gsGlobalInfo.sVolInfo.aswA_Lin1[1]);
+	}
+	else
+	{
+		psVolInfo->aswA_Lin1[1]	= MCDRV_REG_MUTE;
+	}
+
+	if(McDevProf_IsValid(eMCDRV_FUNC_LI2) == 1)
+	{
+		psVolInfo->aswA_Lin2[0]	= MCDRV_REG_MUTE;
+		psVolInfo->aswA_Lin2[1]	= MCDRV_REG_MUTE;
+	}
+
+	if(McResCtrl_IsSrcUsed(eMCDRV_SRC_MIC1) == 0)
+	{/*	MIC1 is unused	*/
+		for(bCh = 0; bCh < MIC1_VOL_CHANNELS; bCh++)
+		{
+			psVolInfo->aswA_Mic1[bCh]		= MCDRV_REG_MUTE;
+			psVolInfo->aswA_Mic1Gain[bCh]	= (SINT16)(McResCtrl_GetRegVal(MCDRV_PACKET_REGTYPE_B_ANA, MCI_MC_GAIN) & MCB_MC1GAIN);
+		}
+	}
+	else
+	{
+		for(bCh = 0; bCh < MIC1_VOL_CHANNELS; bCh++)
+		{
+			if(((gsGlobalInfo.sPathInfo.asHpOut[0].abSrcOnOff[MCDRV_SRC_MIC1_BLOCK] & MCDRV_SRC0_MIC1_ON) != MCDRV_SRC0_MIC1_ON)
+			&& ((gsGlobalInfo.sPathInfo.asHpOut[1].abSrcOnOff[MCDRV_SRC_MIC1_BLOCK] & MCDRV_SRC0_MIC1_ON) != MCDRV_SRC0_MIC1_ON)
+			&& ((gsGlobalInfo.sPathInfo.asRcOut[0].abSrcOnOff[MCDRV_SRC_MIC1_BLOCK] & MCDRV_SRC0_MIC1_ON) != MCDRV_SRC0_MIC1_ON)
+			&& ((gsGlobalInfo.sPathInfo.asLout1[0].abSrcOnOff[MCDRV_SRC_MIC1_BLOCK] & MCDRV_SRC0_MIC1_ON) != MCDRV_SRC0_MIC1_ON)
+			&& ((gsGlobalInfo.sPathInfo.asLout1[1].abSrcOnOff[MCDRV_SRC_MIC1_BLOCK] & MCDRV_SRC0_MIC1_ON) != MCDRV_SRC0_MIC1_ON)
+			&& ((gsGlobalInfo.sPathInfo.asLout2[0].abSrcOnOff[MCDRV_SRC_MIC1_BLOCK] & MCDRV_SRC0_MIC1_ON) != MCDRV_SRC0_MIC1_ON)
+			&& ((gsGlobalInfo.sPathInfo.asLout2[1].abSrcOnOff[MCDRV_SRC_MIC1_BLOCK] & MCDRV_SRC0_MIC1_ON) != MCDRV_SRC0_MIC1_ON))
+			{
+				psVolInfo->aswA_Mic1[bCh]	= MCDRV_REG_MUTE;
+			}
+			else
+			{
+				psVolInfo->aswA_Mic1[bCh]	= GetMcVolReg(gsGlobalInfo.sVolInfo.aswA_Mic1[bCh]);
+			}
+			psVolInfo->aswA_Mic1Gain[bCh]	= GetMcGainReg(gsGlobalInfo.sVolInfo.aswA_Mic1Gain[bCh]);
+		}
+	}
+	if(McResCtrl_IsSrcUsed(eMCDRV_SRC_MIC2) == 0)
+	{/*	MIC2 is unused	*/
+		for(bCh = 0; bCh < MIC2_VOL_CHANNELS; bCh++)
+		{
+			psVolInfo->aswA_Mic2[bCh]		= MCDRV_REG_MUTE;
+			psVolInfo->aswA_Mic2Gain[bCh]	= (SINT16)((McResCtrl_GetRegVal(MCDRV_PACKET_REGTYPE_B_ANA, MCI_MC_GAIN) & MCB_MC2GAIN) >> 4);
+		}
+	}
+	else
+	{
+		for(bCh = 0; bCh < MIC2_VOL_CHANNELS; bCh++)
+		{
+			if(((gsGlobalInfo.sPathInfo.asHpOut[0].abSrcOnOff[MCDRV_SRC_MIC2_BLOCK] & MCDRV_SRC0_MIC2_ON) != MCDRV_SRC0_MIC2_ON)
+			&& ((gsGlobalInfo.sPathInfo.asHpOut[1].abSrcOnOff[MCDRV_SRC_MIC2_BLOCK] & MCDRV_SRC0_MIC2_ON) != MCDRV_SRC0_MIC2_ON)
+			&& ((gsGlobalInfo.sPathInfo.asRcOut[0].abSrcOnOff[MCDRV_SRC_MIC2_BLOCK] & MCDRV_SRC0_MIC2_ON) != MCDRV_SRC0_MIC2_ON)
+			&& ((gsGlobalInfo.sPathInfo.asLout1[0].abSrcOnOff[MCDRV_SRC_MIC2_BLOCK] & MCDRV_SRC0_MIC2_ON) != MCDRV_SRC0_MIC2_ON)
+			&& ((gsGlobalInfo.sPathInfo.asLout1[1].abSrcOnOff[MCDRV_SRC_MIC2_BLOCK] & MCDRV_SRC0_MIC2_ON) != MCDRV_SRC0_MIC2_ON)
+			&& ((gsGlobalInfo.sPathInfo.asLout2[0].abSrcOnOff[MCDRV_SRC_MIC2_BLOCK] & MCDRV_SRC0_MIC2_ON) != MCDRV_SRC0_MIC2_ON)
+			&& ((gsGlobalInfo.sPathInfo.asLout2[1].abSrcOnOff[MCDRV_SRC_MIC2_BLOCK] & MCDRV_SRC0_MIC2_ON) != MCDRV_SRC0_MIC2_ON))
+			{
+				psVolInfo->aswA_Mic2[bCh]	= MCDRV_REG_MUTE;
+			}
+			else
+			{
+				psVolInfo->aswA_Mic2[bCh]	= GetMcVolReg(gsGlobalInfo.sVolInfo.aswA_Mic2[bCh]);
+			}
+			psVolInfo->aswA_Mic2Gain[bCh]	= GetMcGainReg(gsGlobalInfo.sVolInfo.aswA_Mic2Gain[bCh]);
+		}
+	}
+	if(McResCtrl_IsSrcUsed(eMCDRV_SRC_MIC3) == 0)
+	{/*	MIC3 is unused	*/
+		for(bCh = 0; bCh < MIC3_VOL_CHANNELS; bCh++)
+		{
+			psVolInfo->aswA_Mic3[bCh]		= MCDRV_REG_MUTE;
+			psVolInfo->aswA_Mic3Gain[bCh]	= (SINT16)(McResCtrl_GetRegVal(MCDRV_PACKET_REGTYPE_B_ANA, MCI_MC3_GAIN) & MCB_MC3GAIN);
+		}
+	}
+	else
+	{
+		for(bCh = 0; bCh < MIC3_VOL_CHANNELS; bCh++)
+		{
+			if(((gsGlobalInfo.sPathInfo.asHpOut[0].abSrcOnOff[MCDRV_SRC_MIC3_BLOCK] & MCDRV_SRC0_MIC3_ON) != MCDRV_SRC0_MIC3_ON)
+			&& ((gsGlobalInfo.sPathInfo.asHpOut[1].abSrcOnOff[MCDRV_SRC_MIC3_BLOCK] & MCDRV_SRC0_MIC3_ON) != MCDRV_SRC0_MIC3_ON)
+			&& ((gsGlobalInfo.sPathInfo.asRcOut[0].abSrcOnOff[MCDRV_SRC_MIC3_BLOCK] & MCDRV_SRC0_MIC3_ON) != MCDRV_SRC0_MIC3_ON)
+			&& ((gsGlobalInfo.sPathInfo.asLout1[0].abSrcOnOff[MCDRV_SRC_MIC3_BLOCK] & MCDRV_SRC0_MIC3_ON) != MCDRV_SRC0_MIC3_ON)
+			&& ((gsGlobalInfo.sPathInfo.asLout1[1].abSrcOnOff[MCDRV_SRC_MIC3_BLOCK] & MCDRV_SRC0_MIC3_ON) != MCDRV_SRC0_MIC3_ON)
+			&& ((gsGlobalInfo.sPathInfo.asLout2[0].abSrcOnOff[MCDRV_SRC_MIC3_BLOCK] & MCDRV_SRC0_MIC3_ON) != MCDRV_SRC0_MIC3_ON)
+			&& ((gsGlobalInfo.sPathInfo.asLout2[1].abSrcOnOff[MCDRV_SRC_MIC3_BLOCK] & MCDRV_SRC0_MIC3_ON) != MCDRV_SRC0_MIC3_ON))
+			{
+				psVolInfo->aswA_Mic3[bCh]	= MCDRV_REG_MUTE;
+			}
+			else
+			{
+				psVolInfo->aswA_Mic3[bCh]	= GetMcVolReg(gsGlobalInfo.sVolInfo.aswA_Mic3[bCh]);
+			}
+			psVolInfo->aswA_Mic3Gain[bCh]	= GetMcGainReg(gsGlobalInfo.sVolInfo.aswA_Mic3Gain[bCh]);
+		}
+	}
+
+	if(McResCtrl_IsSrcUsed(eMCDRV_SRC_DIR0) == 0)
+	{/*	DIR0 is unused	*/
+		for(bCh = 0; bCh < DIO0_VOL_CHANNELS; bCh++)
+		{
+			psVolInfo->aswD_Dir0[bCh]		= MCDRV_REG_MUTE;
+		}
+	}
+	else
+	{
+		for(bCh = 0; bCh < DIO0_VOL_CHANNELS; bCh++)
+		{
+			psVolInfo->aswD_Dir0[bCh]		= GetDigitalVolReg(gsGlobalInfo.sVolInfo.aswD_Dir0[bCh] - swGainUp);
+		}
+	}
+	if(((gsGlobalInfo.sPathInfo.asMix[0].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK] & MCDRV_SRC3_DIR0_ON) == MCDRV_SRC3_DIR0_ON)
+	|| (((gsGlobalInfo.sPathInfo.asMix[0].abSrcOnOff[MCDRV_SRC_AE_BLOCK] & MCDRV_SRC6_AE_ON) == MCDRV_SRC6_AE_ON)
+		&& (McResCtrl_GetAESource() == eMCDRV_SRC_DIR0)))
+	{
+		for(bCh = 0; bCh < DIO0_VOL_CHANNELS; bCh++)
+		{
+			psVolInfo->aswD_Dir0Att[bCh]	= GetDigitalVolReg(gsGlobalInfo.sVolInfo.aswD_Dir0Att[bCh]);
+		}
+	}
+	else
+	{
+		for(bCh = 0; bCh < DIO0_VOL_CHANNELS; bCh++)
+		{
+			psVolInfo->aswD_Dir0Att[bCh]	= MCDRV_REG_MUTE;
+		}
+	}
+	if(McResCtrl_IsSrcUsed(eMCDRV_SRC_DIR1) == 0)
+	{/*	DIR1 is unused	*/
+		for(bCh = 0; bCh < DIO1_VOL_CHANNELS; bCh++)
+		{
+			psVolInfo->aswD_Dir1[bCh]		= MCDRV_REG_MUTE;
+		}
+	}
+	else
+	{
+		for(bCh = 0; bCh < DIO1_VOL_CHANNELS; bCh++)
+		{
+			psVolInfo->aswD_Dir1[bCh]		= GetDigitalVolReg(gsGlobalInfo.sVolInfo.aswD_Dir1[bCh] - swGainUp);
+		}
+	}
+	if(((gsGlobalInfo.sPathInfo.asMix[0].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK] & MCDRV_SRC3_DIR1_ON) == MCDRV_SRC3_DIR1_ON)
+	|| (((gsGlobalInfo.sPathInfo.asMix[0].abSrcOnOff[MCDRV_SRC_AE_BLOCK] & MCDRV_SRC6_AE_ON) == MCDRV_SRC6_AE_ON)
+		&& (McResCtrl_GetAESource() == eMCDRV_SRC_DIR1)))
+	{
+		for(bCh = 0; bCh < DIO1_VOL_CHANNELS; bCh++)
+		{
+			psVolInfo->aswD_Dir1Att[bCh]	= GetDigitalVolReg(gsGlobalInfo.sVolInfo.aswD_Dir1Att[bCh]);
+		}
+	}
+	else
+	{
+		for(bCh = 0; bCh < DIO1_VOL_CHANNELS; bCh++)
+		{
+			psVolInfo->aswD_Dir1Att[bCh]	= MCDRV_REG_MUTE;
+		}
+	}
+	if(McResCtrl_IsSrcUsed(eMCDRV_SRC_DIR2) == 0)
+	{/*	DIR2 is unused	*/
+		for(bCh = 0; bCh < DIO2_VOL_CHANNELS; bCh++)
+		{
+			psVolInfo->aswD_Dir2[bCh]		= MCDRV_REG_MUTE;
+		}
+	}
+	else
+	{
+		for(bCh = 0; bCh < DIO2_VOL_CHANNELS; bCh++)
+		{
+			psVolInfo->aswD_Dir2[bCh]		= GetDigitalVolReg(gsGlobalInfo.sVolInfo.aswD_Dir2[bCh] - swGainUp);
+		}
+	}
+	if(((gsGlobalInfo.sPathInfo.asMix[0].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK] & MCDRV_SRC3_DIR2_ON) == MCDRV_SRC3_DIR2_ON)
+	|| (((gsGlobalInfo.sPathInfo.asMix[0].abSrcOnOff[MCDRV_SRC_AE_BLOCK] & MCDRV_SRC6_AE_ON) == MCDRV_SRC6_AE_ON)
+		&& (McResCtrl_GetAESource() == eMCDRV_SRC_DIR2)))
+	{
+		for(bCh = 0; bCh < DIO2_VOL_CHANNELS; bCh++)
+		{
+			psVolInfo->aswD_Dir2Att[bCh]	= GetDigitalVolReg(gsGlobalInfo.sVolInfo.aswD_Dir2Att[bCh]);
+		}
+	}
+	else
+	{
+		for(bCh = 0; bCh < DIO2_VOL_CHANNELS; bCh++)
+		{
+			psVolInfo->aswD_Dir2Att[bCh]	= MCDRV_REG_MUTE;
+		}
+	}
+
+	if(McResCtrl_GetDITSource(eMCDRV_DIO_0) == eMCDRV_SRC_NONE)
+	{/*	DIT0 source all off	*/
+		for(bCh = 0; bCh < DIO0_VOL_CHANNELS; bCh++)
+		{
+			psVolInfo->aswD_Dit0[bCh]	= MCDRV_REG_MUTE;
+		}
+	}
+	else
+	{
+		for(bCh = 0; bCh < DIO0_VOL_CHANNELS; bCh++)
+		{
+			psVolInfo->aswD_Dit0[bCh]	= GetDigitalVolReg(gsGlobalInfo.sVolInfo.aswD_Dit0[bCh] + swGainUp);
+		}
+	}
+	if(McResCtrl_GetDITSource(eMCDRV_DIO_1) == eMCDRV_SRC_NONE)
+	{/*	DIT1 source all off	*/
+		for(bCh = 0; bCh < DIO1_VOL_CHANNELS; bCh++)
+		{
+			psVolInfo->aswD_Dit1[bCh]	= MCDRV_REG_MUTE;
+		}
+	}
+	else
+	{
+		for(bCh = 0; bCh < DIO1_VOL_CHANNELS; bCh++)
+		{
+			psVolInfo->aswD_Dit1[bCh]	= GetDigitalVolReg(gsGlobalInfo.sVolInfo.aswD_Dit1[bCh] + swGainUp);
+		}
+	}
+	if(McResCtrl_GetDITSource(eMCDRV_DIO_2) == eMCDRV_SRC_NONE)
+	{/*	DIT2 source all off	*/
+		for(bCh = 0; bCh < DIO2_VOL_CHANNELS; bCh++)
+		{
+			psVolInfo->aswD_Dit2[bCh]	= MCDRV_REG_MUTE;
+		}
+	}
+	else
+	{
+		for(bCh = 0; bCh < DIO2_VOL_CHANNELS; bCh++)
+		{
+			psVolInfo->aswD_Dit2[bCh]	= GetDigitalVolReg(gsGlobalInfo.sVolInfo.aswD_Dit2[bCh] + swGainUp);
+		}
+	}
+
+	if((McResCtrl_GetDACSource(eMCDRV_DAC_MASTER) == eMCDRV_SRC_NONE)
+	&& (McResCtrl_GetDACSource(eMCDRV_DAC_VOICE) == eMCDRV_SRC_NONE))
+	{
+		for(bCh = 0; bCh < DAC_VOL_CHANNELS; bCh++)
+		{
+			psVolInfo->aswD_DacAtt[bCh]		= MCDRV_REG_MUTE;
+			psVolInfo->aswD_DacMaster[bCh]	= MCDRV_REG_MUTE;
+			psVolInfo->aswD_DacVoice[bCh]	= MCDRV_REG_MUTE;
+		}
+	}
+	else
+	{
+		if(McResCtrl_GetDACSource(eMCDRV_DAC_MASTER) == eMCDRV_SRC_NONE)
+		{
+			for(bCh = 0; bCh < DAC_VOL_CHANNELS; bCh++)
+			{
+				psVolInfo->aswD_DacMaster[bCh]	= MCDRV_REG_MUTE;
+			}
+		}
+		else
+		{
+			for(bCh = 0; bCh < DAC_VOL_CHANNELS; bCh++)
+			{
+				psVolInfo->aswD_DacMaster[bCh]	= GetDigitalVolReg(gsGlobalInfo.sVolInfo.aswD_DacMaster[bCh]);
+			}
+		}
+		if(McResCtrl_GetDACSource(eMCDRV_DAC_VOICE) == eMCDRV_SRC_NONE)
+		{
+			for(bCh = 0; bCh < DAC_VOL_CHANNELS; bCh++)
+			{
+				psVolInfo->aswD_DacVoice[bCh]	= MCDRV_REG_MUTE;
+			}
+		}
+		else
+		{
+			for(bCh = 0; bCh < DAC_VOL_CHANNELS; bCh++)
+			{
+				psVolInfo->aswD_DacVoice[bCh]	= GetDigitalVolReg(gsGlobalInfo.sVolInfo.aswD_DacVoice[bCh]);
+			}
+		}
+		for(bCh = 0; bCh < DAC_VOL_CHANNELS; bCh++)
+		{
+			psVolInfo->aswD_DacAtt[bCh]	= GetDigitalVolReg(gsGlobalInfo.sVolInfo.aswD_DacAtt[bCh]);
+		}
+	}
+
+	if((McResCtrl_IsSrcUsed(eMCDRV_SRC_PDM) == 0)
+	&& (McResCtrl_IsSrcUsed(eMCDRV_SRC_ADC0) == 0))
+	{/*	PDM&ADC0 is unused	*/
+		for(bCh = 0; bCh < AENG6_VOL_CHANNELS; bCh++)
+		{
+			psVolInfo->aswD_Aeng6[bCh]	= MCDRV_REG_MUTE;
+		}
+	}
+	else
+	{
+		for(bCh = 0; bCh < AENG6_VOL_CHANNELS; bCh++)
+		{
+			psVolInfo->aswD_Aeng6[bCh]	= GetDigitalVolReg(gsGlobalInfo.sVolInfo.aswD_Aeng6[bCh]);
+		}
+	}
+
+	if(McResCtrl_IsSrcUsed(eMCDRV_SRC_PDM) == 0)
+	{/*	PDM is unused	*/
+		for(bCh = 0; bCh < PDM_VOL_CHANNELS; bCh++)
+		{
+			psVolInfo->aswD_Pdm[bCh]		= MCDRV_REG_MUTE;
+			psVolInfo->aswD_SideTone[bCh]	= MCDRV_REG_MUTE;
+		}
+	}
+	else
+	{
+		for(bCh = 0; bCh < PDM_VOL_CHANNELS; bCh++)
+		{
+			psVolInfo->aswD_Pdm[bCh]		= GetDigitalVolReg(gsGlobalInfo.sVolInfo.aswD_Pdm[bCh] - swGainUp);
+			psVolInfo->aswD_SideTone[bCh]	= GetDigitalVolReg(gsGlobalInfo.sVolInfo.aswD_SideTone[bCh] - swGainUp);
+		}
+	}
+
+	if(McDevProf_IsValid(eMCDRV_FUNC_DTMF) == 1)
+	{
+		/*	DTMF	*/
+		for(bCh = 0; bCh < DTMF_VOL_CHANNELS; bCh++)
+		{
+			psVolInfo->aswD_Dtmfb[bCh]		= GetDigitalVolReg(gsGlobalInfo.sVolInfo.aswD_Dtmfb[bCh] - swGainUp);
+			psVolInfo->aswD_DtmfAtt[bCh]	= GetDigitalVolReg(gsGlobalInfo.sVolInfo.aswD_DtmfAtt[bCh] - swGainUp);
+		}
+	}
+
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncOut("McResCtrl_GetVolReg", 0);
+#endif
+}
+
+/****************************************************************************
+ *	GetDigitalVolReg
+ *
+ *	Description:
+ *			Get value of digital volume registers.
+ *	Arguments:
+ *			swVol	volume(dB value*256)
+ *	Return:
+ *			value of registers
+ *
+ ****************************************************************************/
+static SINT16	GetDigitalVolReg
+(
+	SINT16	swVol
+)
+{
+	SINT16	swRet;
+
+#if (MCDRV_DEBUG_LEVEL>=4)
+	SINT32	sdRet;
+	McDebugLog_FuncIn("GetDigitalVolReg");
+#endif
+
+	if(swVol < (-74*256))
+	{
+		swRet	= 0;
+	}
+	else if(swVol < 0)
+	{
+		swRet	= 96 + (swVol-128)/256;
+	}
+	else
+	{
+		swRet	= 96 + (swVol+128)/256;
+	}
+
+	if(swRet < 22)
+	{
+		swRet	= 0;
+	}
+
+	if(swRet > 114)
+	{
+		swRet	= 114;
+	}
+
+#if (MCDRV_DEBUG_LEVEL>=4)
+	sdRet	= swRet;
+	McDebugLog_FuncOut("GetDigitalVolReg", &sdRet);
+#endif
+
+	return swRet;
+}
+
+/****************************************************************************
+ *	GetADVolReg
+ *
+ *	Description:
+ *			Get update value of analog AD volume registers.
+ *	Arguments:
+ *			swVol	volume(dB value*256)
+ *	Return:
+ *			value of registers
+ *
+ ****************************************************************************/
+static SINT16	GetADVolReg
+(
+	SINT16	swVol
+)
+{
+	SINT16	swRet;
+
+#if (MCDRV_DEBUG_LEVEL>=4)
+	SINT32	sdRet;
+	McDebugLog_FuncIn("GetADVolReg");
+#endif
+
+	if(swVol < (-27*256))
+	{
+		swRet	= 0;
+	}
+	else if(swVol < 0)
+	{
+		swRet	= 19 + (swVol-192) * 2 / (256*3);
+	}
+	else
+	{
+		swRet	= 19 + (swVol+192) * 2 / (256*3);
+	}
+
+	if(swRet < 0)
+	{
+		swRet	= 0;
+	}
+
+	if(swRet > 31)
+	{
+		swRet	= 31;
+	}
+
+#if (MCDRV_DEBUG_LEVEL>=4)
+	sdRet	= swRet;
+	McDebugLog_FuncOut("GetADVolReg", &sdRet);
+#endif
+
+	return swRet;
+}
+
+/****************************************************************************
+ *	GetLIVolReg
+ *
+ *	Description:
+ *			Get update value of analog LIN volume registers.
+ *	Arguments:
+ *			swVol	volume(dB value*256)
+ *	Return:
+ *			value of registers
+ *
+ ****************************************************************************/
+static SINT16	GetLIVolReg
+(
+	SINT16	swVol
+)
+{
+	SINT16	swRet;
+
+#if (MCDRV_DEBUG_LEVEL>=4)
+	SINT32	sdRet;
+	McDebugLog_FuncIn("GetLIVolReg");
+#endif
+
+	if(swVol < (-30*256))
+	{
+		swRet	= 0;
+	}
+	else if(swVol < 0)
+	{
+		swRet	= 21 + (swVol-192) * 2 / (256*3);
+	}
+	else
+	{
+		swRet	= 21 + (swVol+192) * 2 / (256*3);
+	}
+
+	if(swRet < 0)
+	{
+		swRet	= 0;
+	}
+	if(swRet > 31)
+	{
+		swRet	= 31;
+	}
+
+#if (MCDRV_DEBUG_LEVEL>=4)
+	sdRet	= swRet;
+	McDebugLog_FuncOut("GetLIVolReg", &sdRet);
+#endif
+	return swRet;
+}
+
+/****************************************************************************
+ *	GetMcVolReg
+ *
+ *	Description:
+ *			Get update value of analog Mic volume registers.
+ *	Arguments:
+ *			swVol	volume(dB value*256)
+ *	Return:
+ *			value of registers
+ *
+ ****************************************************************************/
+static SINT16	GetMcVolReg
+(
+	SINT16	swVol
+)
+{
+	SINT16	swRet;
+
+#if (MCDRV_DEBUG_LEVEL>=4)
+	SINT32	sdRet;
+	McDebugLog_FuncIn("GetMcVolReg");
+#endif
+
+	if(swVol < (-30*256))
+	{
+		swRet	= 0;
+	}
+	else if(swVol < 0)
+	{
+		swRet	= 21 + (swVol-192) * 2 / (256*3);
+	}
+	else
+	{
+		swRet	= 21 + (swVol+192) * 2 / (256*3);
+	}
+
+	if(swRet < 0)
+	{
+		swRet	= 0;
+	}
+	if(swRet > 31)
+	{
+		swRet	= 31;
+	}
+
+#if (MCDRV_DEBUG_LEVEL>=4)
+	sdRet	= swRet;
+	McDebugLog_FuncOut("GetMcVolReg", &sdRet);
+#endif
+	return swRet;
+}
+
+/****************************************************************************
+ *	GetMcGainReg
+ *
+ *	Description:
+ *			Get update value of analog Mic gain registers.
+ *	Arguments:
+ *			swVol	volume(dB value*256)
+ *	Return:
+ *			value of registers
+ *
+ ****************************************************************************/
+static SINT16	GetMcGainReg
+(
+	SINT16	swVol
+)
+{
+	SINT16	swGain	= (swVol+128)/256;
+	SINT16	swRet	= 3;
+
+#if (MCDRV_DEBUG_LEVEL>=4)
+	SINT32	sdRet;
+	McDebugLog_FuncIn("GetMcGainReg");
+#endif
+
+	if(swGain < 18)
+	{
+		swRet	= 0;
+	}
+	else if(swGain < 23)
+	{
+		swRet	= 1;
+	}
+	else if(swGain < 28)
+	{
+		swRet	= 2;
+	}
+	else
+	{
+	}
+
+#if (MCDRV_DEBUG_LEVEL>=4)
+	sdRet	= swRet;
+	McDebugLog_FuncOut("GetMcGainReg", &sdRet);
+#endif
+
+	return swRet;
+}
+
+/****************************************************************************
+ *	GetHpVolReg
+ *
+ *	Description:
+ *			Get update value of analog Hp volume registers.
+ *	Arguments:
+ *			swVol	volume(dB value*256)
+ *	Return:
+ *			value of registers
+ *
+ ****************************************************************************/
+static SINT16	GetHpVolReg
+(
+	SINT16	swVol
+)
+{
+	SINT16	swDB	= swVol/256;
+	SINT16	swRet;
+
+#if (MCDRV_DEBUG_LEVEL>=4)
+	SINT32	sdRet;
+	McDebugLog_FuncIn("GetHpVolReg");
+#endif
+
+	if(swVol >= 0)
+	{
+		swRet	= 31;
+	}
+	else if(swDB <= -8)
+	{
+		if(swVol < (-36*256))
+		{
+			swRet	= 0;
+		}
+		else if(swDB <= -32)
+		{
+			swRet	= 1;
+		}
+		else if(swDB <= -26)
+		{
+			swRet	= 2;
+		}
+		else if(swDB <= -23)
+		{
+			swRet	= 3;
+		}
+		else if(swDB <= -21)
+		{
+			swRet	= 4;
+		}
+		else if(swDB <= -19)
+		{
+			swRet	= 5;
+		}
+		else if(swDB <= -17)
+		{
+			swRet	= 6;
+		}
+		else
+		{
+			swRet	= 23+(swVol-128)/256;
+		}
+	}
+	else
+	{
+		swRet	= 31 + (swVol-64)*2/256;
+	}
+
+#if (MCDRV_DEBUG_LEVEL>=4)
+	sdRet	= swRet;
+	McDebugLog_FuncOut("GetHpVolReg", &sdRet);
+#endif
+
+	return swRet;
+}
+
+/****************************************************************************
+ *	GetHpGainReg
+ *
+ *	Description:
+ *			Get update value of analog Hp gain registers.
+ *	Arguments:
+ *			swVol	volume(dB value*256)
+ *	Return:
+ *			value of registers
+ *
+ ****************************************************************************/
+static SINT16	GetHpGainReg
+(
+	SINT16	swVol
+)
+{
+	SINT16	swDB	= swVol/(256/4);
+	SINT16	swRet;
+
+#if (MCDRV_DEBUG_LEVEL>=4)
+	SINT32	sdRet;
+	McDebugLog_FuncIn("GetHpGainReg");
+#endif
+
+	if(swDB < 3)
+	{
+		swRet	= 0;
+	}
+	else if(swDB < 9)
+	{
+		swRet	= 1;
+	}
+	else if(swDB < 18)
+	{
+		swRet	= 2;
+	}
+	else
+	{
+		swRet	= 3;
+	}
+
+#if (MCDRV_DEBUG_LEVEL>=4)
+	sdRet	= swRet;
+	McDebugLog_FuncOut("GetHpGainReg", &sdRet);
+#endif
+
+	return swRet;
+}
+
+/****************************************************************************
+ *	GetSpVolReg
+ *
+ *	Description:
+ *			Get update value of analog Sp volume registers.
+ *	Arguments:
+ *			swVol	volume(dB value*256)
+ *	Return:
+ *			value of registers
+ *
+ ****************************************************************************/
+static SINT16	GetSpVolReg
+(
+	SINT16	swVol
+)
+{
+	SINT16	swDB	= swVol/256;
+	SINT16	swRet;
+
+#if (MCDRV_DEBUG_LEVEL>=4)
+	SINT32	sdRet;
+	McDebugLog_FuncIn("GetSpVolReg");
+#endif
+
+	if(swVol >= 0)
+	{
+		swRet	= 31;
+	}
+	else if(swDB <= -8)
+	{
+		if(swVol < (-36*256))
+		{
+			swRet	= 0;
+		}
+		else if(swDB <= -32)
+		{
+			swRet	= 1;
+		}
+		else if(swDB <= -26)
+		{
+			swRet	= 2;
+		}
+		else if(swDB <= -23)
+		{
+			swRet	= 3;
+		}
+		else if(swDB <= -21)
+		{
+			swRet	= 4;
+		}
+		else if(swDB <= -19)
+		{
+			swRet	= 5;
+		}
+		else if(swDB <= -17)
+		{
+			swRet	= 6;
+		}
+		else
+		{
+			swRet	= 23+(swVol-128)/256;
+		}
+	}
+	else
+	{
+		swRet	= 31 + (swVol-64)*2/256;
+	}
+
+#if (MCDRV_DEBUG_LEVEL>=4)
+	sdRet	= swRet;
+	McDebugLog_FuncOut("GetSpVolReg", &sdRet);
+#endif
+
+	return swRet;
+}
+
+/****************************************************************************
+ *	GetRcVolReg
+ *
+ *	Description:
+ *			Get update value of analog Rcv volume registers.
+ *	Arguments:
+ *			swVol	volume(dB value*256)
+ *	Return:
+ *			value of registers
+ *
+ ****************************************************************************/
+static SINT16	GetRcVolReg
+(
+	SINT16	swVol
+)
+{
+	SINT16	swDB	= swVol/256;
+	SINT16	swRet;
+
+#if (MCDRV_DEBUG_LEVEL>=4)
+	SINT32	sdRet;
+	McDebugLog_FuncIn("GetRcVolReg");
+#endif
+
+	if(swVol >= 0)
+	{
+		swRet	= 31;
+	}
+	else if(swDB <= -8)
+	{
+		if(swVol < (-36*256))
+		{
+			swRet	= 0;
+		}
+		else if(swDB <= -32)
+		{
+			swRet	= 1;
+		}
+		else if(swDB <= -26)
+		{
+			swRet	= 2;
+		}
+		else if(swDB <= -23)
+		{
+			swRet	= 3;
+		}
+		else if(swDB <= -21)
+		{
+			swRet	= 4;
+		}
+		else if(swDB <= -19)
+		{
+			swRet	= 5;
+		}
+		else if(swDB <= -17)
+		{
+			swRet	= 6;
+		}
+		else
+		{
+			swRet	= 23+(swVol-128)/256;
+		}
+	}
+	else
+	{
+		swRet	= 31 + (swVol-64)*2/256;
+	}
+
+#if (MCDRV_DEBUG_LEVEL>=4)
+	sdRet	= swRet;
+	McDebugLog_FuncOut("GetRcVolReg", &sdRet);
+#endif
+
+	return swRet;
+}
+
+/****************************************************************************
+ *	GetLoVolReg
+ *
+ *	Description:
+ *			Get update value of analog Lout volume registers.
+ *	Arguments:
+ *			swVol	volume(dB value*256)
+ *	Return:
+ *			value of registers
+ *
+ ****************************************************************************/
+static SINT16	GetLoVolReg
+(
+	SINT16	swVol
+)
+{
+	SINT16	swRet	= 31 + (swVol-128)/256;
+
+#if (MCDRV_DEBUG_LEVEL>=4)
+	SINT32	sdRet;
+	McDebugLog_FuncIn("GetLoVolReg");
+#endif
+
+	if(swVol < (-30*256))
+	{
+		swRet	= 0;
+	}
+	if(swRet < 0)
+	{
+		swRet	= 0;
+	}
+	if(swRet > 31)
+	{
+		swRet	= 31;
+	}
+
+#if (MCDRV_DEBUG_LEVEL>=4)
+	sdRet	= swRet;
+	McDebugLog_FuncOut("GetLoVolReg", &sdRet);
+#endif
+	return swRet;
+}
+
+/****************************************************************************
+ *	McResCtrl_GetPowerInfo
+ *
+ *	Description:
+ *			Get power information.
+ *	Arguments:
+ *			psPowerInfo	power information
+ *	Return:
+ *			none
+ *
+ ****************************************************************************/
+void	McResCtrl_GetPowerInfo
+(
+	MCDRV_POWER_INFO*	psPowerInfo
+)
+{
+	UINT8	i;
+	UINT8	bAnalogOn	= 0;
+	UINT8	bPowerMode	= gsGlobalInfo.sInitInfo.bPowerMode;
+
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncIn("McResCtrl_GetPowerInfo");
+#endif
+
+	/*	Digital power	*/
+	psPowerInfo->dDigital	= 0;
+	if((bPowerMode & MCDRV_POWMODE_CLKON) == 0)
+	{
+		psPowerInfo->dDigital |= (MCDRV_POWINFO_DIGITAL_DP0 | MCDRV_POWINFO_DIGITAL_DP1 | MCDRV_POWINFO_DIGITAL_DP2 | MCDRV_POWINFO_DIGITAL_PLLRST0);
+	}
+	if((McResCtrl_GetDITSource(eMCDRV_DIO_0)	!= eMCDRV_SRC_NONE)
+	|| (McResCtrl_GetDITSource(eMCDRV_DIO_1)	!= eMCDRV_SRC_NONE)
+	|| (McResCtrl_GetDITSource(eMCDRV_DIO_2)	!= eMCDRV_SRC_NONE)
+	|| (McResCtrl_IsSrcUsed(eMCDRV_SRC_DAC_L)	!= 0)
+	|| (McResCtrl_IsSrcUsed(eMCDRV_SRC_DAC_M)	!= 0)
+	|| (McResCtrl_IsSrcUsed(eMCDRV_SRC_DAC_R)	!= 0)
+	|| (McResCtrl_IsSrcUsed(eMCDRV_SRC_ADC0)	!= 0)
+	|| (McResCtrl_IsSrcUsed(eMCDRV_SRC_AE)		!= 0)
+	|| (McResCtrl_IsSrcUsed(eMCDRV_SRC_MIX)		!= 0))
+	{
+		/*	DP0-2, PLLRST0 on	*/
+		psPowerInfo->dDigital &= ~(MCDRV_POWINFO_DIGITAL_DP0 | MCDRV_POWINFO_DIGITAL_DP1 | MCDRV_POWINFO_DIGITAL_DP2 | MCDRV_POWINFO_DIGITAL_PLLRST0);
+	}
+	else
+	{
+		psPowerInfo->dDigital |= MCDRV_POWINFO_DIGITAL_DPB;
+	}
+
+	/*	DPBDSP	*/
+	if((McResCtrl_IsSrcUsed(eMCDRV_SRC_AE) == 0)
+	|| ((gsGlobalInfo.sAeInfo.bOnOff&(MCDRV_BEXWIDE_ON|MCDRV_DRC_ON)) == 0))
+	{
+		psPowerInfo->dDigital |= MCDRV_POWINFO_DIGITAL_DPBDSP;
+	}
+
+	/*	DPADIF	*/
+	if(McResCtrl_IsSrcUsed(eMCDRV_SRC_ADC0) == 0)
+	{
+		psPowerInfo->dDigital |= MCDRV_POWINFO_DIGITAL_DPADIF;
+	}
+
+	/*	DPPDM	*/
+	if((gsGlobalInfo.sInitInfo.bPad0Func != MCDRV_PAD_PDMCK) || (McResCtrl_IsSrcUsed(eMCDRV_SRC_PDM) == 0))
+	{
+		psPowerInfo->dDigital |= MCDRV_POWINFO_DIGITAL_DPPDM;
+	}
+
+	/*	DPDI*	*/
+	if((gsGlobalInfo.sDioInfo.asPortInfo[0].sDioCommon.bMasterSlave == MCDRV_DIO_SLAVE)
+	|| (((McResCtrl_IsSrcUsed(eMCDRV_SRC_DIR0) == 0) && (McResCtrl_GetDITSource(eMCDRV_DIO_0) == eMCDRV_SRC_NONE))))
+	{
+		psPowerInfo->dDigital |= MCDRV_POWINFO_DIGITAL_DPDI0;
+	}
+	if((gsGlobalInfo.sDioInfo.asPortInfo[1].sDioCommon.bMasterSlave == MCDRV_DIO_SLAVE)
+	|| (((McResCtrl_IsSrcUsed(eMCDRV_SRC_DIR1) == 0) && (McResCtrl_GetDITSource(eMCDRV_DIO_1) == eMCDRV_SRC_NONE))))
+	{
+		psPowerInfo->dDigital |= MCDRV_POWINFO_DIGITAL_DPDI1;
+	}
+	if((gsGlobalInfo.sDioInfo.asPortInfo[2].sDioCommon.bMasterSlave == MCDRV_DIO_SLAVE)
+	|| (((McResCtrl_IsSrcUsed(eMCDRV_SRC_DIR2) == 0) && (McResCtrl_GetDITSource(eMCDRV_DIO_2) == eMCDRV_SRC_NONE))))
+	{
+		psPowerInfo->dDigital |= MCDRV_POWINFO_DIGITAL_DPDI2;
+	}
+
+	/*	Analog power	*/
+	for(i = 0; i < 5; i++)
+	{
+		psPowerInfo->abAnalog[i]	= 0;
+	}
+
+	/*	SPL*	*/
+	if(McResCtrl_IsDstUsed(eMCDRV_DST_SP, eMCDRV_DST_CH0) == 0)
+	{
+		psPowerInfo->abAnalog[1] |= MCB_PWM_SPL1;
+		psPowerInfo->abAnalog[1] |= MCB_PWM_SPL2;
+	}
+	else
+	{
+		bAnalogOn	= 1;
+	}
+	/*	SPR*	*/
+	if(McResCtrl_IsDstUsed(eMCDRV_DST_SP, eMCDRV_DST_CH1) == 0)
+	{
+		psPowerInfo->abAnalog[1] |= MCB_PWM_SPR1;
+		psPowerInfo->abAnalog[1] |= MCB_PWM_SPR2;
+	}
+	else
+	{
+		bAnalogOn	= 1;
+	}
+
+	/*	HPL	*/
+	if(McResCtrl_IsDstUsed(eMCDRV_DST_HP, eMCDRV_DST_CH0) == 0)
+	{
+		psPowerInfo->abAnalog[1] |= MCB_PWM_HPL;
+	}
+	else
+	{
+		bAnalogOn	= 1;
+	}
+	/*	HPR	*/
+	if(McResCtrl_IsDstUsed(eMCDRV_DST_HP, eMCDRV_DST_CH1) == 0)
+	{
+		psPowerInfo->abAnalog[1] |= MCB_PWM_HPR;
+	}
+	else
+	{
+		bAnalogOn	= 1;
+	}
+	/*	CP	*/
+	if(((psPowerInfo->abAnalog[1] & MCB_PWM_HPL) != 0) && ((psPowerInfo->abAnalog[1] & MCB_PWM_HPR) != 0))
+	{
+		psPowerInfo->abAnalog[0] |= MCB_PWM_CP;
+	}
+
+	/*	LOUT1L	*/
+	if(McResCtrl_IsDstUsed(eMCDRV_DST_LOUT1, eMCDRV_DST_CH0) == 0)
+	{
+		psPowerInfo->abAnalog[2] |= MCB_PWM_LO1L;
+	}
+	else
+	{
+		bAnalogOn	= 1;
+	}
+	/*	LOUT1R	*/
+	if(McResCtrl_IsDstUsed(eMCDRV_DST_LOUT1, eMCDRV_DST_CH1) == 0)
+	{
+		psPowerInfo->abAnalog[2] |= MCB_PWM_LO1R;
+	}
+	else
+	{
+		bAnalogOn	= 1;
+	}
+	/*	LOUT2L	*/
+	if(McResCtrl_IsDstUsed(eMCDRV_DST_LOUT2, eMCDRV_DST_CH0) == 0)
+	{
+		psPowerInfo->abAnalog[2] |= MCB_PWM_LO2L;
+	}
+	else
+	{
+		bAnalogOn	= 1;
+	}
+	/*	LOUT2R	*/
+	if(McResCtrl_IsDstUsed(eMCDRV_DST_LOUT2, eMCDRV_DST_CH1) == 0)
+	{
+		psPowerInfo->abAnalog[2] |= MCB_PWM_LO2R;
+	}
+	else
+	{
+		bAnalogOn	= 1;
+	}
+	/*	RCV	*/
+	if(McResCtrl_IsDstUsed(eMCDRV_DST_RCV, eMCDRV_DST_CH0) == 0)
+	{
+		psPowerInfo->abAnalog[2] |= MCB_PWM_RC1;
+		psPowerInfo->abAnalog[2] |= MCB_PWM_RC2;
+	}
+	else
+	{
+		bAnalogOn	= 1;
+	}
+	/*	DA	*/
+	if((McResCtrl_IsDstUsed(eMCDRV_DST_DAC, eMCDRV_DST_CH0) == 0)
+	&& (McResCtrl_IsDstUsed(eMCDRV_DST_DAC, eMCDRV_DST_CH1) == 0))
+	{
+		psPowerInfo->abAnalog[3] |= MCB_PWM_DAL;
+		psPowerInfo->abAnalog[3] |= MCB_PWM_DAR;
+	}
+	else
+	{
+		if((McResCtrl_IsSrcUsed(eMCDRV_SRC_DAC_L) == 0)
+		&& (McResCtrl_IsSrcUsed(eMCDRV_SRC_DAC_M) == 0))
+		{
+			psPowerInfo->abAnalog[3] |= MCB_PWM_DAL;
+		}
+		if((McResCtrl_IsSrcUsed(eMCDRV_SRC_DAC_R) == 0)
+		&& (McResCtrl_IsSrcUsed(eMCDRV_SRC_DAC_M) == 0))
+		{
+			psPowerInfo->abAnalog[3] |= MCB_PWM_DAR;
+		}
+		bAnalogOn	= 1;
+	}
+	/*	ADC0L	*/
+	if(McResCtrl_IsDstUsed(eMCDRV_DST_ADC0, eMCDRV_DST_CH0) == 1)
+	{
+		bAnalogOn	= 1;
+	}
+	else
+	{
+		if((McDevProf_IsValid(eMCDRV_FUNC_LI2) == 1)
+		&& (((gsGlobalInfo.sPathInfo.asAdc0[0].abSrcOnOff[MCDRV_SRC_LINE2_L_BLOCK] & MCDRV_SRC2_LINE2_L_ON) == MCDRV_SRC2_LINE2_L_ON)
+			|| ((gsGlobalInfo.sPathInfo.asAdc0[0].abSrcOnOff[MCDRV_SRC_LINE2_M_BLOCK] & MCDRV_SRC2_LINE2_M_ON) == MCDRV_SRC2_LINE2_M_ON)))
+		{
+			bAnalogOn	= 1;
+		}
+		else
+		{
+			psPowerInfo->abAnalog[1] |= MCB_PWM_ADL;
+		}
+	}
+	/*	ADC0R	*/
+	if(McResCtrl_IsDstUsed(eMCDRV_DST_ADC0, eMCDRV_DST_CH1) == 1)
+	{
+		bAnalogOn	= 1;
+	}
+	else
+	{
+		if((McDevProf_IsValid(eMCDRV_FUNC_LI2) == 1)
+		&& (((gsGlobalInfo.sPathInfo.asAdc0[1].abSrcOnOff[MCDRV_SRC_LINE2_R_BLOCK] & MCDRV_SRC2_LINE2_R_ON) == MCDRV_SRC2_LINE2_R_ON)
+			|| ((gsGlobalInfo.sPathInfo.asAdc0[1].abSrcOnOff[MCDRV_SRC_LINE2_M_BLOCK] & MCDRV_SRC2_LINE2_M_ON) == MCDRV_SRC2_LINE2_M_ON)))
+		{
+			bAnalogOn	= 1;
+		}
+		else
+		{
+			psPowerInfo->abAnalog[1] |= MCB_PWM_ADR;
+		}
+	}
+	if(McDevProf_IsValid(eMCDRV_FUNC_ADC1) == 1)
+	{
+	}
+	/*	LI	*/
+	if((McResCtrl_IsSrcUsed(eMCDRV_SRC_LINE1_L) == 0)
+	&& (McResCtrl_IsSrcUsed(eMCDRV_SRC_LINE1_M) == 0)
+	&& (McResCtrl_IsSrcUsed(eMCDRV_SRC_LINE1_R) == 0))
+	{
+		psPowerInfo->abAnalog[4] |= MCB_PWM_LI;
+	}
+	else
+	{
+		bAnalogOn	= 1;
+	}
+	if(McDevProf_IsValid(eMCDRV_FUNC_LI2) == 1)
+	{
+		if((McResCtrl_IsSrcUsed(eMCDRV_SRC_LINE2_L) == 0)
+		&& (McResCtrl_IsSrcUsed(eMCDRV_SRC_LINE2_M) == 0)
+		&& (McResCtrl_IsSrcUsed(eMCDRV_SRC_LINE2_R) == 0))
+		{
+			/*psPowerInfo->abAnalog[4] |= MCB_PWM_LI2;*/
+		}
+		else
+		{
+			bAnalogOn	= 1;
+		}
+	}
+	/*	MC1	*/
+	if(McResCtrl_IsSrcUsed(eMCDRV_SRC_MIC1) == 0)
+	{
+		psPowerInfo->abAnalog[4] |= MCB_PWM_MC1;
+	}
+	else
+	{
+		bAnalogOn	= 1;
+	}
+	/*	MC2	*/
+	if(McResCtrl_IsSrcUsed(eMCDRV_SRC_MIC2) == 0)
+	{
+		psPowerInfo->abAnalog[4] |= MCB_PWM_MC2;
+	}
+	else
+	{
+		bAnalogOn	= 1;
+	}
+	/*	MC3	*/
+	if(McResCtrl_IsSrcUsed(eMCDRV_SRC_MIC3) == 0)
+	{
+		psPowerInfo->abAnalog[4] |= MCB_PWM_MC3;
+	}
+	else
+	{
+		bAnalogOn	= 1;
+	}
+	if((gsGlobalInfo.sPathInfo.asBias[0].abSrcOnOff[MCDRV_SRC_MIC1_BLOCK] & MCDRV_SRC0_MIC1_ON) != MCDRV_SRC0_MIC1_ON)
+	{
+		psPowerInfo->abAnalog[3] |= MCB_PWM_MB1;
+	}
+	else
+	{
+		bAnalogOn	= 1;
+	}
+	if((gsGlobalInfo.sPathInfo.asBias[0].abSrcOnOff[MCDRV_SRC_MIC2_BLOCK] & MCDRV_SRC0_MIC2_ON) != MCDRV_SRC0_MIC2_ON)
+	{
+		psPowerInfo->abAnalog[3] |= MCB_PWM_MB2;
+	}
+	else
+	{
+		bAnalogOn	= 1;
+	}
+	if((gsGlobalInfo.sPathInfo.asBias[0].abSrcOnOff[MCDRV_SRC_MIC3_BLOCK] & MCDRV_SRC0_MIC3_ON) != MCDRV_SRC0_MIC3_ON)
+	{
+		psPowerInfo->abAnalog[3] |= MCB_PWM_MB3;
+	}
+	else
+	{
+		bAnalogOn	= 1;
+	}
+
+	/*	VR/LDOA/REFA	*/
+	if ((0 == bAnalogOn) && ((bPowerMode & MCDRV_POWMODE_VREFON) == 0))
+	{
+		psPowerInfo->abAnalog[0] |= MCB_PWM_VR;
+		psPowerInfo->abAnalog[0] |= MCB_PWM_REFA;
+		psPowerInfo->abAnalog[0] |= MCB_PWM_LDOA;
+	}
+	else
+	{
+		if (MCDRV_LDO_OFF == gsGlobalInfo.sInitInfo.bLdo)
+		{
+			psPowerInfo->abAnalog[0] |= MCB_PWM_LDOA;
+		}
+		else
+		{
+			psPowerInfo->abAnalog[0] |= MCB_PWM_REFA;
+		}
+	}
+
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncOut("McResCtrl_GetPowerInfo", 0);
+#endif
+}
+
+/****************************************************************************
+ *	McResCtrl_GetPowerInfoRegAccess
+ *
+ *	Description:
+ *			Get power information to access register.
+ *	Arguments:
+ *			psRegInfo	register information
+ *			psPowerInfo	power information
+ *	Return:
+ *			none
+ *
+ ****************************************************************************/
+void	McResCtrl_GetPowerInfoRegAccess
+(
+	const MCDRV_REG_INFO*	psRegInfo,
+	MCDRV_POWER_INFO*		psPowerInfo
+)
+{
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncIn("McResCtrl_GetPowerInfoRegAccess");
+#endif
+
+
+	McResCtrl_GetPowerInfo(psPowerInfo);
+
+	switch(psRegInfo->bRegType)
+	{
+	default:
+	case	MCDRV_REGTYPE_A:
+	case	MCDRV_REGTYPE_B_BASE:
+	case	MCDRV_REGTYPE_B_AE:
+		break;
+	case	MCDRV_REGTYPE_B_ANALOG:
+		switch(psRegInfo->bAddress)
+		{
+		case	MCI_APMOFF:
+		case	MCI_HPVOL_L:
+		case	MCI_HPVOL_R:
+		case	MCI_SPVOL_L:
+		case	MCI_SPVOL_R:
+		case	MCI_RCVOL:
+		case	MCI_HPL_MIX:
+		case	MCI_HPL_MONO:
+		case	MCI_HPR_MIX:
+		case	MCI_SPL_MIX:
+		case	MCI_SPL_MONO:
+		case	MCI_SPR_MIX:
+		case	MCI_SPR_MONO:
+		case	MCI_RC_MIX:
+			psPowerInfo->abAnalog[0]	&= (UINT8)~MCB_PWM_VR;
+			break;
+		default:
+			break;
+		}
+		break;
+
+	case	MCDRV_REGTYPE_B_CODEC:
+		switch(psRegInfo->bAddress)
+		{
+		case	MCI_DPADIF:
+		case	MCI_CD_HW_ID:
+		case	MCI_PLL_RST:
+		case	MCI_DIVR0:
+		case	MCI_DIVF0:
+		case	MCI_DIVR1:
+		case	MCI_DIVF1:
+		case	MCI_AD_AGC:
+		case	MCI_DCCUTOFF:
+		case	MCI_DCL:
+			break;
+		default:
+			if((psRegInfo->bAddress >= MCI_SYS_CEQ0_19_12) && (psRegInfo->bAddress <= MCI_SYS_CEQ4_3_0))
+			{
+				break;
+			}
+			psPowerInfo->dDigital	&= ~(MCDRV_POWINFO_DIGITAL_DP0 | MCDRV_POWINFO_DIGITAL_DP1
+										| MCDRV_POWINFO_DIGITAL_DP2 | MCDRV_POWINFO_DIGITAL_PLLRST0 | MCDRV_POWINFO_DIGITAL_DPB);
+			break;
+		}
+		break;
+
+	case	MCDRV_REGTYPE_B_MIXER:
+		switch(psRegInfo->bAddress)
+		{
+		case	MCI_SWP:
+		case	MCI_DIMODE0:
+		case	MCI_DIMODE1:
+		case	MCI_DIMODE2:
+		case	MCI_DI_FS0:
+		case	MCI_DI_FS1:
+		case	MCI_DI_FS2:
+		case	MCI_DI0_SRC:
+		case	MCI_DI1_SRC:
+		case	MCI_DI2_SRC:
+		case	MCI_DIRSRC_RATE0_MSB:
+		case	MCI_DIRSRC_RATE0_LSB:
+		case	MCI_DIRSRC_RATE1_MSB:
+		case	MCI_DIRSRC_RATE1_LSB:
+		case	MCI_DIRSRC_RATE2_MSB:
+		case	MCI_DIRSRC_RATE2_LSB:
+		case	MCI_DIX0_FMT:
+		case	MCI_DIX1_FMT:
+		case	MCI_DIX2_FMT:
+		case	MCI_DIR0_CH:
+		case	MCI_DIR1_CH:
+		case	MCI_DIR2_CH:
+		case	MCI_DIT0_SLOT:
+		case	MCI_DIT1_SLOT:
+		case	MCI_DIT2_SLOT:
+		case	MCI_HIZ_REDGE0:
+		case	MCI_HIZ_REDGE1:
+		case	MCI_HIZ_REDGE2:
+		case	MCI_PCM_RX0:
+		case	MCI_PCM_RX1:
+		case	MCI_PCM_RX2:
+		case	MCI_PCM_SLOT_RX0:
+		case	MCI_PCM_SLOT_RX1:
+		case	MCI_PCM_SLOT_RX2:
+		case	MCI_PCM_TX0:
+		case	MCI_PCM_TX1:
+		case	MCI_PCM_TX2:
+		case	MCI_PCM_SLOT_TX0:
+		case	MCI_PCM_SLOT_TX1:
+		case	MCI_PCM_SLOT_TX2:
+		case	MCI_PDM_AGC:
+		case	MCI_PDM_STWAIT:
+			break;
+		default:
+			psPowerInfo->dDigital	&= ~(MCDRV_POWINFO_DIGITAL_DP0 | MCDRV_POWINFO_DIGITAL_DP1
+										| MCDRV_POWINFO_DIGITAL_DP2 | MCDRV_POWINFO_DIGITAL_PLLRST0 | MCDRV_POWINFO_DIGITAL_DPB);
+			break;
+		}
+		break;
+
+	case	MCDRV_REGTYPE_B_CDSP:
+		break;
+	}
+
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncOut("McResCtrl_GetPowerInfoRegAccess", 0);
+#endif
+}
+
+/****************************************************************************
+ *	McResCtrl_GetCurPowerInfo
+ *
+ *	Description:
+ *			Get current power setting.
+ *	Arguments:
+ *			psPowerInfo	power information
+ *	Return:
+ *			none
+ *
+ ****************************************************************************/
+void	McResCtrl_GetCurPowerInfo
+(
+	MCDRV_POWER_INFO*	psPowerInfo
+)
+{
+	UINT8	bReg;
+
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncIn("McResCtrl_GetCurPowerInfo");
+#endif
+
+
+	psPowerInfo->abAnalog[0]	= gsGlobalInfo.abRegValB_ANA[MCI_PWM_ANALOG_0];
+	psPowerInfo->abAnalog[1]	= gsGlobalInfo.abRegValB_ANA[MCI_PWM_ANALOG_1];
+	psPowerInfo->abAnalog[2]	= gsGlobalInfo.abRegValB_ANA[MCI_PWM_ANALOG_2];
+	psPowerInfo->abAnalog[3]	= gsGlobalInfo.abRegValB_ANA[MCI_PWM_ANALOG_3];
+	psPowerInfo->abAnalog[4]	= gsGlobalInfo.abRegValB_ANA[MCI_PWM_ANALOG_4];
+
+	psPowerInfo->dDigital	= 0;
+	bReg	= gsGlobalInfo.abRegValB_CODEC[MCI_DPADIF];
+	if((bReg & (MCB_DP0_CLKI1|MCB_DP0_CLKI0)) == (MCB_DP0_CLKI1|MCB_DP0_CLKI0))
+	{
+		psPowerInfo->dDigital	|= MCDRV_POWINFO_DIGITAL_DP0;
+	}
+	bReg	= gsGlobalInfo.abRegValB_BASE[MCI_PWM_DIGITAL];
+	if((bReg & MCB_PWM_DP1) == MCB_PWM_DP1)
+	{
+		psPowerInfo->dDigital	|= MCDRV_POWINFO_DIGITAL_DP1;
+	}
+	if((bReg & MCB_PWM_DP2) == MCB_PWM_DP2)
+	{
+		psPowerInfo->dDigital	|= MCDRV_POWINFO_DIGITAL_DP2;
+	}
+
+	bReg	= gsGlobalInfo.abRegValB_BASE[MCI_PWM_DIGITAL_1];
+	if((bReg & MCB_PWM_DPB) == MCB_PWM_DPB)
+	{
+		psPowerInfo->dDigital	|= MCDRV_POWINFO_DIGITAL_DPB;
+	}
+	if((bReg & MCB_PWM_DPDI0) == MCB_PWM_DPDI0)
+	{
+		psPowerInfo->dDigital	|= MCDRV_POWINFO_DIGITAL_DPDI0;
+	}
+	if((bReg & MCB_PWM_DPDI1) == MCB_PWM_DPDI1)
+	{
+		psPowerInfo->dDigital	|= MCDRV_POWINFO_DIGITAL_DPDI1;
+	}
+	if((bReg & MCB_PWM_DPDI2) == MCB_PWM_DPDI2)
+	{
+		psPowerInfo->dDigital	|= MCDRV_POWINFO_DIGITAL_DPDI2;
+	}
+	if((bReg & MCB_PWM_DPPDM) == MCB_PWM_DPPDM)
+	{
+		psPowerInfo->dDigital	|= MCDRV_POWINFO_DIGITAL_DPPDM;
+	}
+
+	bReg	= gsGlobalInfo.abRegValB_BASE[MCI_PWM_DIGITAL_BDSP];
+	if((bReg & MCB_PWM_DPBDSP) == MCB_PWM_DPBDSP)
+	{
+		psPowerInfo->dDigital	|= MCDRV_POWINFO_DIGITAL_DPBDSP;
+	}
+
+	bReg	= gsGlobalInfo.abRegValB_CODEC[MCI_PLL_RST];
+	if((bReg & MCB_PLLRST0) == MCB_PLLRST0)
+	{
+		psPowerInfo->dDigital	|= MCDRV_POWINFO_DIGITAL_PLLRST0;
+	}
+
+	bReg	= gsGlobalInfo.abRegValB_CODEC[MCI_DPADIF];
+	if((bReg & MCB_DPADIF) == MCB_DPADIF)
+	{
+		psPowerInfo->dDigital	|= MCDRV_POWINFO_DIGITAL_DPADIF;
+	}
+
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncOut("McResCtrl_GetCurPowerInfo", 0);
+#endif
+}
+
+/****************************************************************************
+ *	McResCtrl_GetDACSource
+ *
+ *	Description:
+ *			Get DAC source information.
+ *	Arguments:
+ *			eCh	0:Master/1:Voice
+ *	Return:
+ *			path source(MCDRV_SRC_TYPE)
+ *
+ ****************************************************************************/
+MCDRV_SRC_TYPE	McResCtrl_GetDACSource
+(
+	MCDRV_DAC_CH	eCh
+)
+{
+	MCDRV_SRC_TYPE	eSrcType	= eMCDRV_SRC_NONE;
+
+#if (MCDRV_DEBUG_LEVEL>=4)
+	SINT32	sdRet;
+	McDebugLog_FuncIn("McResCtrl_GetDACSource");
+#endif
+
+
+	if((gsGlobalInfo.sPathInfo.asDac[eCh].abSrcOnOff[MCDRV_SRC_PDM_BLOCK] & MCDRV_SRC4_PDM_ON) == MCDRV_SRC4_PDM_ON)
+	{
+		eSrcType	= eMCDRV_SRC_PDM;
+	}
+	else if((gsGlobalInfo.sPathInfo.asDac[eCh].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK] & MCDRV_SRC4_ADC0_ON) == MCDRV_SRC4_ADC0_ON)
+	{
+		eSrcType	= eMCDRV_SRC_ADC0;
+	}
+	else if((gsGlobalInfo.sPathInfo.asDac[eCh].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK] & MCDRV_SRC3_DIR0_ON) == MCDRV_SRC3_DIR0_ON)
+	{
+		eSrcType	= eMCDRV_SRC_DIR0;
+	}
+	else if((gsGlobalInfo.sPathInfo.asDac[eCh].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK] & MCDRV_SRC3_DIR1_ON) == MCDRV_SRC3_DIR1_ON)
+	{
+		eSrcType	= eMCDRV_SRC_DIR1;
+	}
+	else if((gsGlobalInfo.sPathInfo.asDac[eCh].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK] & MCDRV_SRC3_DIR2_ON) == MCDRV_SRC3_DIR2_ON)
+	{
+		eSrcType	= eMCDRV_SRC_DIR2;
+	}
+	else if((gsGlobalInfo.sPathInfo.asDac[eCh].abSrcOnOff[MCDRV_SRC_MIX_BLOCK] & MCDRV_SRC6_MIX_ON) == MCDRV_SRC6_MIX_ON)
+	{
+		eSrcType	= eMCDRV_SRC_MIX;
+	}
+	else if((gsGlobalInfo.sPathInfo.asDac[eCh].abSrcOnOff[MCDRV_SRC_AE_BLOCK] & MCDRV_SRC6_AE_ON) == MCDRV_SRC6_AE_ON)
+	{
+		eSrcType	= McResCtrl_GetAESource();
+	}
+	else
+	{
+	}
+
+#if (MCDRV_DEBUG_LEVEL>=4)
+	sdRet	= eSrcType;
+	McDebugLog_FuncOut("McResCtrl_GetDACSource", &sdRet);
+#endif
+	return eSrcType;
+}
+
+/****************************************************************************
+ *	McResCtrl_GetDITSource
+ *
+ *	Description:
+ *			Get DIT source information.
+ *	Arguments:
+ *			ePort	port number
+ *	Return:
+ *			path source(MCDRV_SRC_TYPE)
+ *
+ ****************************************************************************/
+MCDRV_SRC_TYPE	McResCtrl_GetDITSource
+(
+	MCDRV_DIO_PORT_NO	ePort
+)
+{
+	MCDRV_SRC_TYPE	eSrcType	= eMCDRV_SRC_NONE;
+	MCDRV_CHANNEL*	pasDit		= NULL;
+
+#if (MCDRV_DEBUG_LEVEL>=4)
+	SINT32	sdRet;
+	McDebugLog_FuncIn("McResCtrl_GetDITSource");
+#endif
+
+	if(ePort == 0)
+	{
+		pasDit	= &gsGlobalInfo.sPathInfo.asDit0[0];
+	}
+	else if(ePort == 1)
+	{
+		pasDit	= &gsGlobalInfo.sPathInfo.asDit1[0];
+	}
+	else if(ePort == 2)
+	{
+		pasDit	= &gsGlobalInfo.sPathInfo.asDit2[0];
+	}
+	else
+	{
+	}
+
+	if(pasDit != NULL)
+	{
+		if((pasDit->abSrcOnOff[MCDRV_SRC_PDM_BLOCK] & MCDRV_SRC4_PDM_ON) == MCDRV_SRC4_PDM_ON)
+		{
+			eSrcType	= eMCDRV_SRC_PDM;
+		}
+		else if((pasDit->abSrcOnOff[MCDRV_SRC_ADC0_BLOCK] & MCDRV_SRC4_ADC0_ON) == MCDRV_SRC4_ADC0_ON)
+		{
+			eSrcType	= eMCDRV_SRC_ADC0;
+		}
+		else if((pasDit->abSrcOnOff[MCDRV_SRC_DIR0_BLOCK] & MCDRV_SRC3_DIR0_ON) == MCDRV_SRC3_DIR0_ON)
+		{
+			eSrcType	= eMCDRV_SRC_DIR0;
+		}
+		else if((pasDit->abSrcOnOff[MCDRV_SRC_DIR1_BLOCK] & MCDRV_SRC3_DIR1_ON) == MCDRV_SRC3_DIR1_ON)
+		{
+			eSrcType	= eMCDRV_SRC_DIR1;
+		}
+		else if((pasDit->abSrcOnOff[MCDRV_SRC_DIR2_BLOCK] & MCDRV_SRC3_DIR2_ON) == MCDRV_SRC3_DIR2_ON)
+		{
+			eSrcType	= eMCDRV_SRC_DIR2;
+		}
+		else if((pasDit->abSrcOnOff[MCDRV_SRC_MIX_BLOCK] & MCDRV_SRC6_MIX_ON) == MCDRV_SRC6_MIX_ON)
+		{
+			eSrcType	= eMCDRV_SRC_MIX;
+		}
+		else if((pasDit->abSrcOnOff[MCDRV_SRC_AE_BLOCK] & MCDRV_SRC6_AE_ON) == MCDRV_SRC6_AE_ON)
+		{
+			eSrcType	= McResCtrl_GetAESource();
+		}
+		else
+		{
+		}
+	}
+
+#if (MCDRV_DEBUG_LEVEL>=4)
+	sdRet	= eSrcType;
+	McDebugLog_FuncOut("McResCtrl_GetDITSource", &sdRet);
+#endif
+
+	return eSrcType;
+}
+
+/****************************************************************************
+ *	McResCtrl_GetAESource
+ *
+ *	Description:
+ *			Get AE source information.
+ *	Arguments:
+ *			none
+ *	Return:
+ *			path source(MCDRV_SRC_TYPE)
+ *
+ ****************************************************************************/
+MCDRV_SRC_TYPE	McResCtrl_GetAESource
+(
+	void
+)
+{
+	MCDRV_SRC_TYPE	eSrcType	= eMCDRV_SRC_NONE;
+
+#if (MCDRV_DEBUG_LEVEL>=4)
+	SINT32	sdRet;
+	McDebugLog_FuncIn("McResCtrl_GetAESource");
+#endif
+
+	if((gsGlobalInfo.sPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_PDM_BLOCK] & MCDRV_SRC4_PDM_ON) == MCDRV_SRC4_PDM_ON)
+	{
+		eSrcType	= eMCDRV_SRC_PDM;
+	}
+	else if((gsGlobalInfo.sPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK] & MCDRV_SRC4_ADC0_ON) == MCDRV_SRC4_ADC0_ON)
+	{
+		eSrcType	= eMCDRV_SRC_ADC0;
+	}
+	else if((gsGlobalInfo.sPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK] & MCDRV_SRC3_DIR0_ON) == MCDRV_SRC3_DIR0_ON)
+	{
+		eSrcType	= eMCDRV_SRC_DIR0;
+	}
+	else if((gsGlobalInfo.sPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK] & MCDRV_SRC3_DIR1_ON) == MCDRV_SRC3_DIR1_ON)
+	{
+		eSrcType	= eMCDRV_SRC_DIR1;
+	}
+	else if((gsGlobalInfo.sPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK] & MCDRV_SRC3_DIR2_ON) == MCDRV_SRC3_DIR2_ON)
+	{
+		eSrcType	= eMCDRV_SRC_DIR2;
+	}
+	else if((gsGlobalInfo.sPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_MIX_BLOCK] & MCDRV_SRC6_MIX_ON) == MCDRV_SRC6_MIX_ON)
+	{
+		eSrcType	= eMCDRV_SRC_MIX;
+	}
+	else
+	{
+	}
+
+#if (MCDRV_DEBUG_LEVEL>=4)
+	sdRet	= eSrcType;
+	McDebugLog_FuncOut("McResCtrl_GetAESource", &sdRet);
+#endif
+
+	return eSrcType;
+}
+
+/****************************************************************************
+ *	McResCtrl_IsSrcUsed
+ *
+ *	Description:
+ *			Is Src used
+ *	Arguments:
+ *			ePathSrc	path src type
+ *	Return:
+ *			0:unused/1:used
+ *
+ ****************************************************************************/
+UINT8	McResCtrl_IsSrcUsed
+(
+	MCDRV_SRC_TYPE	ePathSrc
+)
+{
+	UINT8	bUsed	= 0;
+
+#if (MCDRV_DEBUG_LEVEL>=4)
+	SINT32	sdRet;
+	McDebugLog_FuncIn("McResCtrl_IsSrcUsed");
+#endif
+
+	switch(ePathSrc)
+	{
+	case	eMCDRV_SRC_MIC1:
+		if(((gsGlobalInfo.sPathInfo.asHpOut[0].abSrcOnOff[MCDRV_SRC_MIC1_BLOCK] & MCDRV_SRC0_MIC1_ON) == MCDRV_SRC0_MIC1_ON)
+		|| ((gsGlobalInfo.sPathInfo.asHpOut[1].abSrcOnOff[MCDRV_SRC_MIC1_BLOCK] & MCDRV_SRC0_MIC1_ON) == MCDRV_SRC0_MIC1_ON)
+		|| ((gsGlobalInfo.sPathInfo.asRcOut[0].abSrcOnOff[MCDRV_SRC_MIC1_BLOCK] & MCDRV_SRC0_MIC1_ON) == MCDRV_SRC0_MIC1_ON)
+		|| ((gsGlobalInfo.sPathInfo.asLout1[0].abSrcOnOff[MCDRV_SRC_MIC1_BLOCK] & MCDRV_SRC0_MIC1_ON) == MCDRV_SRC0_MIC1_ON)
+		|| ((gsGlobalInfo.sPathInfo.asLout1[1].abSrcOnOff[MCDRV_SRC_MIC1_BLOCK] & MCDRV_SRC0_MIC1_ON) == MCDRV_SRC0_MIC1_ON)
+		|| ((gsGlobalInfo.sPathInfo.asLout2[0].abSrcOnOff[MCDRV_SRC_MIC1_BLOCK] & MCDRV_SRC0_MIC1_ON) == MCDRV_SRC0_MIC1_ON)
+		|| ((gsGlobalInfo.sPathInfo.asLout2[1].abSrcOnOff[MCDRV_SRC_MIC1_BLOCK] & MCDRV_SRC0_MIC1_ON) == MCDRV_SRC0_MIC1_ON)
+		|| ((gsGlobalInfo.sPathInfo.asAdc0[0].abSrcOnOff[MCDRV_SRC_MIC1_BLOCK] & MCDRV_SRC0_MIC1_ON) == MCDRV_SRC0_MIC1_ON)
+		|| ((gsGlobalInfo.sPathInfo.asAdc0[1].abSrcOnOff[MCDRV_SRC_MIC1_BLOCK] & MCDRV_SRC0_MIC1_ON) == MCDRV_SRC0_MIC1_ON))
+		{
+			bUsed	= 1;
+		}
+		break;
+
+	case	eMCDRV_SRC_MIC2:
+		if(((gsGlobalInfo.sPathInfo.asHpOut[0].abSrcOnOff[MCDRV_SRC_MIC2_BLOCK] & MCDRV_SRC0_MIC2_ON) == MCDRV_SRC0_MIC2_ON)
+		|| ((gsGlobalInfo.sPathInfo.asHpOut[1].abSrcOnOff[MCDRV_SRC_MIC2_BLOCK] & MCDRV_SRC0_MIC2_ON) == MCDRV_SRC0_MIC2_ON)
+		|| ((gsGlobalInfo.sPathInfo.asRcOut[0].abSrcOnOff[MCDRV_SRC_MIC2_BLOCK] & MCDRV_SRC0_MIC2_ON) == MCDRV_SRC0_MIC2_ON)
+		|| ((gsGlobalInfo.sPathInfo.asLout1[0].abSrcOnOff[MCDRV_SRC_MIC2_BLOCK] & MCDRV_SRC0_MIC2_ON) == MCDRV_SRC0_MIC2_ON)
+		|| ((gsGlobalInfo.sPathInfo.asLout1[1].abSrcOnOff[MCDRV_SRC_MIC2_BLOCK] & MCDRV_SRC0_MIC2_ON) == MCDRV_SRC0_MIC2_ON)
+		|| ((gsGlobalInfo.sPathInfo.asLout2[0].abSrcOnOff[MCDRV_SRC_MIC2_BLOCK] & MCDRV_SRC0_MIC2_ON) == MCDRV_SRC0_MIC2_ON)
+		|| ((gsGlobalInfo.sPathInfo.asLout2[1].abSrcOnOff[MCDRV_SRC_MIC2_BLOCK] & MCDRV_SRC0_MIC2_ON) == MCDRV_SRC0_MIC2_ON)
+		|| ((gsGlobalInfo.sPathInfo.asAdc0[0].abSrcOnOff[MCDRV_SRC_MIC2_BLOCK] & MCDRV_SRC0_MIC2_ON) == MCDRV_SRC0_MIC2_ON)
+		|| ((gsGlobalInfo.sPathInfo.asAdc0[1].abSrcOnOff[MCDRV_SRC_MIC2_BLOCK] & MCDRV_SRC0_MIC2_ON) == MCDRV_SRC0_MIC2_ON))
+		{
+			bUsed	= 1;
+		}
+		break;
+
+	case	eMCDRV_SRC_MIC3:
+		if(((gsGlobalInfo.sPathInfo.asHpOut[0].abSrcOnOff[MCDRV_SRC_MIC3_BLOCK] & MCDRV_SRC0_MIC3_ON) == MCDRV_SRC0_MIC3_ON)
+		|| ((gsGlobalInfo.sPathInfo.asHpOut[1].abSrcOnOff[MCDRV_SRC_MIC3_BLOCK] & MCDRV_SRC0_MIC3_ON) == MCDRV_SRC0_MIC3_ON)
+		|| ((gsGlobalInfo.sPathInfo.asRcOut[0].abSrcOnOff[MCDRV_SRC_MIC3_BLOCK] & MCDRV_SRC0_MIC3_ON) == MCDRV_SRC0_MIC3_ON)
+		|| ((gsGlobalInfo.sPathInfo.asLout1[0].abSrcOnOff[MCDRV_SRC_MIC3_BLOCK] & MCDRV_SRC0_MIC3_ON) == MCDRV_SRC0_MIC3_ON)
+		|| ((gsGlobalInfo.sPathInfo.asLout1[1].abSrcOnOff[MCDRV_SRC_MIC3_BLOCK] & MCDRV_SRC0_MIC3_ON) == MCDRV_SRC0_MIC3_ON)
+		|| ((gsGlobalInfo.sPathInfo.asLout2[0].abSrcOnOff[MCDRV_SRC_MIC3_BLOCK] & MCDRV_SRC0_MIC3_ON) == MCDRV_SRC0_MIC3_ON)
+		|| ((gsGlobalInfo.sPathInfo.asLout2[1].abSrcOnOff[MCDRV_SRC_MIC3_BLOCK] & MCDRV_SRC0_MIC3_ON) == MCDRV_SRC0_MIC3_ON)
+		|| ((gsGlobalInfo.sPathInfo.asAdc0[0].abSrcOnOff[MCDRV_SRC_MIC3_BLOCK] & MCDRV_SRC0_MIC3_ON) == MCDRV_SRC0_MIC3_ON)
+		|| ((gsGlobalInfo.sPathInfo.asAdc0[1].abSrcOnOff[MCDRV_SRC_MIC3_BLOCK] & MCDRV_SRC0_MIC3_ON) == MCDRV_SRC0_MIC3_ON))
+		{
+			bUsed	= 1;
+		}
+		break;
+
+	case	eMCDRV_SRC_LINE1_L:
+		if(((gsGlobalInfo.sPathInfo.asHpOut[0].abSrcOnOff[MCDRV_SRC_LINE1_L_BLOCK] & MCDRV_SRC1_LINE1_L_ON) == MCDRV_SRC1_LINE1_L_ON)
+		|| ((gsGlobalInfo.sPathInfo.asSpOut[0].abSrcOnOff[MCDRV_SRC_LINE1_L_BLOCK] & MCDRV_SRC1_LINE1_L_ON) == MCDRV_SRC1_LINE1_L_ON)
+		|| ((gsGlobalInfo.sPathInfo.asLout1[0].abSrcOnOff[MCDRV_SRC_LINE1_L_BLOCK] & MCDRV_SRC1_LINE1_L_ON) == MCDRV_SRC1_LINE1_L_ON)
+		|| ((gsGlobalInfo.sPathInfo.asLout1[0].abSrcOnOff[MCDRV_SRC_LINE1_L_BLOCK] & MCDRV_SRC1_LINE1_L_ON) == MCDRV_SRC1_LINE1_L_ON)
+		|| ((gsGlobalInfo.sPathInfo.asLout2[0].abSrcOnOff[MCDRV_SRC_LINE1_L_BLOCK] & MCDRV_SRC1_LINE1_L_ON) == MCDRV_SRC1_LINE1_L_ON)
+		|| ((gsGlobalInfo.sPathInfo.asAdc0[0].abSrcOnOff[MCDRV_SRC_LINE1_L_BLOCK] & MCDRV_SRC1_LINE1_L_ON) == MCDRV_SRC1_LINE1_L_ON))
+		{
+			bUsed	= 1;
+		}
+		break;
+
+	case	eMCDRV_SRC_LINE1_R:
+		if(((gsGlobalInfo.sPathInfo.asHpOut[1].abSrcOnOff[MCDRV_SRC_LINE1_R_BLOCK] & MCDRV_SRC1_LINE1_R_ON) == MCDRV_SRC1_LINE1_R_ON)
+		|| ((gsGlobalInfo.sPathInfo.asSpOut[1].abSrcOnOff[MCDRV_SRC_LINE1_R_BLOCK] & MCDRV_SRC1_LINE1_R_ON) == MCDRV_SRC1_LINE1_R_ON)
+		|| ((gsGlobalInfo.sPathInfo.asLout1[1].abSrcOnOff[MCDRV_SRC_LINE1_R_BLOCK] & MCDRV_SRC1_LINE1_R_ON) == MCDRV_SRC1_LINE1_R_ON)
+		|| ((gsGlobalInfo.sPathInfo.asLout2[1].abSrcOnOff[MCDRV_SRC_LINE1_R_BLOCK] & MCDRV_SRC1_LINE1_R_ON) == MCDRV_SRC1_LINE1_R_ON)
+		|| ((gsGlobalInfo.sPathInfo.asAdc0[1].abSrcOnOff[MCDRV_SRC_LINE1_R_BLOCK] & MCDRV_SRC1_LINE1_R_ON) == MCDRV_SRC1_LINE1_R_ON))
+		{
+			bUsed	= 1;
+		}
+		break;
+
+	case	eMCDRV_SRC_LINE1_M:
+		if(((gsGlobalInfo.sPathInfo.asHpOut[0].abSrcOnOff[MCDRV_SRC_LINE1_M_BLOCK] & MCDRV_SRC1_LINE1_M_ON) == MCDRV_SRC1_LINE1_M_ON)
+		|| ((gsGlobalInfo.sPathInfo.asSpOut[0].abSrcOnOff[MCDRV_SRC_LINE1_M_BLOCK] & MCDRV_SRC1_LINE1_M_ON) == MCDRV_SRC1_LINE1_M_ON)
+		|| ((gsGlobalInfo.sPathInfo.asSpOut[1].abSrcOnOff[MCDRV_SRC_LINE1_M_BLOCK] & MCDRV_SRC1_LINE1_M_ON) == MCDRV_SRC1_LINE1_M_ON)
+		|| ((gsGlobalInfo.sPathInfo.asRcOut[0].abSrcOnOff[MCDRV_SRC_LINE1_M_BLOCK] & MCDRV_SRC1_LINE1_M_ON) == MCDRV_SRC1_LINE1_M_ON)
+		|| ((gsGlobalInfo.sPathInfo.asLout1[0].abSrcOnOff[MCDRV_SRC_LINE1_M_BLOCK] & MCDRV_SRC1_LINE1_M_ON) == MCDRV_SRC1_LINE1_M_ON)
+		|| ((gsGlobalInfo.sPathInfo.asLout1[0].abSrcOnOff[MCDRV_SRC_LINE1_M_BLOCK] & MCDRV_SRC1_LINE1_M_ON) == MCDRV_SRC1_LINE1_M_ON)
+		|| ((gsGlobalInfo.sPathInfo.asLout2[0].abSrcOnOff[MCDRV_SRC_LINE1_M_BLOCK] & MCDRV_SRC1_LINE1_M_ON) == MCDRV_SRC1_LINE1_M_ON)
+		|| ((gsGlobalInfo.sPathInfo.asAdc0[0].abSrcOnOff[MCDRV_SRC_LINE1_M_BLOCK] & MCDRV_SRC1_LINE1_M_ON) == MCDRV_SRC1_LINE1_M_ON)
+		|| ((gsGlobalInfo.sPathInfo.asAdc0[1].abSrcOnOff[MCDRV_SRC_LINE1_M_BLOCK] & MCDRV_SRC1_LINE1_M_ON) == MCDRV_SRC1_LINE1_M_ON))
+		{
+			bUsed	= 1;
+		}
+		break;
+
+	case	eMCDRV_SRC_LINE2_L:
+		if(((gsGlobalInfo.sPathInfo.asHpOut[0].abSrcOnOff[MCDRV_SRC_LINE2_L_BLOCK] & MCDRV_SRC2_LINE2_L_ON) == MCDRV_SRC2_LINE2_L_ON)
+		|| ((gsGlobalInfo.sPathInfo.asSpOut[0].abSrcOnOff[MCDRV_SRC_LINE2_L_BLOCK] & MCDRV_SRC2_LINE2_L_ON) == MCDRV_SRC2_LINE2_L_ON)
+		|| ((gsGlobalInfo.sPathInfo.asLout1[0].abSrcOnOff[MCDRV_SRC_LINE2_L_BLOCK] & MCDRV_SRC2_LINE2_L_ON) == MCDRV_SRC2_LINE2_L_ON)
+		|| ((gsGlobalInfo.sPathInfo.asLout1[0].abSrcOnOff[MCDRV_SRC_LINE2_L_BLOCK] & MCDRV_SRC2_LINE2_L_ON) == MCDRV_SRC2_LINE2_L_ON)
+		|| ((gsGlobalInfo.sPathInfo.asLout2[0].abSrcOnOff[MCDRV_SRC_LINE2_L_BLOCK] & MCDRV_SRC2_LINE2_L_ON) == MCDRV_SRC2_LINE2_L_ON)
+		|| ((gsGlobalInfo.sPathInfo.asAdc0[0].abSrcOnOff[MCDRV_SRC_LINE2_L_BLOCK] & MCDRV_SRC2_LINE2_L_ON) == MCDRV_SRC2_LINE2_L_ON))
+		{
+			bUsed	= 1;
+		}
+		break;
+
+	case	eMCDRV_SRC_LINE2_R:
+		if(((gsGlobalInfo.sPathInfo.asHpOut[1].abSrcOnOff[MCDRV_SRC_LINE2_R_BLOCK] & MCDRV_SRC2_LINE2_R_ON) == MCDRV_SRC2_LINE2_R_ON)
+		|| ((gsGlobalInfo.sPathInfo.asSpOut[1].abSrcOnOff[MCDRV_SRC_LINE2_R_BLOCK] & MCDRV_SRC2_LINE2_R_ON) == MCDRV_SRC2_LINE2_R_ON)
+		|| ((gsGlobalInfo.sPathInfo.asLout1[1].abSrcOnOff[MCDRV_SRC_LINE2_R_BLOCK] & MCDRV_SRC2_LINE2_R_ON) == MCDRV_SRC2_LINE2_R_ON)
+		|| ((gsGlobalInfo.sPathInfo.asLout2[1].abSrcOnOff[MCDRV_SRC_LINE2_R_BLOCK] & MCDRV_SRC2_LINE2_R_ON) == MCDRV_SRC2_LINE2_R_ON)
+		|| ((gsGlobalInfo.sPathInfo.asAdc0[1].abSrcOnOff[MCDRV_SRC_LINE2_R_BLOCK] & MCDRV_SRC2_LINE2_R_ON) == MCDRV_SRC2_LINE2_R_ON))
+		{
+			bUsed	= 1;
+		}
+		break;
+
+	case	eMCDRV_SRC_LINE2_M:
+		if(((gsGlobalInfo.sPathInfo.asHpOut[0].abSrcOnOff[MCDRV_SRC_LINE2_M_BLOCK] & MCDRV_SRC2_LINE2_M_ON) == MCDRV_SRC2_LINE2_M_ON)
+		|| ((gsGlobalInfo.sPathInfo.asSpOut[0].abSrcOnOff[MCDRV_SRC_LINE2_M_BLOCK] & MCDRV_SRC2_LINE2_M_ON) == MCDRV_SRC2_LINE2_M_ON)
+		|| ((gsGlobalInfo.sPathInfo.asSpOut[1].abSrcOnOff[MCDRV_SRC_LINE2_M_BLOCK] & MCDRV_SRC2_LINE2_M_ON) == MCDRV_SRC2_LINE2_M_ON)
+		|| ((gsGlobalInfo.sPathInfo.asRcOut[0].abSrcOnOff[MCDRV_SRC_LINE2_M_BLOCK] & MCDRV_SRC2_LINE2_M_ON) == MCDRV_SRC2_LINE2_M_ON)
+		|| ((gsGlobalInfo.sPathInfo.asLout1[0].abSrcOnOff[MCDRV_SRC_LINE2_M_BLOCK] & MCDRV_SRC2_LINE2_M_ON) == MCDRV_SRC2_LINE2_M_ON)
+		|| ((gsGlobalInfo.sPathInfo.asLout1[0].abSrcOnOff[MCDRV_SRC_LINE2_M_BLOCK] & MCDRV_SRC2_LINE2_M_ON) == MCDRV_SRC2_LINE2_M_ON)
+		|| ((gsGlobalInfo.sPathInfo.asLout2[0].abSrcOnOff[MCDRV_SRC_LINE2_M_BLOCK] & MCDRV_SRC2_LINE2_M_ON) == MCDRV_SRC2_LINE2_M_ON)
+		|| ((gsGlobalInfo.sPathInfo.asAdc0[0].abSrcOnOff[MCDRV_SRC_LINE2_M_BLOCK] & MCDRV_SRC2_LINE2_M_ON) == MCDRV_SRC2_LINE2_M_ON)
+		|| ((gsGlobalInfo.sPathInfo.asAdc0[1].abSrcOnOff[MCDRV_SRC_LINE2_M_BLOCK] & MCDRV_SRC2_LINE2_M_ON) == MCDRV_SRC2_LINE2_M_ON))
+		{
+			bUsed	= 1;
+		}
+		break;
+
+	case	eMCDRV_SRC_DIR0:
+		if(((gsGlobalInfo.sPathInfo.asDit0[0].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK] & MCDRV_SRC3_DIR0_ON) == MCDRV_SRC3_DIR0_ON)
+		|| ((gsGlobalInfo.sPathInfo.asDit1[0].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK] & MCDRV_SRC3_DIR0_ON) == MCDRV_SRC3_DIR0_ON)
+		|| ((gsGlobalInfo.sPathInfo.asDit2[0].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK] & MCDRV_SRC3_DIR0_ON) == MCDRV_SRC3_DIR0_ON)
+		|| ((gsGlobalInfo.sPathInfo.asDac[0].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK] & MCDRV_SRC3_DIR0_ON) == MCDRV_SRC3_DIR0_ON)
+		|| ((gsGlobalInfo.sPathInfo.asDac[1].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK] & MCDRV_SRC3_DIR0_ON) == MCDRV_SRC3_DIR0_ON)
+		|| ((gsGlobalInfo.sPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK] & MCDRV_SRC3_DIR0_ON) == MCDRV_SRC3_DIR0_ON)
+		|| ((gsGlobalInfo.sPathInfo.asMix[0].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK] & MCDRV_SRC3_DIR0_ON) == MCDRV_SRC3_DIR0_ON))
+		{
+			bUsed	= 1;
+		}
+		break;
+
+	case	eMCDRV_SRC_DIR1:
+		if(((gsGlobalInfo.sPathInfo.asDit0[0].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK] & MCDRV_SRC3_DIR1_ON) == MCDRV_SRC3_DIR1_ON)
+		|| ((gsGlobalInfo.sPathInfo.asDit1[0].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK] & MCDRV_SRC3_DIR1_ON) == MCDRV_SRC3_DIR1_ON)
+		|| ((gsGlobalInfo.sPathInfo.asDit2[0].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK] & MCDRV_SRC3_DIR1_ON) == MCDRV_SRC3_DIR1_ON)
+		|| ((gsGlobalInfo.sPathInfo.asDac[0].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK] & MCDRV_SRC3_DIR1_ON) == MCDRV_SRC3_DIR1_ON)
+		|| ((gsGlobalInfo.sPathInfo.asDac[1].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK] & MCDRV_SRC3_DIR1_ON) == MCDRV_SRC3_DIR1_ON)
+		|| ((gsGlobalInfo.sPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK] & MCDRV_SRC3_DIR1_ON) == MCDRV_SRC3_DIR1_ON)
+		|| ((gsGlobalInfo.sPathInfo.asMix[0].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK] & MCDRV_SRC3_DIR1_ON) == MCDRV_SRC3_DIR1_ON))
+		{
+			bUsed	= 1;
+		}
+		break;
+
+	case	eMCDRV_SRC_DIR2:
+		if(((gsGlobalInfo.sPathInfo.asDit0[0].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK] & MCDRV_SRC3_DIR2_ON) == MCDRV_SRC3_DIR2_ON)
+		|| ((gsGlobalInfo.sPathInfo.asDit1[0].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK] & MCDRV_SRC3_DIR2_ON) == MCDRV_SRC3_DIR2_ON)
+		|| ((gsGlobalInfo.sPathInfo.asDit2[0].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK] & MCDRV_SRC3_DIR2_ON) == MCDRV_SRC3_DIR2_ON)
+		|| ((gsGlobalInfo.sPathInfo.asDac[0].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK] & MCDRV_SRC3_DIR2_ON) == MCDRV_SRC3_DIR2_ON)
+		|| ((gsGlobalInfo.sPathInfo.asDac[1].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK] & MCDRV_SRC3_DIR2_ON) == MCDRV_SRC3_DIR2_ON)
+		|| ((gsGlobalInfo.sPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK] & MCDRV_SRC3_DIR2_ON) == MCDRV_SRC3_DIR2_ON)
+		|| ((gsGlobalInfo.sPathInfo.asMix[0].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK] & MCDRV_SRC3_DIR2_ON) == MCDRV_SRC3_DIR2_ON))
+		{
+			bUsed	= 1;
+		}
+		break;
+
+	case	eMCDRV_SRC_DTMF:
+		break;
+
+	case	eMCDRV_SRC_PDM:
+		if(((gsGlobalInfo.sPathInfo.asDit0[0].abSrcOnOff[MCDRV_SRC_PDM_BLOCK] & MCDRV_SRC4_PDM_ON) == MCDRV_SRC4_PDM_ON)
+		|| ((gsGlobalInfo.sPathInfo.asDit1[0].abSrcOnOff[MCDRV_SRC_PDM_BLOCK] & MCDRV_SRC4_PDM_ON) == MCDRV_SRC4_PDM_ON)
+		|| ((gsGlobalInfo.sPathInfo.asDit2[0].abSrcOnOff[MCDRV_SRC_PDM_BLOCK] & MCDRV_SRC4_PDM_ON) == MCDRV_SRC4_PDM_ON)
+		|| ((gsGlobalInfo.sPathInfo.asDac[0].abSrcOnOff[MCDRV_SRC_PDM_BLOCK] & MCDRV_SRC4_PDM_ON) == MCDRV_SRC4_PDM_ON)
+		|| ((gsGlobalInfo.sPathInfo.asDac[1].abSrcOnOff[MCDRV_SRC_PDM_BLOCK] & MCDRV_SRC4_PDM_ON) == MCDRV_SRC4_PDM_ON)
+		|| ((gsGlobalInfo.sPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_PDM_BLOCK] & MCDRV_SRC4_PDM_ON) == MCDRV_SRC4_PDM_ON)
+		|| ((gsGlobalInfo.sPathInfo.asMix[0].abSrcOnOff[MCDRV_SRC_PDM_BLOCK] & MCDRV_SRC4_PDM_ON) == MCDRV_SRC4_PDM_ON))
+		{
+			bUsed	= 1;
+		}
+		break;
+
+	case	eMCDRV_SRC_ADC0:
+		if(((gsGlobalInfo.sPathInfo.asDit0[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK] & MCDRV_SRC4_ADC0_ON) == MCDRV_SRC4_ADC0_ON)
+		|| ((gsGlobalInfo.sPathInfo.asDit1[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK] & MCDRV_SRC4_ADC0_ON) == MCDRV_SRC4_ADC0_ON)
+		|| ((gsGlobalInfo.sPathInfo.asDit2[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK] & MCDRV_SRC4_ADC0_ON) == MCDRV_SRC4_ADC0_ON)
+		|| ((gsGlobalInfo.sPathInfo.asDac[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK] & MCDRV_SRC4_ADC0_ON) == MCDRV_SRC4_ADC0_ON)
+		|| ((gsGlobalInfo.sPathInfo.asDac[1].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK] & MCDRV_SRC4_ADC0_ON) == MCDRV_SRC4_ADC0_ON)
+		|| ((gsGlobalInfo.sPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK] & MCDRV_SRC4_ADC0_ON) == MCDRV_SRC4_ADC0_ON)
+		|| ((gsGlobalInfo.sPathInfo.asMix[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK] & MCDRV_SRC4_ADC0_ON) == MCDRV_SRC4_ADC0_ON))
+		{
+			bUsed	= 1;
+		}
+		break;
+
+	case	eMCDRV_SRC_ADC1:
+		break;
+
+	case	eMCDRV_SRC_DAC_L:
+		if(((gsGlobalInfo.sPathInfo.asHpOut[0].abSrcOnOff[MCDRV_SRC_DAC_L_BLOCK] & MCDRV_SRC5_DAC_L_ON) == MCDRV_SRC5_DAC_L_ON)
+		|| ((gsGlobalInfo.sPathInfo.asSpOut[0].abSrcOnOff[MCDRV_SRC_DAC_L_BLOCK] & MCDRV_SRC5_DAC_L_ON) == MCDRV_SRC5_DAC_L_ON)
+		|| ((gsGlobalInfo.sPathInfo.asRcOut[0].abSrcOnOff[MCDRV_SRC_DAC_L_BLOCK] & MCDRV_SRC5_DAC_L_ON) == MCDRV_SRC5_DAC_L_ON)
+		|| ((gsGlobalInfo.sPathInfo.asLout1[0].abSrcOnOff[MCDRV_SRC_DAC_L_BLOCK] & MCDRV_SRC5_DAC_L_ON) == MCDRV_SRC5_DAC_L_ON)
+		|| ((gsGlobalInfo.sPathInfo.asLout2[0].abSrcOnOff[MCDRV_SRC_DAC_L_BLOCK] & MCDRV_SRC5_DAC_L_ON) == MCDRV_SRC5_DAC_L_ON))
+		{
+			bUsed	= 1;
+		}
+		break;
+
+	case	eMCDRV_SRC_DAC_R:
+		if(((gsGlobalInfo.sPathInfo.asHpOut[1].abSrcOnOff[MCDRV_SRC_DAC_R_BLOCK] & MCDRV_SRC5_DAC_R_ON) == MCDRV_SRC5_DAC_R_ON)
+		|| ((gsGlobalInfo.sPathInfo.asSpOut[1].abSrcOnOff[MCDRV_SRC_DAC_R_BLOCK] & MCDRV_SRC5_DAC_R_ON) == MCDRV_SRC5_DAC_R_ON)
+		|| ((gsGlobalInfo.sPathInfo.asRcOut[0].abSrcOnOff[MCDRV_SRC_DAC_R_BLOCK] & MCDRV_SRC5_DAC_R_ON) == MCDRV_SRC5_DAC_R_ON)
+		|| ((gsGlobalInfo.sPathInfo.asLout1[1].abSrcOnOff[MCDRV_SRC_DAC_R_BLOCK] & MCDRV_SRC5_DAC_R_ON) == MCDRV_SRC5_DAC_R_ON)
+		|| ((gsGlobalInfo.sPathInfo.asLout2[1].abSrcOnOff[MCDRV_SRC_DAC_R_BLOCK] & MCDRV_SRC5_DAC_R_ON) == MCDRV_SRC5_DAC_R_ON))
+		{
+			bUsed	= 1;
+		}
+		break;
+
+	case	eMCDRV_SRC_DAC_M:
+		if(((gsGlobalInfo.sPathInfo.asHpOut[0].abSrcOnOff[MCDRV_SRC_DAC_M_BLOCK] & MCDRV_SRC5_DAC_M_ON) == MCDRV_SRC5_DAC_M_ON)
+		|| ((gsGlobalInfo.sPathInfo.asSpOut[0].abSrcOnOff[MCDRV_SRC_DAC_M_BLOCK] & MCDRV_SRC5_DAC_M_ON) == MCDRV_SRC5_DAC_M_ON)
+		|| ((gsGlobalInfo.sPathInfo.asSpOut[1].abSrcOnOff[MCDRV_SRC_DAC_M_BLOCK] & MCDRV_SRC5_DAC_M_ON) == MCDRV_SRC5_DAC_M_ON)
+		|| ((gsGlobalInfo.sPathInfo.asLout1[0].abSrcOnOff[MCDRV_SRC_DAC_M_BLOCK] & MCDRV_SRC5_DAC_M_ON) == MCDRV_SRC5_DAC_M_ON)
+		|| ((gsGlobalInfo.sPathInfo.asLout2[0].abSrcOnOff[MCDRV_SRC_DAC_M_BLOCK] & MCDRV_SRC5_DAC_M_ON) == MCDRV_SRC5_DAC_M_ON))
+		{
+			bUsed	= 1;
+		}
+		break;
+
+	case	eMCDRV_SRC_AE:
+		if(((gsGlobalInfo.sPathInfo.asDit0[0].abSrcOnOff[MCDRV_SRC_AE_BLOCK] & MCDRV_SRC6_AE_ON) == MCDRV_SRC6_AE_ON)
+		|| ((gsGlobalInfo.sPathInfo.asDit1[0].abSrcOnOff[MCDRV_SRC_AE_BLOCK] & MCDRV_SRC6_AE_ON) == MCDRV_SRC6_AE_ON)
+		|| ((gsGlobalInfo.sPathInfo.asDit2[0].abSrcOnOff[MCDRV_SRC_AE_BLOCK] & MCDRV_SRC6_AE_ON) == MCDRV_SRC6_AE_ON)
+		|| ((gsGlobalInfo.sPathInfo.asDac[0].abSrcOnOff[MCDRV_SRC_AE_BLOCK] & MCDRV_SRC6_AE_ON) == MCDRV_SRC6_AE_ON)
+		|| ((gsGlobalInfo.sPathInfo.asDac[1].abSrcOnOff[MCDRV_SRC_AE_BLOCK] & MCDRV_SRC6_AE_ON) == MCDRV_SRC6_AE_ON)
+		|| ((gsGlobalInfo.sPathInfo.asMix[0].abSrcOnOff[MCDRV_SRC_AE_BLOCK] & MCDRV_SRC6_AE_ON) == MCDRV_SRC6_AE_ON))
+		{
+			bUsed	= 1;
+		}
+		break;
+
+	case	eMCDRV_SRC_CDSP:
+		break;
+
+	case	eMCDRV_SRC_MIX:
+		if(((gsGlobalInfo.sPathInfo.asDit0[0].abSrcOnOff[MCDRV_SRC_MIX_BLOCK] & MCDRV_SRC6_MIX_ON) == MCDRV_SRC6_MIX_ON)
+		|| ((gsGlobalInfo.sPathInfo.asDit1[0].abSrcOnOff[MCDRV_SRC_MIX_BLOCK] & MCDRV_SRC6_MIX_ON) == MCDRV_SRC6_MIX_ON)
+		|| ((gsGlobalInfo.sPathInfo.asDit2[0].abSrcOnOff[MCDRV_SRC_MIX_BLOCK] & MCDRV_SRC6_MIX_ON) == MCDRV_SRC6_MIX_ON)
+		|| ((gsGlobalInfo.sPathInfo.asDac[0].abSrcOnOff[MCDRV_SRC_MIX_BLOCK] & MCDRV_SRC6_MIX_ON) == MCDRV_SRC6_MIX_ON)
+		|| ((gsGlobalInfo.sPathInfo.asDac[1].abSrcOnOff[MCDRV_SRC_MIX_BLOCK] & MCDRV_SRC6_MIX_ON) == MCDRV_SRC6_MIX_ON)
+		|| ((gsGlobalInfo.sPathInfo.asAe[0].abSrcOnOff[MCDRV_SRC_MIX_BLOCK] & MCDRV_SRC6_MIX_ON) == MCDRV_SRC6_MIX_ON))
+		{
+			bUsed	= 1;
+		}
+		break;
+
+	case	eMCDRV_SRC_DIR2_DIRECT:
+		break;
+
+	case	eMCDRV_SRC_CDSP_DIRECT:
+		break;
+
+	default:
+		break;
+	}
+
+#if (MCDRV_DEBUG_LEVEL>=4)
+	sdRet	= (SINT32)bUsed;
+	McDebugLog_FuncOut("McResCtrl_IsSrcUsed", &sdRet);
+#endif
+
+	return bUsed;
+}
+
+/****************************************************************************
+ *	McResCtrl_IsDstUsed
+ *
+ *	Description:
+ *			Is Destination used
+ *	Arguments:
+ *			eType	path destination
+ *			eCh		channel
+ *	Return:
+ *			0:unused/1:used
+ *
+ ****************************************************************************/
+UINT8	McResCtrl_IsDstUsed
+(
+	MCDRV_DST_TYPE	eType,
+	MCDRV_DST_CH	eCh
+)
+{
+	UINT8	bUsed	= 0;
+
+#if (MCDRV_DEBUG_LEVEL>=4)
+	SINT32	sdRet;
+	McDebugLog_FuncIn("McResCtrl_IsDstUsed");
+#endif
+
+	switch(eType)
+	{
+	case	eMCDRV_DST_HP:
+		if(eCh == eMCDRV_DST_CH0)
+		{
+			if(((gsGlobalInfo.sPathInfo.asHpOut[0].abSrcOnOff[MCDRV_SRC_MIC1_BLOCK] & MCDRV_SRC0_MIC1_ON) == MCDRV_SRC0_MIC1_ON)
+			|| ((gsGlobalInfo.sPathInfo.asHpOut[0].abSrcOnOff[MCDRV_SRC_MIC2_BLOCK] & MCDRV_SRC0_MIC2_ON) == MCDRV_SRC0_MIC2_ON)
+			|| ((gsGlobalInfo.sPathInfo.asHpOut[0].abSrcOnOff[MCDRV_SRC_MIC3_BLOCK] & MCDRV_SRC0_MIC3_ON) == MCDRV_SRC0_MIC3_ON)
+			|| ((gsGlobalInfo.sPathInfo.asHpOut[0].abSrcOnOff[MCDRV_SRC_LINE1_L_BLOCK] & MCDRV_SRC1_LINE1_L_ON) == MCDRV_SRC1_LINE1_L_ON)
+			|| ((gsGlobalInfo.sPathInfo.asHpOut[0].abSrcOnOff[MCDRV_SRC_LINE1_M_BLOCK] & MCDRV_SRC1_LINE1_M_ON) == MCDRV_SRC1_LINE1_M_ON)
+			|| ((gsGlobalInfo.sPathInfo.asHpOut[0].abSrcOnOff[MCDRV_SRC_DAC_L_BLOCK] & MCDRV_SRC5_DAC_L_ON) == MCDRV_SRC5_DAC_L_ON)
+			|| ((gsGlobalInfo.sPathInfo.asHpOut[0].abSrcOnOff[MCDRV_SRC_DAC_M_BLOCK] & MCDRV_SRC5_DAC_M_ON) == MCDRV_SRC5_DAC_M_ON))
+			{
+				bUsed	= 1;
+			}
+		}
+		else if(eCh == eMCDRV_DST_CH1)
+		{
+			if(((gsGlobalInfo.sPathInfo.asHpOut[1].abSrcOnOff[MCDRV_SRC_MIC1_BLOCK] & MCDRV_SRC0_MIC1_ON) == MCDRV_SRC0_MIC1_ON)
+			|| ((gsGlobalInfo.sPathInfo.asHpOut[1].abSrcOnOff[MCDRV_SRC_MIC2_BLOCK] & MCDRV_SRC0_MIC2_ON) == MCDRV_SRC0_MIC2_ON)
+			|| ((gsGlobalInfo.sPathInfo.asHpOut[1].abSrcOnOff[MCDRV_SRC_MIC3_BLOCK] & MCDRV_SRC0_MIC3_ON) == MCDRV_SRC0_MIC3_ON)
+			|| ((gsGlobalInfo.sPathInfo.asHpOut[1].abSrcOnOff[MCDRV_SRC_LINE1_R_BLOCK] & MCDRV_SRC1_LINE1_R_ON) == MCDRV_SRC1_LINE1_R_ON)
+			|| ((gsGlobalInfo.sPathInfo.asHpOut[1].abSrcOnOff[MCDRV_SRC_DAC_R_BLOCK] & MCDRV_SRC5_DAC_R_ON) == MCDRV_SRC5_DAC_R_ON))
+			{
+				bUsed	= 1;
+			}
+		}
+		else
+		{
+		}
+		break;
+
+	case	eMCDRV_DST_SP:
+		if(eCh == eMCDRV_DST_CH0)
+		{
+			if(((gsGlobalInfo.sPathInfo.asSpOut[0].abSrcOnOff[MCDRV_SRC_LINE1_L_BLOCK] & MCDRV_SRC1_LINE1_L_ON) == MCDRV_SRC1_LINE1_L_ON)
+			|| ((gsGlobalInfo.sPathInfo.asSpOut[0].abSrcOnOff[MCDRV_SRC_LINE1_M_BLOCK] & MCDRV_SRC1_LINE1_M_ON) == MCDRV_SRC1_LINE1_M_ON)
+			|| ((gsGlobalInfo.sPathInfo.asSpOut[0].abSrcOnOff[MCDRV_SRC_DAC_L_BLOCK] & MCDRV_SRC5_DAC_L_ON) == MCDRV_SRC5_DAC_L_ON)
+			|| ((gsGlobalInfo.sPathInfo.asSpOut[0].abSrcOnOff[MCDRV_SRC_DAC_M_BLOCK] & MCDRV_SRC5_DAC_M_ON) == MCDRV_SRC5_DAC_M_ON))
+			{
+				bUsed	= 1;
+			}
+		}
+		else if(eCh == eMCDRV_DST_CH1)
+		{
+			if(((gsGlobalInfo.sPathInfo.asSpOut[1].abSrcOnOff[MCDRV_SRC_LINE1_R_BLOCK] & MCDRV_SRC1_LINE1_R_ON) == MCDRV_SRC1_LINE1_R_ON)
+			|| ((gsGlobalInfo.sPathInfo.asSpOut[1].abSrcOnOff[MCDRV_SRC_LINE1_M_BLOCK] & MCDRV_SRC1_LINE1_M_ON) == MCDRV_SRC1_LINE1_M_ON)
+			|| ((gsGlobalInfo.sPathInfo.asSpOut[1].abSrcOnOff[MCDRV_SRC_DAC_R_BLOCK] & MCDRV_SRC5_DAC_R_ON) == MCDRV_SRC5_DAC_R_ON)
+			|| ((gsGlobalInfo.sPathInfo.asSpOut[1].abSrcOnOff[MCDRV_SRC_DAC_M_BLOCK] & MCDRV_SRC5_DAC_M_ON) == MCDRV_SRC5_DAC_M_ON))
+			{
+				bUsed	= 1;
+			}
+		}
+		else
+		{
+		}
+		break;
+
+	case	eMCDRV_DST_RCV:
+		if(eCh == eMCDRV_DST_CH0)
+		{
+			if(((gsGlobalInfo.sPathInfo.asRcOut[0].abSrcOnOff[MCDRV_SRC_MIC1_BLOCK] & MCDRV_SRC0_MIC1_ON) == MCDRV_SRC0_MIC1_ON)
+			|| ((gsGlobalInfo.sPathInfo.asRcOut[0].abSrcOnOff[MCDRV_SRC_MIC2_BLOCK] & MCDRV_SRC0_MIC2_ON) == MCDRV_SRC0_MIC2_ON)
+			|| ((gsGlobalInfo.sPathInfo.asRcOut[0].abSrcOnOff[MCDRV_SRC_MIC3_BLOCK] & MCDRV_SRC0_MIC3_ON) == MCDRV_SRC0_MIC3_ON)
+			|| ((gsGlobalInfo.sPathInfo.asRcOut[0].abSrcOnOff[MCDRV_SRC_LINE1_M_BLOCK] & MCDRV_SRC1_LINE1_M_ON) == MCDRV_SRC1_LINE1_M_ON)
+			|| ((gsGlobalInfo.sPathInfo.asRcOut[0].abSrcOnOff[MCDRV_SRC_DAC_L_BLOCK] & MCDRV_SRC5_DAC_L_ON) == MCDRV_SRC5_DAC_L_ON)
+			|| ((gsGlobalInfo.sPathInfo.asRcOut[0].abSrcOnOff[MCDRV_SRC_DAC_R_BLOCK] & MCDRV_SRC5_DAC_R_ON) ==MCDRV_SRC5_DAC_R_ON))
+			{
+				bUsed	= 1;
+			}
+		}
+		else
+		{
+		}
+		break;
+
+	case	eMCDRV_DST_LOUT1:
+		if(eCh == eMCDRV_DST_CH0)
+		{
+			if(((gsGlobalInfo.sPathInfo.asLout1[0].abSrcOnOff[MCDRV_SRC_MIC1_BLOCK] & MCDRV_SRC0_MIC1_ON) == MCDRV_SRC0_MIC1_ON)
+			|| ((gsGlobalInfo.sPathInfo.asLout1[0].abSrcOnOff[MCDRV_SRC_MIC2_BLOCK] & MCDRV_SRC0_MIC2_ON) == MCDRV_SRC0_MIC2_ON)
+			|| ((gsGlobalInfo.sPathInfo.asLout1[0].abSrcOnOff[MCDRV_SRC_MIC3_BLOCK] & MCDRV_SRC0_MIC3_ON) == MCDRV_SRC0_MIC3_ON)
+			|| ((gsGlobalInfo.sPathInfo.asLout1[0].abSrcOnOff[MCDRV_SRC_LINE1_L_BLOCK] & MCDRV_SRC1_LINE1_L_ON) == MCDRV_SRC1_LINE1_L_ON)
+			|| ((gsGlobalInfo.sPathInfo.asLout1[0].abSrcOnOff[MCDRV_SRC_LINE1_M_BLOCK] & MCDRV_SRC1_LINE1_M_ON) == MCDRV_SRC1_LINE1_M_ON)
+			|| ((gsGlobalInfo.sPathInfo.asLout1[0].abSrcOnOff[MCDRV_SRC_DAC_L_BLOCK] & MCDRV_SRC5_DAC_L_ON) == MCDRV_SRC5_DAC_L_ON)
+			|| ((gsGlobalInfo.sPathInfo.asLout1[0].abSrcOnOff[MCDRV_SRC_DAC_M_BLOCK] & MCDRV_SRC5_DAC_M_ON) == MCDRV_SRC5_DAC_M_ON))
+			{
+				bUsed	= 1;
+			}
+		}
+		else if(eCh == eMCDRV_DST_CH1)
+		{
+			if(((gsGlobalInfo.sPathInfo.asLout1[1].abSrcOnOff[MCDRV_SRC_MIC1_BLOCK] & MCDRV_SRC0_MIC1_ON) == MCDRV_SRC0_MIC1_ON)
+			|| ((gsGlobalInfo.sPathInfo.asLout1[1].abSrcOnOff[MCDRV_SRC_MIC2_BLOCK] & MCDRV_SRC0_MIC2_ON) == MCDRV_SRC0_MIC2_ON)
+			|| ((gsGlobalInfo.sPathInfo.asLout1[1].abSrcOnOff[MCDRV_SRC_MIC3_BLOCK] & MCDRV_SRC0_MIC3_ON) == MCDRV_SRC0_MIC3_ON)
+			|| ((gsGlobalInfo.sPathInfo.asLout1[1].abSrcOnOff[MCDRV_SRC_LINE1_R_BLOCK] & MCDRV_SRC1_LINE1_R_ON) == MCDRV_SRC1_LINE1_R_ON)
+			|| ((gsGlobalInfo.sPathInfo.asLout1[1].abSrcOnOff[MCDRV_SRC_DAC_R_BLOCK] & MCDRV_SRC5_DAC_R_ON) == MCDRV_SRC5_DAC_R_ON))
+			{
+				bUsed	= 1;
+			}
+		}
+		else
+		{
+		}
+		break;
+
+	case	eMCDRV_DST_LOUT2:
+		if(eCh == eMCDRV_DST_CH0)
+		{
+			if(((gsGlobalInfo.sPathInfo.asLout2[0].abSrcOnOff[MCDRV_SRC_MIC1_BLOCK] & MCDRV_SRC0_MIC1_ON) == MCDRV_SRC0_MIC1_ON)
+			|| ((gsGlobalInfo.sPathInfo.asLout2[0].abSrcOnOff[MCDRV_SRC_MIC2_BLOCK] & MCDRV_SRC0_MIC2_ON) == MCDRV_SRC0_MIC2_ON)
+			|| ((gsGlobalInfo.sPathInfo.asLout2[0].abSrcOnOff[MCDRV_SRC_MIC3_BLOCK] & MCDRV_SRC0_MIC3_ON) == MCDRV_SRC0_MIC3_ON)
+			|| ((gsGlobalInfo.sPathInfo.asLout2[0].abSrcOnOff[MCDRV_SRC_LINE1_L_BLOCK] & MCDRV_SRC1_LINE1_L_ON) == MCDRV_SRC1_LINE1_L_ON)
+			|| ((gsGlobalInfo.sPathInfo.asLout2[0].abSrcOnOff[MCDRV_SRC_LINE1_M_BLOCK] & MCDRV_SRC1_LINE1_M_ON) == MCDRV_SRC1_LINE1_M_ON)
+			|| ((gsGlobalInfo.sPathInfo.asLout2[0].abSrcOnOff[MCDRV_SRC_DAC_L_BLOCK] & MCDRV_SRC5_DAC_L_ON) == MCDRV_SRC5_DAC_L_ON)
+			|| ((gsGlobalInfo.sPathInfo.asLout2[0].abSrcOnOff[MCDRV_SRC_DAC_M_BLOCK] & MCDRV_SRC5_DAC_M_ON) == MCDRV_SRC5_DAC_M_ON))
+			{
+				bUsed	= 1;
+			}
+		}
+		else if(eCh == eMCDRV_DST_CH1)
+		{
+			if(((gsGlobalInfo.sPathInfo.asLout2[1].abSrcOnOff[MCDRV_SRC_MIC1_BLOCK] & MCDRV_SRC0_MIC1_ON) == MCDRV_SRC0_MIC1_ON)
+			|| ((gsGlobalInfo.sPathInfo.asLout2[1].abSrcOnOff[MCDRV_SRC_MIC2_BLOCK] & MCDRV_SRC0_MIC2_ON) == MCDRV_SRC0_MIC2_ON)
+			|| ((gsGlobalInfo.sPathInfo.asLout2[1].abSrcOnOff[MCDRV_SRC_MIC3_BLOCK] & MCDRV_SRC0_MIC3_ON) == MCDRV_SRC0_MIC3_ON)
+			|| ((gsGlobalInfo.sPathInfo.asLout2[1].abSrcOnOff[MCDRV_SRC_LINE1_R_BLOCK] & MCDRV_SRC1_LINE1_R_ON) == MCDRV_SRC1_LINE1_R_ON)
+			|| ((gsGlobalInfo.sPathInfo.asLout2[1].abSrcOnOff[MCDRV_SRC_DAC_R_BLOCK] & MCDRV_SRC5_DAC_R_ON) == MCDRV_SRC5_DAC_R_ON))
+			{
+				bUsed	= 1;
+			}
+		}
+		else
+		{
+		}
+		break;
+
+	case	eMCDRV_DST_PEAK:
+		break;
+
+	case	eMCDRV_DST_DIT0:
+		if(eCh == eMCDRV_DST_CH0)
+		{
+			if(McResCtrl_GetDITSource(eMCDRV_DIO_0) != eMCDRV_SRC_NONE)
+			{
+				bUsed	= 1;
+			}
+		}
+		else
+		{
+		}
+		break;
+
+	case	eMCDRV_DST_DIT1:
+		if(eCh == eMCDRV_DST_CH0)
+		{
+			if(McResCtrl_GetDITSource(eMCDRV_DIO_1) != eMCDRV_SRC_NONE)
+			{
+				bUsed	= 1;
+			}
+		}
+		else
+		{
+		}
+		break;
+
+	case	eMCDRV_DST_DIT2:
+		if(eCh == eMCDRV_DST_CH0)
+		{
+			if(McResCtrl_GetDITSource(eMCDRV_DIO_2) != eMCDRV_SRC_NONE)
+			{
+				bUsed	= 1;
+			}
+		}
+		else
+		{
+		}
+		break;
+
+	case	eMCDRV_DST_DAC:
+		if(eCh == eMCDRV_DST_CH0)
+		{
+			if(McResCtrl_GetDACSource(eMCDRV_DAC_MASTER) != eMCDRV_SRC_NONE)
+			{
+				bUsed	= 1;
+			}
+		}
+		else if(eCh == eMCDRV_DST_CH1)
+		{
+			if(McResCtrl_GetDACSource(eMCDRV_DAC_VOICE) != eMCDRV_SRC_NONE)
+			{
+				bUsed	= 1;
+			}
+		}
+		else
+		{
+		}
+		break;
+
+	case	eMCDRV_DST_AE:
+		if(eCh == eMCDRV_DST_CH0)
+		{
+			if(McResCtrl_GetAESource() != eMCDRV_SRC_NONE)
+			{
+				bUsed	= 1;
+			}
+		}
+		else
+		{
+		}
+		break;
+
+	case	eMCDRV_DST_CDSP:
+		break;
+
+	case	eMCDRV_DST_ADC0:
+		if(eCh == eMCDRV_DST_CH0)
+		{
+			if(((gsGlobalInfo.sPathInfo.asAdc0[0].abSrcOnOff[MCDRV_SRC_MIC1_BLOCK] & MCDRV_SRC0_MIC1_ON) == MCDRV_SRC0_MIC1_ON)
+			|| ((gsGlobalInfo.sPathInfo.asAdc0[0].abSrcOnOff[MCDRV_SRC_MIC2_BLOCK] & MCDRV_SRC0_MIC2_ON) == MCDRV_SRC0_MIC2_ON)
+			|| ((gsGlobalInfo.sPathInfo.asAdc0[0].abSrcOnOff[MCDRV_SRC_MIC3_BLOCK] & MCDRV_SRC0_MIC3_ON) == MCDRV_SRC0_MIC3_ON)
+			|| ((gsGlobalInfo.sPathInfo.asAdc0[0].abSrcOnOff[MCDRV_SRC_LINE1_L_BLOCK] & MCDRV_SRC1_LINE1_L_ON) == MCDRV_SRC1_LINE1_L_ON)
+			|| ((gsGlobalInfo.sPathInfo.asAdc0[0].abSrcOnOff[MCDRV_SRC_LINE1_M_BLOCK] & MCDRV_SRC1_LINE1_M_ON) == MCDRV_SRC1_LINE1_M_ON))
+			{
+				bUsed	= 1;
+			}
+		}
+		else if(eCh == eMCDRV_DST_CH1)
+		{
+			if(((gsGlobalInfo.sPathInfo.asAdc0[1].abSrcOnOff[MCDRV_SRC_MIC1_BLOCK] & MCDRV_SRC0_MIC1_ON) == MCDRV_SRC0_MIC1_ON)
+			|| ((gsGlobalInfo.sPathInfo.asAdc0[1].abSrcOnOff[MCDRV_SRC_MIC2_BLOCK] & MCDRV_SRC0_MIC2_ON) == MCDRV_SRC0_MIC2_ON)
+			|| ((gsGlobalInfo.sPathInfo.asAdc0[1].abSrcOnOff[MCDRV_SRC_MIC3_BLOCK] & MCDRV_SRC0_MIC3_ON) == MCDRV_SRC0_MIC3_ON)
+			|| ((gsGlobalInfo.sPathInfo.asAdc0[1].abSrcOnOff[MCDRV_SRC_LINE1_R_BLOCK] & MCDRV_SRC1_LINE1_R_ON) == MCDRV_SRC1_LINE1_R_ON)
+			|| ((gsGlobalInfo.sPathInfo.asAdc0[1].abSrcOnOff[MCDRV_SRC_LINE1_M_BLOCK] & MCDRV_SRC1_LINE1_M_ON) == MCDRV_SRC1_LINE1_M_ON))
+			{
+				bUsed	= 1;
+			}
+		}
+		else
+		{
+		}
+		break;
+
+	case	eMCDRV_DST_ADC1:
+		if(McDevProf_IsValid(eMCDRV_FUNC_ADC1) == 1)
+		{
+			if(eCh == eMCDRV_DST_CH0)
+			{
+				if(((gsGlobalInfo.sPathInfo.asAdc1[0].abSrcOnOff[MCDRV_SRC_MIC1_BLOCK] & MCDRV_SRC0_MIC1_ON) == MCDRV_SRC0_MIC1_ON)
+				|| ((gsGlobalInfo.sPathInfo.asAdc1[0].abSrcOnOff[MCDRV_SRC_MIC2_BLOCK] & MCDRV_SRC0_MIC2_ON) == MCDRV_SRC0_MIC2_ON)
+				|| ((gsGlobalInfo.sPathInfo.asAdc1[0].abSrcOnOff[MCDRV_SRC_MIC3_BLOCK] & MCDRV_SRC0_MIC3_ON) == MCDRV_SRC0_MIC3_ON)
+				|| ((gsGlobalInfo.sPathInfo.asAdc1[0].abSrcOnOff[MCDRV_SRC_LINE1_L_BLOCK] & MCDRV_SRC1_LINE1_L_ON) == MCDRV_SRC1_LINE1_L_ON)
+				|| ((gsGlobalInfo.sPathInfo.asAdc1[0].abSrcOnOff[MCDRV_SRC_LINE1_M_BLOCK] & MCDRV_SRC1_LINE1_M_ON) == MCDRV_SRC1_LINE1_M_ON))
+				{
+					bUsed	= 1;
+				}
+			}
+			else
+			{
+			}
+		}
+		break;
+
+	case	eMCDRV_DST_MIX:
+		if(eCh != 0)
+		{
+			break;
+		}
+		if(((gsGlobalInfo.sPathInfo.asMix[0].abSrcOnOff[MCDRV_SRC_PDM_BLOCK] & MCDRV_SRC4_PDM_ON) == MCDRV_SRC4_PDM_ON)
+		|| ((gsGlobalInfo.sPathInfo.asMix[0].abSrcOnOff[MCDRV_SRC_ADC0_BLOCK] & MCDRV_SRC4_ADC0_ON) == MCDRV_SRC4_ADC0_ON)
+		|| ((gsGlobalInfo.sPathInfo.asMix[0].abSrcOnOff[MCDRV_SRC_DIR0_BLOCK] & MCDRV_SRC3_DIR0_ON) == MCDRV_SRC3_DIR0_ON)
+		|| ((gsGlobalInfo.sPathInfo.asMix[0].abSrcOnOff[MCDRV_SRC_DIR1_BLOCK] & MCDRV_SRC3_DIR1_ON) == MCDRV_SRC3_DIR1_ON)
+		|| ((gsGlobalInfo.sPathInfo.asMix[0].abSrcOnOff[MCDRV_SRC_DIR2_BLOCK] & MCDRV_SRC3_DIR2_ON) == MCDRV_SRC3_DIR2_ON)
+		|| ((gsGlobalInfo.sPathInfo.asMix[0].abSrcOnOff[MCDRV_SRC_AE_BLOCK] & MCDRV_SRC6_AE_ON) == MCDRV_SRC6_AE_ON))
+		{
+			bUsed	= 1;
+		}
+		break;
+
+	case	eMCDRV_DST_BIAS:
+		if(eCh == eMCDRV_DST_CH0)
+		{
+			if(((gsGlobalInfo.sPathInfo.asBias[0].abSrcOnOff[MCDRV_SRC_MIC1_BLOCK] & MCDRV_SRC0_MIC1_ON) == MCDRV_SRC0_MIC1_ON)
+			|| ((gsGlobalInfo.sPathInfo.asBias[0].abSrcOnOff[MCDRV_SRC_MIC2_BLOCK] & MCDRV_SRC0_MIC2_ON) == MCDRV_SRC0_MIC2_ON)
+			|| ((gsGlobalInfo.sPathInfo.asBias[0].abSrcOnOff[MCDRV_SRC_MIC3_BLOCK] & MCDRV_SRC0_MIC3_ON) == MCDRV_SRC0_MIC3_ON))
+			{
+				bUsed	= 1;
+			}
+		}
+		else
+		{
+		}
+		break;
+
+	default:
+		break;
+	}
+
+#if (MCDRV_DEBUG_LEVEL>=4)
+	sdRet	= (SINT32)bUsed;
+	McDebugLog_FuncOut("McResCtrl_IsDstUsed", &sdRet);
+#endif
+
+	return bUsed;
+}
+
+/****************************************************************************
+ *	McResCtrl_GetRegAccess
+ *
+ *	Description:
+ *			Get register access availability
+ *	Arguments:
+ *			psRegInfo	register information
+ *	Return:
+ *			MCDRV_REG_ACCSESS
+ *
+ ****************************************************************************/
+MCDRV_REG_ACCSESS	McResCtrl_GetRegAccess
+(
+	const MCDRV_REG_INFO*	psRegInfo
+)
+{
+	MCDRV_REG_ACCSESS	eAccess	= eMCDRV_ACCESS_DENY;
+
+#if (MCDRV_DEBUG_LEVEL>=4)
+	SINT32	sdRet;
+	McDebugLog_FuncIn("McResCtrl_GetRegAccess");
+#endif
+
+	switch(psRegInfo->bRegType)
+	{
+	case	MCDRV_REGTYPE_A:
+		eAccess	= gawRegAccessAvailableA[psRegInfo->bAddress];
+		break;
+	case	MCDRV_REGTYPE_B_BASE:
+		eAccess	= gawRegAccessAvailableB_BASE[psRegInfo->bAddress];
+		break;
+	case	MCDRV_REGTYPE_B_ANALOG:
+		eAccess	= gawRegAccessAvailableB_ANA[psRegInfo->bAddress];
+		break;
+	case	MCDRV_REGTYPE_B_CODEC:
+		eAccess	= gawRegAccessAvailableB_CODEC[psRegInfo->bAddress];
+		break;
+	case	MCDRV_REGTYPE_B_MIXER:
+		eAccess	= gawRegAccessAvailableB_MIX[psRegInfo->bAddress];
+		break;
+	case	MCDRV_REGTYPE_B_AE:
+		eAccess	= gawRegAccessAvailableB_AE[psRegInfo->bAddress];
+		break;
+	default:
+		break;
+	}
+
+#if (MCDRV_DEBUG_LEVEL>=4)
+	sdRet	= eAccess;
+	McDebugLog_FuncOut("McResCtrl_GetRegAccess", &sdRet);
+#endif
+
+	return eAccess;
+}
+
+/****************************************************************************
+ *	McResCtrl_GetAPMode
+ *
+ *	Description:
+ *			get auto power management mode.
+ *	Arguments:
+ *			none
+ *	Return:
+ *			eMCDRV_APM_ON
+ *			eMCDRV_APM_OFF
+ *
+ ****************************************************************************/
+MCDRV_PMODE	McResCtrl_GetAPMode
+(
+	void
+)
+{
+#if (MCDRV_DEBUG_LEVEL>=4)
+	SINT32	sdRet	= gsGlobalInfo.eAPMode;
+	McDebugLog_FuncIn("McResCtrl_GetAPMode");
+#endif
+
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncOut("McResCtrl_GetAPMode", &sdRet);
+#endif
+
+	return gsGlobalInfo.eAPMode;
+}
+
+
+/****************************************************************************
+ *	McResCtrl_AllocPacketBuf
+ *
+ *	Description:
+ *			allocate the buffer for register setting packets.
+ *	Arguments:
+ *			none
+ *	Return:
+ *			pointer to the area to store packets
+ *
+ ****************************************************************************/
+MCDRV_PACKET*	McResCtrl_AllocPacketBuf
+(
+	void
+)
+{
+#if (MCDRV_DEBUG_LEVEL>=4)
+	SINT32	sdRet;
+	McDebugLog_FuncIn("McResCtrl_AllocPacketBuf");
+#endif
+
+	if(eMCDRV_PACKETBUF_ALLOCATED == gsGlobalInfo.ePacketBufAlloc)
+	{
+		#if (MCDRV_DEBUG_LEVEL>=4)
+			sdRet	= 0;
+			McDebugLog_FuncOut("McResCtrl_AllocPacketBuf", &sdRet);
+		#endif
+		return NULL;
+	}
+
+	gsGlobalInfo.ePacketBufAlloc = eMCDRV_PACKETBUF_ALLOCATED;
+
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncOut("McResCtrl_AllocPacketBuf", 0);
+#endif
+	return gasPacket;
+}
+
+/****************************************************************************
+ *	McResCtrl_ReleasePacketBuf
+ *
+ *	Description:
+ *			Release the buffer for register setting packets.
+ *	Arguments:
+ *			none
+ *	Return:
+ *			none
+ *
+ ****************************************************************************/
+void	McResCtrl_ReleasePacketBuf
+(
+	void
+)
+{
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncIn("McResCtrl_ReleasePacketBuf");
+#endif
+
+	gsGlobalInfo.ePacketBufAlloc = eMCDRV_PACKETBUF_FREE;
+
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncOut("McResCtrl_ReleasePacketBuf", 0);
+#endif
+}
+
+/****************************************************************************
+ *	McResCtrl_InitRegUpdate
+ *
+ *	Description:
+ *			Initialize the process of register update.
+ *	Arguments:
+ *			none
+ *	Return:
+ *			none
+ *
+ ****************************************************************************/
+void	McResCtrl_InitRegUpdate
+(
+	void
+)
+{
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncIn("McResCtrl_InitRegUpdate");
+#endif
+
+	gsGlobalInfo.sCtrlPacket.wDataNum	= 0;
+	gsGlobalInfo.wCurSlaveAddress		= 0xFFFF;
+	gsGlobalInfo.wCurRegType			= 0xFFFF;
+	gsGlobalInfo.wCurRegAddress			= 0xFFFF;
+	gsGlobalInfo.wDataContinueCount		= 0;
+	gsGlobalInfo.wPrevAddressIndex		= 0;
+
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncOut("McResCtrl_InitRegUpdate", 0);
+#endif
+}
+
+/****************************************************************************
+ *	McResCtrl_AddRegUpdate
+ *
+ *	Description:
+ *			Add register update packet and save register value.
+ *	Arguments:
+ *			wRegType	register type
+ *			wAddress	address
+ *			bData		write data
+ *			eUpdateMode	updete mode
+ *	Return:
+ *			none
+ *
+ ****************************************************************************/
+void	McResCtrl_AddRegUpdate
+(
+	UINT16	wRegType,
+	UINT16	wAddress,
+	UINT8	bData,
+	MCDRV_UPDATE_MODE	eUpdateMode
+)
+{
+	UINT8			*pbRegVal;
+	UINT8			bAddressADR;
+	UINT8			bAddressWINDOW;
+	UINT8			*pbCtrlData;
+	UINT16			*pwCtrlDataNum;
+	const UINT16	*pwNextAddress;
+	UINT16			wNextAddress;
+	UINT16			wSlaveAddress;
+
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncIn("McResCtrl_AddRegUpdate");
+#endif
+
+	switch (wRegType)
+	{
+	case MCDRV_PACKET_REGTYPE_A:
+		wSlaveAddress	= McDevProf_GetSlaveAddr(eMCDRV_SLAVE_ADDR_DIG);
+		pbRegVal		= gsGlobalInfo.abRegValA;
+		pwNextAddress	= gawNextAddressA;
+		bAddressADR		= (UINT8)wAddress;
+		bAddressWINDOW	= bAddressADR;
+		if(MCDRV_A_REG_NUM <= wAddress)
+		{
+			#if (MCDRV_DEBUG_LEVEL>=4)
+				McDebugLog_FuncOut("McResCtrl_AddRegUpdate", 0);
+			#endif
+			return;
+		}
+		break;
+
+	case MCDRV_PACKET_REGTYPE_B_BASE:
+		wSlaveAddress	= McDevProf_GetSlaveAddr(eMCDRV_SLAVE_ADDR_DIG);
+		pbRegVal		= gsGlobalInfo.abRegValB_BASE;
+		pwNextAddress	= gawNextAddressB_BASE;
+		bAddressADR		= MCI_BASE_ADR;
+		bAddressWINDOW	= MCI_BASE_WINDOW;
+		if(MCDRV_B_BASE_REG_NUM <= wAddress)
+		{
+			#if (MCDRV_DEBUG_LEVEL>=4)
+				McDebugLog_FuncOut("McResCtrl_AddRegUpdate", 0);
+			#endif
+			return;
+		}
+		break;
+
+	case MCDRV_PACKET_REGTYPE_B_CODEC:
+		wSlaveAddress	= McDevProf_GetSlaveAddr(eMCDRV_SLAVE_ADDR_DIG);
+		pbRegVal		= gsGlobalInfo.abRegValB_CODEC;
+		pwNextAddress	= gawNextAddressB_CODEC;
+		bAddressADR		= MCI_CD_ADR;
+		bAddressWINDOW	= MCI_CD_WINDOW;
+		if(MCDRV_B_CODEC_REG_NUM <= wAddress)
+		{
+			#if (MCDRV_DEBUG_LEVEL>=4)
+				McDebugLog_FuncOut("McResCtrl_AddRegUpdate", 0);
+			#endif
+			return;
+		}
+		break;
+
+	case MCDRV_PACKET_REGTYPE_B_ANA:
+		wSlaveAddress	= McDevProf_GetSlaveAddr(eMCDRV_SLAVE_ADDR_ANA);
+		pbRegVal		= gsGlobalInfo.abRegValB_ANA;
+		pwNextAddress	= gawNextAddressB_Ana;
+		bAddressADR		= MCI_ANA_ADR;
+		bAddressWINDOW	= MCI_ANA_WINDOW;
+		if(MCDRV_B_ANA_REG_NUM <= wAddress)
+		{
+			#if (MCDRV_DEBUG_LEVEL>=4)
+				McDebugLog_FuncOut("McResCtrl_AddRegUpdate", 0);
+			#endif
+			return;
+		}
+		break;
+
+	case MCDRV_PACKET_REGTYPE_B_MIXER:
+		wSlaveAddress	= McDevProf_GetSlaveAddr(eMCDRV_SLAVE_ADDR_DIG);
+		pbRegVal		= gsGlobalInfo.abRegValB_MIXER;
+		pwNextAddress	= gawNextAddressB_MIXER;
+		bAddressADR		= MCI_MIX_ADR;
+		bAddressWINDOW	= MCI_MIX_WINDOW;
+		if(MCDRV_B_MIXER_REG_NUM <= wAddress)
+		{
+			#if (MCDRV_DEBUG_LEVEL>=4)
+				McDebugLog_FuncOut("McResCtrl_AddRegUpdate", 0);
+			#endif
+			return;
+		}
+		break;
+
+	case MCDRV_PACKET_REGTYPE_B_AE:
+		wSlaveAddress	= McDevProf_GetSlaveAddr(eMCDRV_SLAVE_ADDR_DIG);
+		pbRegVal		= gsGlobalInfo.abRegValB_AE;
+		pwNextAddress	= gawNextAddressB_AE;
+		bAddressADR		= MCI_AE_ADR;
+		bAddressWINDOW	= MCI_AE_WINDOW;
+		if(MCDRV_B_AE_REG_NUM <= wAddress)
+		{
+			#if (MCDRV_DEBUG_LEVEL>=4)
+				McDebugLog_FuncOut("McResCtrl_AddRegUpdate", 0);
+			#endif
+			return;
+		}
+		break;
+
+	case MCDRV_PACKET_REGTYPE_B_CDSP:
+		wSlaveAddress	= McDevProf_GetSlaveAddr(eMCDRV_SLAVE_ADDR_DIG);
+		pbRegVal		= gsGlobalInfo.abRegValB_CDSP;
+		pwNextAddress	= gawNextAddressB_CDSP;
+		bAddressADR		= MCI_CDSP_ADR;
+		bAddressWINDOW	= MCI_CDSP_WINDOW;
+		if(MCDRV_B_CDSP_REG_NUM <= wAddress)
+		{
+			#if (MCDRV_DEBUG_LEVEL>=4)
+				McDebugLog_FuncOut("McResCtrl_AddRegUpdate", 0);
+			#endif
+			return;
+		}
+		break;
+
+	default:
+		#if (MCDRV_DEBUG_LEVEL>=4)
+			McDebugLog_FuncOut("McResCtrl_AddRegUpdate", 0);
+		#endif
+		return;
+	}
+
+	if((gsGlobalInfo.wCurSlaveAddress != 0xFFFF) && (gsGlobalInfo.wCurSlaveAddress != wSlaveAddress))
+	{
+		McResCtrl_ExecuteRegUpdate();
+		McResCtrl_InitRegUpdate();
+	}
+
+	if((gsGlobalInfo.wCurRegType != 0xFFFF) && (gsGlobalInfo.wCurRegType != wRegType))
+	{
+		McResCtrl_ExecuteRegUpdate();
+		McResCtrl_InitRegUpdate();
+	}
+
+	if((eMCDRV_UPDATE_FORCE == eUpdateMode) || (bData != pbRegVal[wAddress]))
+	{
+		if(gsGlobalInfo.wCurRegAddress == 0xFFFF)
+		{
+			gsGlobalInfo.wCurRegAddress	= wAddress;
+		}
+
+		if (eMCDRV_UPDATE_DUMMY != eUpdateMode)
+		{
+			pbCtrlData		= gsGlobalInfo.sCtrlPacket.abData;
+			pwCtrlDataNum	= &(gsGlobalInfo.sCtrlPacket.wDataNum);
+			wNextAddress	= pwNextAddress[gsGlobalInfo.wCurRegAddress];
+
+			if ((wSlaveAddress == gsGlobalInfo.wCurSlaveAddress)
+			&& (wRegType == gsGlobalInfo.wCurRegType)
+			&& (0xFFFF != wNextAddress)
+			&& (wAddress != wNextAddress))
+			{
+				if (pwNextAddress[wNextAddress] == wAddress)
+				{
+					if (0 == gsGlobalInfo.wDataContinueCount)
+					{
+						pbCtrlData[gsGlobalInfo.wPrevAddressIndex] |= MCDRV_BURST_WRITE_ENABLE;
+					}
+					pbCtrlData[*pwCtrlDataNum]	= pbRegVal[wNextAddress];
+					(*pwCtrlDataNum)++;
+					gsGlobalInfo.wDataContinueCount++;
+					wNextAddress				= pwNextAddress[wNextAddress];
+				}
+				else if ((0xFFFF != pwNextAddress[wNextAddress])
+						&& (pwNextAddress[pwNextAddress[wNextAddress]] == wAddress))
+				{
+					if (0 == gsGlobalInfo.wDataContinueCount)
+					{
+						pbCtrlData[gsGlobalInfo.wPrevAddressIndex] |= MCDRV_BURST_WRITE_ENABLE;
+					}
+					pbCtrlData[*pwCtrlDataNum]	= pbRegVal[wNextAddress];
+					(*pwCtrlDataNum)++;
+					pbCtrlData[*pwCtrlDataNum]	= pbRegVal[pwNextAddress[wNextAddress]];
+					(*pwCtrlDataNum)++;
+					gsGlobalInfo.wDataContinueCount += 2;
+					wNextAddress				= pwNextAddress[pwNextAddress[wNextAddress]];
+				}
+				else
+				{
+				}
+			}
+
+			if ((0 == *pwCtrlDataNum) || (wAddress != wNextAddress))
+			{
+				if (0 != gsGlobalInfo.wDataContinueCount)
+				{
+					McResCtrl_ExecuteRegUpdate();
+					McResCtrl_InitRegUpdate();
+				}
+
+				if (MCDRV_PACKET_REGTYPE_A == (UINT32)wRegType)
+				{
+					pbCtrlData[*pwCtrlDataNum]		= (bAddressADR << 1);
+					gsGlobalInfo.wPrevAddressIndex	= *pwCtrlDataNum;
+					(*pwCtrlDataNum)++;
+				}
+				else
+				{
+					pbCtrlData[(*pwCtrlDataNum)++]	= (bAddressADR << 1);
+					pbCtrlData[(*pwCtrlDataNum)++]	= (UINT8)wAddress;
+					pbCtrlData[*pwCtrlDataNum]		= (bAddressWINDOW << 1);
+					gsGlobalInfo.wPrevAddressIndex	= (*pwCtrlDataNum)++;
+				}
+			}
+			else
+			{
+				if (0 == gsGlobalInfo.wDataContinueCount)
+				{
+					pbCtrlData[gsGlobalInfo.wPrevAddressIndex] |= MCDRV_BURST_WRITE_ENABLE;
+				}
+				gsGlobalInfo.wDataContinueCount++;
+			}
+
+			pbCtrlData[(*pwCtrlDataNum)++]	= bData;
+		}
+
+		gsGlobalInfo.wCurSlaveAddress	= wSlaveAddress;
+		gsGlobalInfo.wCurRegType		= wRegType;
+		gsGlobalInfo.wCurRegAddress		= wAddress;
+
+		/* save register value */
+		pbRegVal[wAddress] = bData;
+	}
+
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncOut("McResCtrl_AddRegUpdate", 0);
+#endif
+}
+
+/****************************************************************************
+ *	McResCtrl_ExecuteRegUpdate
+ *
+ *	Description:
+ *			Add register update packet and save register value.
+ *	Arguments:
+ *			none
+ *	Return:
+ *			none
+ *
+ ****************************************************************************/
+void	McResCtrl_ExecuteRegUpdate
+(
+	void
+)
+{
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncIn("McResCtrl_ExecuteRegUpdate");
+#endif
+
+	if (0 != gsGlobalInfo.sCtrlPacket.wDataNum)
+	{
+		McSrv_WriteI2C((UINT8)gsGlobalInfo.wCurSlaveAddress, gsGlobalInfo.sCtrlPacket.abData, gsGlobalInfo.sCtrlPacket.wDataNum);
+	}
+
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncOut("McResCtrl_ExecuteRegUpdate", 0);
+#endif
+}
+
+/****************************************************************************
+ *	McResCtrl_WaitEvent
+ *
+ *	Description:
+ *			Wait event.
+ *	Arguments:
+ *			dEvent	event to wait
+ *			dParam	event parameter
+ *	Return:
+ *			MCDRV_SUCCESS
+ *			MCDRV_ERROR_TIMEOUT
+ *
+ ****************************************************************************/
+SINT32	McResCtrl_WaitEvent
+(
+	UINT32	dEvent,
+	UINT32	dParam
+)
+{
+	SINT32	sdRet	= MCDRV_SUCCESS;
+	UINT32	dInterval;
+	UINT32	dTimeOut;
+	UINT8	bSlaveAddr;
+	UINT8	abWriteData[2];
+
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncIn("McResCtrl_WaitEvent");
+#endif
+
+
+	switch(dEvent)
+	{
+	case	MCDRV_EVT_INSFLG:
+		dInterval	= gsGlobalInfo.sInitInfo.sWaitTime.dSvolInterval;
+		dTimeOut	= gsGlobalInfo.sInitInfo.sWaitTime.dSvolTimeOut;
+		bSlaveAddr	= McDevProf_GetSlaveAddr(eMCDRV_SLAVE_ADDR_DIG);
+		if((dParam>>8) != (UINT32)0)
+		{
+			abWriteData[0]	= MCI_MIX_ADR<<1;
+			abWriteData[1]	= MCI_DAC_INS_FLAG;
+			McSrv_WriteI2C(bSlaveAddr, abWriteData, 2);
+			sdRet	= WaitBitRelease(bSlaveAddr, MCI_MIX_WINDOW, (UINT8)(dParam>>8), dInterval, dTimeOut);
+			if(MCDRV_SUCCESS != sdRet)
+			{
+				break;
+			}
+		}
+		else if((dParam&(UINT32)0xFF) != (UINT32)0)
+		{
+			abWriteData[0]	= MCI_MIX_ADR<<1;
+			abWriteData[1]	= MCI_INS_FLAG;
+			McSrv_WriteI2C(bSlaveAddr, abWriteData, 2);
+			sdRet	= WaitBitRelease(bSlaveAddr, (UINT16)MCI_MIX_WINDOW, (UINT8)(dParam&(UINT32)0xFF), dInterval, dTimeOut);
+		}
+		else
+		{
+		}
+		break;
+
+	case	MCDRV_EVT_ALLMUTE:
+		dInterval	= gsGlobalInfo.sInitInfo.sWaitTime.dSvolInterval;
+		dTimeOut	= gsGlobalInfo.sInitInfo.sWaitTime.dSvolTimeOut;
+		bSlaveAddr	= McDevProf_GetSlaveAddr(eMCDRV_SLAVE_ADDR_DIG);
+		abWriteData[0]	= MCI_MIX_ADR<<1;
+		abWriteData[1]	= MCI_DIT_INVFLAGL;
+		McSrv_WriteI2C(bSlaveAddr, abWriteData, 2);
+		sdRet	= WaitBitRelease(bSlaveAddr, (UINT16)MCI_MIX_WINDOW, (MCB_DIT0_INVFLAGL|MCB_DIT1_INVFLAGL|MCB_DIT2_INVFLAGL), dInterval, dTimeOut);
+		if(MCDRV_SUCCESS != sdRet)
+		{
+			break;
+		}
+		abWriteData[0]	= MCI_MIX_ADR<<1;
+		abWriteData[1]	= MCI_DIT_INVFLAGR;
+		McSrv_WriteI2C(McDevProf_GetSlaveAddr(eMCDRV_SLAVE_ADDR_DIG), abWriteData, 2);
+		sdRet	= WaitBitRelease(bSlaveAddr, (UINT16)MCI_MIX_WINDOW, (MCB_DIT0_INVFLAGR|MCB_DIT1_INVFLAGR|MCB_DIT2_INVFLAGR), dInterval, dTimeOut);
+		if(MCDRV_SUCCESS != sdRet)
+		{
+			break;
+		}
+		abWriteData[0]	= MCI_MIX_ADR<<1;
+		abWriteData[1]	= MCI_DIR_VFLAGL;
+		McSrv_WriteI2C(bSlaveAddr, abWriteData, 2);
+		sdRet	= WaitBitRelease(bSlaveAddr, (UINT16)MCI_MIX_WINDOW, (MCB_PDM0_VFLAGL|MCB_DIR0_VFLAGL|MCB_DIR1_VFLAGL|MCB_DIR2_VFLAGL), dInterval, dTimeOut);
+		if(MCDRV_SUCCESS != sdRet)
+		{
+			break;
+		}
+		abWriteData[0]	= MCI_MIX_ADR<<1;
+		abWriteData[1]	= MCI_DIR_VFLAGR;
+		McSrv_WriteI2C(bSlaveAddr, abWriteData, 2);
+		sdRet	= WaitBitRelease(bSlaveAddr, (UINT16)MCI_MIX_WINDOW, (MCB_PDM0_VFLAGR|MCB_DIR0_VFLAGR|MCB_DIR1_VFLAGR|MCB_DIR2_VFLAGR), dInterval, dTimeOut);
+		if(MCDRV_SUCCESS != sdRet)
+		{
+			break;
+		}
+		abWriteData[0]	= MCI_MIX_ADR<<1;
+		abWriteData[1]	= MCI_AD_VFLAGL;
+		McSrv_WriteI2C(bSlaveAddr, abWriteData, 2);
+		sdRet	= WaitBitRelease(bSlaveAddr, (UINT16)MCI_MIX_WINDOW, (MCB_ADC_VFLAGL|MCB_AENG6_VFLAGL), dInterval, dTimeOut);
+		if(MCDRV_SUCCESS != sdRet)
+		{
+			break;
+		}
+		abWriteData[0]	= MCI_MIX_ADR<<1;
+		abWriteData[1]	= MCI_AD_VFLAGR;
+		McSrv_WriteI2C(bSlaveAddr, abWriteData, 2);
+		sdRet	= WaitBitRelease(bSlaveAddr, (UINT16)MCI_MIX_WINDOW, (MCB_ADC_VFLAGR|MCB_AENG6_VFLAGR), dInterval, dTimeOut);
+		if(MCDRV_SUCCESS != sdRet)
+		{
+			break;
+		}
+		abWriteData[0]	= MCI_MIX_ADR<<1;
+		abWriteData[1]	= MCI_AFLAGL;
+		McSrv_WriteI2C(bSlaveAddr, abWriteData, 2);
+		sdRet	= WaitBitRelease(bSlaveAddr, (UINT16)MCI_MIX_WINDOW, (MCB_ADC_AFLAGL|MCB_DIR0_AFLAGL|MCB_DIR1_AFLAGL|MCB_DIR2_AFLAGL), dInterval, dTimeOut);
+		if(MCDRV_SUCCESS != sdRet)
+		{
+			break;
+		}
+		abWriteData[0]	= MCI_MIX_ADR<<1;
+		abWriteData[1]	= MCI_AFLAGR;
+		McSrv_WriteI2C(bSlaveAddr, abWriteData, 2);
+		sdRet	= WaitBitRelease(bSlaveAddr, (UINT16)MCI_MIX_WINDOW, (MCB_ADC_AFLAGR|MCB_DIR0_AFLAGR|MCB_DIR1_AFLAGR|MCB_DIR2_AFLAGR), dInterval, dTimeOut);
+		if(MCDRV_SUCCESS != sdRet)
+		{
+			break;
+		}
+		abWriteData[0]	= MCI_MIX_ADR<<1;
+		abWriteData[1]	= MCI_DAC_FLAGL;
+		McSrv_WriteI2C(bSlaveAddr, abWriteData, 2);
+		sdRet	= WaitBitRelease(bSlaveAddr, (UINT16)MCI_MIX_WINDOW, (MCB_ST_FLAGL|MCB_MASTER_OFLAGL|MCB_VOICE_FLAGL|MCB_DAC_FLAGL), dInterval, dTimeOut);
+		if(MCDRV_SUCCESS != sdRet)
+		{
+			break;
+		}
+		abWriteData[0]	= MCI_MIX_ADR<<1;
+		abWriteData[1]	= MCI_DAC_FLAGR;
+		McSrv_WriteI2C(bSlaveAddr, abWriteData, 2);
+		sdRet	= WaitBitRelease(bSlaveAddr, (UINT16)MCI_MIX_WINDOW, (MCB_ST_FLAGR|MCB_MASTER_OFLAGR|MCB_VOICE_FLAGR|MCB_DAC_FLAGR), dInterval, dTimeOut);
+		break;
+
+	case	MCDRV_EVT_DITMUTE:
+		dInterval	= gsGlobalInfo.sInitInfo.sWaitTime.dSvolInterval;
+		dTimeOut	= gsGlobalInfo.sInitInfo.sWaitTime.dSvolTimeOut;
+		bSlaveAddr	= McDevProf_GetSlaveAddr(eMCDRV_SLAVE_ADDR_DIG);
+		if((dParam>>8) != (UINT32)0)
+		{
+			abWriteData[0]	= MCI_MIX_ADR<<1;
+			abWriteData[1]	= MCI_DIT_INVFLAGL;
+			McSrv_WriteI2C(bSlaveAddr, abWriteData, 2);
+			sdRet	= WaitBitRelease(bSlaveAddr, (UINT16)MCI_MIX_WINDOW, (UINT8)(dParam>>8), dInterval, dTimeOut);
+			if(MCDRV_SUCCESS != sdRet)
+			{
+				break;
+			}
+		}
+		if((dParam&(UINT32)0xFF) != (UINT32)0)
+		{
+			abWriteData[0]	= MCI_MIX_ADR<<1;
+			abWriteData[1]	= MCI_DIT_INVFLAGR;
+			McSrv_WriteI2C(bSlaveAddr, abWriteData, 2);
+			sdRet	= WaitBitRelease(bSlaveAddr, (UINT16)MCI_MIX_WINDOW, (UINT8)(dParam&(UINT32)0xFF), dInterval, dTimeOut);
+		}
+		break;
+
+	case	MCDRV_EVT_DACMUTE:
+		dInterval	= gsGlobalInfo.sInitInfo.sWaitTime.dSvolInterval;
+		dTimeOut	= gsGlobalInfo.sInitInfo.sWaitTime.dSvolTimeOut;
+		bSlaveAddr	= McDevProf_GetSlaveAddr(eMCDRV_SLAVE_ADDR_DIG);
+		if((dParam>>8) != (UINT32)0)
+		{
+			abWriteData[0]	= MCI_MIX_ADR<<1;
+			abWriteData[1]	= MCI_DAC_FLAGL;
+			McSrv_WriteI2C(bSlaveAddr, abWriteData, 2);
+			sdRet	= WaitBitRelease(bSlaveAddr, (UINT16)MCI_MIX_WINDOW, (UINT8)(dParam>>8), dInterval, dTimeOut);
+			if(MCDRV_SUCCESS != sdRet)
+			{
+				break;
+			}
+		}
+		if((dParam&(UINT32)0xFF) != (UINT32)0)
+		{
+			abWriteData[0]	= MCI_MIX_ADR<<1;
+			abWriteData[1]	= MCI_DAC_FLAGR;
+			McSrv_WriteI2C(bSlaveAddr, abWriteData, 2);
+			sdRet	= WaitBitRelease(bSlaveAddr, (UINT16)MCI_MIX_WINDOW, (UINT8)(dParam&(UINT32)0xFF), dInterval, dTimeOut);
+		}
+		break;
+
+	case	MCDRV_EVT_SVOL_DONE:
+		dInterval	= gsGlobalInfo.sInitInfo.sWaitTime.dSvolInterval;
+		dTimeOut	= gsGlobalInfo.sInitInfo.sWaitTime.dSvolTimeOut;
+		bSlaveAddr	= McDevProf_GetSlaveAddr(eMCDRV_SLAVE_ADDR_ANA);
+		if((dParam>>8) != (UINT32)0)
+		{
+			abWriteData[0]	= MCI_ANA_ADR<<1;
+			abWriteData[1]	= MCI_BUSY1;
+			McSrv_WriteI2C(bSlaveAddr, abWriteData, 2);
+			sdRet	= WaitBitRelease(bSlaveAddr, (UINT16)MCI_ANA_WINDOW, (UINT8)(dParam>>8), dInterval, dTimeOut);
+			if(MCDRV_SUCCESS != sdRet)
+			{
+				break;
+			}
+		}
+		if((dParam&(UINT32)0xFF) != (UINT32)0)
+		{
+			abWriteData[0]	= MCI_ANA_ADR<<1;
+			abWriteData[1]	= MCI_BUSY2;
+			McSrv_WriteI2C(bSlaveAddr, abWriteData, 2);
+			sdRet	= WaitBitRelease(bSlaveAddr, (UINT16)MCI_ANA_WINDOW, (UINT8)(dParam&(UINT8)0xFF), dInterval, dTimeOut);
+		}
+		break;
+
+	case	MCDRV_EVT_APM_DONE:
+		dInterval	= gsGlobalInfo.sInitInfo.sWaitTime.dSvolInterval;
+		dTimeOut	= gsGlobalInfo.sInitInfo.sWaitTime.dSvolTimeOut;
+		bSlaveAddr	= McDevProf_GetSlaveAddr(eMCDRV_SLAVE_ADDR_ANA);
+		abWriteData[0]	= MCI_ANA_ADR<<1;
+		abWriteData[1]	= MCI_AP_A1;
+		McSrv_WriteI2C(bSlaveAddr, abWriteData, 2);
+		sdRet	= WaitBitSet(bSlaveAddr, (UINT16)MCI_ANA_WINDOW, (UINT8)(dParam>>8), dInterval, dTimeOut);
+		if(MCDRV_SUCCESS != sdRet)
+		{
+			break;
+		}
+		abWriteData[0]	= MCI_ANA_ADR<<1;
+		abWriteData[1]	= MCI_AP_A2;
+		McSrv_WriteI2C(bSlaveAddr, abWriteData, 2);
+		sdRet	= WaitBitSet(bSlaveAddr, (UINT16)MCI_ANA_WINDOW, (UINT8)(dParam&(UINT8)0xFF), dInterval, dTimeOut);
+		break;
+
+	case	MCDRV_EVT_ANA_RDY:
+		dInterval	= gsGlobalInfo.sInitInfo.sWaitTime.dAnaRdyInterval;
+		dTimeOut	= gsGlobalInfo.sInitInfo.sWaitTime.dAnaRdyTimeOut;
+		bSlaveAddr	= McDevProf_GetSlaveAddr(eMCDRV_SLAVE_ADDR_ANA);
+		abWriteData[0]	= MCI_ANA_ADR<<1;
+		abWriteData[1]	= MCI_RDY_FLAG;
+		McSrv_WriteI2C(bSlaveAddr, abWriteData, 2);
+		sdRet	= WaitBitSet(bSlaveAddr, (UINT16)MCI_ANA_WINDOW, (UINT8)dParam, dInterval, dTimeOut);
+		break;
+
+	case	MCDRV_EVT_SYSEQ_FLAG_RESET:
+		dInterval	= gsGlobalInfo.sInitInfo.sWaitTime.dSvolInterval;
+		dTimeOut	= gsGlobalInfo.sInitInfo.sWaitTime.dSvolTimeOut;
+		bSlaveAddr	= McDevProf_GetSlaveAddr(eMCDRV_SLAVE_ADDR_DIG);
+		abWriteData[0]	= MCI_CD_ADR<<1;
+		abWriteData[1]	= MCI_SYSTEM_EQON;
+		McSrv_WriteI2C(bSlaveAddr, abWriteData, 2);
+		sdRet	= WaitBitRelease(bSlaveAddr, (UINT16)MCI_CD_WINDOW, MCB_SYSEQ_FLAG, dInterval, dTimeOut);
+		break;
+
+	case	MCDRV_EVT_CLKBUSY_RESET:
+		dInterval	= gsGlobalInfo.sInitInfo.sWaitTime.dSvolInterval;
+		dTimeOut	= gsGlobalInfo.sInitInfo.sWaitTime.dSvolTimeOut;
+		bSlaveAddr	= McDevProf_GetSlaveAddr(eMCDRV_SLAVE_ADDR_DIG);
+		abWriteData[0]	= MCI_CD_ADR<<1;
+		abWriteData[1]	= MCI_DPADIF;
+		McSrv_WriteI2C(bSlaveAddr, abWriteData, 2);
+		sdRet	= WaitBitRelease(bSlaveAddr, (UINT16)MCI_CD_WINDOW, MCB_CLKBUSY, dInterval, dTimeOut);
+		break;
+
+	case	MCDRV_EVT_CLKSRC_SET:
+		dInterval	= gsGlobalInfo.sInitInfo.sWaitTime.dSvolInterval;
+		dTimeOut	= gsGlobalInfo.sInitInfo.sWaitTime.dSvolTimeOut;
+		bSlaveAddr	= McDevProf_GetSlaveAddr(eMCDRV_SLAVE_ADDR_DIG);
+		abWriteData[0]	= MCI_CD_ADR<<1;
+		abWriteData[1]	= MCI_DPADIF;
+		McSrv_WriteI2C(bSlaveAddr, abWriteData, 2);
+		sdRet	= WaitBitSet(bSlaveAddr, (UINT16)MCI_CD_WINDOW, MCB_CLKSRC, dInterval, dTimeOut);
+		break;
+
+	case	MCDRV_EVT_CLKSRC_RESET:
+		dInterval	= gsGlobalInfo.sInitInfo.sWaitTime.dSvolInterval;
+		dTimeOut	= gsGlobalInfo.sInitInfo.sWaitTime.dSvolTimeOut;
+		bSlaveAddr	= McDevProf_GetSlaveAddr(eMCDRV_SLAVE_ADDR_DIG);
+		abWriteData[0]	= MCI_CD_ADR<<1;
+		abWriteData[1]	= MCI_DPADIF;
+		McSrv_WriteI2C(bSlaveAddr, abWriteData, 2);
+		sdRet	= WaitBitRelease(bSlaveAddr, (UINT16)MCI_CD_WINDOW, MCB_CLKSRC, dInterval, dTimeOut);
+		break;
+
+	case	MCDRV_EVT_ADCMUTE:
+		dInterval	= gsGlobalInfo.sInitInfo.sWaitTime.dSvolInterval;
+		dTimeOut	= gsGlobalInfo.sInitInfo.sWaitTime.dSvolTimeOut;
+		bSlaveAddr 	= McDevProf_GetSlaveAddr(eMCDRV_SLAVE_ADDR_DIG);
+		abWriteData[0] 	 = MCI_MIX_ADR<<1;
+		abWriteData[1] 	 = MCI_AD_VFLAGL;
+		McSrv_WriteI2C(bSlaveAddr, abWriteData, 2);
+		sdRet	= WaitBitRelease(bSlaveAddr, (UINT16)MCI_MIX_WINDOW, MCB_ADC_VFLAGL, dInterval, dTimeOut);
+		if(MCDRV_SUCCESS != sdRet)
+		{
+			 break;
+		}
+		abWriteData[1] 	 = MCI_AD_VFLAGR;
+		McSrv_WriteI2C(bSlaveAddr, abWriteData, 2);
+		sdRet	= WaitBitRelease(bSlaveAddr, (UINT16)MCI_MIX_WINDOW, MCB_ADC_VFLAGR, dInterval, dTimeOut);
+		break;
+
+
+	default:
+		sdRet	= MCDRV_ERROR_ARGUMENT;
+	}
+
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncOut("McResCtrl_WaitEvent", &sdRet);
+#endif
+
+	return sdRet;
+}
+
+/****************************************************************************
+ *	WaitBitSet
+ *
+ *	Description:
+ *			Wait register bit to set.
+ *	Arguments:
+ *			bSlaveAddr	slave address
+ *			wRegAddr	register address
+ *			bBit		bit
+ *			dCycleTime	cycle time to poll [us]
+ *			dTimeOut	number of read cycles for time out
+ *	Return:
+ *			MCDRV_SUCCESS
+ *			MCDRV_ERROR_TIMEOUT
+ *
+ ****************************************************************************/
+static SINT32	WaitBitSet
+(
+	UINT8	bSlaveAddr,
+	UINT16	wRegAddr,
+	UINT8	bBit,
+	UINT32	dCycleTime,
+	UINT32	dTimeOut
+)
+{
+	UINT8	bData;
+	UINT32	dCycles;
+	SINT32	sdRet;
+
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncIn("WaitBitSet");
+#endif
+
+
+	dCycles	= 0;
+	sdRet	= MCDRV_ERROR_TIMEOUT;
+
+	while(dCycles < dTimeOut)
+	{
+		bData	= McSrv_ReadI2C(bSlaveAddr, wRegAddr);
+		if((bData & bBit) == bBit)
+		{
+			sdRet	= MCDRV_SUCCESS;
+			break;
+		}
+
+		McSrv_Sleep(dCycleTime);
+		dCycles++;
+	}
+
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncOut("WaitBitSet", &sdRet);
+#endif
+
+	return sdRet;
+}
+
+/****************************************************************************
+ *	WaitBitRelease
+ *
+ *	Description:
+ *			Wait register bit to release.
+ *	Arguments:
+ *			bSlaveAddr	slave address
+ *			wRegAddr	register address
+ *			bBit		bit
+ *			dCycleTime	cycle time to poll [us]
+ *			dTimeOut	number of read cycles for time out
+ *	Return:
+ *			MCDRV_SUCCESS
+ *			MCDRV_ERROR_TIMEOUT
+ *
+ ****************************************************************************/
+static SINT32	WaitBitRelease
+(
+	UINT8	bSlaveAddr,
+	UINT16	wRegAddr,
+	UINT8	bBit,
+	UINT32	dCycleTime,
+	UINT32	dTimeOut
+)
+{
+	UINT8	bData;
+	UINT32	dCycles;
+	SINT32	sdRet;
+
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncIn("WaitBitRelease");
+#endif
+
+
+	dCycles	= 0;
+	sdRet	= MCDRV_ERROR_TIMEOUT;
+
+	while(dCycles < dTimeOut)
+	{
+		bData	= McSrv_ReadI2C(bSlaveAddr, wRegAddr);
+		if(0 == (bData & bBit))
+		{
+			sdRet	= MCDRV_SUCCESS;
+			break;
+		}
+
+		McSrv_Sleep(dCycleTime);
+		dCycles++;
+	}
+
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncOut("WaitBitRelease", &sdRet);
+#endif
+
+	return sdRet;
+}
+
diff --git a/sound/soc/codecs/mc1n2/mcresctrl.h b/sound/soc/codecs/mc1n2/mcresctrl.h
new file mode 100644
index 0000000..b5f1399
--- /dev/null
+++ b/sound/soc/codecs/mc1n2/mcresctrl.h
@@ -0,0 +1,263 @@
+/****************************************************************************
+ *
+ *		Copyright(c) 2010 Yamaha Corporation. All rights reserved.
+ *
+ *		Module		: mcresctrl.h
+ *
+ *		Description	: MC Driver resource control header
+ *
+ *		Version		: 1.0.0 	2010.09.01
+ *
+ ****************************************************************************/
+
+#ifndef _MCRESCTRL_H_
+#define _MCRESCTRL_H_
+
+#include "mcdevif.h"
+#include "mcpacking.h"
+
+/* HW_ID */
+#define	MCDRV_HWID_AA	(0x78)
+#define	MCDRV_HWID_AB	(0x79)
+
+#define	MCDRV_BURST_WRITE_ENABLE	(0x01)
+
+/*	eState setting	*/
+typedef enum _MCDRV_STATE
+{
+	eMCDRV_STATE_NOTINIT,
+	eMCDRV_STATE_READY
+} MCDRV_STATE;
+
+/*	volume setting	*/
+#define	MCDRV_LOGICAL_VOL_MUTE		(-24576)	/*	-96dB	*/
+#define	MCDRV_LOGICAL_MICGAIN_DEF	(3840)		/*	15dB	*/
+#define	MCDRV_LOGICAL_HPGAIN_DEF	(0)			/*	0dB		*/
+
+#define	MCDRV_VOLUPDATE_ALL			(0xFFFFFFFFUL)
+#define	MCDRV_VOLUPDATE_ANAOUT_ALL	(0x00000001UL)
+
+#define	MCDRV_REG_MUTE	(0x00)
+
+/*	DAC source setting	*/
+typedef enum _MCDRV_DAC_CH
+{
+	eMCDRV_DAC_MASTER	= 0,
+	eMCDRV_DAC_VOICE
+} MCDRV_DAC_CH;
+
+/*	DIO port setting	*/
+typedef enum _MCDRV_DIO_PORT_NO
+{
+	eMCDRV_DIO_0	= 0,
+	eMCDRV_DIO_1,
+	eMCDRV_DIO_2
+} MCDRV_DIO_PORT_NO;
+
+/*	Path source setting	*/
+typedef enum _MCDRV_SRC_TYPE
+{
+	eMCDRV_SRC_NONE			= (0),
+	eMCDRV_SRC_MIC1			= (1<<0),
+	eMCDRV_SRC_MIC2			= (1<<1),
+	eMCDRV_SRC_MIC3			= (1<<2),
+	eMCDRV_SRC_LINE1_L		= (1<<3),
+	eMCDRV_SRC_LINE1_R		= (1<<4),
+	eMCDRV_SRC_LINE1_M		= (1<<5),
+	eMCDRV_SRC_LINE2_L		= (1<<6),
+	eMCDRV_SRC_LINE2_R		= (1<<7),
+	eMCDRV_SRC_LINE2_M		= (1<<8),
+	eMCDRV_SRC_DIR0			= (1<<9),
+	eMCDRV_SRC_DIR1			= (1<<10),
+	eMCDRV_SRC_DIR2			= (1<<11),
+	eMCDRV_SRC_DTMF			= (1<<12),
+	eMCDRV_SRC_PDM			= (1<<13),
+	eMCDRV_SRC_ADC0			= (1<<14),
+	eMCDRV_SRC_ADC1			= (1<<15),
+	eMCDRV_SRC_DAC_L		= (1<<16),
+	eMCDRV_SRC_DAC_R		= (1<<17),
+	eMCDRV_SRC_DAC_M		= (1<<18),
+	eMCDRV_SRC_AE			= (1<<19),
+	eMCDRV_SRC_CDSP			= (1<<20),
+	eMCDRV_SRC_MIX			= (1<<21),
+	eMCDRV_SRC_DIR2_DIRECT	= (1<<22),
+	eMCDRV_SRC_CDSP_DIRECT	= (1<<23)
+} MCDRV_SRC_TYPE;
+
+/*	Path destination setting	*/
+typedef enum _MCDRV_DST_CH
+{
+	eMCDRV_DST_CH0	= 0,
+	eMCDRV_DST_CH1
+} MCDRV_DST_CH;
+typedef enum _MCDRV_DST_TYPE
+{
+	eMCDRV_DST_HP	= 0,
+	eMCDRV_DST_SP,
+	eMCDRV_DST_RCV,
+	eMCDRV_DST_LOUT1,
+	eMCDRV_DST_LOUT2,
+	eMCDRV_DST_PEAK,
+	eMCDRV_DST_DIT0,
+	eMCDRV_DST_DIT1,
+	eMCDRV_DST_DIT2,
+	eMCDRV_DST_DAC,
+	eMCDRV_DST_AE,
+	eMCDRV_DST_CDSP,
+	eMCDRV_DST_ADC0,
+	eMCDRV_DST_ADC1,
+	eMCDRV_DST_MIX,
+	eMCDRV_DST_BIAS
+} MCDRV_DST_TYPE;
+
+/*	Register accsess availability	*/
+typedef enum _MCDRV_REG_ACCSESS
+{
+	eMCDRV_ACCESS_DENY	= 0,
+	eMCDRV_READ_ONLY	= 0x01,
+	eMCDRV_WRITE_ONLY	= 0x02,
+	eMCDRV_READ_WRITE	= eMCDRV_READ_ONLY | eMCDRV_WRITE_ONLY
+} MCDRV_REG_ACCSESS;
+
+
+/*	UpdateReg parameter	*/
+typedef enum _MCDRV_UPDATE_MODE
+{
+	eMCDRV_UPDATE_NORMAL,
+	eMCDRV_UPDATE_FORCE,
+	eMCDRV_UPDATE_DUMMY
+} MCDRV_UPDATE_MODE;
+
+/*	ePacketBufAlloc setting	*/
+typedef enum _MCDRV_PACKETBUF_ALLOC
+{
+	eMCDRV_PACKETBUF_FREE,
+	eMCDRV_PACKETBUF_ALLOCATED
+} MCDRV_PACKETBUF_ALLOC;
+
+/* power management sequence mode */
+typedef enum _MCDRV_PMODE
+{
+	eMCDRV_APM_ON,
+	eMCDRV_APM_OFF
+} MCDRV_PMODE;
+
+#define	MCDRV_A_REG_NUM			(64)
+#define	MCDRV_B_BASE_REG_NUM	(32)
+#define	MCDRV_B_MIXER_REG_NUM	(218)
+#define	MCDRV_B_AE_REG_NUM		(255)
+#define	MCDRV_B_CDSP_REG_NUM	(130)
+#define	MCDRV_B_CODEC_REG_NUM	(128)
+#define	MCDRV_B_ANA_REG_NUM		(128)
+
+/* control packet for serial host interface */
+#define	MCDRV_MAX_CTRL_DATA_NUM	(1024)
+typedef struct
+{
+	UINT8	abData[MCDRV_MAX_CTRL_DATA_NUM];
+	UINT16	wDataNum;
+} MCDRV_SERIAL_CTRL_PACKET;
+
+/*	global information	*/
+typedef struct
+{
+	UINT8						bHwId;
+	MCDRV_PACKETBUF_ALLOC		ePacketBufAlloc;
+	UINT8						abRegValA[MCDRV_A_REG_NUM];
+	UINT8						abRegValB_BASE[MCDRV_B_BASE_REG_NUM];
+	UINT8						abRegValB_MIXER[MCDRV_B_MIXER_REG_NUM];
+	UINT8						abRegValB_AE[MCDRV_B_AE_REG_NUM];
+	UINT8						abRegValB_CDSP[MCDRV_B_CDSP_REG_NUM];
+	UINT8						abRegValB_CODEC[MCDRV_B_CODEC_REG_NUM];
+	UINT8						abRegValB_ANA[MCDRV_B_ANA_REG_NUM];
+
+	MCDRV_INIT_INFO				sInitInfo;
+	MCDRV_PATH_INFO				sPathInfo;
+	MCDRV_PATH_INFO				sPathInfoVirtual;
+	MCDRV_VOL_INFO				sVolInfo;
+	MCDRV_DIO_INFO				sDioInfo;
+	MCDRV_DAC_INFO				sDacInfo;
+	MCDRV_ADC_INFO				sAdcInfo;
+	MCDRV_SP_INFO				sSpInfo;
+	MCDRV_DNG_INFO				sDngInfo;
+	MCDRV_AE_INFO				sAeInfo;
+	MCDRV_PDM_INFO				sPdmInfo;
+	MCDRV_GP_MODE				sGpMode;
+	UINT8						abGpMask[GPIO_PAD_NUM];
+	MCDRV_SYSEQ_INFO			sSysEq;
+	MCDRV_CLKSW_INFO			sClockSwitch;
+
+	MCDRV_SERIAL_CTRL_PACKET	sCtrlPacket;
+	UINT16						wCurSlaveAddress;
+	UINT16						wCurRegType;
+	UINT16						wCurRegAddress;
+	UINT16						wDataContinueCount;
+	UINT16						wPrevAddressIndex;
+
+	MCDRV_PMODE					eAPMode;
+} MCDRV_GLOBAL_INFO;
+
+
+
+SINT32			McResCtrl_SetHwId				(UINT8 bHwId);
+UINT8			McResCtrl_GetHwId				(void);
+void			McResCtrl_Init					(const MCDRV_INIT_INFO* psInitInfo);
+void			McResCtrl_UpdateState			(MCDRV_STATE eState);
+MCDRV_STATE		McResCtrl_GetState				(void);
+UINT8			McResCtrl_GetRegVal				(UINT16 wRegType, UINT16 wRegAddr);
+void			McResCtrl_SetRegVal				(UINT16 wRegType, UINT16 wRegAddr, UINT8 bRegVal);
+
+void			McResCtrl_GetInitInfo			(MCDRV_INIT_INFO* psInitInfo);
+void			McResCtrl_SetClockInfo			(const MCDRV_CLOCK_INFO* psClockInfo);
+void			McResCtrl_SetPathInfo			(const MCDRV_PATH_INFO* psPathInfo);
+void			McResCtrl_GetPathInfo			(MCDRV_PATH_INFO* psPathInfo);
+void			McResCtrl_GetPathInfoVirtual	(MCDRV_PATH_INFO* psPathInfo);
+void			McResCtrl_SetDioInfo			(const MCDRV_DIO_INFO* psDioInfo, UINT32 dUpdateInfo);
+void			McResCtrl_GetDioInfo			(MCDRV_DIO_INFO* psDioInfo);
+void			McResCtrl_SetVolInfo			(const MCDRV_VOL_INFO* psVolInfo);
+void			McResCtrl_GetVolInfo			(MCDRV_VOL_INFO* psVolInfo);
+void			McResCtrl_SetDacInfo			(const MCDRV_DAC_INFO* psDacInfo, UINT32 dUpdateInfo);
+void			McResCtrl_GetDacInfo			(MCDRV_DAC_INFO* psDacInfo);
+void			McResCtrl_SetAdcInfo			(const MCDRV_ADC_INFO* psAdcInfo, UINT32 dUpdateInfo);
+void			McResCtrl_GetAdcInfo			(MCDRV_ADC_INFO* psAdcInfo);
+void			McResCtrl_SetSpInfo				(const MCDRV_SP_INFO* psSpInfo);
+void			McResCtrl_GetSpInfo				(MCDRV_SP_INFO* psSpInfo);
+void			McResCtrl_SetDngInfo			(const MCDRV_DNG_INFO* psDngInfo, UINT32 dUpdateInfo);
+void			McResCtrl_GetDngInfo			(MCDRV_DNG_INFO* psDngInfo);
+void			McResCtrl_SetAeInfo				(const MCDRV_AE_INFO* psAeInfo, UINT32 dUpdateInfo);
+void			McResCtrl_GetAeInfo				(MCDRV_AE_INFO* psAeInfo);
+void			McResCtrl_SetPdmInfo			(const MCDRV_PDM_INFO* psPdmInfo, UINT32 dUpdateInfo);
+void			McResCtrl_GetPdmInfo			(MCDRV_PDM_INFO* psPdmInfo);
+void			McResCtrl_SetGPMode				(const MCDRV_GP_MODE* psGpMode);
+void			McResCtrl_GetGPMode				(MCDRV_GP_MODE* psGpMode);
+void			McResCtrl_SetGPMask				(UINT8 bMask, UINT32 dPadNo);
+void			McResCtrl_GetGPMask				(UINT8* pabMask);
+void			McResCtrl_GetSysEq				(MCDRV_SYSEQ_INFO* psSysEq);
+void			McResCtrl_SetSysEq				(const MCDRV_SYSEQ_INFO* psSysEq, UINT32 dUpdateInfo);
+void			McResCtrl_GetClockSwitch		(MCDRV_CLKSW_INFO* psClockInfo);
+void			McResCtrl_SetClockSwitch		(const MCDRV_CLKSW_INFO* psClockInfo);
+
+void			McResCtrl_GetVolReg				(MCDRV_VOL_INFO* psVolInfo);
+void			McResCtrl_GetPowerInfo			(MCDRV_POWER_INFO* psPowerInfo);
+void			McResCtrl_GetPowerInfoRegAccess	(const MCDRV_REG_INFO* psRegInfo, MCDRV_POWER_INFO* psPowerInfo);
+void			McResCtrl_GetCurPowerInfo		(MCDRV_POWER_INFO* psPowerInfo);
+MCDRV_SRC_TYPE	McResCtrl_GetDACSource			(MCDRV_DAC_CH eCh);
+MCDRV_SRC_TYPE	McResCtrl_GetDITSource			(MCDRV_DIO_PORT_NO ePort);
+MCDRV_SRC_TYPE	McResCtrl_GetAESource			(void);
+UINT8			McResCtrl_IsSrcUsed				(MCDRV_SRC_TYPE ePathSrc);
+UINT8			McResCtrl_IsDstUsed				(MCDRV_DST_TYPE eType, MCDRV_DST_CH eCh);
+MCDRV_REG_ACCSESS	McResCtrl_GetRegAccess		(const MCDRV_REG_INFO* psRegInfo);
+
+MCDRV_PMODE		McResCtrl_GetAPMode				(void);
+
+MCDRV_PACKET*	McResCtrl_AllocPacketBuf		(void);
+void			McResCtrl_ReleasePacketBuf		(void);
+
+void			McResCtrl_InitRegUpdate			(void);
+void			McResCtrl_AddRegUpdate			(UINT16 wRegType, UINT16 wAddress, UINT8 bData, MCDRV_UPDATE_MODE eUpdateMode);
+void			McResCtrl_ExecuteRegUpdate		(void);
+SINT32			McResCtrl_WaitEvent				(UINT32 dEvent, UINT32 dParam);
+
+
+
+#endif /* _MCRESCTRL_H_ */
diff --git a/sound/soc/codecs/mc1n2/mcservice.c b/sound/soc/codecs/mc1n2/mcservice.c
new file mode 100644
index 0000000..27ee6d5
--- /dev/null
+++ b/sound/soc/codecs/mc1n2/mcservice.c
@@ -0,0 +1,365 @@
+/****************************************************************************
+ *
+ *		Copyright(c) 2010 Yamaha Corporation. All rights reserved.
+ *
+ *		Module		: mcservice.c
+ *
+ *		Description	: MC Driver service routine
+ *
+ *		Version		: 1.0.0 	2010.09.10
+ *
+ ****************************************************************************/
+
+
+#include "mcservice.h"
+#include "mcmachdep.h"
+#if (MCDRV_DEBUG_LEVEL>=4)
+#include "mcdebuglog.h"
+#endif
+
+
+/****************************************************************************
+ *	McSrv_SystemInit
+ *
+ *	Description:
+ *			Initialize the system.
+ *	Arguments:
+ *			none
+ *	Return:
+ *			none
+ *
+ ****************************************************************************/
+void	McSrv_SystemInit
+(
+	void
+)
+{
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncIn("McSrv_SystemInit");
+#endif
+
+	machdep_SystemInit();
+
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncOut("McSrv_SystemInit", 0);
+#endif
+}
+
+/****************************************************************************
+ *	McSrv_SystemTerm
+ *
+ *	Description:
+ *			Terminate the system.
+ *	Arguments:
+ *			none
+ *	Return:
+ *			none
+ *
+ ****************************************************************************/
+void	McSrv_SystemTerm
+(
+	void
+)
+{
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncIn("McSrv_SystemTerm");
+#endif
+
+	machdep_SystemTerm();
+
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncOut("McSrv_SystemTerm", 0);
+#endif
+}
+
+/****************************************************************************
+ *	McSrv_ClockStart
+ *
+ *	Description:
+ *			Start clock.
+ *	Arguments:
+ *			none
+ *	Return:
+ *			none
+ *
+ ****************************************************************************/
+void	McSrv_ClockStart
+(
+	void
+)
+{
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncIn("McSrv_ClockStart");
+#endif
+
+	machdep_ClockStart();
+
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncOut("McSrv_ClockStart", 0);
+#endif
+}
+
+/****************************************************************************
+ *	McSrv_ClockStop
+ *
+ *	Description:
+ *			Stop clock.
+ *	Arguments:
+ *			none
+ *	Return:
+ *			none
+ *
+ ****************************************************************************/
+void	McSrv_ClockStop
+(
+	void
+)
+{
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncIn("McSrv_ClockStop");
+#endif
+
+	machdep_ClockStop();
+
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncOut("McSrv_ClockStop", 0);
+#endif
+}
+
+/****************************************************************************
+ *	McSrv_WriteI2C
+ *
+ *	Description:
+ *			Write data to register.
+ *	Arguments:
+ *			bSlaveAddr	slave address
+ *			pbData		data
+ *			dSize		data size
+ *	Return:
+ *			none
+ *
+ ****************************************************************************/
+void	McSrv_WriteI2C
+(
+	UINT8	bSlaveAddr,
+	UINT8	*pbData,
+	UINT32	dSize
+)
+{
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncIn("McSrv_WriteI2C");
+#endif
+
+	McSrv_DisableIrq();
+	machdep_WriteI2C( bSlaveAddr, pbData, dSize );
+	McSrv_EnableIrq();
+
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncOut("McSrv_WriteI2C", 0);
+#endif
+}
+
+/****************************************************************************
+ *	McSrv_ReadI2C
+ *
+ *	Function:
+ *			Read a byte data from the register.
+ *	Arguments:
+ *			bSlaveAddr	slave address
+ *			dRegAddr	address of register
+ *	Return:
+ *			read data
+ *
+ ****************************************************************************/
+UINT8	McSrv_ReadI2C
+(
+	UINT8	bSlaveAddr,
+	UINT32	dRegAddr
+)
+{
+	UINT8	bReg;
+
+#if (MCDRV_DEBUG_LEVEL>=4)
+	SINT32	sdRet;
+	McDebugLog_FuncIn("McSrv_ReadI2C");
+#endif
+
+	McSrv_DisableIrq();
+	bReg	= machdep_ReadI2C( bSlaveAddr, dRegAddr );
+	McSrv_EnableIrq();
+
+#if (MCDRV_DEBUG_LEVEL>=4)
+	sdRet	= (SINT32)bReg;
+	McDebugLog_FuncOut("McSrv_ReadI2C", &sdRet);
+#endif
+
+	return bReg;
+}
+
+/***************************************************************************
+ *	McSrv_Sleep
+ *
+ *	Function:
+ *			Sleep for a specified interval.
+ *	Arguments:
+ *			dSleepTime	sleep time [us]
+ *	Return:
+ *			none
+ *
+ ****************************************************************************/
+void	McSrv_Sleep
+(
+	UINT32	dSleepTime
+)
+{
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncIn("McSrv_Sleep");
+#endif
+
+	machdep_Sleep( dSleepTime );
+
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncOut("McSrv_Sleep", 0);
+#endif
+}
+
+/****************************************************************************
+ *	McSrv_Lock
+ *
+ *	Description:
+ *			Lock a call of the driver.
+ *	Arguments:
+ *			none
+ *	Return:
+ *			none
+ *
+ ****************************************************************************/
+void	McSrv_Lock
+(
+	void
+)
+{
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncIn("McSrv_Lock");
+#endif
+
+	machdep_Lock();
+
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncOut("McSrv_Lock", 0);
+#endif
+}
+
+/***************************************************************************
+ *	McSrv_Unlock
+ *
+ *	Function:
+ *			Unlock a call of the driver.
+ *	Arguments:
+ *			none
+ *	Return:
+ *			none
+ *
+ ****************************************************************************/
+void	McSrv_Unlock
+(
+	void
+)
+{
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncIn("McSrv_Unlock");
+#endif
+
+	machdep_Unlock();
+
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncOut("McSrv_Unlock", 0);
+#endif
+}
+
+/***************************************************************************
+ *	McSrv_MemCopy
+ *
+ *	Function:
+ *			Copy memory.
+ *	Arguments:
+ *			pbSrc	copy source
+ *			pbDest	copy destination
+ *			dSize	size
+ *	Return:
+ *			none
+ *
+ ****************************************************************************/
+void	McSrv_MemCopy
+(
+	const UINT8	*pbSrc,
+	UINT8		*pbDest,
+	UINT32		dSize
+)
+{
+	UINT32	i;
+
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncIn("McSrv_MemCopy");
+#endif
+
+	for ( i = 0; i < dSize; i++ )
+	{
+		pbDest[i] = pbSrc[i];
+	}
+
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncOut("McSrv_MemCopy", 0);
+#endif
+}
+
+/***************************************************************************
+ *	McSrv_DisableIrq
+ *
+ *	Function:
+ *			Disable interrupt.
+ *	Arguments:
+ *			none
+ *	Return:
+ *			none
+ *
+ ****************************************************************************/
+void	McSrv_DisableIrq
+(
+	void
+)
+{
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncIn("McSrv_DisableIrq");
+#endif
+
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncOut("McSrv_DisableIrq", 0);
+#endif
+}
+
+/***************************************************************************
+ *	McSrv_EnableIrq
+ *
+ *	Function:
+ *			Enable interrupt.
+ *	Arguments:
+ *			none
+ *	Return:
+ *			none
+ *
+ ****************************************************************************/
+void	McSrv_EnableIrq
+(
+	void
+)
+{
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncIn("McSrv_EnableIrq");
+#endif
+
+#if (MCDRV_DEBUG_LEVEL>=4)
+	McDebugLog_FuncOut("McSrv_EnableIrq", 0);
+#endif
+}
+
diff --git a/sound/soc/codecs/mc1n2/mcservice.h b/sound/soc/codecs/mc1n2/mcservice.h
new file mode 100644
index 0000000..3d72722
--- /dev/null
+++ b/sound/soc/codecs/mc1n2/mcservice.h
@@ -0,0 +1,34 @@
+/****************************************************************************
+ *
+ *		Copyright(c) 2010 Yamaha Corporation. All rights reserved.
+ *
+ *		Module		: mcservice.h
+ *
+ *		Description	: MC Driver service routine header
+ *
+ *		Version		: 1.0.0 	2010.03.18
+ *
+ ****************************************************************************/
+
+#ifndef _MCSERVICE_H_
+#define _MCSERVICE_H_
+
+#include "mctypedef.h"
+
+
+void	McSrv_SystemInit	( void );
+void	McSrv_SystemTerm	( void );
+void	McSrv_ClockStart	( void );
+void	McSrv_ClockStop		( void );
+void	McSrv_WriteI2C		( UINT8	bSlaveAddr, UINT8 *pbData, UINT32 dSize );
+UINT8	McSrv_ReadI2C		( UINT8	bSlaveAddr, UINT32 dRegAddr );
+void	McSrv_Sleep			( UINT32 dSleepTime );
+void	McSrv_Lock			( void );
+void	McSrv_Unlock		( void );
+void	McSrv_MemCopy		( const UINT8 *pbSrc, UINT8 *pbDest, UINT32 dSize );
+void	McSrv_DisableIrq	( void );
+void	McSrv_EnableIrq		( void );
+
+
+
+#endif /* _MCSERVICE_H_ */
diff --git a/sound/soc/codecs/mc1n2/mctypedef.h b/sound/soc/codecs/mc1n2/mctypedef.h
new file mode 100644
index 0000000..794fec1
--- /dev/null
+++ b/sound/soc/codecs/mc1n2/mctypedef.h
@@ -0,0 +1,38 @@
+/****************************************************************************
+ *
+ *		Copyright(c) 2010 Yamaha Corporation. All rights reserved.
+ *
+ *		Module		: mctypedef.h
+ *
+ *		Description	: MC Device Type definitions
+ *
+ *		Version		: 1.0.0 	2010.03.18
+ *
+ ****************************************************************************/
+
+#ifndef _MCTYPEDEF_H_
+#define _MCTYPEDEF_H_
+
+#ifndef NULL
+ #define NULL						((void *)0)
+#endif
+#ifndef UINT8
+ #define	UINT8					unsigned char
+#endif
+#ifndef UINT16
+ #define	UINT16					unsigned short
+#endif
+#ifndef UINT32
+ #define	UINT32					unsigned long
+#endif
+#ifndef SINT8
+ #define	SINT8					signed char
+#endif
+#ifndef SINT16
+ #define	SINT16					signed short
+#endif
+#ifndef SINT32
+ #define	SINT32					signed long
+#endif
+
+#endif	/*_MCTYPEDEF_H_*/
-- 
1.8.3.2

