From f0e4de92e626a9db654d0e35304e38d725285488 Mon Sep 17 00:00:00 2001
From: Andrzej Pietrasiewicz <andrzej.p@samsung.com>
Date: Tue, 14 Jan 2014 14:26:29 +0100
Subject: [PATCH 1089/1302] Revert "usb/gadget: acm_ms: convert to new
 interface of f_mass_storage"

This reverts commit 7ab27e2ab83e3d760dd4ebb8175eac0f04f776f2.

Signed-off-by: MyungJoo Ham <myungjoo.ham@samsung.com>
---
 drivers/usb/gadget/Kconfig  |   1 -
 drivers/usb/gadget/acm_ms.c | 113 +++++++++++++++-----------------------------
 2 files changed, 39 insertions(+), 75 deletions(-)

diff --git a/drivers/usb/gadget/Kconfig b/drivers/usb/gadget/Kconfig
index e327cc3..bef6e86 100644
--- a/drivers/usb/gadget/Kconfig
+++ b/drivers/usb/gadget/Kconfig
@@ -1045,7 +1045,6 @@ config USB_G_ACM_MS
 	select USB_U_SERIAL
 	select USB_F_ACM
 	select USB_U_MS
-	select USB_F_MASS_STORAGE
 	help
 	  This driver provides two functions in one configuration:
 	  a mass storage, and a CDC ACM (serial port) link.
diff --git a/drivers/usb/gadget/acm_ms.c b/drivers/usb/gadget/acm_ms.c
index b405bc4..31aae8f 100644
--- a/drivers/usb/gadget/acm_ms.c
+++ b/drivers/usb/gadget/acm_ms.c
@@ -31,7 +31,17 @@
 #define ACM_MS_VENDOR_NUM	0x1d6b	/* Linux Foundation */
 #define ACM_MS_PRODUCT_NUM	0x0106	/* Composite Gadget: ACM + MS*/
 
-#include "f_mass_storage.h"
+/*-------------------------------------------------------------------------*/
+
+/*
+ * Kbuild is not very cooperative with respect to linking separately
+ * compiled library objects into one module.  So for now we won't use
+ * separate compilation ... ensuring init/exit sections work to shrink
+ * the runtime footprint, and giving us at least some parts of what
+ * a "gcc --combine ... part1.c part2.c part3.c ... " build would.
+ */
+#define USB_FMS_INCLUDED
+#include "f_mass_storage.c"
 
 /*-------------------------------------------------------------------------*/
 USB_GADGET_COMPOSITE_OPTIONS();
@@ -111,19 +121,16 @@ static unsigned int fsg_num_buffers = CONFIG_USB_GADGET_STORAGE_NUM_BUFFERS;
 
 FSG_MODULE_PARAMETERS(/* no prefix */, fsg_mod_data);
 
+static struct fsg_common fsg_common;
+
 /*-------------------------------------------------------------------------*/
 static struct usb_function *f_acm;
 static struct usb_function_instance *f_acm_inst;
-
-static struct usb_function_instance *fi_msg;
-static struct usb_function *f_msg;
-
 /*
  * We _always_ have both ACM and mass storage functions.
  */
 static int __init acm_ms_do_config(struct usb_configuration *c)
 {
-	struct fsg_opts *opts;
 	int	status;
 
 	if (gadget_is_otg(c->cdev->gadget)) {
@@ -131,37 +138,31 @@ static int __init acm_ms_do_config(struct usb_configuration *c)
 		c->bmAttributes |= USB_CONFIG_ATT_WAKEUP;
 	}
 
-	opts = container_of(fi_msg, struct fsg_opts, func_inst);
+	f_acm_inst = usb_get_function_instance("acm");
+	if (IS_ERR(f_acm_inst))
+		return PTR_ERR(f_acm_inst);
 
 	f_acm = usb_get_function(f_acm_inst);
-	if (IS_ERR(f_acm))
-		return PTR_ERR(f_acm);
-
-	f_msg = usb_get_function(fi_msg);
-	if (IS_ERR(f_msg)) {
-		status = PTR_ERR(f_msg);
-		goto put_acm;
+	if (IS_ERR(f_acm)) {
+		status = PTR_ERR(f_acm);
+		goto err_func;
 	}
 
 	status = usb_add_function(c, f_acm);
 	if (status < 0)
-		goto put_msg;
-
-	status = fsg_common_run_thread(opts->common);
-	if (status)
-		goto remove_acm;
+		goto err_conf;
 
-	status = usb_add_function(c, f_msg);
-	if (status)
-		goto remove_acm;
+	status = fsg_bind_config(c->cdev, c, &fsg_common);
+	if (status < 0)
+		goto err_fsg;
 
 	return 0;
-remove_acm:
+err_fsg:
 	usb_remove_function(c, f_acm);
-put_msg:
-	usb_put_function(f_msg);
-put_acm:
+err_conf:
 	usb_put_function(f_acm);
+err_func:
+	usb_put_function_instance(f_acm_inst);
 	return status;
 }
 
@@ -177,82 +178,46 @@ static struct usb_configuration acm_ms_config_driver = {
 static int __init acm_ms_bind(struct usb_composite_dev *cdev)
 {
 	struct usb_gadget	*gadget = cdev->gadget;
-	struct fsg_opts		*opts;
-	struct fsg_config	config;
 	int			status;
-
-	f_acm_inst = usb_get_function_instance("acm");
-	if (IS_ERR(f_acm_inst))
-		return PTR_ERR(f_acm_inst);
-
-	fi_msg = usb_get_function_instance("mass_storage");
-	if (IS_ERR(fi_msg)) {
-		status = PTR_ERR(fi_msg);
-		goto fail_get_msg;
-	}
+	void			*retp;
 
 	/* set up mass storage function */
-	fsg_config_from_params(&config, &fsg_mod_data, fsg_num_buffers);
-	opts = container_of(fi_msg, struct fsg_opts, func_inst);
-
-	opts->no_configfs = true;
-	status = fsg_common_set_num_buffers(opts->common, fsg_num_buffers);
-	if (status)
-		goto fail;
-
-	status = fsg_common_set_nluns(opts->common, config.nluns);
-	if (status)
-		goto fail_set_nluns;
-
-	status = fsg_common_set_cdev(opts->common, cdev, config.can_stall);
-	if (status)
-		goto fail_set_cdev;
-
-	fsg_common_set_sysfs(opts->common, true);
-	status = fsg_common_create_luns(opts->common, &config);
-	if (status)
-		goto fail_set_cdev;
+	retp = fsg_common_from_params(&fsg_common, cdev, &fsg_mod_data,
+				      fsg_num_buffers);
+	if (IS_ERR(retp)) {
+		status = PTR_ERR(retp);
+		return PTR_ERR(retp);
+	}
 
-	fsg_common_set_inquiry_string(opts->common, config.vendor_name,
-				      config.product_name);
 	/*
 	 * Allocate string descriptor numbers ... note that string
 	 * contents can be overridden by the composite_dev glue.
 	 */
 	status = usb_string_ids_tab(cdev, strings_dev);
 	if (status < 0)
-		goto fail_string_ids;
+		goto fail1;
 	device_desc.iManufacturer = strings_dev[USB_GADGET_MANUFACTURER_IDX].id;
 	device_desc.iProduct = strings_dev[USB_GADGET_PRODUCT_IDX].id;
 
 	/* register our configuration */
 	status = usb_add_config(cdev, &acm_ms_config_driver, acm_ms_do_config);
 	if (status < 0)
-		goto fail_string_ids;
+		goto fail1;
 
 	usb_composite_overwrite_options(cdev, &coverwrite);
 	dev_info(&gadget->dev, "%s, version: " DRIVER_VERSION "\n",
 			DRIVER_DESC);
+	fsg_common_put(&fsg_common);
 	return 0;
 
 	/* error recovery */
-fail_string_ids:
-	fsg_common_remove_luns(opts->common);
-fail_set_cdev:
-	fsg_common_free_luns(opts->common);
-fail_set_nluns:
-	fsg_common_free_buffers(opts->common);
-fail:
-	usb_put_function_instance(fi_msg);
-fail_get_msg:
-	usb_put_function_instance(f_acm_inst);
+fail1:
+	fsg_common_put(&fsg_common);
 	return status;
 }
 
 static int __exit acm_ms_unbind(struct usb_composite_dev *cdev)
 {
-	usb_put_function(f_msg);
-	usb_put_function_instance(fi_msg);
 	usb_put_function(f_acm);
 	usb_put_function_instance(f_acm_inst);
 	return 0;
-- 
1.8.3.2

