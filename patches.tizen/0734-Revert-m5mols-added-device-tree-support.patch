From 8681bc9577df6a2c03904ca7a4c89c95f1507d0d Mon Sep 17 00:00:00 2001
From: Sylwester Nawrocki <s.nawrocki@samsung.com>
Date: Mon, 2 Sep 2013 16:32:48 +0200
Subject: [PATCH 0734/1302] Revert "m5mols: added device tree support"

This reverts commit 12f6bb8f0dc0c8865ca85825596e02a03d907b57.

Signed-off-by: Sylwester Nawrocki <s.nawrocki@samsung.com>
Signed-off-by: MyungJoo Ham <myungjoo.ham@samsung.com>
---
 drivers/media/i2c/m5mols/m5mols.h      |  8 ++--
 drivers/media/i2c/m5mols/m5mols_core.c | 71 ++++++++++------------------------
 2 files changed, 25 insertions(+), 54 deletions(-)

diff --git a/drivers/media/i2c/m5mols/m5mols.h b/drivers/media/i2c/m5mols/m5mols.h
index 0599b8a..90a6c52 100644
--- a/drivers/media/i2c/m5mols/m5mols.h
+++ b/drivers/media/i2c/m5mols/m5mols.h
@@ -18,8 +18,6 @@
 
 #include <linux/sizes.h>
 #include <media/v4l2-subdev.h>
-#include <media/m5mols.h>
-
 #include "m5mols_reg.h"
 
 
@@ -184,6 +182,7 @@ struct m5mols_version {
  * @wdr: wide dynamic range control
  * @stabilization: image stabilization control
  * @jpeg_quality: JPEG compression quality control
+ * @set_power: optional power callback to the board code
  * @lock: mutex protecting the structure fields below
  * @ffmt: current fmt according to resolution type
  * @res_type: current resolution type
@@ -196,8 +195,7 @@ struct m5mols_version {
  * @mode: register value for current operation mode
  */
 struct m5mols_info {
-	struct m5mols_platform_data pdata;
-
+	const struct m5mols_platform_data *pdata;
 	struct v4l2_subdev sd;
 	struct media_pad pad;
 
@@ -227,6 +225,8 @@ struct m5mols_info {
 	struct v4l2_ctrl *stabilization;
 	struct v4l2_ctrl *jpeg_quality;
 
+	int (*set_power)(struct device *dev, int on);
+
 	struct mutex lock;
 
 	struct v4l2_mbus_framefmt ffmt[M5MOLS_RESTYPE_MAX];
diff --git a/drivers/media/i2c/m5mols/m5mols_core.c b/drivers/media/i2c/m5mols/m5mols_core.c
index 4d174c3..f720a41 100644
--- a/drivers/media/i2c/m5mols/m5mols_core.c
+++ b/drivers/media/i2c/m5mols/m5mols_core.c
@@ -19,13 +19,13 @@
 #include <linux/interrupt.h>
 #include <linux/delay.h>
 #include <linux/gpio.h>
-#include <linux/of_gpio.h>
 #include <linux/regulator/consumer.h>
 #include <linux/videodev2.h>
 #include <linux/module.h>
 #include <media/v4l2-ctrls.h>
 #include <media/v4l2-device.h>
 #include <media/v4l2-subdev.h>
+#include <media/m5mols.h>
 
 #include "m5mols.h"
 #include "m5mols_reg.h"
@@ -762,15 +762,15 @@ static int m5mols_sensor_power(struct m5mols_info *info, bool enable)
 {
 	struct v4l2_subdev *sd = &info->sd;
 	struct i2c_client *client = v4l2_get_subdevdata(sd);
-	struct m5mols_platform_data *pdata = &info->pdata;
+	const struct m5mols_platform_data *pdata = info->pdata;
 	int ret;
 
 	if (info->power == enable)
 		return 0;
 
 	if (enable) {
-		if (pdata->set_power) {
-			ret = pdata->set_power(&client->dev, 1);
+		if (info->set_power) {
+			ret = info->set_power(&client->dev, 1);
 			if (ret)
 				return ret;
 		}
@@ -778,7 +778,7 @@ static int m5mols_sensor_power(struct m5mols_info *info, bool enable)
 		ret = regulator_bulk_enable_sync(ARRAY_SIZE(supplies),
 						  supplies);
 		if (ret) {
-			pdata->set_power(&client->dev, 0);
+			info->set_power(&client->dev, 0);
 			return ret;
 		}
 
@@ -793,8 +793,8 @@ static int m5mols_sensor_power(struct m5mols_info *info, bool enable)
 	if (ret)
 		return ret;
 
-	if (pdata->set_power)
-		pdata->set_power(&client->dev, 0);
+	if (info->set_power)
+		info->set_power(&client->dev, 0);
 
 	gpio_set_value(pdata->gpio_reset, pdata->reset_polarity);
 	usleep_range(1000, 1000);
@@ -971,38 +971,24 @@ static irqreturn_t m5mols_irq_handler(int irq, void *data)
 	return IRQ_HANDLED;
 }
 
-static int m5mols_get_platform_data(struct m5mols_info *info,
-				    struct device *dev)
-{
-	struct m5mols_platform_data *pdata = dev->platform_data;
-	struct device_node *node = dev->of_node;
-	enum of_gpio_flags of_flags;
-
-	if (!node) {
-		if (!pdata) {
-			dev_err(dev, "No platform data\n");
-			return -EINVAL;
-		}
-		info->pdata = *pdata;
-		return 0;
-	}
-
-	pdata = &info->pdata;
-
-	pdata->gpio_reset = of_get_gpio_flags(node, 0, &of_flags);
-	pdata->reset_polarity = !(of_flags & OF_GPIO_ACTIVE_LOW);
-
-	return 0;
-}
-
 static int m5mols_probe(struct i2c_client *client,
 			const struct i2c_device_id *id)
 {
-	struct m5mols_platform_data *pdata;
+	const struct m5mols_platform_data *pdata = client->dev.platform_data;
 	struct m5mols_info *info;
 	struct v4l2_subdev *sd;
 	int ret;
 
+	if (pdata == NULL) {
+		dev_err(&client->dev, "No platform data\n");
+		return -EINVAL;
+	}
+
+	if (!gpio_is_valid(pdata->gpio_reset)) {
+		dev_err(&client->dev, "No valid RESET GPIO specified\n");
+		return -EINVAL;
+	}
+
 	if (!client->irq) {
 		dev_err(&client->dev, "Interrupt not assigned\n");
 		return -EINVAL;
@@ -1012,16 +998,8 @@ static int m5mols_probe(struct i2c_client *client,
 	if (!info)
 		return -ENOMEM;
 
-	ret = m5mols_get_platform_data(info, &client->dev);
-	if (ret < 0)
-		return ret;
-
-	pdata = &info->pdata;
-
-	if (!gpio_is_valid(pdata->gpio_reset)) {
-		dev_err(&client->dev, "No valid RESET GPIO specified\n");
-		return -EINVAL;
-	}
+	info->pdata = pdata;
+	info->set_power	= pdata->set_power;
 
 	ret = gpio_request(pdata->gpio_reset, "M5MOLS_NRST");
 	if (ret) {
@@ -1084,7 +1062,7 @@ static int m5mols_remove(struct i2c_client *client)
 	free_irq(client->irq, sd);
 
 	regulator_bulk_free(ARRAY_SIZE(supplies), supplies);
-	gpio_free(info->pdata.gpio_reset);
+	gpio_free(info->pdata->gpio_reset);
 	media_entity_cleanup(&sd->entity);
 	kfree(info);
 	return 0;
@@ -1096,15 +1074,8 @@ static const struct i2c_device_id m5mols_id[] = {
 };
 MODULE_DEVICE_TABLE(i2c, m5mols_id);
 
-static const struct of_device_id m5mols_of_match[] = {
-	{ .compatible = "samsung,m5mols" },
-	{ }
-};
-MODULE_DEVICE_TABLE(of, m5mols_of_match);
-
 static struct i2c_driver m5mols_i2c_driver = {
 	.driver = {
-		.of_match_table = m5mols_of_match,
 		.name	= MODULE_NAME,
 	},
 	.probe		= m5mols_probe,
-- 
1.8.3.2

