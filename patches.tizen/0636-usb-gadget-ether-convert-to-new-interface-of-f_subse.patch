From b850d196a60df60a14061c910711fbe553285ac2 Mon Sep 17 00:00:00 2001
From: Andrzej Pietrasiewicz <andrzej.p@samsung.com>
Date: Tue, 28 May 2013 09:15:54 +0200
Subject: [PATCH 0636/1302] usb: gadget: ether: convert to new interface of
 f_subset

teach ethernet code about the new interface of f_subset so
the old one can eventually be removed.

Signed-off-by: Andrzej Pietrasiewicz <andrzej.p@samsung.com>
Signed-off-by: Kyungmin Park <kyungmin.park@samsung.com>
Signed-off-by: Felipe Balbi <balbi@ti.com>
Signed-off-by: MyungJoo Ham <myungjoo.ham@samsung.com>
---
 drivers/usb/gadget/Kconfig |   1 +
 drivers/usb/gadget/ether.c | 104 +++++++++++++++++++++++++--------------------
 2 files changed, 58 insertions(+), 47 deletions(-)

diff --git a/drivers/usb/gadget/Kconfig b/drivers/usb/gadget/Kconfig
index a557205..15d28e5 100644
--- a/drivers/usb/gadget/Kconfig
+++ b/drivers/usb/gadget/Kconfig
@@ -652,6 +652,7 @@ config USB_ETH
 	select USB_U_ETHER
 	select USB_U_RNDIS
 	select USB_F_ECM
+	select USB_F_SUBSET
 	select CRC32
 	help
 	  This driver implements Ethernet style communication, in one of
diff --git a/drivers/usb/gadget/ether.c b/drivers/usb/gadget/ether.c
index 3173966..9e96d55 100644
--- a/drivers/usb/gadget/ether.c
+++ b/drivers/usb/gadget/ether.c
@@ -14,6 +14,7 @@
 /* #define VERBOSE_DEBUG */
 
 #include <linux/kernel.h>
+#include <linux/netdevice.h>
 
 #if defined USB_ETH_RNDIS
 #  undef USB_ETH_RNDIS
@@ -103,8 +104,7 @@ static inline bool has_rndis(void)
  * a "gcc --combine ... part1.c part2.c part3.c ... " build would.
  */
 #include "u_ecm.h"
-#define USB_FSUBSET_INCLUDED
-#include "f_subset.c"
+#include "u_gether.h"
 #ifdef	USB_ETH_RNDIS
 #include "f_rndis.c"
 #include "rndis.h"
@@ -220,6 +220,9 @@ static struct usb_function *f_ecm;
 static struct usb_function_instance *fi_eem;
 static struct usb_function *f_eem;
 
+static struct usb_function_instance *fi_geth;
+static struct usb_function *f_geth;
+
 /*-------------------------------------------------------------------------*/
 
 /*
@@ -290,8 +293,17 @@ static int __init eth_do_config(struct usb_configuration *c)
 			usb_put_function(f_ecm);
 
 		return status;
-	} else
-		return geth_bind_config(c, host_mac, the_dev);
+	} else {
+		f_geth = usb_get_function(fi_geth);
+		if (IS_ERR(f_geth))
+			return PTR_ERR(f_geth);
+
+		status = usb_add_function(c, f_geth);
+		if (status < 0)
+			usb_put_function(f_geth);
+
+		return status;
+	}
 
 }
 
@@ -309,16 +321,10 @@ static int __init eth_bind(struct usb_composite_dev *cdev)
 	struct usb_gadget	*gadget = cdev->gadget;
 	struct f_eem_opts	*eem_opts = NULL;
 	struct f_ecm_opts	*ecm_opts = NULL;
+	struct f_gether_opts	*geth_opts = NULL;
+	struct net_device	*net;
 	int			status;
 
-	if (!use_eem && !can_support_ecm(gadget)) {
-		/* set up network link layer */
-		the_dev = gether_setup(cdev->gadget, dev_addr, host_addr,
-				host_mac, qmult);
-		if (IS_ERR(the_dev))
-			return PTR_ERR(the_dev);
-	}
-
 	/* set up main config label and device descriptor */
 	if (use_eem) {
 		/* EEM */
@@ -328,13 +334,8 @@ static int __init eth_bind(struct usb_composite_dev *cdev)
 
 		eem_opts = container_of(fi_eem, struct f_eem_opts, func_inst);
 
-		gether_set_qmult(eem_opts->net, qmult);
-		if (!gether_set_host_addr(eem_opts->net, host_addr))
-			pr_info("using host ethernet address: %s", host_addr);
-		if (!gether_set_dev_addr(eem_opts->net, dev_addr))
-			pr_info("using self ethernet address: %s", dev_addr);
-
-		the_dev = netdev_priv(eem_opts->net);
+		net = eem_opts->net;
+		the_dev = netdev_priv(net);
 
 		eth_config_driver.label = "CDC Ethernet (EEM)";
 		device_desc.idVendor = cpu_to_le16(EEM_VENDOR_NUM);
@@ -348,17 +349,23 @@ static int __init eth_bind(struct usb_composite_dev *cdev)
 
 		ecm_opts = container_of(fi_ecm, struct f_ecm_opts, func_inst);
 
-		gether_set_qmult(ecm_opts->net, qmult);
-		if (!gether_set_host_addr(ecm_opts->net, host_addr))
-			pr_info("using host ethernet address: %s", host_addr);
-		if (!gether_set_dev_addr(ecm_opts->net, dev_addr))
-			pr_info("using self ethernet address: %s", dev_addr);
-
-		the_dev = netdev_priv(ecm_opts->net);
+		net = ecm_opts->net;
+		the_dev = netdev_priv(net);
 
 		eth_config_driver.label = "CDC Ethernet (ECM)";
 	} else {
 		/* CDC Subset */
+
+		fi_geth = usb_get_function_instance("geth");
+		if (IS_ERR(fi_geth))
+			return PTR_ERR(fi_geth);
+
+		geth_opts = container_of(fi_geth, struct f_gether_opts,
+					 func_inst);
+
+		net = geth_opts->net;
+		the_dev = netdev_priv(net);
+
 		eth_config_driver.label = "CDC Subset/SAFE";
 
 		device_desc.idVendor = cpu_to_le16(SIMPLE_VENDOR_NUM);
@@ -367,23 +374,26 @@ static int __init eth_bind(struct usb_composite_dev *cdev)
 			device_desc.bDeviceClass = USB_CLASS_VENDOR_SPEC;
 	}
 
+	gether_set_qmult(net, qmult);
+	if (!gether_set_host_addr(net, host_addr))
+		pr_info("using host ethernet address: %s", host_addr);
+	if (!gether_set_dev_addr(net, dev_addr))
+		pr_info("using self ethernet address: %s", dev_addr);
+
 	if (has_rndis()) {
 		/* RNDIS plus ECM-or-Subset */
-		if (use_eem) {
-			gether_set_gadget(eem_opts->net, cdev->gadget);
-			status = gether_register_netdev(eem_opts->net);
-			if (status)
-				goto fail;
+		gether_set_gadget(net, cdev->gadget);
+		status = gether_register_netdev(net);
+		if (status)
+			goto fail;
+		gether_get_host_addr_u8(net, host_mac);
+
+		if (use_eem)
 			eem_opts->bound = true;
-			gether_get_host_addr_u8(eem_opts->net, host_mac);
-		} else if (can_support_ecm(gadget)) {
-			gether_set_gadget(ecm_opts->net, cdev->gadget);
-			status = gether_register_netdev(ecm_opts->net);
-			if (status)
-				goto fail;
+		else if (can_support_ecm(gadget))
 			ecm_opts->bound = true;
-			gether_get_host_addr_u8(ecm_opts->net, host_mac);
-		}
+		else
+			geth_opts->bound = true;
 
 		device_desc.idVendor = cpu_to_le16(RNDIS_VENDOR_NUM);
 		device_desc.idProduct = cpu_to_le16(RNDIS_PRODUCT_NUM);
@@ -419,23 +429,23 @@ static int __init eth_bind(struct usb_composite_dev *cdev)
 	return 0;
 
 fail:
-	if (!use_eem && !can_support_ecm(gadget))
-		gether_cleanup(the_dev);
-	else if (use_eem)
+	if (use_eem)
 		usb_put_function_instance(fi_eem);
-	else
+	else if (can_support_ecm(gadget))
 		usb_put_function_instance(fi_ecm);
+	else
+		usb_put_function_instance(fi_geth);
 	return status;
 }
 
 static int __exit eth_unbind(struct usb_composite_dev *cdev)
 {
-	if (!use_eem && !can_support_ecm(cdev->gadget))
-		gether_cleanup(the_dev);
-	else if (use_eem)
+	if (use_eem)
 		usb_put_function_instance(fi_eem);
-	else
+	else if (can_support_ecm(cdev->gadget))
 		usb_put_function_instance(fi_ecm);
+	else
+		usb_put_function_instance(fi_geth);
 	return 0;
 }
 
-- 
1.8.3.2

